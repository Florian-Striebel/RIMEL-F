<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/lib/Sema/TreeTransform.h">











<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_LIB_SEMA_TREETRANSFORM_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_LIB_SEMA_TREETRANSFORM_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"CoroutineStmtBuilder.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"TypeLocBuilder.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Decl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclObjC.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclTemplate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Expr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ExprConcepts.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ExprCXX.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ExprObjC.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ExprOpenMP.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/OpenMPClause.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Stmt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/StmtCXX.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/StmtObjC.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/StmtOpenMP.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/DiagnosticParse.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/OpenMPKinds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Sema/Designator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Sema/Lookup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Sema/Ownership.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Sema/ParsedTemplate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Sema/ScopeInfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Sema/SemaDiagnostic.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Sema/SemaInternal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/ArrayRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/ErrorHandling.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;algorithm&gt;</cpp:file></cpp:include>

<expr_stmt><expr><name>using</name> <name>namespace</name> <name>llvm</name><operator>::</operator>omp</expr>;</expr_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>
<decl_stmt><decl><type><name>using</name> <name>namespace</name></type> <name>sema</name></decl>;</decl_stmt>




















































<decl_stmt><decl><type><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>TreeTransform</name> <block>{<block_content>



<decl_stmt><decl><type><name>class</name></type> <name>ForgetPartiallySubstitutedPackRAII</name> <block>{<block_content>
<decl_stmt><decl><type><name>Derived</name> <modifier>&amp;</modifier></type><name>Self</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TemplateArgument</name></type> <name>Old</name></decl>;</decl_stmt>

<label><name>public</name>:</label>
<expr_stmt><expr><call><name>ForgetPartiallySubstitutedPackRAII</name><argument_list>(<argument><expr><name>Derived</name> <operator>&amp;</operator><name>Self</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>Self</name><argument_list>(<argument>Self</argument>)</argument_list></macro> <block>{
<expr><name>Old</name> <operator>=</operator> <call><name><name>Self</name><operator>.</operator><name>ForgetPartiallySubstitutedPack</name></name><argument_list>()</argument_list></call></expr>;
}</block>

<operator>~</operator><macro><name>ForgetPartiallySubstitutedPackRAII</name><argument_list>()</argument_list></macro> <block>{
<expr><call><name><name>Self</name><operator>.</operator><name>RememberPartiallySubstitutedPack</name></name><argument_list>(<argument><expr><name>Old</name></expr></argument>)</argument_list></call></expr>;
}</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<label><name>protected</name>:</label>
<decl_stmt><decl><type><name>Sema</name> <modifier>&amp;</modifier></type><name>SemaRef</name></decl>;</decl_stmt>




<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <operator>*</operator></expr></argument>, <argument><expr><name>Decl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>TransformedLocalDecls</name></expr>;</expr_stmt>

<label><name>public</name>:</label>

<expr_stmt><expr><call><name>TreeTransform</name><argument_list>(<argument><expr><name>Sema</name> <operator>&amp;</operator><name>SemaRef</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>SemaRef</name><argument_list>(<argument>SemaRef</argument>)</argument_list></macro> <block>{ }</block>


<name>Derived</name> <operator>&amp;</operator><macro><name>getDerived</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><specifier>const</specifier> <name>Derived</name> <operator>&amp;</operator><macro><name>getDerived</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Derived</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>ExprResult</name></type> <name>Owned</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>E</name></expr>;</return> </block_content>}</block></function>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>StmtResult</name></type> <name>Owned</name><parameter_list>(<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>S</name></expr>;</return> </block_content>}</block></function>



<expr_stmt><expr><name>Sema</name> <operator>&amp;</operator><macro><name>getSema</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>SemaRef</name></expr>;</return> }</block></expr></expr_stmt>










<function><type><name>bool</name></type> <name>AlwaysRebuild</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name><name>SemaRef</name><operator>.</operator><name>ArgumentPackSubstitutionIndex</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</return> </block_content>}</block></function>




<function><type><name>bool</name></type> <name>ReplacingOriginal</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>false</name></expr>;</return> </block_content>}</block></function>






<function><type><name>bool</name></type> <name>AllowSkippingCXXConstructExpr</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>true</name></expr>;</return> </block_content>}</block></function>







<function><type><name>SourceLocation</name></type> <name>getBaseLocation</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>






<function><type><name>DeclarationName</name></type> <name>getBaseEntity</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name>DeclarationName</name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>






<function><type><name>void</name></type> <name>setBase</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>DeclarationName</name></type> <name>Entity</name></decl></parameter>)</parameter_list> <block>{<block_content> </block_content>}</block></function>



<decl_stmt><decl><type><name>class</name></type> <name>TemporaryBase</name> <block>{<block_content>
<decl_stmt><decl><type><name>TreeTransform</name> <modifier>&amp;</modifier></type><name>Self</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>OldLocation</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DeclarationName</name></type> <name>OldEntity</name></decl>;</decl_stmt>

<label><name>public</name>:</label>
<macro><name>TemporaryBase</name><argument_list>(<argument>TreeTransform &amp;Self</argument>, <argument>SourceLocation Location</argument>,
<argument>DeclarationName Entity</argument>)</argument_list></macro> : <macro><name>Self</name><argument_list>(<argument>Self</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name>OldLocation</name> <operator>=</operator> <call><name><name>Self</name><operator>.</operator><name>getDerived</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getBaseLocation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>OldEntity</name> <operator>=</operator> <call><name><name>Self</name><operator>.</operator><name>getDerived</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getBaseEntity</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>Location</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>Self</name><operator>.</operator><name>getDerived</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>setBase</name><argument_list>(<argument><expr><name>Location</name></expr></argument>, <argument><expr><name>Entity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>

<expr_stmt><expr><operator>~</operator><macro><name>TemporaryBase</name><argument_list>()</argument_list></macro> <block>{
<expr><call><name><name>Self</name><operator>.</operator><name>getDerived</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>setBase</name><argument_list>(<argument><expr><name>OldLocation</name></expr></argument>, <argument><expr><name>OldEntity</name></expr></argument>)</argument_list></call></expr>;
}</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>








<function><type><name>bool</name></type> <name>AlreadyTransformed</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>T</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>unsigned</name></type> <name>TransformTemplateDepth</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>Depth</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>Depth</name></expr>;</return>
</block_content>}</block></function>







<function><type><name>bool</name></type> <name>DropCallArgument</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>E</name><operator>-&gt;</operator><name>isDefaultArgument</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>






































<function><type><name>bool</name></type> <name>TryExpandParameterPacks</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>EllipsisLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceRange</name></type> <name>PatternRange</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>UnexpandedParameterPack</name></expr></argument>&gt;</argument_list></name></type> <name>Unexpanded</name></decl></parameter>,
<parameter><decl><type><name>bool</name> <modifier>&amp;</modifier></type><name>ShouldExpand</name></decl></parameter>,
<parameter><decl><type><name>bool</name> <modifier>&amp;</modifier></type><name>RetainExpansion</name></decl></parameter>,
<parameter><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>NumExpansions</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>ShouldExpand</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>






<function><type><name>TemplateArgument</name></type> <name>ForgetPartiallySubstitutedPack</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name>TemplateArgument</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>






<function><type><name>void</name></type> <name>RememberPartiallySubstitutedPack</name><parameter_list>(<parameter><decl><type><name>TemplateArgument</name></type> <name>Arg</name></decl></parameter>)</parameter_list> <block>{<block_content> </block_content>}</block></function>



<function><type><name>void</name></type> <name>ExpandingFunctionParameterPack</name><parameter_list>(<parameter><decl><type><name>ParmVarDecl</name> <modifier>*</modifier></type><name>Pack</name></decl></parameter>)</parameter_list> <block>{<block_content> </block_content>}</block></function>










<function_decl><type><name>QualType</name></type> <name>TransformType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>)</parameter_list>;</function_decl>









<function_decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TransformType</name><parameter_list>(<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>DI</name></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>QualType</name></type> <name>TransformType</name><parameter_list>(<parameter><decl><type><name>TypeLocBuilder</name> <modifier>&amp;</modifier></type><name>TLB</name></decl></parameter>, <parameter><decl><type><name>TypeLoc</name></type> <name>TL</name></decl></parameter>)</parameter_list>;</function_decl>








<function_decl><type><name>QualType</name></type> <name>TransformTypeWithDeducedTST</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TransformTypeWithDeducedTST</name><parameter_list>(<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>DI</name></decl></parameter>)</parameter_list>;</function_decl>



<enum>enum <name>StmtDiscardKind</name> <block>{
<decl><name>SDK_Discarded</name></decl>,
<decl><name>SDK_NotDiscarded</name></decl>,
<decl><name>SDK_StmtExprResult</name></decl>,
}</block>;</enum>










<function_decl><type><name>StmtResult</name></type> <name>TransformStmt</name><parameter_list>(<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>StmtDiscardKind</name></type> <name>SDK</name> <init>= <expr><name>SDK_Discarded</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>









<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>TransformOMPClause</name><parameter_list>(<parameter><decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>









<function_decl><type><specifier>const</specifier> <name>Attr</name> <modifier>*</modifier></type><name>TransformAttr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Attr</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>







<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ATTR</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRAGMA_SPELLING_ATTR</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>const X##Attr *Transform##X##Attr(const X##Attr *R) { return R; }</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/AttrList.inc"</cpp:file></cpp:include>









<function_decl><type><name>ExprResult</name></type> <name>TransformExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>








<function_decl><type><name>ExprResult</name></type> <name>TransformInitializer</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Init</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>NotCopyInit</name></decl></parameter>)</parameter_list>;</function_decl>
























<function_decl><type><name>bool</name></type> <name>TransformExprs</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>Inputs</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>NumInputs</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsCall</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>Outputs</name></decl></parameter>,
<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>ArgChanged</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>







<function><type><name>Decl</name> <modifier>*</modifier></type><name>TransformDecl</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <operator>*</operator></expr></argument>, <argument><expr><name>Decl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name> <name>Known</name>
<operator>=</operator> <call><name><name>TransformedLocalDecls</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>Known</name> <operator>!=</operator> <call><name><name>TransformedLocalDecls</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>Known</name><operator>-&gt;</operator><name>second</name></name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>D</name></expr>;</return>
</block_content>}</block></function>





<expr_stmt><expr><name>Sema</name><operator>::</operator><name>ConditionResult</name> <macro><name>TransformCondition</name><argument_list>(<argument>SourceLocation Loc</argument>, <argument>VarDecl *Var</argument>,
<argument>Expr *Expr</argument>,
<argument>Sema::ConditionKind Kind</argument>)</argument_list></macro></expr>;</expr_stmt>






<function><type><name>void</name></type> <name>transformAttrs</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>Old</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>New</name></decl></parameter>)</parameter_list> <block>{<block_content> </block_content>}</block></function>








<function><type><name>void</name></type> <name>transformedLocalDecl</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>Old</name></decl></parameter>, <parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>New</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>New</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
<literal type="string">"must override transformedLocalDecl if performing pack expansion"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>TransformedLocalDecls</name><index>[<expr><name>Old</name></expr>]</index></name> <operator>=</operator> <call><name><name>New</name><operator>.</operator><name>front</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><name>Decl</name> <modifier>*</modifier></type><name>TransformDefinition</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDecl</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>










<function><type><name>NamedDecl</name> <modifier>*</modifier></type><name>TransformFirstQualifierInScope</name><parameter_list>(<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDecl</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function_decl><type><name>bool</name></type> <name>TransformOverloadExprDecls</name><parameter_list>(<parameter><decl><type><name>OverloadExpr</name> <modifier>*</modifier></type><name>Old</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>RequiresADL</name></decl></parameter>,
<parameter><decl><type><name>LookupResult</name> <modifier>&amp;</modifier></type><name>R</name></decl></parameter>)</parameter_list>;</function_decl>







<function_decl><type><name>NestedNameSpecifierLoc</name></type>
<name>TransformNestedNameSpecifierLoc</name><parameter_list>(<parameter><decl><type><name>NestedNameSpecifierLoc</name></type> <name>NNS</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>ObjectType</name> <init>= <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr></init></decl></parameter>,
<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>FirstQualifierInScope</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>







<function_decl><type><name>DeclarationNameInfo</name></type>
<name>TransformDeclarationNameInfo</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DeclarationNameInfo</name> <modifier>&amp;</modifier></type><name>NameInfo</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>bool</name></type> <name>TransformRequiresExprRequirements</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>concepts</name><operator>::</operator><name>Requirement</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Reqs</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>concepts</name><operator>::</operator><name>Requirement</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Transformed</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<expr_stmt><expr><name>concepts</name><operator>::</operator><name>TypeRequirement</name> <operator>*</operator>
<call><name>TransformTypeRequirement</name><argument_list>(<argument><expr><name>concepts</name><operator>::</operator><name>TypeRequirement</name> <operator>*</operator><name>Req</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>concepts</name><operator>::</operator><name>ExprRequirement</name> <operator>*</operator>
<call><name>TransformExprRequirement</name><argument_list>(<argument><expr><name>concepts</name><operator>::</operator><name>ExprRequirement</name> <operator>*</operator><name>Req</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>concepts</name><operator>::</operator><name>NestedRequirement</name> <operator>*</operator>
<call><name>TransformNestedRequirement</name><argument_list>(<argument><expr><name>concepts</name><operator>::</operator><name>NestedRequirement</name> <operator>*</operator><name>Req</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





















<function_decl><type><name>TemplateName</name></type>
<name>TransformTemplateName</name><parameter_list>(<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>, <parameter><decl><type><name>TemplateName</name></type> <name>Name</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>NameLoc</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>ObjectType</name> <init>= <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr></init></decl></parameter>,
<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>FirstQualifierInScope</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AllowInjectedClassName</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>









<function_decl><type><name>bool</name></type> <name>TransformTemplateArgument</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TemplateArgumentLoc</name> <modifier>&amp;</modifier></type><name>Input</name></decl></parameter>,
<parameter><decl><type><name>TemplateArgumentLoc</name> <modifier>&amp;</modifier></type><name>Output</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>Uneval</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>



















<function><type><name>bool</name></type> <name>TransformTemplateArguments</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TemplateArgumentLoc</name> <modifier>*</modifier></type><name>Inputs</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>NumInputs</name></decl></parameter>,
<parameter><decl><type><name>TemplateArgumentListInfo</name> <modifier>&amp;</modifier></type><name>Outputs</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>Uneval</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>TransformTemplateArguments</name><argument_list>(<argument><expr><name>Inputs</name></expr></argument>, <argument><expr><name>Inputs</name> <operator>+</operator> <name>NumInputs</name></expr></argument>, <argument><expr><name>Outputs</name></expr></argument>,
<argument><expr><name>Uneval</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>















<function_decl><type><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>InputIterator</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>TransformTemplateArguments</name><parameter_list>(<parameter><decl><type><name>InputIterator</name></type> <name>First</name></decl></parameter>,
<parameter><decl><type><name>InputIterator</name></type> <name>Last</name></decl></parameter>,
<parameter><decl><type><name>TemplateArgumentListInfo</name> <modifier>&amp;</modifier></type><name>Outputs</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>Uneval</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>InventTemplateArgumentLoc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TemplateArgument</name> <modifier>&amp;</modifier></type><name>Arg</name></decl></parameter>,
<parameter><decl><type><name>TemplateArgumentLoc</name> <modifier>&amp;</modifier></type><name>ArgLoc</name></decl></parameter>)</parameter_list>;</function_decl>


<function><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>InventTypeSourceInfo</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>getTrivialTypeSourceInfo</name></name><argument_list>(<argument><expr><name>T</name></expr></argument>,
<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getBaseLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ABSTRACT_TYPELOC</name><parameter_list>(<parameter><type><name>CLASS</name></type></parameter>, <parameter><type><name>PARENT</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPELOC</name><parameter_list>(<parameter><type><name>CLASS</name></type></parameter>, <parameter><type><name>PARENT</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>QualType Transform##CLASS##Type(TypeLocBuilder &amp;TLB, CLASS##TypeLoc T);</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/TypeLocNodes.def"</cpp:file></cpp:include>

<function_decl><type><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Fn</name></expr></argument>&gt;</argument_list></name>
<name>QualType</name></type> <name>TransformFunctionProtoType</name><parameter_list>(<parameter><decl><type><name>TypeLocBuilder</name> <modifier>&amp;</modifier></type><name>TLB</name></decl></parameter>,
<parameter><decl><type><name>FunctionProtoTypeLoc</name></type> <name>TL</name></decl></parameter>,
<parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>ThisContext</name></decl></parameter>,
<parameter><decl><type><name>Qualifiers</name></type> <name>ThisTypeQuals</name></decl></parameter>,
<parameter><decl><type><name>Fn</name></type> <name>TransformExceptionSpec</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>bool</name></type> <name>TransformExceptionSpec</name><argument_list>(<argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>,
<argument><expr><name>FunctionProtoType</name><operator>::</operator><name>ExceptionSpecInfo</name> <operator>&amp;</operator><name>ESI</name></expr></argument>,
<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Exceptions</name></expr></argument>,
<argument><expr><name>bool</name> <operator>&amp;</operator><name>Changed</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function_decl><type><name>StmtResult</name></type> <name>TransformSEHHandler</name><parameter_list>(<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Handler</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>QualType</name></type>
<name>TransformTemplateSpecializationType</name><parameter_list>(<parameter><decl><type><name>TypeLocBuilder</name> <modifier>&amp;</modifier></type><name>TLB</name></decl></parameter>,
<parameter><decl><type><name>TemplateSpecializationTypeLoc</name></type> <name>TL</name></decl></parameter>,
<parameter><decl><type><name>TemplateName</name></type> <name>Template</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>QualType</name></type>
<name>TransformDependentTemplateSpecializationType</name><parameter_list>(<parameter><decl><type><name>TypeLocBuilder</name> <modifier>&amp;</modifier></type><name>TLB</name></decl></parameter>,
<parameter><decl><type><name>DependentTemplateSpecializationTypeLoc</name></type> <name>TL</name></decl></parameter>,
<parameter><decl><type><name>TemplateName</name></type> <name>Template</name></decl></parameter>,
<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>QualType</name></type> <name>TransformDependentTemplateSpecializationType</name><parameter_list>(
<parameter><decl><type><name>TypeLocBuilder</name> <modifier>&amp;</modifier></type><name>TLB</name></decl></parameter>, <parameter><decl><type><name>DependentTemplateSpecializationTypeLoc</name></type> <name>TL</name></decl></parameter>,
<parameter><decl><type><name>NestedNameSpecifierLoc</name></type> <name>QualifierLoc</name></decl></parameter>)</parameter_list>;</function_decl>








<decl_stmt><decl><type><name>bool</name></type> <name>TransformFunctionTypeParams</name><argument_list>(
<argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>, <argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Params</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>QualType</name> <operator>*</operator><name>ParamTypes</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>FunctionProtoType</name><operator>::</operator><name>ExtParameterInfo</name> <operator>*</operator><name>ParamInfos</name></expr></argument>,
<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>PTypes</name></expr></argument>, <argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <operator>*</operator><name>PVars</name></expr></argument>,
<argument><expr><name>Sema</name><operator>::</operator><name>ExtParameterInfoBuilder</name> <operator>&amp;</operator><name>PInfos</name></expr></argument>)</argument_list></decl>;</decl_stmt>






<function_decl><type><name>ParmVarDecl</name> <modifier>*</modifier></type><name>TransformFunctionTypeParam</name><parameter_list>(<parameter><decl><type><name>ParmVarDecl</name> <modifier>*</modifier></type><name>OldParm</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>indexAdjustment</name></decl></parameter>,
<parameter><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></type> <name>NumExpansions</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ExpectParameterPack</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>StmtResult</name></type> <name>TransformLambdaBody</name><parameter_list>(<parameter><decl><type><name>LambdaExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Body</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>StmtResult</name></type> <name>SkipLambdaBody</name><parameter_list>(<parameter><decl><type><name>LambdaExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Body</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>QualType</name></type> <name>TransformReferenceType</name><parameter_list>(<parameter><decl><type><name>TypeLocBuilder</name> <modifier>&amp;</modifier></type><name>TLB</name></decl></parameter>, <parameter><decl><type><name>ReferenceTypeLoc</name></type> <name>TL</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>StmtResult</name></type> <name>TransformCompoundStmt</name><parameter_list>(<parameter><decl><type><name>CompoundStmt</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsStmtExpr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>TransformCXXNamedCastExpr</name><parameter_list>(<parameter><decl><type><name>CXXNamedCastExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>TemplateParameterList</name> <modifier>*</modifier></type><name>TransformTemplateParameterList</name><parameter_list>(
<parameter><decl><type><name>TemplateParameterList</name> <modifier>*</modifier></type><name>TPL</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>TPL</name></expr>;</return>
</block_content>}</block></function>

<function_decl><type><name>ExprResult</name></type> <name>TransformAddressOfOperand</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>TransformDependentScopeDeclRefExpr</name><parameter_list>(<parameter><decl><type><name>DependentScopeDeclRefExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsAddressOfOperand</name></decl></parameter>,
<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>RecoveryTSI</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>TransformParenDependentScopeDeclRefExpr</name><parameter_list>(
<parameter><decl><type><name>ParenExpr</name> <modifier>*</modifier></type><name>PE</name></decl></parameter>, <parameter><decl><type><name>DependentScopeDeclRefExpr</name> <modifier>*</modifier></type><name>DRE</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsAddressOfOperand</name></decl></parameter>,
<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>RecoveryTSI</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>StmtResult</name></type> <name>TransformOMPExecutableDirective</name><parameter_list>(<parameter><decl><type><name>OMPExecutableDirective</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STMT</name><parameter_list>(<parameter><type><name>Node</name></type></parameter>, <parameter><type><name>Parent</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>LLVM_ATTRIBUTE_NOINLINE StmtResult Transform##Node(Node *S);</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VALUESTMT</name><parameter_list>(<parameter><type><name>Node</name></type></parameter>, <parameter><type><name>Parent</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>LLVM_ATTRIBUTE_NOINLINE StmtResult Transform##Node(Node *S, StmtDiscardKind SDK);</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPR</name><parameter_list>(<parameter><type><name>Node</name></type></parameter>, <parameter><type><name>Parent</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>LLVM_ATTRIBUTE_NOINLINE ExprResult Transform##Node(Node *E);</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ABSTRACT_STMT</name><parameter_list>(<parameter><type><name>Stmt</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/StmtNodes.inc"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GEN_CLANG_CLAUSE_CLASS</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLAUSE_CLASS</name><parameter_list>(<parameter><type><name>Enum</name></type></parameter>, <parameter><type><name>Str</name></type></parameter>, <parameter><type><name>Class</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>LLVM_ATTRIBUTE_NOINLINE OMPClause *Transform##Class(Class *S);</cpp:value></cpp:define>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Frontend/OpenMP/OMP.inc"</cpp:file></cpp:include>







<function_decl><type><name>QualType</name></type> <name>RebuildQualifiedType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>QualifiedTypeLoc</name></type> <name>TL</name></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>QualType</name></type> <name>RebuildPointerType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>PointeeType</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Sigil</name></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>QualType</name></type> <name>RebuildBlockPointerType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>PointeeType</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Sigil</name></decl></parameter>)</parameter_list>;</function_decl>









<function_decl><type><name>QualType</name></type> <name>RebuildReferenceType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>ReferentType</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>LValue</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Sigil</name></decl></parameter>)</parameter_list>;</function_decl>






<function_decl><type><name>QualType</name></type> <name>RebuildMemberPointerType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>PointeeType</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>ClassType</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Sigil</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>QualType</name></type> <name>RebuildObjCTypeParamType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjCTypeParamDecl</name> <modifier>*</modifier></type><name>Decl</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ProtocolLAngleLoc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ObjCProtocolDecl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Protocols</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name></type> <name>ProtocolLocs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ProtocolRAngleLoc</name></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>QualType</name></type> <name>RebuildObjCObjectType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>BaseType</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TypeArgsLAngleLoc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TypeSourceInfo</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>TypeArgs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TypeArgsRAngleLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ProtocolLAngleLoc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ObjCProtocolDecl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Protocols</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name></type> <name>ProtocolLocs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ProtocolRAngleLoc</name></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>QualType</name></type> <name>RebuildObjCObjectPointerType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>PointeeType</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Star</name></decl></parameter>)</parameter_list>;</function_decl>








<decl_stmt><decl><type><name>QualType</name></type> <name>RebuildArrayType</name><argument_list>(<argument><expr><name>QualType</name> <name>ElementType</name></expr></argument>,
<argument><expr><name>ArrayType</name><operator>::</operator><name>ArraySizeModifier</name> <name>SizeMod</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name>APInt</name> <operator>*</operator><name>Size</name></expr></argument>,
<argument><expr><name>Expr</name> <operator>*</operator><name>SizeExpr</name></expr></argument>,
<argument><expr><name>unsigned</name> <name>IndexTypeQuals</name></expr></argument>,
<argument><expr><name>SourceRange</name> <name>BracketsRange</name></expr></argument>)</argument_list></decl>;</decl_stmt>






<decl_stmt><decl><type><name>QualType</name></type> <name>RebuildConstantArrayType</name><argument_list>(<argument><expr><name>QualType</name> <name>ElementType</name></expr></argument>,
<argument><expr><name>ArrayType</name><operator>::</operator><name>ArraySizeModifier</name> <name>SizeMod</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name>APInt</name> <operator>&amp;</operator><name>Size</name></expr></argument>,
<argument><expr><name>Expr</name> <operator>*</operator><name>SizeExpr</name></expr></argument>,
<argument><expr><name>unsigned</name> <name>IndexTypeQuals</name></expr></argument>,
<argument><expr><name>SourceRange</name> <name>BracketsRange</name></expr></argument>)</argument_list></decl>;</decl_stmt>






<decl_stmt><decl><type><name>QualType</name></type> <name>RebuildIncompleteArrayType</name><argument_list>(<argument><expr><name>QualType</name> <name>ElementType</name></expr></argument>,
<argument><expr><name>ArrayType</name><operator>::</operator><name>ArraySizeModifier</name> <name>SizeMod</name></expr></argument>,
<argument><expr><name>unsigned</name> <name>IndexTypeQuals</name></expr></argument>,
<argument><expr><name>SourceRange</name> <name>BracketsRange</name></expr></argument>)</argument_list></decl>;</decl_stmt>






<decl_stmt><decl><type><name>QualType</name></type> <name>RebuildVariableArrayType</name><argument_list>(<argument><expr><name>QualType</name> <name>ElementType</name></expr></argument>,
<argument><expr><name>ArrayType</name><operator>::</operator><name>ArraySizeModifier</name> <name>SizeMod</name></expr></argument>,
<argument><expr><name>Expr</name> <operator>*</operator><name>SizeExpr</name></expr></argument>,
<argument><expr><name>unsigned</name> <name>IndexTypeQuals</name></expr></argument>,
<argument><expr><name>SourceRange</name> <name>BracketsRange</name></expr></argument>)</argument_list></decl>;</decl_stmt>






<decl_stmt><decl><type><name>QualType</name></type> <name>RebuildDependentSizedArrayType</name><argument_list>(<argument><expr><name>QualType</name> <name>ElementType</name></expr></argument>,
<argument><expr><name>ArrayType</name><operator>::</operator><name>ArraySizeModifier</name> <name>SizeMod</name></expr></argument>,
<argument><expr><name>Expr</name> <operator>*</operator><name>SizeExpr</name></expr></argument>,
<argument><expr><name>unsigned</name> <name>IndexTypeQuals</name></expr></argument>,
<argument><expr><name>SourceRange</name> <name>BracketsRange</name></expr></argument>)</argument_list></decl>;</decl_stmt>






<decl_stmt><decl><type><name>QualType</name></type> <name>RebuildVectorType</name><argument_list>(<argument><expr><name>QualType</name> <name>ElementType</name></expr></argument>, <argument><expr><name>unsigned</name> <name>NumElements</name></expr></argument>,
<argument><expr><name>VectorType</name><operator>::</operator><name>VectorKind</name> <name>VecKind</name></expr></argument>)</argument_list></decl>;</decl_stmt>






<decl_stmt><decl><type><name>QualType</name></type> <name>RebuildDependentVectorType</name><argument_list>(<argument><expr><name>QualType</name> <name>ElementType</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator><name>SizeExpr</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>AttributeLoc</name></expr></argument>,
<argument><expr><name>VectorType</name><operator>::</operator><name>VectorKind</name></expr></argument>)</argument_list></decl>;</decl_stmt>






<function_decl><type><name>QualType</name></type> <name>RebuildExtVectorType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>ElementType</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>NumElements</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>AttributeLoc</name></decl></parameter>)</parameter_list>;</function_decl>






<function_decl><type><name>QualType</name></type> <name>RebuildDependentSizedExtVectorType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>ElementType</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>SizeExpr</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>AttributeLoc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>QualType</name></type> <name>RebuildConstantMatrixType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>ElementType</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>NumRows</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>NumColumns</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>QualType</name></type> <name>RebuildDependentSizedMatrixType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>ElementType</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>RowExpr</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>ColumnExpr</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>AttributeLoc</name></decl></parameter>)</parameter_list>;</function_decl>









<function_decl><type><name>QualType</name></type> <name>RebuildDependentAddressSpaceType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>PointeeType</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>AddrSpaceExpr</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>AttributeLoc</name></decl></parameter>)</parameter_list>;</function_decl>





<decl_stmt><decl><type><name>QualType</name></type> <name>RebuildFunctionProtoType</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>,
<argument><expr><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>&gt;</argument_list></name> <name>ParamTypes</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>FunctionProtoType</name><operator>::</operator><name>ExtProtoInfo</name> <operator>&amp;</operator><name>EPI</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<function_decl><type><name>QualType</name></type> <name>RebuildFunctionNoProtoType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>ResultType</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>QualType</name></type> <name>RebuildUnresolvedUsingType</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>NameLoc</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>


<function><type><name>QualType</name></type> <name>RebuildTypedefType</name><parameter_list>(<parameter><decl><type><name>TypedefNameDecl</name> <modifier>*</modifier></type><name>Typedef</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>getTypeDeclType</name></name><argument_list>(<argument><expr><name>Typedef</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>QualType</name></type> <name>RebuildMacroQualifiedType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>IdentifierInfo</name> <modifier>*</modifier></type><name>MacroII</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>getMacroQualifiedType</name></name><argument_list>(<argument><expr><name>T</name></expr></argument>, <argument><expr><name>MacroII</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>QualType</name></type> <name>RebuildRecordType</name><parameter_list>(<parameter><decl><type><name>RecordDecl</name> <modifier>*</modifier></type><name>Record</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>getTypeDeclType</name></name><argument_list>(<argument><expr><name>Record</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>QualType</name></type> <name>RebuildEnumType</name><parameter_list>(<parameter><decl><type><name>EnumDecl</name> <modifier>*</modifier></type><name>Enum</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>getTypeDeclType</name></name><argument_list>(<argument><expr><name>Enum</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function_decl><type><name>QualType</name></type> <name>RebuildTypeOfExprType</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Underlying</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>QualType</name></type> <name>RebuildTypeOfType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>Underlying</name></decl></parameter>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><name>QualType</name></type> <name>RebuildUnaryTransformType</name><argument_list>(<argument><expr><name>QualType</name> <name>BaseType</name></expr></argument>,
<argument><expr><name>UnaryTransformType</name><operator>::</operator><name>UTTKind</name> <name>UKind</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>)</argument_list></decl>;</decl_stmt>





<function_decl><type><name>QualType</name></type> <name>RebuildDecltypeType</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Underlying</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>




<function><type><name>QualType</name></type> <name>RebuildAutoType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>Deduced</name></decl></parameter>, <parameter><decl><type><name>AutoTypeKeyword</name></type> <name>Keyword</name></decl></parameter>,
<parameter><decl><type><name>ConceptDecl</name> <modifier>*</modifier></type><name>TypeConstraintConcept</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name></expr></argument>&gt;</argument_list></name></type> <name>TypeConstraintArgs</name></decl></parameter>)</parameter_list> <block>{<block_content>



<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>getAutoType</name></name><argument_list>(<argument><expr><name>Deduced</name></expr></argument>, <argument><expr><name>Keyword</name></expr></argument>,
<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
<argument><expr><name>TypeConstraintConcept</name></expr></argument>,
<argument><expr><name>TypeConstraintArgs</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<function><type><name>QualType</name></type> <name>RebuildDeducedTemplateSpecializationType</name><parameter_list>(<parameter><decl><type><name>TemplateName</name></type> <name>Template</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>Deduced</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>getDeducedTemplateSpecializationType</name></name><argument_list>(
<argument><expr><name>Template</name></expr></argument>, <argument><expr><name>Deduced</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>






<function_decl><type><name>QualType</name></type> <name>RebuildTemplateSpecializationType</name><parameter_list>(<parameter><decl><type><name>TemplateName</name></type> <name>Template</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TemplateLoc</name></decl></parameter>,
<parameter><decl><type><name>TemplateArgumentListInfo</name> <modifier>&amp;</modifier></type><name>Args</name></decl></parameter>)</parameter_list>;</function_decl>





<function><type><name>QualType</name></type> <name>RebuildParenType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>InnerType</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>BuildParenType</name></name><argument_list>(<argument><expr><name>InnerType</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>






<function><type><name>QualType</name></type> <name>RebuildElaboratedType</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>KeywordLoc</name></decl></parameter>,
<parameter><decl><type><name>ElaboratedTypeKeyword</name></type> <name>Keyword</name></decl></parameter>,
<parameter><decl><type><name>NestedNameSpecifierLoc</name></type> <name>QualifierLoc</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>Named</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>getElaboratedType</name></name><argument_list>(<argument><expr><name>Keyword</name></expr></argument>,
<argument><expr><call><name><name>QualifierLoc</name><operator>.</operator><name>getNestedNameSpecifier</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>Named</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>






<function><type><name>QualType</name></type> <name>RebuildDependentTemplateSpecializationType</name><parameter_list>(
<parameter><decl><type><name>ElaboratedTypeKeyword</name></type> <name>Keyword</name></decl></parameter>,
<parameter><decl><type><name>NestedNameSpecifierLoc</name></type> <name>QualifierLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TemplateKWLoc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>IdentifierInfo</name> <modifier>*</modifier></type><name>Name</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>NameLoc</name></decl></parameter>,
<parameter><decl><type><name>TemplateArgumentListInfo</name> <modifier>&amp;</modifier></type><name>Args</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AllowInjectedClassName</name></decl></parameter>)</parameter_list> <block>{<block_content>


<decl_stmt><decl><type><name>CXXScopeSpec</name></type> <name>SS</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>SS</name><operator>.</operator><name>Adopt</name></name><argument_list>(<argument><expr><name>QualifierLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>TemplateName</name></type> <name>InstName</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildTemplateName</name><argument_list>(
<argument><expr><name>SS</name></expr></argument>, <argument><expr><name>TemplateKWLoc</name></expr></argument>, <argument><expr><operator>*</operator><name>Name</name></expr></argument>, <argument><expr><name>NameLoc</name></expr></argument>, <argument><expr><call><name>QualType</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><name>AllowInjectedClassName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>InstName</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name><name>InstName</name><operator>.</operator><name>getAsDependentTemplateName</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>getDependentTemplateSpecializationType</name></name><argument_list>(<argument><expr><name>Keyword</name></expr></argument>,
<argument><expr><call><name><name>QualifierLoc</name><operator>.</operator><name>getNestedNameSpecifier</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>Name</name></expr></argument>,
<argument><expr><name>Args</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>



<decl_stmt><decl><type><name>QualType</name></type> <name>T</name> <init>=
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildTemplateSpecializationType</name><argument_list>(<argument><expr><name>InstName</name></expr></argument>, <argument><expr><name>NameLoc</name></expr></argument>, <argument><expr><name>Args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>T</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>Keyword</name> <operator>==</operator> <name>ETK_None</name> <operator>&amp;&amp;</operator> <call><name><name>QualifierLoc</name><operator>.</operator><name>getNestedNameSpecifier</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>nullptr</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>T</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>getElaboratedType</name></name><argument_list>(<argument><expr><name>Keyword</name></expr></argument>,
<argument><expr><call><name><name>QualifierLoc</name><operator>.</operator><name>getNestedNameSpecifier</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>






<function><type><name>QualType</name></type> <name>RebuildDependentNameType</name><parameter_list>(<parameter><decl><type><name>ElaboratedTypeKeyword</name></type> <name>Keyword</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>KeywordLoc</name></decl></parameter>,
<parameter><decl><type><name>NestedNameSpecifierLoc</name></type> <name>QualifierLoc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>IdentifierInfo</name> <modifier>*</modifier></type><name>Id</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>IdLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>DeducedTSTContext</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>CXXScopeSpec</name></type> <name>SS</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>SS</name><operator>.</operator><name>Adopt</name></name><argument_list>(<argument><expr><name>QualifierLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>QualifierLoc</name><operator>.</operator><name>getNestedNameSpecifier</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isDependent</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>SemaRef</name><operator>.</operator><name>computeDeclContext</name></name><argument_list>(<argument><expr><name>SS</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>getDependentNameType</name></name><argument_list>(<argument><expr><name>Keyword</name></expr></argument>,
<argument><expr><call><name><name>QualifierLoc</name><operator>.</operator><name>getNestedNameSpecifier</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>Id</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>Keyword</name> <operator>==</operator> <name>ETK_None</name> <operator>||</operator> <name>Keyword</name> <operator>==</operator> <name>ETK_Typename</name></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>CheckTypenameType</name></name><argument_list>(<argument><expr><name>Keyword</name></expr></argument>, <argument><expr><name>KeywordLoc</name></expr></argument>, <argument><expr><name>QualifierLoc</name></expr></argument>,
<argument><expr><operator>*</operator><name>Id</name></expr></argument>, <argument><expr><name>IdLoc</name></expr></argument>, <argument><expr><name>DeducedTSTContext</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>TagTypeKind</name></type> <name>Kind</name> <init>= <expr><name>TypeWithKeyword</name><operator>::</operator><call><name>getTagTypeKindForKeyword</name><argument_list>(<argument><expr><name>Keyword</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>




<decl_stmt><decl><type><name>LookupResult</name></type> <name>Result</name><argument_list>(<argument><expr><name>SemaRef</name></expr></argument>, <argument><expr><name>Id</name></expr></argument>, <argument><expr><name>IdLoc</name></expr></argument>, <argument><expr><name>Sema</name><operator>::</operator><name>LookupTagName</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>DC</name> <init>= <expr><call><name><name>SemaRef</name><operator>.</operator><name>computeDeclContext</name></name><argument_list>(<argument><expr><name>SS</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>DC</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>SemaRef</name><operator>.</operator><name>RequireCompleteDeclContext</name></name><argument_list>(<argument><expr><name>SS</name></expr></argument>, <argument><expr><name>DC</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>TagDecl</name> <modifier>*</modifier></type><name>Tag</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>SemaRef</name><operator>.</operator><name>LookupQualifiedName</name></name><argument_list>(<argument><expr><name>Result</name></expr></argument>, <argument><expr><name>DC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>getResultKind</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>LookupResult</name><operator>::</operator><name>NotFound</name></expr>:</case>
<case>case <expr><name>LookupResult</name><operator>::</operator><name>NotFoundInCurrentInstantiation</name></expr>:</case>
<break>break;</break>

<case>case <expr><name>LookupResult</name><operator>::</operator><name>Found</name></expr>:</case>
<expr_stmt><expr><name>Tag</name> <operator>=</operator> <name><name>Result</name><operator>.</operator><name>getAsSingle</name></name><operator>&lt;</operator><name>TagDecl</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>LookupResult</name><operator>::</operator><name>FoundOverloaded</name></expr>:</case>
<case>case <expr><name>LookupResult</name><operator>::</operator><name>FoundUnresolvedValue</name></expr>:</case>
<expr_stmt><expr><call><name>llvm_unreachable</name><argument_list>(<argument><expr><literal type="string">"Tag lookup cannot find non-tags"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>LookupResult</name><operator>::</operator><name>Ambiguous</name></expr>:</case>

<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Tag</name></expr>)</condition> <block>{<block_content>


<decl_stmt><decl><type><name>LookupResult</name></type> <name>Result</name><argument_list>(<argument><expr><name>SemaRef</name></expr></argument>, <argument><expr><name>Id</name></expr></argument>, <argument><expr><name>IdLoc</name></expr></argument>, <argument><expr><name>Sema</name><operator>::</operator><name>LookupTagName</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>SemaRef</name><operator>.</operator><name>LookupQualifiedName</name></name><argument_list>(<argument><expr><name>Result</name></expr></argument>, <argument><expr><name>DC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>getResultKind</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>LookupResult</name><operator>::</operator><name>Found</name></expr>:</case>
<case>case <expr><name>LookupResult</name><operator>::</operator><name>FoundOverloaded</name></expr>:</case>
<case>case <expr><name>LookupResult</name><operator>::</operator><name>FoundUnresolvedValue</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>SomeDecl</name> <init>= <expr><call><name><name>Result</name><operator>.</operator><name>getRepresentativeDecl</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>Sema</name><operator>::</operator><name>NonTagKind</name> <name>NTK</name> <operator>=</operator> <call><name><name>SemaRef</name><operator>.</operator><name>getNonTagTypeDeclKind</name></name><argument_list>(<argument><expr><name>SomeDecl</name></expr></argument>, <argument><expr><name>Kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>SemaRef</name><operator>.</operator><name>Diag</name></name><argument_list>(<argument><expr><name>IdLoc</name></expr></argument>, <argument><expr><name>diag</name><operator>::</operator><name>err_tag_reference_non_tag</name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <name>SomeDecl</name>
<operator>&lt;&lt;</operator> <name>NTK</name> <operator>&lt;&lt;</operator> <name>Kind</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>SemaRef</name><operator>.</operator><name>Diag</name></name><argument_list>(<argument><expr><call><name><name>SomeDecl</name><operator>-&gt;</operator><name>getLocation</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>diag</name><operator>::</operator><name>note_declared_at</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<default>default:</default>
<expr_stmt><expr><call><name><name>SemaRef</name><operator>.</operator><name>Diag</name></name><argument_list>(<argument><expr><name>IdLoc</name></expr></argument>, <argument><expr><name>diag</name><operator>::</operator><name>err_not_tag_in_scope</name></expr></argument>)</argument_list></call>
<operator>&lt;&lt;</operator> <name>Kind</name> <operator>&lt;&lt;</operator> <name>Id</name> <operator>&lt;&lt;</operator> <name>DC</name> <operator>&lt;&lt;</operator> <call><name><name>QualifierLoc</name><operator>.</operator><name>getSourceRange</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>SemaRef</name><operator>.</operator><name>isAcceptableTagRedeclaration</name></name><argument_list>(<argument><expr><name>Tag</name></expr></argument>, <argument><expr><name>Kind</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
<argument><expr><name>IdLoc</name></expr></argument>, <argument><expr><name>Id</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>SemaRef</name><operator>.</operator><name>Diag</name></name><argument_list>(<argument><expr><name>KeywordLoc</name></expr></argument>, <argument><expr><name>diag</name><operator>::</operator><name>err_use_with_wrong_tag</name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <name>Id</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>SemaRef</name><operator>.</operator><name>Diag</name></name><argument_list>(<argument><expr><call><name><name>Tag</name><operator>-&gt;</operator><name>getLocation</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>diag</name><operator>::</operator><name>note_previous_use</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>


<decl_stmt><decl><type><name>QualType</name></type> <name>T</name> <init>= <expr><call><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>getTypeDeclType</name></name><argument_list>(<argument><expr><name>Tag</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>getElaboratedType</name></name><argument_list>(<argument><expr><name>Keyword</name></expr></argument>,
<argument><expr><call><name><name>QualifierLoc</name><operator>.</operator><name>getNestedNameSpecifier</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>QualType</name></type> <name>RebuildPackExpansionType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>Pattern</name></decl></parameter>,
<parameter><decl><type><name>SourceRange</name></type> <name>PatternRange</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EllipsisLoc</name></decl></parameter>,
<parameter><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></type> <name>NumExpansions</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>CheckPackExpansion</name><argument_list>(<argument><expr><name>Pattern</name></expr></argument>, <argument><expr><name>PatternRange</name></expr></argument>, <argument><expr><name>EllipsisLoc</name></expr></argument>,
<argument><expr><name>NumExpansions</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function_decl><type><name>QualType</name></type> <name>RebuildAtomicType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>ValueType</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>KWLoc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>QualType</name></type> <name>RebuildPipeType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>ValueType</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>KWLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>isReadPipe</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>QualType</name></type> <name>RebuildExtIntType</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>IsUnsigned</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>NumBits</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>QualType</name></type> <name>RebuildDependentExtIntType</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>IsUnsigned</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>NumBitsExpr</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>







<function_decl><type><name>TemplateName</name></type> <name>RebuildTemplateName</name><parameter_list>(<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>TemplateKW</name></decl></parameter>,
<parameter><decl><type><name>TemplateDecl</name> <modifier>*</modifier></type><name>Template</name></decl></parameter>)</parameter_list>;</function_decl>








<function_decl><type><name>TemplateName</name></type> <name>RebuildTemplateName</name><parameter_list>(<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TemplateKWLoc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>IdentifierInfo</name> <modifier>&amp;</modifier></type><name>Name</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>NameLoc</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>ObjectType</name></decl></parameter>,
<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>FirstQualifierInScope</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AllowInjectedClassName</name></decl></parameter>)</parameter_list>;</function_decl>








<function_decl><type><name>TemplateName</name></type> <name>RebuildTemplateName</name><parameter_list>(<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TemplateKWLoc</name></decl></parameter>,
<parameter><decl><type><name>OverloadedOperatorKind</name></type> <name>Operator</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>NameLoc</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>ObjectType</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AllowInjectedClassName</name></decl></parameter>)</parameter_list>;</function_decl>








<function><type><name>TemplateName</name></type> <name>RebuildTemplateName</name><parameter_list>(<parameter><decl><type><name>TemplateTemplateParmDecl</name> <modifier>*</modifier></type><name>Param</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>TemplateArgument</name> <modifier>&amp;</modifier></type><name>ArgPack</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>Context</name><operator>.</operator><name>getSubstTemplateTemplateParmPack</name></name><argument_list>(<argument><expr><name>Param</name></expr></argument>, <argument><expr><name>ArgPack</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>StmtResult</name></type> <name>RebuildCompoundStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>LBraceLoc</name></decl></parameter>,
<parameter><decl><type><name>MultiStmtArg</name></type> <name>Statements</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RBraceLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsStmtExpr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnCompoundStmt</name><argument_list>(<argument><expr><name>LBraceLoc</name></expr></argument>, <argument><expr><name>RBraceLoc</name></expr></argument>, <argument><expr><name>Statements</name></expr></argument>,
<argument><expr><name>IsStmtExpr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>StmtResult</name></type> <name>RebuildCaseStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>CaseLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>LHS</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EllipsisLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>RHS</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ColonLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnCaseStmt</name><argument_list>(<argument><expr><name>CaseLoc</name></expr></argument>, <argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>EllipsisLoc</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>,
<argument><expr><name>ColonLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>StmtResult</name></type> <name>RebuildCaseStmtBody</name><parameter_list>(<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Body</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnCaseStmtBody</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>Body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>S</name></expr>;</return>
</block_content>}</block></function>





<function><type><name>StmtResult</name></type> <name>RebuildDefaultStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>DefaultLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ColonLoc</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>SubStmt</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnDefaultStmt</name><argument_list>(<argument><expr><name>DefaultLoc</name></expr></argument>, <argument><expr><name>ColonLoc</name></expr></argument>, <argument><expr><name>SubStmt</name></expr></argument>,
<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>StmtResult</name></type> <name>RebuildLabelStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>IdentLoc</name></decl></parameter>, <parameter><decl><type><name>LabelDecl</name> <modifier>*</modifier></type><name>L</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ColonLoc</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>SubStmt</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>ActOnLabelStmt</name></name><argument_list>(<argument><expr><name>IdentLoc</name></expr></argument>, <argument><expr><name>L</name></expr></argument>, <argument><expr><name>ColonLoc</name></expr></argument>, <argument><expr><name>SubStmt</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>StmtResult</name></type> <name>RebuildAttributedStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>AttrLoc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Attr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Attrs</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>SubStmt</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>BuildAttributedStmt</name></name><argument_list>(<argument><expr><name>AttrLoc</name></expr></argument>, <argument><expr><name>Attrs</name></expr></argument>, <argument><expr><name>SubStmt</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<decl_stmt><decl><type><name>StmtResult</name></type> <name>RebuildIfStmt</name><argument_list>(<argument><expr><name>SourceLocation</name> <name>IfLoc</name></expr></argument>, <argument><expr><name>bool</name> <name>IsConstexpr</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>LParenLoc</name></expr></argument>, <argument><expr><name>Sema</name><operator>::</operator><name>ConditionResult</name> <name>Cond</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>RParenLoc</name></expr></argument>, <argument><expr><name>Stmt</name> <operator>*</operator><name>Init</name></expr></argument>, <argument><expr><name>Stmt</name> <operator>*</operator><name>Then</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>ElseLoc</name></expr></argument>, <argument><expr><name>Stmt</name> <operator>*</operator><name>Else</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnIfStmt</name><argument_list>(<argument><expr><name>IfLoc</name></expr></argument>, <argument><expr><name>IsConstexpr</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>Init</name></expr></argument>, <argument><expr><name>Cond</name></expr></argument>,
<argument><expr><name>RParenLoc</name></expr></argument>, <argument><expr><name>Then</name></expr></argument>, <argument><expr><name>ElseLoc</name></expr></argument>, <argument><expr><name>Else</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>





<decl_stmt><decl><type><name>StmtResult</name></type> <name>RebuildSwitchStmtStart</name><argument_list>(<argument><expr><name>SourceLocation</name> <name>SwitchLoc</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>LParenLoc</name></expr></argument>, <argument><expr><name>Stmt</name> <operator>*</operator><name>Init</name></expr></argument>,
<argument><expr><name>Sema</name><operator>::</operator><name>ConditionResult</name> <name>Cond</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>RParenLoc</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnStartOfSwitchStmt</name><argument_list>(<argument><expr><name>SwitchLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>Init</name></expr></argument>, <argument><expr><name>Cond</name></expr></argument>,
<argument><expr><name>RParenLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>





<function><type><name>StmtResult</name></type> <name>RebuildSwitchStmtBody</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>SwitchLoc</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Switch</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Body</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnFinishSwitchStmt</name><argument_list>(<argument><expr><name>SwitchLoc</name></expr></argument>, <argument><expr><name>Switch</name></expr></argument>, <argument><expr><name>Body</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<decl_stmt><decl><type><name>StmtResult</name></type> <name>RebuildWhileStmt</name><argument_list>(<argument><expr><name>SourceLocation</name> <name>WhileLoc</name></expr></argument>, <argument><expr><name>SourceLocation</name> <name>LParenLoc</name></expr></argument>,
<argument><expr><name>Sema</name><operator>::</operator><name>ConditionResult</name> <name>Cond</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>RParenLoc</name></expr></argument>, <argument><expr><name>Stmt</name> <operator>*</operator><name>Body</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnWhileStmt</name><argument_list>(<argument><expr><name>WhileLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>Cond</name></expr></argument>, <argument><expr><name>RParenLoc</name></expr></argument>, <argument><expr><name>Body</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>





<function><type><name>StmtResult</name></type> <name>RebuildDoStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>DoLoc</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Body</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>WhileLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Cond</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnDoStmt</name><argument_list>(<argument><expr><name>DoLoc</name></expr></argument>, <argument><expr><name>Body</name></expr></argument>, <argument><expr><name>WhileLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>,
<argument><expr><name>Cond</name></expr></argument>, <argument><expr><name>RParenLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<decl_stmt><decl><type><name>StmtResult</name></type> <name>RebuildForStmt</name><argument_list>(<argument><expr><name>SourceLocation</name> <name>ForLoc</name></expr></argument>, <argument><expr><name>SourceLocation</name> <name>LParenLoc</name></expr></argument>,
<argument><expr><name>Stmt</name> <operator>*</operator><name>Init</name></expr></argument>, <argument><expr><name>Sema</name><operator>::</operator><name>ConditionResult</name> <name>Cond</name></expr></argument>,
<argument><expr><name>Sema</name><operator>::</operator><name>FullExprArg</name> <name>Inc</name></expr></argument>, <argument><expr><name>SourceLocation</name> <name>RParenLoc</name></expr></argument>,
<argument><expr><name>Stmt</name> <operator>*</operator><name>Body</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnForStmt</name><argument_list>(<argument><expr><name>ForLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>Init</name></expr></argument>, <argument><expr><name>Cond</name></expr></argument>,
<argument><expr><name>Inc</name></expr></argument>, <argument><expr><name>RParenLoc</name></expr></argument>, <argument><expr><name>Body</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>





<function><type><name>StmtResult</name></type> <name>RebuildGotoStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>GotoLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>LabelLoc</name></decl></parameter>,
<parameter><decl><type><name>LabelDecl</name> <modifier>*</modifier></type><name>Label</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnGotoStmt</name><argument_list>(<argument><expr><name>GotoLoc</name></expr></argument>, <argument><expr><name>LabelLoc</name></expr></argument>, <argument><expr><name>Label</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>StmtResult</name></type> <name>RebuildIndirectGotoStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>GotoLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StarLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Target</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnIndirectGotoStmt</name><argument_list>(<argument><expr><name>GotoLoc</name></expr></argument>, <argument><expr><name>StarLoc</name></expr></argument>, <argument><expr><name>Target</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>StmtResult</name></type> <name>RebuildReturnStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>ReturnLoc</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Result</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildReturnStmt</name><argument_list>(<argument><expr><name>ReturnLoc</name></expr></argument>, <argument><expr><name>Result</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>StmtResult</name></type> <name>RebuildDeclStmt</name><parameter_list>(<parameter><decl><type><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Decls</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>Sema</name><operator>::</operator><name>DeclGroupPtrTy</name> <name>DG</name> <operator>=</operator> <call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildDeclaratorGroup</name><argument_list>(<argument><expr><name>Decls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnDeclStmt</name><argument_list>(<argument><expr><name>DG</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>StmtResult</name></type> <name>RebuildGCCAsmStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>AsmLoc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsSimple</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsVolatile</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>NumOutputs</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>NumInputs</name></decl></parameter>, <parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>Names</name></decl></parameter>,
<parameter><decl><type><name>MultiExprArg</name></type> <name>Constraints</name></decl></parameter>, <parameter><decl><type><name>MultiExprArg</name></type> <name>Exprs</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>AsmString</name></decl></parameter>, <parameter><decl><type><name>MultiExprArg</name></type> <name>Clobbers</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>NumLabels</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnGCCAsmStmt</name><argument_list>(<argument><expr><name>AsmLoc</name></expr></argument>, <argument><expr><name>IsSimple</name></expr></argument>, <argument><expr><name>IsVolatile</name></expr></argument>, <argument><expr><name>NumOutputs</name></expr></argument>,
<argument><expr><name>NumInputs</name></expr></argument>, <argument><expr><name>Names</name></expr></argument>, <argument><expr><name>Constraints</name></expr></argument>, <argument><expr><name>Exprs</name></expr></argument>,
<argument><expr><name>AsmString</name></expr></argument>, <argument><expr><name>Clobbers</name></expr></argument>, <argument><expr><name>NumLabels</name></expr></argument>, <argument><expr><name>RParenLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>StmtResult</name></type> <name>RebuildMSAsmStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>AsmLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>LBraceLoc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Token</name></expr></argument>&gt;</argument_list></name></type> <name>AsmToks</name></decl></parameter>,
<parameter><decl><type><name>StringRef</name></type> <name>AsmString</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>NumOutputs</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>NumInputs</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>StringRef</name></expr></argument>&gt;</argument_list></name></type> <name>Constraints</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>StringRef</name></expr></argument>&gt;</argument_list></name></type> <name>Clobbers</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name><modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Exprs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnMSAsmStmt</name><argument_list>(<argument><expr><name>AsmLoc</name></expr></argument>, <argument><expr><name>LBraceLoc</name></expr></argument>, <argument><expr><name>AsmToks</name></expr></argument>, <argument><expr><name>AsmString</name></expr></argument>,
<argument><expr><name>NumOutputs</name></expr></argument>, <argument><expr><name>NumInputs</name></expr></argument>,
<argument><expr><name>Constraints</name></expr></argument>, <argument><expr><name>Clobbers</name></expr></argument>, <argument><expr><name>Exprs</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>StmtResult</name></type> <name>RebuildCoreturnStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>CoreturnLoc</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Result</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsImplicit</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildCoreturnStmt</name><argument_list>(<argument><expr><name>CoreturnLoc</name></expr></argument>, <argument><expr><name>Result</name></expr></argument>, <argument><expr><name>IsImplicit</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildCoawaitExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>CoawaitLoc</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Result</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsImplicit</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildResolvedCoawaitExpr</name><argument_list>(<argument><expr><name>CoawaitLoc</name></expr></argument>, <argument><expr><name>Result</name></expr></argument>, <argument><expr><name>IsImplicit</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildDependentCoawaitExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>CoawaitLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Result</name></decl></parameter>,
<parameter><decl><type><name>UnresolvedLookupExpr</name> <modifier>*</modifier></type><name>Lookup</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildUnresolvedCoawaitExpr</name><argument_list>(<argument><expr><name>CoawaitLoc</name></expr></argument>, <argument><expr><name>Result</name></expr></argument>, <argument><expr><name>Lookup</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildCoyieldExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>CoyieldLoc</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Result</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildCoyieldExpr</name><argument_list>(<argument><expr><name>CoyieldLoc</name></expr></argument>, <argument><expr><name>Result</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><name>StmtResult</name></type> <name>RebuildCoroutineBodyStmt</name><argument_list>(<argument><expr><name>CoroutineBodyStmt</name><operator>::</operator><name>CtorArgs</name> <name>Args</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildCoroutineBodyStmt</name><argument_list>(<argument><expr><name>Args</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>





<function><type><name>StmtResult</name></type> <name>RebuildObjCAtTryStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>AtLoc</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>TryBody</name></decl></parameter>,
<parameter><decl><type><name>MultiStmtArg</name></type> <name>CatchStmts</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Finally</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnObjCAtTryStmt</name><argument_list>(<argument><expr><name>AtLoc</name></expr></argument>, <argument><expr><name>TryBody</name></expr></argument>, <argument><expr><name>CatchStmts</name></expr></argument>,
<argument><expr><name>Finally</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>VarDecl</name> <modifier>*</modifier></type><name>RebuildObjCExceptionDecl</name><parameter_list>(<parameter><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>ExceptionDecl</name></decl></parameter>,
<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TInfo</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildObjCExceptionDecl</name><argument_list>(<argument><expr><name>TInfo</name></expr></argument>, <argument><expr><name>T</name></expr></argument>,
<argument><expr><call><name><name>ExceptionDecl</name><operator>-&gt;</operator><name>getInnerLocStart</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>ExceptionDecl</name><operator>-&gt;</operator><name>getLocation</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>ExceptionDecl</name><operator>-&gt;</operator><name>getIdentifier</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>StmtResult</name></type> <name>RebuildObjCAtCatchStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>AtLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>,
<parameter><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>Var</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Body</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnObjCAtCatchStmt</name><argument_list>(<argument><expr><name>AtLoc</name></expr></argument>, <argument><expr><name>RParenLoc</name></expr></argument>,
<argument><expr><name>Var</name></expr></argument>, <argument><expr><name>Body</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>StmtResult</name></type> <name>RebuildObjCAtFinallyStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>AtLoc</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Body</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnObjCAtFinallyStmt</name><argument_list>(<argument><expr><name>AtLoc</name></expr></argument>, <argument><expr><name>Body</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>StmtResult</name></type> <name>RebuildObjCAtThrowStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>AtLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Operand</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildObjCAtThrowStmt</name><argument_list>(<argument><expr><name>AtLoc</name></expr></argument>, <argument><expr><name>Operand</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>StmtResult</name></type> <name>RebuildOMPCanonicalLoop</name><parameter_list>(<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>LoopStmt</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPCanonicalLoop</name><argument_list>(<argument><expr><name>LoopStmt</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>StmtResult</name></type> <name>RebuildOMPExecutableDirective</name><parameter_list>(<parameter><decl><type><name>OpenMPDirectiveKind</name></type> <name>Kind</name></decl></parameter>,
<parameter><decl><type><name>DeclarationNameInfo</name></type> <name>DirName</name></decl></parameter>,
<parameter><decl><type><name>OpenMPDirectiveKind</name></type> <name>CancelRegion</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPExecutableDirective</name><argument_list>(
<argument><expr><name>Kind</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>, <argument><expr><name>CancelRegion</name></expr></argument>, <argument><expr><name>Clauses</name></expr></argument>, <argument><expr><name>AStmt</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type><name>RebuildOMPIfClause</name><parameter_list>(<parameter><decl><type><name>OpenMPDirectiveKind</name></type> <name>NameModifier</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Condition</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>NameModifierLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ColonLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPIfClause</name><argument_list>(<argument><expr><name>NameModifier</name></expr></argument>, <argument><expr><name>Condition</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>,
<argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>NameModifierLoc</name></expr></argument>, <argument><expr><name>ColonLoc</name></expr></argument>,
<argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type><name>RebuildOMPFinalClause</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Condition</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPFinalClause</name><argument_list>(<argument><expr><name>Condition</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>,
<argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type><name>RebuildOMPNumThreadsClause</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>NumThreads</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPNumThreadsClause</name><argument_list>(<argument><expr><name>NumThreads</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>,
<argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type><name>RebuildOMPSafelenClause</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Len</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPSafelenClause</name><argument_list>(<argument><expr><name>Len</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type><name>RebuildOMPSimdlenClause</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Len</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPSimdlenClause</name><argument_list>(<argument><expr><name>Len</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>OMPClause</name> <modifier>*</modifier></type><name>RebuildOMPSizesClause</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Sizes</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPSizesClause</name><argument_list>(<argument><expr><name>Sizes</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>OMPClause</name> <modifier>*</modifier></type><name>RebuildOMPFullClause</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPFullClause</name><argument_list>(<argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>OMPClause</name> <modifier>*</modifier></type><name>RebuildOMPPartialClause</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Factor</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPPartialClause</name><argument_list>(<argument><expr><name>Factor</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>,
<argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type><name>RebuildOMPAllocatorClause</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>A</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPAllocatorClause</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type><name>RebuildOMPCollapseClause</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Num</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPCollapseClause</name><argument_list>(<argument><expr><name>Num</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>,
<argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type><name>RebuildOMPDefaultClause</name><parameter_list>(<parameter><decl><type><name>DefaultKind</name></type> <name>Kind</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>KindKwLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPDefaultClause</name><argument_list>(<argument><expr><name>Kind</name></expr></argument>, <argument><expr><name>KindKwLoc</name></expr></argument>,
<argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type><name>RebuildOMPProcBindClause</name><parameter_list>(<parameter><decl><type><name>ProcBindKind</name></type> <name>Kind</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>KindKwLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPProcBindClause</name><argument_list>(<argument><expr><name>Kind</name></expr></argument>, <argument><expr><name>KindKwLoc</name></expr></argument>,
<argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type><name>RebuildOMPScheduleClause</name><parameter_list>(
<parameter><decl><type><name>OpenMPScheduleClauseModifier</name></type> <name>M1</name></decl></parameter>, <parameter><decl><type><name>OpenMPScheduleClauseModifier</name></type> <name>M2</name></decl></parameter>,
<parameter><decl><type><name>OpenMPScheduleClauseKind</name></type> <name>Kind</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>ChunkSize</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>M1Loc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>M2Loc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>KindLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>CommaLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPScheduleClause</name><argument_list>(
<argument><expr><name>M1</name></expr></argument>, <argument><expr><name>M2</name></expr></argument>, <argument><expr><name>Kind</name></expr></argument>, <argument><expr><name>ChunkSize</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>M1Loc</name></expr></argument>, <argument><expr><name>M2Loc</name></expr></argument>, <argument><expr><name>KindLoc</name></expr></argument>,
<argument><expr><name>CommaLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type><name>RebuildOMPOrderedClause</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Num</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPOrderedClause</name><argument_list>(<argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>Num</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type><name>RebuildOMPPrivateClause</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>VarList</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPPrivateClause</name><argument_list>(<argument><expr><name>VarList</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>,
<argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type><name>RebuildOMPFirstprivateClause</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>VarList</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPFirstprivateClause</name><argument_list>(<argument><expr><name>VarList</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>,
<argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type><name>RebuildOMPLastprivateClause</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>VarList</name></decl></parameter>,
<parameter><decl><type><name>OpenMPLastprivateModifier</name></type> <name>LPKind</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LPKindLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ColonLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPLastprivateClause</name><argument_list>(
<argument><expr><name>VarList</name></expr></argument>, <argument><expr><name>LPKind</name></expr></argument>, <argument><expr><name>LPKindLoc</name></expr></argument>, <argument><expr><name>ColonLoc</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type><name>RebuildOMPSharedClause</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>VarList</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPSharedClause</name><argument_list>(<argument><expr><name>VarList</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>,
<argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type><name>RebuildOMPReductionClause</name><parameter_list>(
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>VarList</name></decl></parameter>, <parameter><decl><type><name>OpenMPReductionClauseModifier</name></type> <name>Modifier</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ModifierLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>ColonLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>, <parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>ReductionIdScopeSpec</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>DeclarationNameInfo</name> <modifier>&amp;</modifier></type><name>ReductionId</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>UnresolvedReductions</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPReductionClause</name><argument_list>(
<argument><expr><name>VarList</name></expr></argument>, <argument><expr><name>Modifier</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>ModifierLoc</name></expr></argument>, <argument><expr><name>ColonLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>,
<argument><expr><name>ReductionIdScopeSpec</name></expr></argument>, <argument><expr><name>ReductionId</name></expr></argument>, <argument><expr><name>UnresolvedReductions</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type><name>RebuildOMPTaskReductionClause</name><parameter_list>(
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>VarList</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>ColonLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>,
<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>ReductionIdScopeSpec</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>DeclarationNameInfo</name> <modifier>&amp;</modifier></type><name>ReductionId</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>UnresolvedReductions</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPTaskReductionClause</name><argument_list>(
<argument><expr><name>VarList</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>ColonLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>, <argument><expr><name>ReductionIdScopeSpec</name></expr></argument>,
<argument><expr><name>ReductionId</name></expr></argument>, <argument><expr><name>UnresolvedReductions</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type>
<name>RebuildOMPInReductionClause</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>VarList</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>ColonLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>,
<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>ReductionIdScopeSpec</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>DeclarationNameInfo</name> <modifier>&amp;</modifier></type><name>ReductionId</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>UnresolvedReductions</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPInReductionClause</name><argument_list>(
<argument><expr><name>VarList</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>ColonLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>, <argument><expr><name>ReductionIdScopeSpec</name></expr></argument>,
<argument><expr><name>ReductionId</name></expr></argument>, <argument><expr><name>UnresolvedReductions</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type><name>RebuildOMPLinearClause</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>VarList</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Step</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>OpenMPLinearClauseKind</name></type> <name>Modifier</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ModifierLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ColonLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPLinearClause</name><argument_list>(<argument><expr><name>VarList</name></expr></argument>, <argument><expr><name>Step</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>,
<argument><expr><name>Modifier</name></expr></argument>, <argument><expr><name>ModifierLoc</name></expr></argument>, <argument><expr><name>ColonLoc</name></expr></argument>,
<argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type><name>RebuildOMPAlignedClause</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>VarList</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Alignment</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ColonLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPAlignedClause</name><argument_list>(<argument><expr><name>VarList</name></expr></argument>, <argument><expr><name>Alignment</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>,
<argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>ColonLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type><name>RebuildOMPCopyinClause</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>VarList</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPCopyinClause</name><argument_list>(<argument><expr><name>VarList</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>,
<argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type><name>RebuildOMPCopyprivateClause</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>VarList</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPCopyprivateClause</name><argument_list>(<argument><expr><name>VarList</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>,
<argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type><name>RebuildOMPFlushClause</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>VarList</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPFlushClause</name><argument_list>(<argument><expr><name>VarList</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>,
<argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type><name>RebuildOMPDepobjClause</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Depobj</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPDepobjClause</name><argument_list>(<argument><expr><name>Depobj</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>,
<argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type>
<name>RebuildOMPDependClause</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>DepModifier</name></decl></parameter>, <parameter><decl><type><name>OpenMPDependClauseKind</name></type> <name>DepKind</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>DepLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>ColonLoc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>VarList</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPDependClause</name><argument_list>(<argument><expr><name>DepModifier</name></expr></argument>, <argument><expr><name>DepKind</name></expr></argument>, <argument><expr><name>DepLoc</name></expr></argument>,
<argument><expr><name>ColonLoc</name></expr></argument>, <argument><expr><name>VarList</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>,
<argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type><name>RebuildOMPDeviceClause</name><parameter_list>(<parameter><decl><type><name>OpenMPDeviceClauseModifier</name></type> <name>Modifier</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Device</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ModifierLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPDeviceClause</name><argument_list>(<argument><expr><name>Modifier</name></expr></argument>, <argument><expr><name>Device</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>,
<argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>ModifierLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type><name>RebuildOMPMapClause</name><parameter_list>(
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OpenMPMapModifierKind</name></expr></argument>&gt;</argument_list></name></type> <name>MapTypeModifiers</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name></type> <name>MapTypeModifiersLoc</name></decl></parameter>,
<parameter><decl><type><name>CXXScopeSpec</name></type> <name>MapperIdScopeSpec</name></decl></parameter>, <parameter><decl><type><name>DeclarationNameInfo</name></type> <name>MapperId</name></decl></parameter>,
<parameter><decl><type><name>OpenMPMapClauseKind</name></type> <name>MapType</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsMapTypeImplicit</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>MapLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>ColonLoc</name></decl></parameter>, <parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>VarList</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>OMPVarListLocTy</name> <modifier>&amp;</modifier></type><name>Locs</name></decl></parameter>, <parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>UnresolvedMappers</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPMapClause</name><argument_list>(<argument><expr><name>MapTypeModifiers</name></expr></argument>, <argument><expr><name>MapTypeModifiersLoc</name></expr></argument>,
<argument><expr><name>MapperIdScopeSpec</name></expr></argument>, <argument><expr><name>MapperId</name></expr></argument>, <argument><expr><name>MapType</name></expr></argument>,
<argument><expr><name>IsMapTypeImplicit</name></expr></argument>, <argument><expr><name>MapLoc</name></expr></argument>, <argument><expr><name>ColonLoc</name></expr></argument>,
<argument><expr><name>VarList</name></expr></argument>, <argument><expr><name>Locs</name></expr></argument>, <argument><expr><name>UnresolvedMappers</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type><name>RebuildOMPAllocateClause</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Allocate</name></decl></parameter>, <parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>VarList</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ColonLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPAllocateClause</name><argument_list>(<argument><expr><name>Allocate</name></expr></argument>, <argument><expr><name>VarList</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>,
<argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>ColonLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type><name>RebuildOMPNumTeamsClause</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>NumTeams</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPNumTeamsClause</name><argument_list>(<argument><expr><name>NumTeams</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>,
<argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type><name>RebuildOMPThreadLimitClause</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>ThreadLimit</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPThreadLimitClause</name><argument_list>(<argument><expr><name>ThreadLimit</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>,
<argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type><name>RebuildOMPPriorityClause</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Priority</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPPriorityClause</name><argument_list>(<argument><expr><name>Priority</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>,
<argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type><name>RebuildOMPGrainsizeClause</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Grainsize</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPGrainsizeClause</name><argument_list>(<argument><expr><name>Grainsize</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>,
<argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type><name>RebuildOMPNumTasksClause</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>NumTasks</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPNumTasksClause</name><argument_list>(<argument><expr><name>NumTasks</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>,
<argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type><name>RebuildOMPHintClause</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Hint</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPHintClause</name><argument_list>(<argument><expr><name>Hint</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type><name>RebuildOMPDetachClause</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Evt</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPDetachClause</name><argument_list>(<argument><expr><name>Evt</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type>
<name>RebuildOMPDistScheduleClause</name><parameter_list>(<parameter><decl><type><name>OpenMPDistScheduleClauseKind</name></type> <name>Kind</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>ChunkSize</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>KindLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>CommaLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPDistScheduleClause</name><argument_list>(
<argument><expr><name>Kind</name></expr></argument>, <argument><expr><name>ChunkSize</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>KindLoc</name></expr></argument>, <argument><expr><name>CommaLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type>
<name>RebuildOMPToClause</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OpenMPMotionModifierKind</name></expr></argument>&gt;</argument_list></name></type> <name>MotionModifiers</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name></type> <name>MotionModifiersLoc</name></decl></parameter>,
<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>MapperIdScopeSpec</name></decl></parameter>,
<parameter><decl><type><name>DeclarationNameInfo</name> <modifier>&amp;</modifier></type><name>MapperId</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>ColonLoc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>VarList</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>OMPVarListLocTy</name> <modifier>&amp;</modifier></type><name>Locs</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>UnresolvedMappers</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPToClause</name><argument_list>(<argument><expr><name>MotionModifiers</name></expr></argument>, <argument><expr><name>MotionModifiersLoc</name></expr></argument>,
<argument><expr><name>MapperIdScopeSpec</name></expr></argument>, <argument><expr><name>MapperId</name></expr></argument>, <argument><expr><name>ColonLoc</name></expr></argument>,
<argument><expr><name>VarList</name></expr></argument>, <argument><expr><name>Locs</name></expr></argument>, <argument><expr><name>UnresolvedMappers</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type>
<name>RebuildOMPFromClause</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OpenMPMotionModifierKind</name></expr></argument>&gt;</argument_list></name></type> <name>MotionModifiers</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name></type> <name>MotionModifiersLoc</name></decl></parameter>,
<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>MapperIdScopeSpec</name></decl></parameter>,
<parameter><decl><type><name>DeclarationNameInfo</name> <modifier>&amp;</modifier></type><name>MapperId</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>ColonLoc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>VarList</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>OMPVarListLocTy</name> <modifier>&amp;</modifier></type><name>Locs</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>UnresolvedMappers</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPFromClause</name><argument_list>(
<argument><expr><name>MotionModifiers</name></expr></argument>, <argument><expr><name>MotionModifiersLoc</name></expr></argument>, <argument><expr><name>MapperIdScopeSpec</name></expr></argument>, <argument><expr><name>MapperId</name></expr></argument>,
<argument><expr><name>ColonLoc</name></expr></argument>, <argument><expr><name>VarList</name></expr></argument>, <argument><expr><name>Locs</name></expr></argument>, <argument><expr><name>UnresolvedMappers</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type><name>RebuildOMPUseDevicePtrClause</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>VarList</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>OMPVarListLocTy</name> <modifier>&amp;</modifier></type><name>Locs</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPUseDevicePtrClause</name><argument_list>(<argument><expr><name>VarList</name></expr></argument>, <argument><expr><name>Locs</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type><name>RebuildOMPUseDeviceAddrClause</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>VarList</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>OMPVarListLocTy</name> <modifier>&amp;</modifier></type><name>Locs</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPUseDeviceAddrClause</name><argument_list>(<argument><expr><name>VarList</name></expr></argument>, <argument><expr><name>Locs</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type><name>RebuildOMPIsDevicePtrClause</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>VarList</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>OMPVarListLocTy</name> <modifier>&amp;</modifier></type><name>Locs</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPIsDevicePtrClause</name><argument_list>(<argument><expr><name>VarList</name></expr></argument>, <argument><expr><name>Locs</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type><name>RebuildOMPDefaultmapClause</name><parameter_list>(<parameter><decl><type><name>OpenMPDefaultmapClauseModifier</name></type> <name>M</name></decl></parameter>,
<parameter><decl><type><name>OpenMPDefaultmapClauseKind</name></type> <name>Kind</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>MLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>KindLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPDefaultmapClause</name><argument_list>(<argument><expr><name>M</name></expr></argument>, <argument><expr><name>Kind</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>,
<argument><expr><name>MLoc</name></expr></argument>, <argument><expr><name>KindLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type><name>RebuildOMPNontemporalClause</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>VarList</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPNontemporalClause</name><argument_list>(<argument><expr><name>VarList</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>,
<argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type><name>RebuildOMPInclusiveClause</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>VarList</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPInclusiveClause</name><argument_list>(<argument><expr><name>VarList</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>,
<argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type><name>RebuildOMPExclusiveClause</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>VarList</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPExclusiveClause</name><argument_list>(<argument><expr><name>VarList</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>,
<argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type><name>RebuildOMPUsesAllocatorsClause</name><parameter_list>(
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Sema</name><operator>::</operator><name>UsesAllocatorsData</name></expr></argument>&gt;</argument_list></name></type> <name>Data</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPUsesAllocatorClause</name><argument_list>(<argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>,
<argument><expr><name>Data</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type><name>RebuildOMPAffinityClause</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ColonLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Modifier</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Locators</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPAffinityClause</name><argument_list>(<argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>ColonLoc</name></expr></argument>,
<argument><expr><name>EndLoc</name></expr></argument>, <argument><expr><name>Modifier</name></expr></argument>, <argument><expr><name>Locators</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type><name>RebuildOMPOrderClause</name><parameter_list>(<parameter><decl><type><name>OpenMPOrderClauseKind</name></type> <name>Kind</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>KindKwLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPOrderClause</name><argument_list>(<argument><expr><name>Kind</name></expr></argument>, <argument><expr><name>KindKwLoc</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>,
<argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type><name>RebuildOMPInitClause</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>InteropVar</name></decl></parameter>, <parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>PrefExprs</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsTarget</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsTargetSync</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>VarLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPInitClause</name><argument_list>(<argument><expr><name>InteropVar</name></expr></argument>, <argument><expr><name>PrefExprs</name></expr></argument>, <argument><expr><name>IsTarget</name></expr></argument>,
<argument><expr><name>IsTargetSync</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>,
<argument><expr><name>VarLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type><name>RebuildOMPUseClause</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>InteropVar</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>VarLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPUseClause</name><argument_list>(<argument><expr><name>InteropVar</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>,
<argument><expr><name>VarLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type><name>RebuildOMPDestroyClause</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>InteropVar</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>VarLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPDestroyClause</name><argument_list>(<argument><expr><name>InteropVar</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>,
<argument><expr><name>VarLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type><name>RebuildOMPNovariantsClause</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Condition</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPNovariantsClause</name><argument_list>(<argument><expr><name>Condition</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>,
<argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type><name>RebuildOMPNocontextClause</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Condition</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPNocontextClause</name><argument_list>(<argument><expr><name>Condition</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>,
<argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>OMPClause</name> <modifier>*</modifier></type><name>RebuildOMPFilterClause</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>ThreadID</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPFilterClause</name><argument_list>(<argument><expr><name>ThreadID</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>,
<argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildObjCAtSynchronizedOperand</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>atLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>object</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnObjCAtSynchronizedOperand</name><argument_list>(<argument><expr><name>atLoc</name></expr></argument>, <argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>StmtResult</name></type> <name>RebuildObjCAtSynchronizedStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>AtLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Object</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Body</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnObjCAtSynchronizedStmt</name><argument_list>(<argument><expr><name>AtLoc</name></expr></argument>, <argument><expr><name>Object</name></expr></argument>, <argument><expr><name>Body</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>StmtResult</name></type> <name>RebuildObjCAutoreleasePoolStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>AtLoc</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Body</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnObjCAutoreleasePoolStmt</name><argument_list>(<argument><expr><name>AtLoc</name></expr></argument>, <argument><expr><name>Body</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>StmtResult</name></type> <name>RebuildObjCForCollectionStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>ForLoc</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Element</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Collection</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Body</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>StmtResult</name></type> <name>ForEachStmt</name> <init>= <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnObjCForCollectionStmt</name><argument_list>(<argument><expr><name>ForLoc</name></expr></argument>,
<argument><expr><name>Element</name></expr></argument>,
<argument><expr><name>Collection</name></expr></argument>,
<argument><expr><name>RParenLoc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>ForEachStmt</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>FinishObjCForCollectionStmt</name><argument_list>(<argument><expr><call><name><name>ForEachStmt</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Body</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>VarDecl</name> <modifier>*</modifier></type><name>RebuildExceptionDecl</name><parameter_list>(<parameter><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>ExceptionDecl</name></decl></parameter>,
<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>Declarator</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>IdLoc</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Id</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>Var</name> <init>= <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildExceptionDeclaration</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>, <argument><expr><name>Declarator</name></expr></argument>,
<argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>IdLoc</name></expr></argument>, <argument><expr><name>Id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>Var</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>CurContext</name><operator>-&gt;</operator><name>addDecl</name></name><argument_list>(<argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>Var</name></expr>;</return>
</block_content>}</block></function>





<function><type><name>StmtResult</name></type> <name>RebuildCXXCatchStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>CatchLoc</name></decl></parameter>,
<parameter><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>ExceptionDecl</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Handler</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>Owned</name><argument_list>(<argument><expr><macro><name>new</name> <argument_list>(<argument>getSema().Context</argument>)</argument_list></macro> <call><name>CXXCatchStmt</name><argument_list>(<argument><expr><name>CatchLoc</name></expr></argument>, <argument><expr><name>ExceptionDecl</name></expr></argument>,
<argument><expr><name>Handler</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>StmtResult</name></type> <name>RebuildCXXTryStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>TryLoc</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>TryBlock</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Handlers</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnCXXTryBlock</name><argument_list>(<argument><expr><name>TryLoc</name></expr></argument>, <argument><expr><name>TryBlock</name></expr></argument>, <argument><expr><name>Handlers</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>StmtResult</name></type> <name>RebuildCXXForRangeStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>ForLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>CoawaitLoc</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Init</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ColonLoc</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Range</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Begin</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>End</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Cond</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Inc</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>LoopVar</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>


<if_stmt><if>if <condition>(<decl><type><name>DeclStmt</name> <modifier>*</modifier></type><name>RangeStmt</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>DeclStmt</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Range</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>RangeStmt</name><operator>-&gt;</operator><name>isSingleDecl</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>RangeVar</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>VarDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>RangeStmt</name><operator>-&gt;</operator><name>getSingleDecl</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>RangeVar</name><operator>-&gt;</operator><name>isInvalidDecl</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>RangeExpr</name> <init>= <expr><call><name><name>RangeVar</name><operator>-&gt;</operator><name>getInit</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>RangeExpr</name><operator>-&gt;</operator><name>isTypeDependent</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>RangeExpr</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isObjCObjectPointerType</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><name>Init</name></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>Diag</name></name><argument_list>(<argument><expr><call><name><name>Init</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>diag</name><operator>::</operator><name>err_objc_for_range_init_stmt</name></expr></argument>)</argument_list></call>
<operator>&lt;&lt;</operator> <call><name><name>Init</name><operator>-&gt;</operator><name>getSourceRange</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnObjCForCollectionStmt</name><argument_list>(<argument><expr><name>ForLoc</name></expr></argument>, <argument><expr><name>LoopVar</name></expr></argument>,
<argument><expr><name>RangeExpr</name></expr></argument>, <argument><expr><name>RParenLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildCXXForRangeStmt</name><argument_list>(<argument><expr><name>ForLoc</name></expr></argument>, <argument><expr><name>CoawaitLoc</name></expr></argument>, <argument><expr><name>Init</name></expr></argument>, <argument><expr><name>ColonLoc</name></expr></argument>,
<argument><expr><name>Range</name></expr></argument>, <argument><expr><name>Begin</name></expr></argument>, <argument><expr><name>End</name></expr></argument>, <argument><expr><name>Cond</name></expr></argument>, <argument><expr><name>Inc</name></expr></argument>, <argument><expr><name>LoopVar</name></expr></argument>,
<argument><expr><name>RParenLoc</name></expr></argument>, <argument><expr><name>Sema</name><operator>::</operator><name>BFRK_Rebuild</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>StmtResult</name></type> <name>RebuildMSDependentExistsStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>KeywordLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsIfExists</name></decl></parameter>,
<parameter><decl><type><name>NestedNameSpecifierLoc</name></type> <name>QualifierLoc</name></decl></parameter>,
<parameter><decl><type><name>DeclarationNameInfo</name></type> <name>NameInfo</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Nested</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildMSDependentExistsStmt</name><argument_list>(<argument><expr><name>KeywordLoc</name></expr></argument>, <argument><expr><name>IsIfExists</name></expr></argument>,
<argument><expr><name>QualifierLoc</name></expr></argument>, <argument><expr><name>NameInfo</name></expr></argument>, <argument><expr><name>Nested</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>StmtResult</name></type> <name>FinishCXXForRangeStmt</name><parameter_list>(<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>ForRange</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Body</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>FinishCXXForRangeStmt</name><argument_list>(<argument><expr><name>ForRange</name></expr></argument>, <argument><expr><name>Body</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>StmtResult</name></type> <name>RebuildSEHTryStmt</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>IsCXXTry</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>TryLoc</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>TryBlock</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Handler</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnSEHTryBlock</name><argument_list>(<argument><expr><name>IsCXXTry</name></expr></argument>, <argument><expr><name>TryLoc</name></expr></argument>, <argument><expr><name>TryBlock</name></expr></argument>, <argument><expr><name>Handler</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>StmtResult</name></type> <name>RebuildSEHExceptStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>FilterExpr</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Block</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnSEHExceptBlock</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>FilterExpr</name></expr></argument>, <argument><expr><name>Block</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>StmtResult</name></type> <name>RebuildSEHFinallyStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Block</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>SEHFinallyStmt</name><operator>::</operator><call><name>Create</name><argument_list>(<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getASTContext</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>Block</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>ExprResult</name></type> <name>RebuildSYCLUniqueStableNameExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParen</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParen</name></decl></parameter>,
<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TSI</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildSYCLUniqueStableNameExpr</name><argument_list>(<argument><expr><name>OpLoc</name></expr></argument>, <argument><expr><name>LParen</name></expr></argument>, <argument><expr><name>RParen</name></expr></argument>, <argument><expr><name>TSI</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<decl_stmt><decl><type><name>ExprResult</name></type> <name>RebuildPredefinedExpr</name><argument_list>(<argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>,
<argument><expr><name>PredefinedExpr</name><operator>::</operator><name>IdentKind</name> <name>IK</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildPredefinedExpr</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>IK</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>





<function><type><name>ExprResult</name></type> <name>RebuildDeclarationNameExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>LookupResult</name> <modifier>&amp;</modifier></type><name>R</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>RequiresADL</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildDeclarationNameExpr</name><argument_list>(<argument><expr><name>SS</name></expr></argument>, <argument><expr><name>R</name></expr></argument>, <argument><expr><name>RequiresADL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>






<function><type><name>ExprResult</name></type> <name>RebuildDeclRefExpr</name><parameter_list>(<parameter><decl><type><name>NestedNameSpecifierLoc</name></type> <name>QualifierLoc</name></decl></parameter>,
<parameter><decl><type><name>ValueDecl</name> <modifier>*</modifier></type><name>VD</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>DeclarationNameInfo</name> <modifier>&amp;</modifier></type><name>NameInfo</name></decl></parameter>,
<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>Found</name></decl></parameter>,
<parameter><decl><type><name>TemplateArgumentListInfo</name> <modifier>*</modifier></type><name>TemplateArgs</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>CXXScopeSpec</name></type> <name>SS</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>SS</name><operator>.</operator><name>Adopt</name></name><argument_list>(<argument><expr><name>QualifierLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildDeclarationNameExpr</name><argument_list>(<argument><expr><name>SS</name></expr></argument>, <argument><expr><name>NameInfo</name></expr></argument>, <argument><expr><name>VD</name></expr></argument>, <argument><expr><name>Found</name></expr></argument>,
<argument><expr><name>TemplateArgs</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildParenExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>SubExpr</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>LParen</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParen</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnParenExpr</name><argument_list>(<argument><expr><name>LParen</name></expr></argument>, <argument><expr><name>RParen</name></expr></argument>, <argument><expr><name>SubExpr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function_decl><type><name>ExprResult</name></type> <name>RebuildCXXPseudoDestructorExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Base</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>OperatorLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>isArrow</name></decl></parameter>,
<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>ScopeType</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>CCLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TildeLoc</name></decl></parameter>,
<parameter><decl><type><name>PseudoDestructorTypeStorage</name></type> <name>Destroyed</name></decl></parameter>)</parameter_list>;</function_decl>





<function><type><name>ExprResult</name></type> <name>RebuildUnaryOperator</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl></parameter>,
<parameter><decl><type><name>UnaryOperatorKind</name></type> <name>Opc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>SubExpr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildUnaryOp</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>, <argument><expr><name>OpLoc</name></expr></argument>, <argument><expr><name>Opc</name></expr></argument>, <argument><expr><name>SubExpr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildOffsetOfExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>OperatorLoc</name></decl></parameter>,
<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>Type</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Sema</name><operator>::</operator><name>OffsetOfComponent</name></expr></argument>&gt;</argument_list></name></type> <name>Components</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildBuiltinOffsetOf</name><argument_list>(<argument><expr><name>OperatorLoc</name></expr></argument>, <argument><expr><name>Type</name></expr></argument>, <argument><expr><name>Components</name></expr></argument>,
<argument><expr><name>RParenLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>






<function><type><name>ExprResult</name></type> <name>RebuildUnaryExprOrTypeTrait</name><parameter_list>(<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TInfo</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl></parameter>,
<parameter><decl><type><name>UnaryExprOrTypeTrait</name></type> <name>ExprKind</name></decl></parameter>,
<parameter><decl><type><name>SourceRange</name></type> <name>R</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>CreateUnaryExprOrTypeTraitExpr</name><argument_list>(<argument><expr><name>TInfo</name></expr></argument>, <argument><expr><name>OpLoc</name></expr></argument>, <argument><expr><name>ExprKind</name></expr></argument>, <argument><expr><name>R</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>






<function><type><name>ExprResult</name></type> <name>RebuildUnaryExprOrTypeTrait</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>SubExpr</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl></parameter>,
<parameter><decl><type><name>UnaryExprOrTypeTrait</name></type> <name>ExprKind</name></decl></parameter>,
<parameter><decl><type><name>SourceRange</name></type> <name>R</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>Result</name>
<init>= <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>CreateUnaryExprOrTypeTraitExpr</name><argument_list>(<argument><expr><name>SubExpr</name></expr></argument>, <argument><expr><name>OpLoc</name></expr></argument>, <argument><expr><name>ExprKind</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>Result</name></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildArraySubscriptExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>LHS</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LBracketLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>RHS</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RBracketLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnArraySubscriptExpr</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>, <argument><expr><name>LHS</name></expr></argument>,
<argument><expr><name>LBracketLoc</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>,
<argument><expr><name>RBracketLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildMatrixSubscriptExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Base</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>RowIdx</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>ColumnIdx</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RBracketLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>CreateBuiltinMatrixSubscriptExpr</name><argument_list>(<argument><expr><name>Base</name></expr></argument>, <argument><expr><name>RowIdx</name></expr></argument>, <argument><expr><name>ColumnIdx</name></expr></argument>,
<argument><expr><name>RBracketLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildOMPArraySectionExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Base</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>LBracketLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>LowerBound</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ColonLocFirst</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ColonLocSecond</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Length</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Stride</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RBracketLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOMPArraySectionExpr</name><argument_list>(<argument><expr><name>Base</name></expr></argument>, <argument><expr><name>LBracketLoc</name></expr></argument>, <argument><expr><name>LowerBound</name></expr></argument>,
<argument><expr><name>ColonLocFirst</name></expr></argument>, <argument><expr><name>ColonLocSecond</name></expr></argument>,
<argument><expr><name>Length</name></expr></argument>, <argument><expr><name>Stride</name></expr></argument>, <argument><expr><name>RBracketLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildOMPArrayShapingExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Base</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Dims</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>SourceRange</name></expr></argument>&gt;</argument_list></name></type> <name>BracketsRanges</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOMPArrayShapingExpr</name><argument_list>(<argument><expr><name>Base</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>RParenLoc</name></expr></argument>, <argument><expr><name>Dims</name></expr></argument>,
<argument><expr><name>BracketsRanges</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildOMPIteratorExpr</name><parameter_list>(
<parameter><decl><type><name>SourceLocation</name></type> <name>IteratorKwLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>LLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>RLoc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Sema</name><operator>::</operator><name>OMPIteratorData</name></expr></argument>&gt;</argument_list></name></type> <name>Data</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOMPIteratorExpr</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>, <argument><expr><name>IteratorKwLoc</name></expr></argument>,
<argument><expr><name>LLoc</name></expr></argument>, <argument><expr><name>RLoc</name></expr></argument>, <argument><expr><name>Data</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildCallExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Callee</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>MultiExprArg</name></type> <name>Args</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>ExecConfig</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnCallExpr</name><argument_list>(
<argument><expr><name>nullptr</name></expr></argument>, <argument><expr><name>Callee</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>Args</name></expr></argument>, <argument><expr><name>RParenLoc</name></expr></argument>, <argument><expr><name>ExecConfig</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildMemberExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Base</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>isArrow</name></decl></parameter>,
<parameter><decl><type><name>NestedNameSpecifierLoc</name></type> <name>QualifierLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TemplateKWLoc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>DeclarationNameInfo</name> <modifier>&amp;</modifier></type><name>MemberNameInfo</name></decl></parameter>,
<parameter><decl><type><name>ValueDecl</name> <modifier>*</modifier></type><name>Member</name></decl></parameter>,
<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>FoundDecl</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>TemplateArgumentListInfo</name> <modifier>*</modifier></type><name>ExplicitTemplateArgs</name></decl></parameter>,
<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>FirstQualifierInScope</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>BaseResult</name> <init>= <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>PerformMemberExprBaseConversion</name><argument_list>(<argument><expr><name>Base</name></expr></argument>,
<argument><expr><name>isArrow</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>Member</name><operator>-&gt;</operator><name>getDeclName</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>Member</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isRecordType</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"unnamed member not of record type?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BaseResult</name> <operator>=</operator>
<call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>PerformObjectMemberConversion</name><argument_list>(<argument><expr><call><name><name>BaseResult</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>QualifierLoc</name><operator>.</operator><name>getNestedNameSpecifier</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>FoundDecl</name></expr></argument>, <argument><expr><name>Member</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>BaseResult</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>Base</name> <operator>=</operator> <call><name><name>BaseResult</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>CXXScopeSpec</name></type> <name>EmptySS</name></decl>;</decl_stmt>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildFieldReferenceExpr</name><argument_list>(
<argument><expr><name>Base</name></expr></argument>, <argument><expr><name>isArrow</name></expr></argument>, <argument><expr><name>OpLoc</name></expr></argument>, <argument><expr><name>EmptySS</name></expr></argument>, <argument><expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>FieldDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Member</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>DeclAccessPair</name><operator>::</operator><call><name>make</name><argument_list>(<argument><expr><name>FoundDecl</name></expr></argument>, <argument><expr><call><name><name>FoundDecl</name><operator>-&gt;</operator><name>getAccess</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MemberNameInfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>CXXScopeSpec</name></type> <name>SS</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>SS</name><operator>.</operator><name>Adopt</name></name><argument_list>(<argument><expr><name>QualifierLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>Base</name> <operator>=</operator> <call><name><name>BaseResult</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>QualType</name></type> <name>BaseType</name> <init>= <expr><call><name><name>Base</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>isArrow</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>BaseType</name><operator>-&gt;</operator><name>isPointerType</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>



<decl_stmt><decl><type><name>LookupResult</name></type> <name>R</name><argument_list>(<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>MemberNameInfo</name></expr></argument>, <argument><expr><name>Sema</name><operator>::</operator><name>LookupMemberName</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>R</name><operator>.</operator><name>addDecl</name></name><argument_list>(<argument><expr><name>FoundDecl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>R</name><operator>.</operator><name>resolveKind</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildMemberReferenceExpr</name><argument_list>(<argument><expr><name>Base</name></expr></argument>, <argument><expr><name>BaseType</name></expr></argument>, <argument><expr><name>OpLoc</name></expr></argument>, <argument><expr><name>isArrow</name></expr></argument>,
<argument><expr><name>SS</name></expr></argument>, <argument><expr><name>TemplateKWLoc</name></expr></argument>,
<argument><expr><name>FirstQualifierInScope</name></expr></argument>,
<argument><expr><name>R</name></expr></argument>, <argument><expr><name>ExplicitTemplateArgs</name></expr></argument>,
<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildBinaryOperator</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl></parameter>,
<parameter><decl><type><name>BinaryOperatorKind</name></type> <name>Opc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>LHS</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>RHS</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildBinOp</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>, <argument><expr><name>OpLoc</name></expr></argument>, <argument><expr><name>Opc</name></expr></argument>, <argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildCXXRewrittenBinaryOperator</name><parameter_list>(
<parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl></parameter>, <parameter><decl><type><name>BinaryOperatorKind</name></type> <name>Opcode</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>UnresolvedSetImpl</name> <modifier>&amp;</modifier></type><name>UnqualLookups</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>LHS</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>RHS</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>CreateOverloadedBinOp</name><argument_list>(<argument><expr><name>OpLoc</name></expr></argument>, <argument><expr><name>Opcode</name></expr></argument>, <argument><expr><name>UnqualLookups</name></expr></argument>, <argument><expr><name>LHS</name></expr></argument>,
<argument><expr><name>RHS</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildConditionalOperator</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Cond</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>QuestionLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>LHS</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ColonLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>RHS</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnConditionalOp</name><argument_list>(<argument><expr><name>QuestionLoc</name></expr></argument>, <argument><expr><name>ColonLoc</name></expr></argument>, <argument><expr><name>Cond</name></expr></argument>,
<argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildCStyleCastExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TInfo</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>SubExpr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildCStyleCastExpr</name><argument_list>(<argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>TInfo</name></expr></argument>, <argument><expr><name>RParenLoc</name></expr></argument>,
<argument><expr><name>SubExpr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildCompoundLiteralExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TInfo</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Init</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildCompoundLiteralExpr</name><argument_list>(<argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>TInfo</name></expr></argument>, <argument><expr><name>RParenLoc</name></expr></argument>,
<argument><expr><name>Init</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildExtVectorElementExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Base</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>AccessorLoc</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>&amp;</modifier></type><name>Accessor</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>CXXScopeSpec</name></type> <name>SS</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DeclarationNameInfo</name></type> <name>NameInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Accessor</name></expr></argument>, <argument><expr><name>AccessorLoc</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildMemberReferenceExpr</name><argument_list>(<argument><expr><name>Base</name></expr></argument>, <argument><expr><call><name><name>Base</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>OpLoc</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
<argument><expr><name>SS</name></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><name>NameInfo</name></expr></argument>,
<argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildInitList</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>LBraceLoc</name></decl></parameter>,
<parameter><decl><type><name>MultiExprArg</name></type> <name>Inits</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RBraceLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>BuildInitList</name></name><argument_list>(<argument><expr><name>LBraceLoc</name></expr></argument>, <argument><expr><name>Inits</name></expr></argument>, <argument><expr><name>RBraceLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildDesignatedInitExpr</name><parameter_list>(<parameter><decl><type><name>Designation</name> <modifier>&amp;</modifier></type><name>Desig</name></decl></parameter>,
<parameter><decl><type><name>MultiExprArg</name></type> <name>ArrayExprs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EqualOrColonLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>GNUSyntax</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Init</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>Result</name>
<init>= <expr><call><name><name>SemaRef</name><operator>.</operator><name>ActOnDesignatedInitializer</name></name><argument_list>(<argument><expr><name>Desig</name></expr></argument>, <argument><expr><name>EqualOrColonLoc</name></expr></argument>, <argument><expr><name>GNUSyntax</name></expr></argument>,
<argument><expr><name>Init</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>Result</name></expr>;</return>
</block_content>}</block></function>






<function><type><name>ExprResult</name></type> <name>RebuildImplicitValueInitExpr</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <macro><name>new</name> <argument_list>(<argument>SemaRef.Context</argument>)</argument_list></macro> <expr><call><name>ImplicitValueInitExpr</name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildVAArgExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>BuiltinLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>SubExpr</name></decl></parameter>, <parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TInfo</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildVAArgExpr</name><argument_list>(<argument><expr><name>BuiltinLoc</name></expr></argument>,
<argument><expr><name>SubExpr</name></expr></argument>, <argument><expr><name>TInfo</name></expr></argument>,
<argument><expr><name>RParenLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildParenListExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>MultiExprArg</name></type> <name>SubExprs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnParenListExpr</name><argument_list>(<argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>RParenLoc</name></expr></argument>, <argument><expr><name>SubExprs</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>






<function><type><name>ExprResult</name></type> <name>RebuildAddrLabelExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>AmpAmpLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LabelLoc</name></decl></parameter>, <parameter><decl><type><name>LabelDecl</name> <modifier>*</modifier></type><name>Label</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnAddrLabel</name><argument_list>(<argument><expr><name>AmpAmpLoc</name></expr></argument>, <argument><expr><name>LabelLoc</name></expr></argument>, <argument><expr><name>Label</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildStmtExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>SubStmt</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>TemplateDepth</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildStmtExpr</name><argument_list>(<argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>SubStmt</name></expr></argument>, <argument><expr><name>RParenLoc</name></expr></argument>,
<argument><expr><name>TemplateDepth</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildChooseExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>BuiltinLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Cond</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>LHS</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>RHS</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>ActOnChooseExpr</name></name><argument_list>(<argument><expr><name>BuiltinLoc</name></expr></argument>,
<argument><expr><name>Cond</name></expr></argument>, <argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>,
<argument><expr><name>RParenLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildGenericSelectionExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>KeyLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>DefaultLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>ControllingExpr</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TypeSourceInfo</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Types</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Exprs</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>CreateGenericSelectionExpr</name><argument_list>(<argument><expr><name>KeyLoc</name></expr></argument>, <argument><expr><name>DefaultLoc</name></expr></argument>, <argument><expr><name>RParenLoc</name></expr></argument>,
<argument><expr><name>ControllingExpr</name></expr></argument>, <argument><expr><name>Types</name></expr></argument>, <argument><expr><name>Exprs</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>









<function_decl><type><name>ExprResult</name></type> <name>RebuildCXXOperatorCallExpr</name><parameter_list>(<parameter><decl><type><name>OverloadedOperatorKind</name></type> <name>Op</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Callee</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>First</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Second</name></decl></parameter>)</parameter_list>;</function_decl>







<decl_stmt><decl><type><name>ExprResult</name></type> <name>RebuildCXXNamedCastExpr</name><argument_list>(<argument><expr><name>SourceLocation</name> <name>OpLoc</name></expr></argument>,
<argument><expr><name>Stmt</name><operator>::</operator><name>StmtClass</name> <name>Class</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>LAngleLoc</name></expr></argument>,
<argument><expr><name>TypeSourceInfo</name> <operator>*</operator><name>TInfo</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>RAngleLoc</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>LParenLoc</name></expr></argument>,
<argument><expr><name>Expr</name> <operator>*</operator><name>SubExpr</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>RParenLoc</name></expr></argument>)</argument_list> <block>{<block_content>
<switch>switch <condition>(<expr><name>Class</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>Stmt</name><operator>::</operator><name>CXXStaticCastExprClass</name></expr>:</case>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildCXXStaticCastExpr</name><argument_list>(<argument><expr><name>OpLoc</name></expr></argument>, <argument><expr><name>LAngleLoc</name></expr></argument>, <argument><expr><name>TInfo</name></expr></argument>,
<argument><expr><name>RAngleLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>,
<argument><expr><name>SubExpr</name></expr></argument>, <argument><expr><name>RParenLoc</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>Stmt</name><operator>::</operator><name>CXXDynamicCastExprClass</name></expr>:</case>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildCXXDynamicCastExpr</name><argument_list>(<argument><expr><name>OpLoc</name></expr></argument>, <argument><expr><name>LAngleLoc</name></expr></argument>, <argument><expr><name>TInfo</name></expr></argument>,
<argument><expr><name>RAngleLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>,
<argument><expr><name>SubExpr</name></expr></argument>, <argument><expr><name>RParenLoc</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>Stmt</name><operator>::</operator><name>CXXReinterpretCastExprClass</name></expr>:</case>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildCXXReinterpretCastExpr</name><argument_list>(<argument><expr><name>OpLoc</name></expr></argument>, <argument><expr><name>LAngleLoc</name></expr></argument>, <argument><expr><name>TInfo</name></expr></argument>,
<argument><expr><name>RAngleLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>,
<argument><expr><name>SubExpr</name></expr></argument>,
<argument><expr><name>RParenLoc</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>Stmt</name><operator>::</operator><name>CXXConstCastExprClass</name></expr>:</case>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildCXXConstCastExpr</name><argument_list>(<argument><expr><name>OpLoc</name></expr></argument>, <argument><expr><name>LAngleLoc</name></expr></argument>, <argument><expr><name>TInfo</name></expr></argument>,
<argument><expr><name>RAngleLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>,
<argument><expr><name>SubExpr</name></expr></argument>, <argument><expr><name>RParenLoc</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>Stmt</name><operator>::</operator><name>CXXAddrspaceCastExprClass</name></expr>:</case>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildCXXAddrspaceCastExpr</name><argument_list>(
<argument><expr><name>OpLoc</name></expr></argument>, <argument><expr><name>LAngleLoc</name></expr></argument>, <argument><expr><name>TInfo</name></expr></argument>, <argument><expr><name>RAngleLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>SubExpr</name></expr></argument>, <argument><expr><name>RParenLoc</name></expr></argument>)</argument_list></call></expr>;</return>

<default>default:</default>
<expr_stmt><expr><call><name>llvm_unreachable</name><argument_list>(<argument><expr><literal type="string">"Invalid C++ named cast"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></decl></decl_stmt>





<function><type><name>ExprResult</name></type> <name>RebuildCXXStaticCastExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LAngleLoc</name></decl></parameter>,
<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TInfo</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RAngleLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>SubExpr</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildCXXNamedCast</name><argument_list>(<argument><expr><name>OpLoc</name></expr></argument>, <argument><expr><name>tok</name><operator>::</operator><name>kw_static_cast</name></expr></argument>,
<argument><expr><name>TInfo</name></expr></argument>, <argument><expr><name>SubExpr</name></expr></argument>,
<argument><expr><call><name>SourceRange</name><argument_list>(<argument><expr><name>LAngleLoc</name></expr></argument>, <argument><expr><name>RAngleLoc</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>SourceRange</name><argument_list>(<argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>RParenLoc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildCXXDynamicCastExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LAngleLoc</name></decl></parameter>,
<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TInfo</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RAngleLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>SubExpr</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildCXXNamedCast</name><argument_list>(<argument><expr><name>OpLoc</name></expr></argument>, <argument><expr><name>tok</name><operator>::</operator><name>kw_dynamic_cast</name></expr></argument>,
<argument><expr><name>TInfo</name></expr></argument>, <argument><expr><name>SubExpr</name></expr></argument>,
<argument><expr><call><name>SourceRange</name><argument_list>(<argument><expr><name>LAngleLoc</name></expr></argument>, <argument><expr><name>RAngleLoc</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>SourceRange</name><argument_list>(<argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>RParenLoc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildCXXReinterpretCastExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LAngleLoc</name></decl></parameter>,
<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TInfo</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RAngleLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>SubExpr</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildCXXNamedCast</name><argument_list>(<argument><expr><name>OpLoc</name></expr></argument>, <argument><expr><name>tok</name><operator>::</operator><name>kw_reinterpret_cast</name></expr></argument>,
<argument><expr><name>TInfo</name></expr></argument>, <argument><expr><name>SubExpr</name></expr></argument>,
<argument><expr><call><name>SourceRange</name><argument_list>(<argument><expr><name>LAngleLoc</name></expr></argument>, <argument><expr><name>RAngleLoc</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>SourceRange</name><argument_list>(<argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>RParenLoc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildCXXConstCastExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LAngleLoc</name></decl></parameter>,
<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TInfo</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RAngleLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>SubExpr</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildCXXNamedCast</name><argument_list>(<argument><expr><name>OpLoc</name></expr></argument>, <argument><expr><name>tok</name><operator>::</operator><name>kw_const_cast</name></expr></argument>,
<argument><expr><name>TInfo</name></expr></argument>, <argument><expr><name>SubExpr</name></expr></argument>,
<argument><expr><call><name>SourceRange</name><argument_list>(<argument><expr><name>LAngleLoc</name></expr></argument>, <argument><expr><name>RAngleLoc</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>SourceRange</name><argument_list>(<argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>RParenLoc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>ExprResult</name></type>
<name>RebuildCXXAddrspaceCastExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>LAngleLoc</name></decl></parameter>,
<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TInfo</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>RAngleLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>SubExpr</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildCXXNamedCast</name><argument_list>(
<argument><expr><name>OpLoc</name></expr></argument>, <argument><expr><name>tok</name><operator>::</operator><name>kw_addrspace_cast</name></expr></argument>, <argument><expr><name>TInfo</name></expr></argument>, <argument><expr><name>SubExpr</name></expr></argument>,
<argument><expr><call><name>SourceRange</name><argument_list>(<argument><expr><name>LAngleLoc</name></expr></argument>, <argument><expr><name>RAngleLoc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SourceRange</name><argument_list>(<argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>RParenLoc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildCXXFunctionalCastExpr</name><parameter_list>(<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TInfo</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Sub</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ListInitialization</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildCXXTypeConstructExpr</name><argument_list>(<argument><expr><name>TInfo</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>,
<argument><expr><call><name>MultiExprArg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Sub</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>RParenLoc</name></expr></argument>,
<argument><expr><name>ListInitialization</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildBuiltinBitCastExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>KWLoc</name></decl></parameter>,
<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TSI</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Sub</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildBuiltinBitCastExpr</name><argument_list>(<argument><expr><name>KWLoc</name></expr></argument>, <argument><expr><name>TSI</name></expr></argument>, <argument><expr><name>Sub</name></expr></argument>, <argument><expr><name>RParenLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildCXXTypeidExpr</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>TypeInfoType</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TypeidLoc</name></decl></parameter>,
<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>Operand</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildCXXTypeId</name><argument_list>(<argument><expr><name>TypeInfoType</name></expr></argument>, <argument><expr><name>TypeidLoc</name></expr></argument>, <argument><expr><name>Operand</name></expr></argument>,
<argument><expr><name>RParenLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>






<function><type><name>ExprResult</name></type> <name>RebuildCXXTypeidExpr</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>TypeInfoType</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TypeidLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Operand</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildCXXTypeId</name><argument_list>(<argument><expr><name>TypeInfoType</name></expr></argument>, <argument><expr><name>TypeidLoc</name></expr></argument>, <argument><expr><name>Operand</name></expr></argument>,
<argument><expr><name>RParenLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildCXXUuidofExpr</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>Type</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>TypeidLoc</name></decl></parameter>,
<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>Operand</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildCXXUuidof</name><argument_list>(<argument><expr><name>Type</name></expr></argument>, <argument><expr><name>TypeidLoc</name></expr></argument>, <argument><expr><name>Operand</name></expr></argument>, <argument><expr><name>RParenLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildCXXUuidofExpr</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>Type</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>TypeidLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Operand</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildCXXUuidof</name><argument_list>(<argument><expr><name>Type</name></expr></argument>, <argument><expr><name>TypeidLoc</name></expr></argument>, <argument><expr><name>Operand</name></expr></argument>, <argument><expr><name>RParenLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>






<function><type><name>ExprResult</name></type> <name>RebuildCXXThisExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>ThisLoc</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>ThisType</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>isImplicit</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildCXXThisExpr</name><argument_list>(<argument><expr><name>ThisLoc</name></expr></argument>, <argument><expr><name>ThisType</name></expr></argument>, <argument><expr><name>isImplicit</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildCXXThrowExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>ThrowLoc</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Sub</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsThrownVariableInScope</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildCXXThrow</name><argument_list>(<argument><expr><name>ThrowLoc</name></expr></argument>, <argument><expr><name>Sub</name></expr></argument>, <argument><expr><name>IsThrownVariableInScope</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>






<function><type><name>ExprResult</name></type> <name>RebuildCXXDefaultArgExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>ParmVarDecl</name> <modifier>*</modifier></type><name>Param</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>CXXDefaultArgExpr</name><operator>::</operator><call><name>Create</name><argument_list>(<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><name>Context</name></expr></argument>, <argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>,
<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><name>CurContext</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>






<function><type><name>ExprResult</name></type> <name>RebuildCXXDefaultInitExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>FieldDecl</name> <modifier>*</modifier></type><name>Field</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>CXXDefaultInitExpr</name><operator>::</operator><call><name>Create</name><argument_list>(<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><name>Context</name></expr></argument>, <argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>Field</name></expr></argument>,
<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><name>CurContext</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildCXXScalarValueInitExpr</name><parameter_list>(<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TSInfo</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildCXXTypeConstructExpr</name><argument_list>(
<argument><expr><name>TSInfo</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>None</name></expr></argument>, <argument><expr><name>RParenLoc</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildCXXNewExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>UseGlobal</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>PlacementLParen</name></decl></parameter>,
<parameter><decl><type><name>MultiExprArg</name></type> <name>PlacementArgs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>PlacementRParen</name></decl></parameter>,
<parameter><decl><type><name>SourceRange</name></type> <name>TypeIdParens</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>AllocatedType</name></decl></parameter>,
<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>AllocatedTypeInfo</name></decl></parameter>,
<parameter><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>ArraySize</name></decl></parameter>,
<parameter><decl><type><name>SourceRange</name></type> <name>DirectInitRange</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Initializer</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildCXXNew</name><argument_list>(<argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>UseGlobal</name></expr></argument>,
<argument><expr><name>PlacementLParen</name></expr></argument>,
<argument><expr><name>PlacementArgs</name></expr></argument>,
<argument><expr><name>PlacementRParen</name></expr></argument>,
<argument><expr><name>TypeIdParens</name></expr></argument>,
<argument><expr><name>AllocatedType</name></expr></argument>,
<argument><expr><name>AllocatedTypeInfo</name></expr></argument>,
<argument><expr><name>ArraySize</name></expr></argument>,
<argument><expr><name>DirectInitRange</name></expr></argument>,
<argument><expr><name>Initializer</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildCXXDeleteExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsGlobalDelete</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsArrayForm</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Operand</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnCXXDelete</name><argument_list>(<argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>IsGlobalDelete</name></expr></argument>, <argument><expr><name>IsArrayForm</name></expr></argument>,
<argument><expr><name>Operand</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildTypeTrait</name><parameter_list>(<parameter><decl><type><name>TypeTrait</name></type> <name>Trait</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TypeSourceInfo</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Args</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildTypeTrait</name><argument_list>(<argument><expr><name>Trait</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>Args</name></expr></argument>, <argument><expr><name>RParenLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildArrayTypeTrait</name><parameter_list>(<parameter><decl><type><name>ArrayTypeTrait</name></type> <name>Trait</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TSInfo</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>DimExpr</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildArrayTypeTrait</name><argument_list>(<argument><expr><name>Trait</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>TSInfo</name></expr></argument>, <argument><expr><name>DimExpr</name></expr></argument>, <argument><expr><name>RParenLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildExpressionTrait</name><parameter_list>(<parameter><decl><type><name>ExpressionTrait</name></type> <name>Trait</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Queried</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildExpressionTrait</name><argument_list>(<argument><expr><name>Trait</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>Queried</name></expr></argument>, <argument><expr><name>RParenLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>






<function><type><name>ExprResult</name></type> <name>RebuildDependentScopeDeclRefExpr</name><parameter_list>(
<parameter><decl><type><name>NestedNameSpecifierLoc</name></type> <name>QualifierLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TemplateKWLoc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>DeclarationNameInfo</name> <modifier>&amp;</modifier></type><name>NameInfo</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>TemplateArgumentListInfo</name> <modifier>*</modifier></type><name>TemplateArgs</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsAddressOfOperand</name></decl></parameter>,
<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>RecoveryTSI</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>CXXScopeSpec</name></type> <name>SS</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>SS</name><operator>.</operator><name>Adopt</name></name><argument_list>(<argument><expr><name>QualifierLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>TemplateArgs</name> <operator>||</operator> <call><name><name>TemplateKWLoc</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildQualifiedTemplateIdExpr</name><argument_list>(<argument><expr><name>SS</name></expr></argument>, <argument><expr><name>TemplateKWLoc</name></expr></argument>, <argument><expr><name>NameInfo</name></expr></argument>,
<argument><expr><name>TemplateArgs</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildQualifiedDeclarationNameExpr</name><argument_list>(
<argument><expr><name>SS</name></expr></argument>, <argument><expr><name>NameInfo</name></expr></argument>, <argument><expr><name>IsAddressOfOperand</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>, <argument><expr><name>RecoveryTSI</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildTemplateIdExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TemplateKWLoc</name></decl></parameter>,
<parameter><decl><type><name>LookupResult</name> <modifier>&amp;</modifier></type><name>R</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>RequiresADL</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>TemplateArgumentListInfo</name> <modifier>*</modifier></type><name>TemplateArgs</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildTemplateIdExpr</name><argument_list>(<argument><expr><name>SS</name></expr></argument>, <argument><expr><name>TemplateKWLoc</name></expr></argument>, <argument><expr><name>R</name></expr></argument>, <argument><expr><name>RequiresADL</name></expr></argument>,
<argument><expr><name>TemplateArgs</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<decl_stmt><decl><type><name>ExprResult</name></type> <name>RebuildCXXConstructExpr</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>,
<argument><expr><name>CXXConstructorDecl</name> <operator>*</operator><name>Constructor</name></expr></argument>,
<argument><expr><name>bool</name> <name>IsElidable</name></expr></argument>,
<argument><expr><name>MultiExprArg</name> <name>Args</name></expr></argument>,
<argument><expr><name>bool</name> <name>HadMultipleCandidates</name></expr></argument>,
<argument><expr><name>bool</name> <name>ListInitialization</name></expr></argument>,
<argument><expr><name>bool</name> <name>StdInitListInitialization</name></expr></argument>,
<argument><expr><name>bool</name> <name>RequiresZeroInit</name></expr></argument>,
<argument><expr><name>CXXConstructExpr</name><operator>::</operator><name>ConstructionKind</name> <name>ConstructKind</name></expr></argument>,
<argument><expr><name>SourceRange</name> <name>ParenRange</name></expr></argument>)</argument_list> <block>{<block_content>


<decl_stmt><decl><type><name>CXXConstructorDecl</name> <modifier>*</modifier></type><name>FoundCtor</name> <init>= <expr><name>Constructor</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Constructor</name><operator>-&gt;</operator><name>isInheritingConstructor</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>FoundCtor</name> <operator>=</operator> <call><name><name>Constructor</name><operator>-&gt;</operator><name>getInheritedConstructor</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getConstructor</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name></type> <name>ConvertedArgs</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>CompleteConstructorCall</name><argument_list>(<argument><expr><name>FoundCtor</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>Args</name></expr></argument>, <argument><expr><name>Loc</name></expr></argument>,
<argument><expr><name>ConvertedArgs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildCXXConstructExpr</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>Constructor</name></expr></argument>,
<argument><expr><name>IsElidable</name></expr></argument>,
<argument><expr><name>ConvertedArgs</name></expr></argument>,
<argument><expr><name>HadMultipleCandidates</name></expr></argument>,
<argument><expr><name>ListInitialization</name></expr></argument>,
<argument><expr><name>StdInitListInitialization</name></expr></argument>,
<argument><expr><name>RequiresZeroInit</name></expr></argument>, <argument><expr><name>ConstructKind</name></expr></argument>,
<argument><expr><name>ParenRange</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<function><type><name>ExprResult</name></type> <name>RebuildCXXInheritedCtorInitExpr</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>CXXConstructorDecl</name> <modifier>*</modifier></type><name>Constructor</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ConstructsVBase</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>InheritedFromVBase</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <macro><name>new</name> <argument_list>(<argument>getSema().Context</argument>)</argument_list></macro> <expr><call><name>CXXInheritedCtorInitExpr</name><argument_list>(
<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>Constructor</name></expr></argument>, <argument><expr><name>ConstructsVBase</name></expr></argument>, <argument><expr><name>InheritedFromVBase</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildCXXTemporaryObjectExpr</name><parameter_list>(<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TSInfo</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenOrBraceLoc</name></decl></parameter>,
<parameter><decl><type><name>MultiExprArg</name></type> <name>Args</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenOrBraceLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ListInitialization</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildCXXTypeConstructExpr</name><argument_list>(
<argument><expr><name>TSInfo</name></expr></argument>, <argument><expr><name>LParenOrBraceLoc</name></expr></argument>, <argument><expr><name>Args</name></expr></argument>, <argument><expr><name>RParenOrBraceLoc</name></expr></argument>, <argument><expr><name>ListInitialization</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildCXXUnresolvedConstructExpr</name><parameter_list>(<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TSInfo</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>MultiExprArg</name></type> <name>Args</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ListInitialization</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildCXXTypeConstructExpr</name><argument_list>(<argument><expr><name>TSInfo</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>Args</name></expr></argument>,
<argument><expr><name>RParenLoc</name></expr></argument>, <argument><expr><name>ListInitialization</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildCXXDependentScopeMemberExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>BaseE</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>BaseType</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsArrow</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>OperatorLoc</name></decl></parameter>,
<parameter><decl><type><name>NestedNameSpecifierLoc</name></type> <name>QualifierLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TemplateKWLoc</name></decl></parameter>,
<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>FirstQualifierInScope</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>DeclarationNameInfo</name> <modifier>&amp;</modifier></type><name>MemberNameInfo</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>TemplateArgumentListInfo</name> <modifier>*</modifier></type><name>TemplateArgs</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>CXXScopeSpec</name></type> <name>SS</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>SS</name><operator>.</operator><name>Adopt</name></name><argument_list>(<argument><expr><name>QualifierLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>BuildMemberReferenceExpr</name></name><argument_list>(<argument><expr><name>BaseE</name></expr></argument>, <argument><expr><name>BaseType</name></expr></argument>,
<argument><expr><name>OperatorLoc</name></expr></argument>, <argument><expr><name>IsArrow</name></expr></argument>,
<argument><expr><name>SS</name></expr></argument>, <argument><expr><name>TemplateKWLoc</name></expr></argument>,
<argument><expr><name>FirstQualifierInScope</name></expr></argument>,
<argument><expr><name>MemberNameInfo</name></expr></argument>,
<argument><expr><name>TemplateArgs</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildUnresolvedMemberExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>BaseE</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>BaseType</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>OperatorLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsArrow</name></decl></parameter>,
<parameter><decl><type><name>NestedNameSpecifierLoc</name></type> <name>QualifierLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TemplateKWLoc</name></decl></parameter>,
<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>FirstQualifierInScope</name></decl></parameter>,
<parameter><decl><type><name>LookupResult</name> <modifier>&amp;</modifier></type><name>R</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>TemplateArgumentListInfo</name> <modifier>*</modifier></type><name>TemplateArgs</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>CXXScopeSpec</name></type> <name>SS</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>SS</name><operator>.</operator><name>Adopt</name></name><argument_list>(<argument><expr><name>QualifierLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>BuildMemberReferenceExpr</name></name><argument_list>(<argument><expr><name>BaseE</name></expr></argument>, <argument><expr><name>BaseType</name></expr></argument>,
<argument><expr><name>OperatorLoc</name></expr></argument>, <argument><expr><name>IsArrow</name></expr></argument>,
<argument><expr><name>SS</name></expr></argument>, <argument><expr><name>TemplateKWLoc</name></expr></argument>,
<argument><expr><name>FirstQualifierInScope</name></expr></argument>,
<argument><expr><name>R</name></expr></argument>, <argument><expr><name>TemplateArgs</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildCXXNoexceptExpr</name><parameter_list>(<parameter><decl><type><name>SourceRange</name></type> <name>Range</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Arg</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>BuildCXXNoexceptExpr</name></name><argument_list>(<argument><expr><call><name><name>Range</name><operator>.</operator><name>getBegin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Arg</name></expr></argument>, <argument><expr><call><name><name>Range</name><operator>.</operator><name>getEnd</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>ExprResult</name></type> <name>RebuildSizeOfPackExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>OperatorLoc</name></decl></parameter>,
<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>Pack</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>PackLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>,
<parameter><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></type> <name>Length</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name></expr></argument>&gt;</argument_list></name></type> <name>PartialArgs</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>SizeOfPackExpr</name><operator>::</operator><call><name>Create</name><argument_list>(<argument><expr><name><name>SemaRef</name><operator>.</operator><name>Context</name></name></expr></argument>, <argument><expr><name>OperatorLoc</name></expr></argument>, <argument><expr><name>Pack</name></expr></argument>, <argument><expr><name>PackLoc</name></expr></argument>,
<argument><expr><name>RParenLoc</name></expr></argument>, <argument><expr><name>Length</name></expr></argument>, <argument><expr><name>PartialArgs</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>






<decl_stmt><decl><type><name>ExprResult</name></type> <name>RebuildSourceLocExpr</name><argument_list>(<argument><expr><name>SourceLocExpr</name><operator>::</operator><name>IdentKind</name> <name>Kind</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>BuiltinLoc</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>RPLoc</name></expr></argument>,
<argument><expr><name>DeclContext</name> <operator>*</operator><name>ParentContext</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildSourceLocExpr</name><argument_list>(<argument><expr><name>Kind</name></expr></argument>, <argument><expr><name>BuiltinLoc</name></expr></argument>, <argument><expr><name>RPLoc</name></expr></argument>, <argument><expr><name>ParentContext</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>





<function><type><name>ExprResult</name></type> <name>RebuildConceptSpecializationExpr</name><parameter_list>(<parameter><decl><type><name>NestedNameSpecifierLoc</name></type> <name>NNS</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TemplateKWLoc</name></decl></parameter>, <parameter><decl><type><name>DeclarationNameInfo</name></type> <name>ConceptNameInfo</name></decl></parameter>,
<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>FoundDecl</name></decl></parameter>, <parameter><decl><type><name>ConceptDecl</name> <modifier>*</modifier></type><name>NamedConcept</name></decl></parameter>,
<parameter><decl><type><name>TemplateArgumentListInfo</name> <modifier>*</modifier></type><name>TALI</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>CXXScopeSpec</name></type> <name>SS</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>SS</name><operator>.</operator><name>Adopt</name></name><argument_list>(<argument><expr><name>NNS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>Result</name> <init>= <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>CheckConceptTemplateId</name><argument_list>(<argument><expr><name>SS</name></expr></argument>, <argument><expr><name>TemplateKWLoc</name></expr></argument>,
<argument><expr><name>ConceptNameInfo</name></expr></argument>,
<argument><expr><name>FoundDecl</name></expr></argument>,
<argument><expr><name>NamedConcept</name></expr></argument>, <argument><expr><name>TALI</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>Result</name></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildRequiresExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>RequiresKWLoc</name></decl></parameter>,
<parameter><decl><type><name>RequiresExprBodyDecl</name> <modifier>*</modifier></type><name>Body</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>LocalParameters</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>concepts</name><operator>::</operator><name>Requirement</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Requirements</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ClosingBraceLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>RequiresExpr</name><operator>::</operator><call><name>Create</name><argument_list>(<argument><expr><name><name>SemaRef</name><operator>.</operator><name>Context</name></name></expr></argument>, <argument><expr><name>RequiresKWLoc</name></expr></argument>, <argument><expr><name>Body</name></expr></argument>,
<argument><expr><name>LocalParameters</name></expr></argument>, <argument><expr><name>Requirements</name></expr></argument>, <argument><expr><name>ClosingBraceLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><name>concepts</name><operator>::</operator><name>TypeRequirement</name> <operator>*</operator>
<macro><name>RebuildTypeRequirement</name><argument_list>(
<argument>concepts::Requirement::SubstitutionDiagnostic *SubstDiag</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>BuildTypeRequirement</name></name><argument_list>(<argument><expr><name>SubstDiag</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>concepts</name><operator>::</operator><name>TypeRequirement</name> <operator>*</operator><macro><name>RebuildTypeRequirement</name><argument_list>(<argument>TypeSourceInfo *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>BuildTypeRequirement</name></name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>concepts</name><operator>::</operator><name>ExprRequirement</name> <operator>*</operator>
<macro><name>RebuildExprRequirement</name><argument_list>(
<argument>concepts::Requirement::SubstitutionDiagnostic *SubstDiag</argument>, <argument>bool IsSimple</argument>,
<argument>SourceLocation NoexceptLoc</argument>,
<argument>concepts::ExprRequirement::ReturnTypeRequirement Ret</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>BuildExprRequirement</name></name><argument_list>(<argument><expr><name>SubstDiag</name></expr></argument>, <argument><expr><name>IsSimple</name></expr></argument>, <argument><expr><name>NoexceptLoc</name></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>Ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>concepts</name><operator>::</operator><name>ExprRequirement</name> <operator>*</operator>
<macro><name>RebuildExprRequirement</name><argument_list>(<argument>Expr *E</argument>, <argument>bool IsSimple</argument>, <argument>SourceLocation NoexceptLoc</argument>,
<argument>concepts::ExprRequirement::ReturnTypeRequirement Ret</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>BuildExprRequirement</name></name><argument_list>(<argument><expr><name>E</name></expr></argument>, <argument><expr><name>IsSimple</name></expr></argument>, <argument><expr><name>NoexceptLoc</name></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>Ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>concepts</name><operator>::</operator><name>NestedRequirement</name> <operator>*</operator>
<macro><name>RebuildNestedRequirement</name><argument_list>(
<argument>concepts::Requirement::SubstitutionDiagnostic *SubstDiag</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>BuildNestedRequirement</name></name><argument_list>(<argument><expr><name>SubstDiag</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>concepts</name><operator>::</operator><name>NestedRequirement</name> <operator>*</operator><macro><name>RebuildNestedRequirement</name><argument_list>(<argument>Expr *Constraint</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>BuildNestedRequirement</name></name><argument_list>(<argument><expr><name>Constraint</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>





<function><type><name>ExprResult</name></type> <name>RebuildObjCBoxedExpr</name><parameter_list>(<parameter><decl><type><name>SourceRange</name></type> <name>SR</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>ValueExpr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildObjCBoxedExpr</name><argument_list>(<argument><expr><name>SR</name></expr></argument>, <argument><expr><name>ValueExpr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildObjCArrayLiteral</name><parameter_list>(<parameter><decl><type><name>SourceRange</name></type> <name>Range</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier><modifier>*</modifier></type><name>Elements</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>NumElements</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildObjCArrayLiteral</name><argument_list>(<argument><expr><name>Range</name></expr></argument>,
<argument><expr><call><name>MultiExprArg</name><argument_list>(<argument><expr><name>Elements</name></expr></argument>, <argument><expr><name>NumElements</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>ExprResult</name></type> <name>RebuildObjCSubscriptRefExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>RB</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Base</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Key</name></decl></parameter>,
<parameter><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>getterMethod</name></decl></parameter>,
<parameter><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>setterMethod</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildObjCSubscriptExpression</name><argument_list>(<argument><expr><name>RB</name></expr></argument>, <argument><expr><name>Base</name></expr></argument>, <argument><expr><name>Key</name></expr></argument>,
<argument><expr><name>getterMethod</name></expr></argument>, <argument><expr><name>setterMethod</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildObjCDictionaryLiteral</name><parameter_list>(<parameter><decl><type><name>SourceRange</name></type> <name>Range</name></decl></parameter>,
<parameter><decl><type><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ObjCDictionaryElement</name></expr></argument>&gt;</argument_list></name></type> <name>Elements</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildObjCDictionaryLiteral</name><argument_list>(<argument><expr><name>Range</name></expr></argument>, <argument><expr><name>Elements</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildObjCEncodeExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>AtLoc</name></decl></parameter>,
<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>EncodeTypeInfo</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>BuildObjCEncodeExpression</name></name><argument_list>(<argument><expr><name>AtLoc</name></expr></argument>, <argument><expr><name>EncodeTypeInfo</name></expr></argument>, <argument><expr><name>RParenLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>ExprResult</name></type> <name>RebuildObjCMessageExpr</name><parameter_list>(<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>ReceiverTypeInfo</name></decl></parameter>,
<parameter><decl><type><name>Selector</name></type> <name>Sel</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name></type> <name>SelectorLocs</name></decl></parameter>,
<parameter><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>Method</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LBracLoc</name></decl></parameter>,
<parameter><decl><type><name>MultiExprArg</name></type> <name>Args</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RBracLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>BuildClassMessage</name></name><argument_list>(<argument><expr><name>ReceiverTypeInfo</name></expr></argument>,
<argument><expr><call><name><name>ReceiverTypeInfo</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>Sel</name></expr></argument>, <argument><expr><name>Method</name></expr></argument>, <argument><expr><name>LBracLoc</name></expr></argument>, <argument><expr><name>SelectorLocs</name></expr></argument>,
<argument><expr><name>RBracLoc</name></expr></argument>, <argument><expr><name>Args</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>ExprResult</name></type> <name>RebuildObjCMessageExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Receiver</name></decl></parameter>,
<parameter><decl><type><name>Selector</name></type> <name>Sel</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name></type> <name>SelectorLocs</name></decl></parameter>,
<parameter><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>Method</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LBracLoc</name></decl></parameter>,
<parameter><decl><type><name>MultiExprArg</name></type> <name>Args</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RBracLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>BuildInstanceMessage</name></name><argument_list>(<argument><expr><name>Receiver</name></expr></argument>,
<argument><expr><call><name><name>Receiver</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>Sel</name></expr></argument>, <argument><expr><name>Method</name></expr></argument>, <argument><expr><name>LBracLoc</name></expr></argument>, <argument><expr><name>SelectorLocs</name></expr></argument>,
<argument><expr><name>RBracLoc</name></expr></argument>, <argument><expr><name>Args</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>ExprResult</name></type> <name>RebuildObjCMessageExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>SuperLoc</name></decl></parameter>,
<parameter><decl><type><name>Selector</name></type> <name>Sel</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name></type> <name>SelectorLocs</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>SuperType</name></decl></parameter>,
<parameter><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>Method</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LBracLoc</name></decl></parameter>,
<parameter><decl><type><name>MultiExprArg</name></type> <name>Args</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RBracLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><ternary><condition><expr><call><name><name>Method</name><operator>-&gt;</operator><name>isInstanceMethod</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name><name>SemaRef</name><operator>.</operator><name>BuildInstanceMessage</name></name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><name>SuperType</name></expr></argument>,
<argument><expr><name>SuperLoc</name></expr></argument>,
<argument><expr><name>Sel</name></expr></argument>, <argument><expr><name>Method</name></expr></argument>, <argument><expr><name>LBracLoc</name></expr></argument>, <argument><expr><name>SelectorLocs</name></expr></argument>,
<argument><expr><name>RBracLoc</name></expr></argument>, <argument><expr><name>Args</name></expr></argument>)</argument_list></call></expr>
</then><else>: <expr><call><name><name>SemaRef</name><operator>.</operator><name>BuildClassMessage</name></name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><name>SuperType</name></expr></argument>,
<argument><expr><name>SuperLoc</name></expr></argument>,
<argument><expr><name>Sel</name></expr></argument>, <argument><expr><name>Method</name></expr></argument>, <argument><expr><name>LBracLoc</name></expr></argument>, <argument><expr><name>SelectorLocs</name></expr></argument>,
<argument><expr><name>RBracLoc</name></expr></argument>, <argument><expr><name>Args</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>


</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildObjCIvarRefExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>BaseArg</name></decl></parameter>, <parameter><decl><type><name>ObjCIvarDecl</name> <modifier>*</modifier></type><name>Ivar</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>IvarLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsArrow</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsFreeIvar</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>CXXScopeSpec</name></type> <name>SS</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DeclarationNameInfo</name></type> <name>NameInfo</name><argument_list>(<argument><expr><call><name><name>Ivar</name><operator>-&gt;</operator><name>getDeclName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>IvarLoc</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>Result</name> <init>= <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildMemberReferenceExpr</name><argument_list>(
<argument><expr><name>BaseArg</name></expr></argument>, <argument><expr><call><name><name>BaseArg</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>IvarLoc</name></expr></argument>, <argument><expr><name>IsArrow</name></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>nullptr</name></expr></argument>, <argument><expr><name>NameInfo</name></expr></argument>,
<argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>IsFreeIvar</name> <operator>&amp;&amp;</operator> <call><name><name>Result</name><operator>.</operator><name>isUsable</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>ObjCIvarRefExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Result</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>setIsFreeIvar</name><argument_list>(<argument><expr><name>IsFreeIvar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>Result</name></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildObjCPropertyRefExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>BaseArg</name></decl></parameter>,
<parameter><decl><type><name>ObjCPropertyDecl</name> <modifier>*</modifier></type><name>Property</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>PropertyLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>CXXScopeSpec</name></type> <name>SS</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DeclarationNameInfo</name></type> <name>NameInfo</name><argument_list>(<argument><expr><call><name><name>Property</name><operator>-&gt;</operator><name>getDeclName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>PropertyLoc</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildMemberReferenceExpr</name><argument_list>(<argument><expr><name>BaseArg</name></expr></argument>, <argument><expr><call><name><name>BaseArg</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>PropertyLoc</name></expr></argument>,
<argument><expr><name>false</name></expr></argument>,
<argument><expr><name>SS</name></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><name>NameInfo</name></expr></argument>,
<argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildObjCPropertyRefExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Base</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>,
<parameter><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>Getter</name></decl></parameter>,
<parameter><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>Setter</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>PropertyLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>


<return>return <expr><call><name>Owned</name><argument_list>(
<argument><expr><macro><name>new</name> <argument_list>(<argument>getSema().Context</argument>)</argument_list></macro> <call><name>ObjCPropertyRefExpr</name><argument_list>(<argument><expr><name>Getter</name></expr></argument>, <argument><expr><name>Setter</name></expr></argument>, <argument><expr><name>T</name></expr></argument>,
<argument><expr><name>VK_LValue</name></expr></argument>, <argument><expr><name>OK_ObjCProperty</name></expr></argument>,
<argument><expr><name>PropertyLoc</name></expr></argument>, <argument><expr><name>Base</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildObjCIsaExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>BaseArg</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>IsaLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsArrow</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>CXXScopeSpec</name></type> <name>SS</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DeclarationNameInfo</name></type> <name>NameInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>Context</name><operator>.</operator><name>Idents</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"isa"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>IsaLoc</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildMemberReferenceExpr</name><argument_list>(<argument><expr><name>BaseArg</name></expr></argument>, <argument><expr><call><name><name>BaseArg</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>OpLoc</name></expr></argument>, <argument><expr><name>IsArrow</name></expr></argument>,
<argument><expr><name>SS</name></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><name>NameInfo</name></expr></argument>,
<argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildShuffleVectorExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>BuiltinLoc</name></decl></parameter>,
<parameter><decl><type><name>MultiExprArg</name></type> <name>SubExprs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>IdentifierInfo</name> <modifier>&amp;</modifier></type><name>Name</name>
<init>= <expr><call><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>Idents</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><literal type="string">"__builtin_shufflevector"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TranslationUnitDecl</name> <modifier>*</modifier></type><name>TUDecl</name> <init>= <expr><call><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>getTranslationUnitDecl</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>DeclContext</name><operator>::</operator><name>lookup_result</name> <name>Lookup</name> <operator>=</operator> <call><name><name>TUDecl</name><operator>-&gt;</operator><name>lookup</name></name><argument_list>(<argument><expr><call><name>DeclarationName</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>Lookup</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"No __builtin_shufflevector?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>Builtin</name> <init>= <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>FunctionDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Lookup</name><operator>.</operator><name>front</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Callee</name> <init>= <macro><name>new</name> <argument_list>(<argument>SemaRef.Context</argument>)</argument_list></macro>
<expr><call><name>DeclRefExpr</name><argument_list>(<argument><expr><name><name>SemaRef</name><operator>.</operator><name>Context</name></name></expr></argument>, <argument><expr><name>Builtin</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
<argument><expr><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>BuiltinFnTy</name></name></expr></argument>, <argument><expr><name>VK_PRValue</name></expr></argument>, <argument><expr><name>BuiltinLoc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>QualType</name></type> <name>CalleePtrTy</name> <init>= <expr><call><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>getPointerType</name></name><argument_list>(<argument><expr><call><name><name>Builtin</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>Callee</name> <operator>=</operator> <call><name><name>SemaRef</name><operator>.</operator><name>ImpCastExprToType</name></name><argument_list>(<argument><expr><name>Callee</name></expr></argument>, <argument><expr><name>CalleePtrTy</name></expr></argument>,
<argument><expr><name>CK_BuiltinFnToFnPtr</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>get</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><name>ExprResult</name></type> <name>TheCall</name> <init>= <expr><name>CallExpr</name><operator>::</operator><call><name>Create</name><argument_list>(
<argument><expr><name><name>SemaRef</name><operator>.</operator><name>Context</name></name></expr></argument>, <argument><expr><name>Callee</name></expr></argument>, <argument><expr><name>SubExprs</name></expr></argument>, <argument><expr><call><name><name>Builtin</name><operator>-&gt;</operator><name>getCallResultType</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>Expr</name><operator>::</operator><call><name>getValueKindForType</name><argument_list>(<argument><expr><call><name><name>Builtin</name><operator>-&gt;</operator><name>getReturnType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>RParenLoc</name></expr></argument>,
<argument><expr><call><name>FPOptionsOverride</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>SemaBuiltinShuffleVector</name></name><argument_list>(<argument><expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>CallExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>TheCall</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>ExprResult</name></type> <name>RebuildConvertVectorExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>BuiltinLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>SrcExpr</name></decl></parameter>, <parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>DstTInfo</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>SemaConvertVectorExpr</name></name><argument_list>(<argument><expr><name>SrcExpr</name></expr></argument>, <argument><expr><name>DstTInfo</name></expr></argument>,
<argument><expr><name>BuiltinLoc</name></expr></argument>, <argument><expr><name>RParenLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>






<function><type><name>TemplateArgumentLoc</name></type> <name>RebuildPackExpansion</name><parameter_list>(<parameter><decl><type><name>TemplateArgumentLoc</name></type> <name>Pattern</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EllipsisLoc</name></decl></parameter>,
<parameter><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></type> <name>NumExpansions</name></decl></parameter>)</parameter_list> <block>{<block_content>
<switch>switch <condition>(<expr><call><name><name>Pattern</name><operator>.</operator><name>getArgument</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getKind</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>TemplateArgument</name><operator>::</operator><name>Expression</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>Result</name>
<init>= <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>CheckPackExpansion</name><argument_list>(<argument><expr><call><name><name>Pattern</name><operator>.</operator><name>getSourceExpression</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>EllipsisLoc</name></expr></argument>, <argument><expr><name>NumExpansions</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>TemplateArgumentLoc</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>TemplateArgumentLoc</name><argument_list>(<argument><expr><call><name><name>Result</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Result</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>

<case>case <expr><name>TemplateArgument</name><operator>::</operator><name>Template</name></expr>:</case>
<return>return <expr><call><name>TemplateArgumentLoc</name><argument_list>(
<argument><expr><name><name>SemaRef</name><operator>.</operator><name>Context</name></name></expr></argument>,
<argument><expr><call><name>TemplateArgument</name><argument_list>(<argument><expr><call><name><name>Pattern</name><operator>.</operator><name>getArgument</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getAsTemplate</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>NumExpansions</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Pattern</name><operator>.</operator><name>getTemplateQualifierLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Pattern</name><operator>.</operator><name>getTemplateNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>EllipsisLoc</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>TemplateArgument</name><operator>::</operator><name>Null</name></expr>:</case>
<case>case <expr><name>TemplateArgument</name><operator>::</operator><name>Integral</name></expr>:</case>
<case>case <expr><name>TemplateArgument</name><operator>::</operator><name>Declaration</name></expr>:</case>
<case>case <expr><name>TemplateArgument</name><operator>::</operator><name>Pack</name></expr>:</case>
<case>case <expr><name>TemplateArgument</name><operator>::</operator><name>TemplateExpansion</name></expr>:</case>
<case>case <expr><name>TemplateArgument</name><operator>::</operator><name>NullPtr</name></expr>:</case>
<expr_stmt><expr><call><name>llvm_unreachable</name><argument_list>(<argument><expr><literal type="string">"Pack expansion pattern has no parameter packs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>TemplateArgument</name><operator>::</operator><name>Type</name></expr>:</case>
<if_stmt><if>if <condition>(<decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>Expansion</name>
<init>= <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>CheckPackExpansion</name><argument_list>(<argument><expr><call><name><name>Pattern</name><operator>.</operator><name>getTypeSourceInfo</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>EllipsisLoc</name></expr></argument>,
<argument><expr><name>NumExpansions</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>TemplateArgumentLoc</name><argument_list>(<argument><expr><call><name>TemplateArgument</name><argument_list>(<argument><expr><call><name><name>Expansion</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>Expansion</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block></switch>

<return>return <expr><call><name>TemplateArgumentLoc</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>






<function><type><name>ExprResult</name></type> <name>RebuildPackExpansion</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Pattern</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>EllipsisLoc</name></decl></parameter>,
<parameter><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></type> <name>NumExpansions</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>CheckPackExpansion</name><argument_list>(<argument><expr><name>Pattern</name></expr></argument>, <argument><expr><name>EllipsisLoc</name></expr></argument>, <argument><expr><name>NumExpansions</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildCXXFoldExpr</name><parameter_list>(<parameter><decl><type><name>UnresolvedLookupExpr</name> <modifier>*</modifier></type><name>ULE</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>LHS</name></decl></parameter>,
<parameter><decl><type><name>BinaryOperatorKind</name></type> <name>Operator</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EllipsisLoc</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>RHS</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>,
<parameter><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></type> <name>NumExpansions</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildCXXFoldExpr</name><argument_list>(<argument><expr><name>ULE</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>Operator</name></expr></argument>,
<argument><expr><name>EllipsisLoc</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>, <argument><expr><name>RParenLoc</name></expr></argument>,
<argument><expr><name>NumExpansions</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>ExprResult</name></type> <name>RebuildEmptyCXXFoldExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>EllipsisLoc</name></decl></parameter>,
<parameter><decl><type><name>BinaryOperatorKind</name></type> <name>Operator</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildEmptyCXXFoldExpr</name><argument_list>(<argument><expr><name>EllipsisLoc</name></expr></argument>, <argument><expr><name>Operator</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<decl_stmt><decl><type><name>ExprResult</name></type> <name>RebuildAtomicExpr</name><argument_list>(<argument><expr><name>SourceLocation</name> <name>BuiltinLoc</name></expr></argument>, <argument><expr><name>MultiExprArg</name> <name>SubExprs</name></expr></argument>,
<argument><expr><name>AtomicExpr</name><operator>::</operator><name>AtomicOp</name> <name>Op</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>RParenLoc</name></expr></argument>)</argument_list> <block>{<block_content>


<decl_stmt><decl><type><name>SourceRange</name></type> <name>Range</name><block>{<block_content><expr><name>BuiltinLoc</name></expr><operator>,</operator> <expr><name>RParenLoc</name></expr></block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildAtomicExpr</name><argument_list>(<argument><expr><name>Range</name></expr></argument>, <argument><expr><name>Range</name></expr></argument>, <argument><expr><name>RParenLoc</name></expr></argument>, <argument><expr><name>SubExprs</name></expr></argument>, <argument><expr><name>Op</name></expr></argument>,
<argument><expr><name>Sema</name><operator>::</operator><name>AtomicArgumentOrder</name><operator>::</operator><name>AST</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<function><type><name>ExprResult</name></type> <name>RebuildRecoveryExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>BeginLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>SubExprs</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>Type</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>CreateRecoveryExpr</name><argument_list>(<argument><expr><name>BeginLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>, <argument><expr><name>SubExprs</name></expr></argument>, <argument><expr><name>Type</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<label><name>private</name>:</label>
<function_decl><type><name>TypeLoc</name></type> <name>TransformTypeInObjectScope</name><parameter_list>(<parameter><decl><type><name>TypeLoc</name></type> <name>TL</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>ObjectType</name></decl></parameter>,
<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>FirstQualifierInScope</name></decl></parameter>,
<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TransformTypeInObjectScope</name><parameter_list>(<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TSInfo</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>ObjectType</name></decl></parameter>,
<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>FirstQualifierInScope</name></decl></parameter>,
<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TransformTSIInObjectScope</name><parameter_list>(<parameter><decl><type><name>TypeLoc</name></type> <name>TL</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>ObjectType</name></decl></parameter>,
<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>FirstQualifierInScope</name></decl></parameter>,
<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>QualType</name></type> <name>TransformDependentNameType</name><parameter_list>(<parameter><decl><type><name>TypeLocBuilder</name> <modifier>&amp;</modifier></type><name>TLB</name></decl></parameter>,
<parameter><decl><type><name>DependentNameTypeLoc</name></type> <name>TL</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>DeducibleTSTContext</name></decl></parameter>)</parameter_list>;</function_decl>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformStmt</name><argument_list>(<argument>Stmt *S</argument>, <argument>StmtDiscardKind SDK</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>S</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>S</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<switch>switch <condition>(<expr><call><name><name>S</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>Stmt</name><operator>::</operator><name>NoStmtClass</name></expr>:</case> <break>break;</break>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STMT</name><parameter_list>(<parameter><type><name>Node</name></type></parameter>, <parameter><type><name>Parent</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case Stmt::Node##Class: return getDerived().Transform##Node(cast&lt;Node&gt;(S));</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VALUESTMT</name><parameter_list>(<parameter><type><name>Node</name></type></parameter>, <parameter><type><name>Parent</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case Stmt::Node##Class: return getDerived().Transform##Node(cast&lt;Node&gt;(S), SDK);</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ABSTRACT_STMT</name><parameter_list>(<parameter><type><name>Node</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPR</name><parameter_list>(<parameter><type><name>Node</name></type></parameter>, <parameter><type><name>Parent</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/StmtNodes.inc"</cpp:file></cpp:include>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STMT</name><parameter_list>(<parameter><type><name>Node</name></type></parameter>, <parameter><type><name>Parent</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ABSTRACT_STMT</name><parameter_list>(<parameter><type><name>Stmt</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPR</name><parameter_list>(<parameter><type><name>Node</name></type></parameter>, <parameter><type><name>Parent</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case Stmt::Node##Class:</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/StmtNodes.inc"</cpp:file></cpp:include>
<block>{<block_content>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>E</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>S</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>SDK</name> <operator>==</operator> <name>SDK_StmtExprResult</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>E</name> <operator>=</operator> <call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnStmtExprResult</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnExprStmt</name><argument_list>(<argument><expr><name>E</name></expr></argument>, <argument><expr><name>SDK</name> <operator>==</operator> <name>SDK_Discarded</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>
</block_content>}</block></switch>

<return>return <expr><name>S</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>OMPClause</name> <operator>*</operator><name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPClause</name><argument_list>(<argument>OMPClause *S</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>S</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>S</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<switch>switch <condition>(<expr><call><name><name>S</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<default>default:</default> <break>break;</break>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GEN_CLANG_CLAUSE_CLASS</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLAUSE_CLASS</name><parameter_list>(<parameter><type><name>Enum</name></type></parameter>, <parameter><type><name>Str</name></type></parameter>, <parameter><type><name>Class</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case Enum: return getDerived().Transform##Class(cast&lt;Class&gt;(S));</cpp:value></cpp:define>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Frontend/OpenMP/OMP.inc"</cpp:file></cpp:include>
</block_content>}</block></switch>

<return>return <expr><name>S</name></expr>;</return>
}


template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformExpr</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>E</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<switch>switch <condition>(<expr><call><name><name>E</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>Stmt</name><operator>::</operator><name>NoStmtClass</name></expr>:</case> <break>break;</break>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STMT</name><parameter_list>(<parameter><type><name>Node</name></type></parameter>, <parameter><type><name>Parent</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case Stmt::Node##Class: break;</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ABSTRACT_STMT</name><parameter_list>(<parameter><type><name>Stmt</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPR</name><parameter_list>(<parameter><type><name>Node</name></type></parameter>, <parameter><type><name>Parent</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case Stmt::Node##Class: return getDerived().Transform##Node(cast&lt;Node&gt;(E));</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/StmtNodes.inc"</cpp:file></cpp:include>
</block_content>}</block></switch>

<return>return <expr><name>E</name></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformInitializer</name><argument_list>(<argument>Expr *Init</argument>,
<argument>bool NotCopyInit</argument>)</argument_list></macro> <block>{


<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Init</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>Init</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>FE</name> <operator>=</operator> <call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>FullExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Init</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>Init</name> <operator>=</operator> <call><name><name>FE</name><operator>-&gt;</operator><name>getSubExpr</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>AIL</name> <operator>=</operator> <call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>ArrayInitLoopExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Init</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>Init</name> <operator>=</operator> <call><name><name>AIL</name><operator>-&gt;</operator><name>getCommonExpr</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<decl><type><name>MaterializeTemporaryExpr</name> <modifier>*</modifier></type><name>MTE</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>MaterializeTemporaryExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Init</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>Init</name> <operator>=</operator> <call><name><name>MTE</name><operator>-&gt;</operator><name>getSubExpr</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<while>while <condition>(<decl><type><name>CXXBindTemporaryExpr</name> <modifier>*</modifier></type><name>Binder</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXBindTemporaryExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Init</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>Init</name> <operator>=</operator> <call><name><name>Binder</name><operator>-&gt;</operator><name>getSubExpr</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></while>

<if_stmt><if>if <condition>(<decl><type><name>ImplicitCastExpr</name> <modifier>*</modifier></type><name>ICE</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>ImplicitCastExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Init</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>Init</name> <operator>=</operator> <call><name><name>ICE</name><operator>-&gt;</operator><name>getSubExprAsWritten</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<decl><type><name>CXXStdInitializerListExpr</name> <modifier>*</modifier></type><name>ILE</name> <init>=
<expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXStdInitializerListExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Init</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>TransformInitializer</name><argument_list>(<argument><expr><call><name><name>ILE</name><operator>-&gt;</operator><name>getSubExpr</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NotCopyInit</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>




<decl_stmt><decl><type><name>CXXConstructExpr</name> <modifier>*</modifier></type><name>Construct</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXConstructExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Init</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>NotCopyInit</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>Construct</name> <operator>&amp;&amp;</operator> <call><name><name>Construct</name><operator>-&gt;</operator><name>isListInitialization</name></name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><name>Init</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<decl><type><name>CXXScalarValueInitExpr</name> <modifier>*</modifier></type><name>VIE</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXScalarValueInitExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Init</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>SourceRange</name></type> <name>Parens</name> <init>= <expr><call><name><name>VIE</name><operator>-&gt;</operator><name>getSourceRange</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildParenListExpr</name><argument_list>(<argument><expr><call><name><name>Parens</name><operator>.</operator><name>getBegin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>None</name></expr></argument>,
<argument><expr><call><name><name>Parens</name><operator>.</operator><name>getEnd</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>ImplicitValueInitExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Init</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildParenListExpr</name><argument_list>(<argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>None</name></expr></argument>,
<argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Construct</name> <operator>||</operator> <call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>CXXTemporaryObjectExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Construct</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><name>Init</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><name>Construct</name> <operator>&amp;&amp;</operator> <call><name><name>Construct</name><operator>-&gt;</operator><name>isStdInitListInitialization</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>TransformInitializer</name><argument_list>(<argument><expr><call><name><name>Construct</name><operator>-&gt;</operator><name>getArg</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NotCopyInit</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<decl_stmt><decl><type><name>EnterExpressionEvaluationContext</name></type> <name>Context</name><argument_list>(
<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>EnterExpressionEvaluationContext</name><operator>::</operator><name>InitList</name></expr></argument>,
<argument><expr><call><name><name>Construct</name><operator>-&gt;</operator><name>isListInitialization</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name><modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name></type> <name>NewArgs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>ArgChanged</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExprs</name><argument_list>(<argument><expr><call><name><name>Construct</name><operator>-&gt;</operator><name>getArgs</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Construct</name><operator>-&gt;</operator><name>getNumArgs</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>true</name></expr></argument>, <argument><expr><name>NewArgs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ArgChanged</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name><name>Construct</name><operator>-&gt;</operator><name>isListInitialization</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildInitList</name><argument_list>(<argument><expr><call><name><name>Construct</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NewArgs</name></expr></argument>,
<argument><expr><call><name><name>Construct</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<decl_stmt><decl><type><name>SourceRange</name></type> <name>Parens</name> <init>= <expr><call><name><name>Construct</name><operator>-&gt;</operator><name>getParenOrBraceRange</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Parens</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>NewArgs</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"no parens or braces but have direct init with arguments?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>ExprEmpty</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildParenListExpr</name><argument_list>(<argument><expr><call><name><name>Parens</name><operator>.</operator><name>getBegin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NewArgs</name></expr></argument>,
<argument><expr><call><name><name>Parens</name><operator>.</operator><name>getEnd</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>bool</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformExprs</name><argument_list>(<argument>Expr *const *Inputs</argument>,
<argument>unsigned NumInputs</argument>,
<argument>bool IsCall</argument>,
<argument>SmallVectorImpl&lt;Expr *&gt; &amp;Outputs</argument>,
<argument>bool *ArgChanged</argument>)</argument_list></macro> <block>{
<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>I</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>I</name> <operator>!=</operator> <name>NumInputs</name></expr>;</condition> <incr><expr><operator>++</operator><name>I</name></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>IsCall</name> <operator>&amp;&amp;</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>DropCallArgument</name><argument_list>(<argument><expr><name><name>Inputs</name><index>[<expr><name>I</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>ArgChanged</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>ArgChanged</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<break>break;</break>
<expr_stmt/></block_content></block></if></if_stmt></block_content></block></for>}</block></expr></expr_stmt>

<if_stmt><if>if <condition>(<decl><type><name>PackExpansionExpr</name> <modifier>*</modifier></type><name>Expansion</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>PackExpansionExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>Inputs</name><index>[<expr><name>I</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Pattern</name> <init>= <expr><call><name><name>Expansion</name><operator>-&gt;</operator><name>getPattern</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>UnexpandedParameterPack</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name></type> <name>Unexpanded</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>collectUnexpandedParameterPacks</name><argument_list>(<argument><expr><name>Pattern</name></expr></argument>, <argument><expr><name>Unexpanded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>Unexpanded</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Pack expansion without parameter packs?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>Expand</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>RetainExpansion</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></type> <name>OrigNumExpansions</name> <init>= <expr><call><name><name>Expansion</name><operator>-&gt;</operator><name>getNumExpansions</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></type> <name>NumExpansions</name> <init>= <expr><name>OrigNumExpansions</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TryExpandParameterPacks</name><argument_list>(<argument><expr><call><name><name>Expansion</name><operator>-&gt;</operator><name>getEllipsisLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Pattern</name><operator>-&gt;</operator><name>getSourceRange</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>Unexpanded</name></expr></argument>,
<argument><expr><name>Expand</name></expr></argument>, <argument><expr><name>RetainExpansion</name></expr></argument>,
<argument><expr><name>NumExpansions</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Expand</name></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><name>Sema</name><operator>::</operator><name>ArgumentPackSubstitutionIndexRAII</name> <call><name>SubstIndex</name><argument_list>(<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>OutPattern</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><name>Pattern</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>OutPattern</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>ExprResult</name></type> <name>Out</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildPackExpansion</name><argument_list>(<argument><expr><call><name><name>OutPattern</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Expansion</name><operator>-&gt;</operator><name>getEllipsisLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>NumExpansions</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Out</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ArgChanged</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>ArgChanged</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>Outputs</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>Out</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><name>ArgChanged</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>ArgChanged</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>



<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>I</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>I</name> <operator>!=</operator> <operator>*</operator><name>NumExpansions</name></expr>;</condition> <incr><expr><operator>++</operator><name>I</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>Sema</name><operator>::</operator><name>ArgumentPackSubstitutionIndexRAII</name> <call><name>SubstIndex</name><argument_list>(<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>I</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>Out</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><name>Pattern</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Out</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>Out</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>containsUnexpandedParameterPack</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Out</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildPackExpansion</name><argument_list>(
<argument><expr><call><name><name>Out</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Expansion</name><operator>-&gt;</operator><name>getEllipsisLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>OrigNumExpansions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Out</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name><name>Outputs</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>Out</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>



<if_stmt><if>if <condition>(<expr><name>RetainExpansion</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ForgetPartiallySubstitutedPackRAII</name></type> <name>Forget</name><argument_list>(<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ExprResult</name></type> <name>Out</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><name>Pattern</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Out</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>Out</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildPackExpansion</name><argument_list>(
<argument><expr><call><name><name>Out</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Expansion</name><operator>-&gt;</operator><name>getEllipsisLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>OrigNumExpansions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Out</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name><name>Outputs</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>Out</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ExprResult</name></type> <name>Result</name> <init>=
<expr><ternary><condition><expr><name>IsCall</name></expr> ?</condition><then> <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformInitializer</name><argument_list>(<argument><expr><name><name>Inputs</name><index>[<expr><name>I</name></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>
</then><else>: <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><name><name>Inputs</name><index>[<expr><name>I</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name><name>Inputs</name><index>[<expr><name>I</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name>ArgChanged</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>ArgChanged</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name><name>Outputs</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>Result</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}

return <expr_stmt><expr><name>false</name></expr>;</expr_stmt>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>Sema</name><operator>::</operator><name>ConditionResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformCondition</name><argument_list>(
<argument>SourceLocation Loc</argument>, <argument>VarDecl *Var</argument>, <argument>Expr *Expr</argument>, <argument>Sema::ConditionKind Kind</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><name>Var</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>ConditionVar</name> <init>= <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>VarDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDefinition</name><argument_list>(<argument><expr><call><name><name>Var</name><operator>-&gt;</operator><name>getLocation</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ConditionVar</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>Sema</name><operator>::</operator><call><name>ConditionError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnConditionVariable</name><argument_list>(<argument><expr><name>ConditionVar</name></expr></argument>, <argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>Kind</name></expr></argument>)</argument_list></call></expr>;</return>
<expr_stmt/></block_content></block></if></if_stmt>}</block></expr></expr_stmt>

<if_stmt><if>if <condition>(<expr><name>Expr</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>CondExpr</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><name>Expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>CondExpr</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>Sema</name><operator>::</operator><call><name>ConditionError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnCondition</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>, <argument><expr><name>Loc</name></expr></argument>, <argument><expr><call><name><name>CondExpr</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Kind</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>Sema</name><operator>::</operator><call><name>ConditionResult</name><argument_list>()</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>NestedNameSpecifierLoc</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformNestedNameSpecifierLoc</name><argument_list>(
<argument>NestedNameSpecifierLoc NNS</argument>, <argument>QualType ObjectType</argument>,
<argument>NamedDecl *FirstQualifierInScope</argument>)</argument_list></macro> <block>{
<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>NestedNameSpecifierLoc</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>Qualifiers</name></expr>;
<for>for <control>(<init><decl><type><name>NestedNameSpecifierLoc</name></type> <name>Qualifier</name> <init>= <expr><name>NNS</name></expr></init></decl>;</init> <condition><expr><name>Qualifier</name></expr>;</condition>
<incr><expr><name>Qualifier</name> <operator>=</operator> <call><name><name>Qualifier</name><operator>.</operator><name>getPrefix</name></name><argument_list>()</argument_list></call></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>Qualifiers</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>Qualifier</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<name>CXXScopeSpec</name> <name>SS</name></block></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>!</operator><call><name><name>Qualifiers</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>NestedNameSpecifierLoc</name></type> <name>Q</name> <init>= <expr><call><name><name>Qualifiers</name><operator>.</operator><name>pop_back_val</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>NestedNameSpecifier</name> <modifier>*</modifier></type><name>QNNS</name> <init>= <expr><call><name><name>Q</name><operator>.</operator><name>getNestedNameSpecifier</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><call><name><name>QNNS</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>NestedNameSpecifier</name><operator>::</operator><name>Identifier</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><name>Sema</name><operator>::</operator><name>NestedNameSpecInfo</name> <call><name>IdInfo</name><argument_list>(<argument><expr><call><name><name>QNNS</name><operator>-&gt;</operator><name>getAsIdentifier</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Q</name><operator>.</operator><name>getLocalBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Q</name><operator>.</operator><name>getLocalEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>ObjectType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>SemaRef</name><operator>.</operator><name>BuildCXXNestedNameSpecifier</name></name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>, <argument><expr><name>IdInfo</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
<argument><expr><name>SS</name></expr></argument>, <argument><expr><name>FirstQualifierInScope</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>NestedNameSpecifierLoc</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block>

<case>case <expr><name>NestedNameSpecifier</name><operator>::</operator><name>Namespace</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>NamespaceDecl</name> <modifier>*</modifier></type><name>NS</name> <init>=
<expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>NamespaceDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDecl</name><argument_list>(
<argument><expr><call><name><name>Q</name><operator>.</operator><name>getLocalBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>QNNS</name><operator>-&gt;</operator><name>getAsNamespace</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>SS</name><operator>.</operator><name>Extend</name></name><argument_list>(<argument><expr><name><name>SemaRef</name><operator>.</operator><name>Context</name></name></expr></argument>, <argument><expr><name>NS</name></expr></argument>, <argument><expr><call><name><name>Q</name><operator>.</operator><name>getLocalBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Q</name><operator>.</operator><name>getLocalEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>

<case>case <expr><name>NestedNameSpecifier</name><operator>::</operator><name>NamespaceAlias</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>NamespaceAliasDecl</name> <modifier>*</modifier></type><name>Alias</name> <init>=
<expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>NamespaceAliasDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDecl</name><argument_list>(
<argument><expr><call><name><name>Q</name><operator>.</operator><name>getLocalBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>QNNS</name><operator>-&gt;</operator><name>getAsNamespaceAlias</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>SS</name><operator>.</operator><name>Extend</name></name><argument_list>(<argument><expr><name><name>SemaRef</name><operator>.</operator><name>Context</name></name></expr></argument>, <argument><expr><name>Alias</name></expr></argument>, <argument><expr><call><name><name>Q</name><operator>.</operator><name>getLocalBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Q</name><operator>.</operator><name>getLocalEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>

<case>case <expr><name>NestedNameSpecifier</name><operator>::</operator><name>Global</name></expr>:</case>


<expr_stmt><expr><call><name><name>SS</name><operator>.</operator><name>MakeGlobal</name></name><argument_list>(<argument><expr><name><name>SemaRef</name><operator>.</operator><name>Context</name></name></expr></argument>, <argument><expr><call><name><name>Q</name><operator>.</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>NestedNameSpecifier</name><operator>::</operator><name>Super</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>RD</name> <init>=
<expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>CXXRecordDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDecl</name><argument_list>(
<argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>QNNS</name><operator>-&gt;</operator><name>getAsRecordDecl</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>SS</name><operator>.</operator><name>MakeSuper</name></name><argument_list>(<argument><expr><name><name>SemaRef</name><operator>.</operator><name>Context</name></name></expr></argument>, <argument><expr><name>RD</name></expr></argument>, <argument><expr><call><name><name>Q</name><operator>.</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Q</name><operator>.</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>

<case>case <expr><name>NestedNameSpecifier</name><operator>::</operator><name>TypeSpecWithTemplate</name></expr>:</case>
<case>case <expr><name>NestedNameSpecifier</name><operator>::</operator><name>TypeSpec</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>TypeLoc</name></type> <name>TL</name> <init>= <expr><call><name>TransformTypeInObjectScope</name><argument_list>(<argument><expr><call><name><name>Q</name><operator>.</operator><name>getTypeLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ObjectType</name></expr></argument>,
<argument><expr><name>FirstQualifierInScope</name></expr></argument>, <argument><expr><name>SS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>TL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>NestedNameSpecifierLoc</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isDependentType</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isRecordType</name><argument_list>()</argument_list></call> <operator>||</operator>
<operator>(</operator><call><name><name>SemaRef</name><operator>.</operator><name>getLangOpts</name></name><argument_list>()</argument_list></call><operator>.</operator><name>CPlusPlus11</name> <operator>&amp;&amp;</operator>
<call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isEnumeralType</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>hasLocalQualifiers</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"Can't get cv-qualifiers here"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isEnumeralType</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>SemaRef</name><operator>.</operator><name>Diag</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>diag</name><operator>::</operator><name>warn_cxx98_compat_enum_nested_name_spec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>SS</name><operator>.</operator><name>Extend</name></name><argument_list>(<argument><expr><name><name>SemaRef</name><operator>.</operator><name>Context</name></name></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>TL</name></expr></argument>,
<argument><expr><call><name><name>Q</name><operator>.</operator><name>getLocalEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>


<decl_stmt><decl><type><name>TypedefTypeLoc</name></type> <name>TTL</name> <init>= <expr><name><name>TL</name><operator>.</operator><name>getAs</name></name><operator>&lt;</operator><name>TypedefTypeLoc</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>TTL</name> <operator>||</operator> <operator>!</operator><call><name><name>TTL</name><operator>.</operator><name>getTypedefNameDecl</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isInvalidDecl</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>SemaRef</name><operator>.</operator><name>Diag</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>diag</name><operator>::</operator><name>err_nested_name_spec_non_tag</name></expr></argument>)</argument_list></call>
<operator>&lt;&lt;</operator> <call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call> <operator>&lt;&lt;</operator> <call><name><name>SS</name><operator>.</operator><name>getRange</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>NestedNameSpecifierLoc</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>
</block_content>}</block></switch>


<expr_stmt><expr><name>FirstQualifierInScope</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ObjectType</name> <operator>=</operator> <call><name>QualType</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>


<if_stmt><if>if <condition>(<expr><call><name><name>SS</name><operator>.</operator><name>getScopeRep</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>NNS</name><operator>.</operator><name>getNestedNameSpecifier</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NNS</name></expr>;</return></block_content></block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><call><name><name>SS</name><operator>.</operator><name>location_size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>NNS</name><operator>.</operator><name>getDataLength</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name>memcmp</name><argument_list>(<argument><expr><call><name><name>SS</name><operator>.</operator><name>location_data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>NNS</name><operator>.</operator><name>getOpaqueData</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>SS</name><operator>.</operator><name>location_size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>NestedNameSpecifierLoc</name><argument_list>(<argument><expr><call><name><name>SS</name><operator>.</operator><name>getScopeRep</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>NNS</name><operator>.</operator><name>getOpaqueData</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<return>return <expr><call><name><name>SS</name><operator>.</operator><name>getWithLocInContext</name></name><argument_list>(<argument><expr><name><name>SemaRef</name><operator>.</operator><name>Context</name></name></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>DeclarationNameInfo</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name>
<operator>::</operator><macro><name>TransformDeclarationNameInfo</name><argument_list>(<argument>const DeclarationNameInfo &amp;NameInfo</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationName</name> <name>Name</name> <operator>=</operator> <call><name><name>NameInfo</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Name</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>DeclarationNameInfo</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<switch>switch <condition>(<expr><call><name><name>Name</name><operator>.</operator><name>getNameKind</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DeclarationName</name><operator>::</operator><name>Identifier</name></expr>:</case>
<case>case <expr><name>DeclarationName</name><operator>::</operator><name>ObjCZeroArgSelector</name></expr>:</case>
<case>case <expr><name>DeclarationName</name><operator>::</operator><name>ObjCOneArgSelector</name></expr>:</case>
<case>case <expr><name>DeclarationName</name><operator>::</operator><name>ObjCMultiArgSelector</name></expr>:</case>
<case>case <expr><name>DeclarationName</name><operator>::</operator><name>CXXOperatorName</name></expr>:</case>
<case>case <expr><name>DeclarationName</name><operator>::</operator><name>CXXLiteralOperatorName</name></expr>:</case>
<case>case <expr><name>DeclarationName</name><operator>::</operator><name>CXXUsingDirective</name></expr>:</case>
<return>return <expr><name>NameInfo</name></expr>;</return>

<case>case <expr><name>DeclarationName</name><operator>::</operator><name>CXXDeductionGuideName</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>TemplateDecl</name> <modifier>*</modifier></type><name>OldTemplate</name> <init>= <expr><call><name><name>Name</name><operator>.</operator><name>getCXXDeductionGuideTemplate</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TemplateDecl</name> <modifier>*</modifier></type><name>NewTemplate</name> <init>= <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>TemplateDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDecl</name><argument_list>(<argument><expr><call><name><name>NameInfo</name><operator>.</operator><name>getLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>OldTemplate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>NewTemplate</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>DeclarationNameInfo</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<function_decl><type><name>DeclarationNameInfo</name></type> <name>NewNameInfo</name><parameter_list>(<parameter><decl><type><name>NameInfo</name></type></decl></parameter>)</parameter_list>;</function_decl>
<expr_stmt><expr><call><name><name>NewNameInfo</name><operator>.</operator><name>setName</name></name><argument_list>(
<argument><expr><call><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>DeclarationNames</name><operator>.</operator><name>getCXXDeductionGuideName</name></name><argument_list>(<argument><expr><name>NewTemplate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NewNameInfo</name></expr>;</return>
</block_content>}</block>

<case>case <expr><name>DeclarationName</name><operator>::</operator><name>CXXConstructorName</name></expr>:</case>
<case>case <expr><name>DeclarationName</name><operator>::</operator><name>CXXDestructorName</name></expr>:</case>
<case>case <expr><name>DeclarationName</name><operator>::</operator><name>CXXConversionFunctionName</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>NewTInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CanQualType</name></type> <name>NewCanTy</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>OldTInfo</name> <init>= <expr><call><name><name>NameInfo</name><operator>.</operator><name>getNamedTypeInfo</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<expr_stmt><expr><name>NewTInfo</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>OldTInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>NewTInfo</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>DeclarationNameInfo</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>NewCanTy</name> <operator>=</operator> <call><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>getCanonicalType</name></name><argument_list>(<argument><expr><call><name><name>NewTInfo</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>NewTInfo</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>TemporaryBase</name></type> <name>Rebase</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><call><name><name>NameInfo</name><operator>.</operator><name>getLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Name</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>QualType</name></type> <name>NewT</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><call><name><name>Name</name><operator>.</operator><name>getCXXNameType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>NewT</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>DeclarationNameInfo</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>NewCanTy</name> <operator>=</operator> <call><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>getCanonicalType</name></name><argument_list>(<argument><expr><name>NewT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<decl_stmt><decl><type><name>DeclarationName</name></type> <name>NewName</name>
<init>= <expr><call><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>DeclarationNames</name><operator>.</operator><name>getCXXSpecialName</name></name><argument_list>(<argument><expr><call><name><name>Name</name><operator>.</operator><name>getNameKind</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>NewCanTy</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<function_decl><type><name>DeclarationNameInfo</name></type> <name>NewNameInfo</name><parameter_list>(<parameter><decl><type><name>NameInfo</name></type></decl></parameter>)</parameter_list>;</function_decl>
<expr_stmt><expr><call><name><name>NewNameInfo</name><operator>.</operator><name>setName</name></name><argument_list>(<argument><expr><name>NewName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewNameInfo</name><operator>.</operator><name>setNamedTypeInfo</name></name><argument_list>(<argument><expr><name>NewTInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NewNameInfo</name></expr>;</return>
</block_content>}</block>
</block_content>}</block></switch>

<expr_stmt><expr><call><name>llvm_unreachable</name><argument_list>(<argument><expr><literal type="string">"Unknown name kind."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>TemplateName</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformTemplateName</name><argument_list>(<argument>CXXScopeSpec &amp;SS</argument>,
<argument>TemplateName Name</argument>,
<argument>SourceLocation NameLoc</argument>,
<argument>QualType ObjectType</argument>,
<argument>NamedDecl *FirstQualifierInScope</argument>,
<argument>bool AllowInjectedClassName</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<decl><type><name>QualifiedTemplateName</name> <modifier>*</modifier></type><name>QTN</name> <init>= <expr><call><name><name>Name</name><operator>.</operator><name>getAsQualifiedTemplateName</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>TemplateDecl</name> <modifier>*</modifier></type><name>Template</name> <init>= <expr><call><name><name>QTN</name><operator>-&gt;</operator><name>getTemplateDecl</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>Template</name> <operator>&amp;&amp;</operator> <literal type="string">"qualified template name must refer to a template"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>TemplateDecl</name> <modifier>*</modifier></type><name>TransTemplate</name>
<init>= <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>TemplateDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDecl</name><argument_list>(<argument><expr><name>NameLoc</name></expr></argument>,
<argument><expr><name>Template</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>TransTemplate</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>TemplateName</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>SS</name><operator>.</operator><name>getScopeRep</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>QTN</name><operator>-&gt;</operator><name>getQualifier</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<name>TransTemplate</name> <operator>==</operator> <name>Template</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>Name</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildTemplateName</name><argument_list>(<argument><expr><name>SS</name></expr></argument>, <argument><expr><call><name><name>QTN</name><operator>-&gt;</operator><name>hasTemplateKeyword</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>TransTemplate</name></expr></argument>)</argument_list></call></expr>;</return>
<expr_stmt/></block_content></block></if></if_stmt>}</block></expr></expr_stmt>

<if_stmt><if>if <condition>(<decl><type><name>DependentTemplateName</name> <modifier>*</modifier></type><name>DTN</name> <init>= <expr><call><name><name>Name</name><operator>.</operator><name>getAsDependentTemplateName</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>SS</name><operator>.</operator><name>getScopeRep</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ObjectType</name> <operator>=</operator> <call><name>QualType</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>FirstQualifierInScope</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>SS</name><operator>.</operator><name>getScopeRep</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>DTN</name><operator>-&gt;</operator><name>getQualifier</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>ObjectType</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>Name</name></expr>;</return></block_content></block></if></if_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>TemplateKWLoc</name> <init>= <expr><name>NameLoc</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>DTN</name><operator>-&gt;</operator><name>isIdentifier</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildTemplateName</name><argument_list>(<argument><expr><name>SS</name></expr></argument>,
<argument><expr><name>TemplateKWLoc</name></expr></argument>,
<argument><expr><operator>*</operator><call><name><name>DTN</name><operator>-&gt;</operator><name>getIdentifier</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>NameLoc</name></expr></argument>,
<argument><expr><name>ObjectType</name></expr></argument>,
<argument><expr><name>FirstQualifierInScope</name></expr></argument>,
<argument><expr><name>AllowInjectedClassName</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildTemplateName</name><argument_list>(<argument><expr><name>SS</name></expr></argument>, <argument><expr><name>TemplateKWLoc</name></expr></argument>,
<argument><expr><call><name><name>DTN</name><operator>-&gt;</operator><name>getOperator</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NameLoc</name></expr></argument>,
<argument><expr><name>ObjectType</name></expr></argument>, <argument><expr><name>AllowInjectedClassName</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<decl><type><name>TemplateDecl</name> <modifier>*</modifier></type><name>Template</name> <init>= <expr><call><name><name>Name</name><operator>.</operator><name>getAsTemplateDecl</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>TemplateDecl</name> <modifier>*</modifier></type><name>TransTemplate</name>
<init>= <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>TemplateDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDecl</name><argument_list>(<argument><expr><name>NameLoc</name></expr></argument>,
<argument><expr><name>Template</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>TransTemplate</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>TemplateName</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<name>TransTemplate</name> <operator>==</operator> <name>Template</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>Name</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>TemplateName</name><argument_list>(<argument><expr><name>TransTemplate</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<decl><type><name>SubstTemplateTemplateParmPackStorage</name> <modifier>*</modifier></type><name>SubstPack</name>
<init>= <expr><call><name><name>Name</name><operator>.</operator><name>getAsSubstTemplateTemplateParmPack</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>TemplateTemplateParmDecl</name> <modifier>*</modifier></type><name>TransParam</name>
<init>= <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>TemplateTemplateParmDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDecl</name><argument_list>(<argument><expr><name>NameLoc</name></expr></argument>, <argument><expr><call><name><name>SubstPack</name><operator>-&gt;</operator><name>getParameterPack</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>TransParam</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>TemplateName</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<name>TransParam</name> <operator>==</operator> <call><name><name>SubstPack</name><operator>-&gt;</operator><name>getParameterPack</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>Name</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildTemplateName</name><argument_list>(<argument><expr><name>TransParam</name></expr></argument>,
<argument><expr><call><name><name>SubstPack</name><operator>-&gt;</operator><name>getArgumentPack</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>llvm_unreachable</name><argument_list>(<argument><expr><literal type="string">"overloaded function decl survived to here"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>void</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>InventTemplateArgumentLoc</name><argument_list>(
<argument>const TemplateArgument &amp;Arg</argument>,
<argument>TemplateArgumentLoc &amp;Output</argument>)</argument_list></macro> <block>{
<expr><name>Output</name> <operator>=</operator> <call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getTrivialTemplateArgumentLoc</name><argument_list>(
<argument><expr><name>Arg</name></expr></argument>, <argument><expr><call><name>QualType</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getBaseLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformTemplateArgument</name><argument_list>(
<argument>const TemplateArgumentLoc &amp;Input</argument>, <argument>TemplateArgumentLoc &amp;Output</argument>,
<argument>bool Uneval</argument>)</argument_list></macro> <block>{
<expr><specifier>const</specifier> <name>TemplateArgument</name> <operator>&amp;</operator><name>Arg</name> <operator>=</operator> <call><name><name>Input</name><operator>.</operator><name>getArgument</name></name><argument_list>()</argument_list></call></expr>;
<switch>switch <condition>(<expr><call><name><name>Arg</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>TemplateArgument</name><operator>::</operator><name>Null</name></expr>:</case>
<case>case <expr><name>TemplateArgument</name><operator>::</operator><name>Pack</name></expr>:</case>
<expr_stmt><expr><call><name>llvm_unreachable</name><argument_list>(<argument><expr><literal type="string">"Unexpected TemplateArgument"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>TemplateArgument</name><operator>::</operator><name>Integral</name></expr>:</case>
<case>case <expr><name>TemplateArgument</name><operator>::</operator><name>NullPtr</name></expr>:</case>
<case>case <expr><name>TemplateArgument</name><operator>::</operator><name>Declaration</name></expr>:</case> <block>{<block_content>



<decl_stmt><decl><type><name>QualType</name></type> <name>T</name> <init>= <expr><call><name><name>Arg</name><operator>.</operator><name>getNonTypeTemplateArgumentType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>QualType</name></type> <name>NewT</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>NewT</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>ValueDecl</name> <modifier>*</modifier></type><name>D</name> <init>= <expr><ternary><condition><expr><call><name><name>Arg</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>TemplateArgument</name><operator>::</operator><name>Declaration</name></expr>
?</condition><then> <expr><call><name><name>Arg</name><operator>.</operator><name>getAsDecl</name></name><argument_list>()</argument_list></call></expr>
</then><else>: <expr><name>nullptr</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ValueDecl</name> <modifier>*</modifier></type><name>NewD</name> <init>= <expr><ternary><condition><expr><name>D</name></expr> ?</condition><then> <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>ValueDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDecl</name><argument_list>(
<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getBaseLocation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>
</then><else>: <expr><name>nullptr</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>D</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>NewD</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>NewT</name> <operator>==</operator> <name>T</name> <operator>&amp;&amp;</operator> <name>D</name> <operator>==</operator> <name>NewD</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>Output</name> <operator>=</operator> <name>Input</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name><name>Arg</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>TemplateArgument</name><operator>::</operator><name>Integral</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>Output</name> <operator>=</operator> <call><name>TemplateArgumentLoc</name><argument_list>(
<argument><expr><call><name>TemplateArgument</name><argument_list>(<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><name>Context</name></expr></argument>, <argument><expr><call><name><name>Arg</name><operator>.</operator><name>getAsIntegral</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NewT</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>TemplateArgumentLocInfo</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name><name>Arg</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>TemplateArgument</name><operator>::</operator><name>NullPtr</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>Output</name> <operator>=</operator> <call><name>TemplateArgumentLoc</name><argument_list>(<argument><expr><call><name>TemplateArgument</name><argument_list>(<argument><expr><name>NewT</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>TemplateArgumentLocInfo</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>Output</name> <operator>=</operator> <call><name>TemplateArgumentLoc</name><argument_list>(<argument><expr><call><name>TemplateArgument</name><argument_list>(<argument><expr><name>NewD</name></expr></argument>, <argument><expr><name>NewT</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>TemplateArgumentLocInfo</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return <expr><name>false</name></expr>;</return>
<expr_stmt/></block_content></block></block_content></block></switch>}</block></expr></expr_stmt>

<case>case <expr><name>TemplateArgument</name><operator>::</operator><name>Type</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>DI</name> <init>= <expr><call><name><name>Input</name><operator>.</operator><name>getTypeSourceInfo</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>DI</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>DI</name> <operator>=</operator> <call><name>InventTypeSourceInfo</name><argument_list>(<argument><expr><call><name><name>Input</name><operator>.</operator><name>getArgument</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getAsType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>DI</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>DI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>DI</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>Output</name> <operator>=</operator> <call><name>TemplateArgumentLoc</name><argument_list>(<argument><expr><call><name>TemplateArgument</name><argument_list>(<argument><expr><call><name><name>DI</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>DI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block>

<case>case <expr><name>TemplateArgument</name><operator>::</operator><name>Template</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>NestedNameSpecifierLoc</name></type> <name>QualifierLoc</name> <init>= <expr><call><name><name>Input</name><operator>.</operator><name>getTemplateQualifierLoc</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>QualifierLoc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>QualifierLoc</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformNestedNameSpecifierLoc</name><argument_list>(<argument><expr><name>QualifierLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>QualifierLoc</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>CXXScopeSpec</name></type> <name>SS</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>SS</name><operator>.</operator><name>Adopt</name></name><argument_list>(<argument><expr><name>QualifierLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>TemplateName</name></type> <name>Template</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformTemplateName</name><argument_list>(
<argument><expr><name>SS</name></expr></argument>, <argument><expr><call><name><name>Arg</name><operator>.</operator><name>getAsTemplate</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Input</name><operator>.</operator><name>getTemplateNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Template</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>Output</name> <operator>=</operator> <call><name>TemplateArgumentLoc</name><argument_list>(<argument><expr><name><name>SemaRef</name><operator>.</operator><name>Context</name></name></expr></argument>, <argument><expr><call><name>TemplateArgument</name><argument_list>(<argument><expr><name>Template</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>QualifierLoc</name></expr></argument>, <argument><expr><call><name><name>Input</name><operator>.</operator><name>getTemplateNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block>

<case>case <expr><name>TemplateArgument</name><operator>::</operator><name>TemplateExpansion</name></expr>:</case>
<expr_stmt><expr><call><name>llvm_unreachable</name><argument_list>(<argument><expr><literal type="string">"Caller should expand pack expansions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>TemplateArgument</name><operator>::</operator><name>Expression</name></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><name>EnterExpressionEvaluationContext</name></type> <name>Unevaluated</name><argument_list>(
<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><ternary><condition><expr><name>Uneval</name></expr> ?</condition><then> <expr><name>Sema</name><operator>::</operator><name>ExpressionEvaluationContext</name><operator>::</operator><name>Unevaluated</name></expr>
</then><else>: <expr><name>Sema</name><operator>::</operator><name>ExpressionEvaluationContext</name><operator>::</operator><name>ConstantEvaluated</name></expr></else></ternary></expr></argument>,
<argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><name>Sema</name><operator>::</operator><name>ExpressionEvaluationContextRecord</name><operator>::</operator><name>EK_TemplateArgument</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>InputExpr</name> <init>= <expr><call><name><name>Input</name><operator>.</operator><name>getSourceExpression</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>InputExpr</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>InputExpr</name> <operator>=</operator> <call><name><name>Input</name><operator>.</operator><name>getArgument</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getAsExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>ExprResult</name></type> <name>E</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><name>InputExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>E</name> <operator>=</operator> <call><name><name>SemaRef</name><operator>.</operator><name>ActOnConstantExpression</name></name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>Output</name> <operator>=</operator> <call><name>TemplateArgumentLoc</name><argument_list>(<argument><expr><call><name>TemplateArgument</name><argument_list>(<argument><expr><call><name><name>E</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block>
}


return <expr_stmt><expr><name>true</name></expr>;</expr_stmt>
}



template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name></expr><operator>,</operator> <expr><name>typename</name> <name>InputIterator</name><operator>&gt;</operator>
<name>class</name> <name>TemplateArgumentLocInventIterator</name> <block>{
<expr><name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Self</name></expr>;
<expr><name>InputIterator</name> <name>Iter</name></expr>;

<expr><name>public</name><operator>:</operator></expr>
<typedef>typedef <type><name>TemplateArgumentLoc</name></type> <name>value_type</name>;</typedef></block></expr></expr_stmt>
<typedef>typedef <type><name>TemplateArgumentLoc</name></type> <name>reference</name>;</typedef>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name>std</name><operator>::</operator><name><name>iterator_traits</name><argument_list type="generic">&lt;<argument><expr><name>InputIterator</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>difference_type</name>
<name>difference_type</name></expr>;</expr_stmt></typedef>
<typedef>typedef <expr_stmt><expr><name>std</name><operator>::</operator><name>input_iterator_tag</name> <name>iterator_category</name></expr>;</expr_stmt></typedef>

<decl_stmt><decl><type><name>class</name></type> <name>pointer</name> <block>{<block_content>
<decl_stmt><decl><type><name>TemplateArgumentLoc</name></type> <name>Arg</name></decl>;</decl_stmt>

<label><name>public</name>:</label>
<macro><name>explicit</name></macro> <macro><name>pointer</name><argument_list>(<argument>TemplateArgumentLoc Arg</argument>)</argument_list></macro> : <macro><name>Arg</name><argument_list>(<argument>Arg</argument>)</argument_list></macro> <block>{<block_content> </block_content>}</block>

<expr_stmt><expr><specifier>const</specifier> <name>TemplateArgumentLoc</name> <operator>*</operator><name><name>operator</name><operator>-&gt;</operator><name/></name>(</expr></expr_stmt>)</block_content> const <block>{<block_content> <return>return <expr><operator>&amp;</operator><name>Arg</name></expr>;</return> </block_content>}</block></block></decl></decl_stmt>
};

<macro><name>TemplateArgumentLocInventIterator</name><argument_list>()</argument_list></macro> <block>{<block_content> </block_content>}</block>

<macro><name>explicit</name></macro> <macro><name>TemplateArgumentLocInventIterator</name><argument_list>(<argument>TreeTransform&lt;Derived&gt; &amp;Self</argument>,
<argument>InputIterator Iter</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>Self</name><argument_list>(<argument><expr><name>Self</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Iter</name><argument_list>(<argument>Iter</argument>)</argument_list></macro> <expr><block>{ }</block>

<name>TemplateArgumentLocInventIterator</name> <operator>&amp;</operator><name>operator</name><operator>++</operator><operator>(</operator><operator>)</operator> <block>{
<expr><operator>++</operator><name>Iter</name></expr>;
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>TemplateArgumentLocInventIterator</name> <name>operator</name><operator>++</operator><operator>(</operator><name>int</name><operator>)</operator> <block>{
<expr><name>TemplateArgumentLocInventIterator</name> <call><name>Old</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>;
<expr><operator>++</operator><operator>(</operator><operator>*</operator><name>this</name><operator>)</operator></expr>;
<return>return <expr><name>Old</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>reference</name> <name>operator</name><operator>*</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{
<expr><name>TemplateArgumentLoc</name> <name>Result</name></expr>;
<expr><call><name><name>Self</name><operator>.</operator><name>InventTemplateArgumentLoc</name></name><argument_list>(<argument><expr><operator>*</operator><name>Iter</name></expr></argument>, <argument><expr><name>Result</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Result</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>pointer</name> <name><name>operator</name><operator>-&gt;</operator><name/></name>(</expr></expr_stmt>) <expr_stmt><expr><specifier>const</specifier> <block>{ <return>return <expr><call><name>pointer</name><argument_list>(<argument><expr><operator>*</operator><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>friend</name> <name>bool</name> <name>operator</name><operator>==</operator><operator>(</operator><specifier>const</specifier> <name>TemplateArgumentLocInventIterator</name> <operator>&amp;</operator><name>X</name><operator>,</operator>
<specifier>const</specifier> <name>TemplateArgumentLocInventIterator</name> <operator>&amp;</operator><name>Y</name><operator>)</operator> <block>{
<return>return <expr><name><name>X</name><operator>.</operator><name>Iter</name></name> <operator>==</operator> <name><name>Y</name><operator>.</operator><name>Iter</name></name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>friend</name> <name>bool</name> <name>operator</name><operator>!=</operator><operator>(</operator><specifier>const</specifier> <name>TemplateArgumentLocInventIterator</name> <operator>&amp;</operator><name>X</name><operator>,</operator>
<specifier>const</specifier> <name>TemplateArgumentLocInventIterator</name> <operator>&amp;</operator><name>Y</name><operator>)</operator> <block>{
<return>return <expr><name><name>X</name><operator>.</operator><name>Iter</name></name> <operator>!=</operator> <name><name>Y</name><operator>.</operator><name>Iter</name></name></expr>;</return>
}</block></expr></expr_stmt>
};

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>InputIterator</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformTemplateArguments</name><argument_list>(
<argument>InputIterator First</argument>, <argument>InputIterator Last</argument>, <argument>TemplateArgumentListInfo &amp;Outputs</argument>,
<argument>bool Uneval</argument>)</argument_list></macro> <block>{
<for>for <control>(<init>;</init> <condition><expr><name>First</name> <operator>!=</operator> <name>Last</name></expr>;</condition> <incr><expr><operator>++</operator><name>First</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>TemplateArgumentLoc</name></type> <name>Out</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TemplateArgumentLoc</name></type> <name>In</name> <init>= <expr><operator>*</operator><name>First</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>In</name><operator>.</operator><name>getArgument</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>TemplateArgument</name><operator>::</operator><name>Pack</name></expr>)</condition> <block>{<block_content>





<typedef>typedef <type><name><name>TemplateArgumentLocInventIterator</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>,
<argument><expr><name>TemplateArgument</name><operator>::</operator><name>pack_iterator</name></expr></argument>&gt;</argument_list></name></type>
<name>PackLocIterator</name>;</typedef>
<if_stmt><if>if <condition>(<expr><call><name>TransformTemplateArguments</name><argument_list>(<argument><expr><call><name>PackLocIterator</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>,
<argument><expr><call><name><name>In</name><operator>.</operator><name>getArgument</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>pack_begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>PackLocIterator</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>,
<argument><expr><call><name><name>In</name><operator>.</operator><name>getArgument</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>pack_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>Outputs</name></expr></argument>, <argument><expr><name>Uneval</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

<continue>continue;</continue>
<expr_stmt/></block_content></block></if></if_stmt></block_content></block></for>}</block></expr></expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>In</name><operator>.</operator><name>getArgument</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isPackExpansion</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>Ellipsis</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></type> <name>OrigNumExpansions</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TemplateArgumentLoc</name></type> <name>Pattern</name>
<init>= <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getTemplateArgumentPackExpansionPattern</name><argument_list>(
<argument><expr><name>In</name></expr></argument>, <argument><expr><name>Ellipsis</name></expr></argument>, <argument><expr><name>OrigNumExpansions</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>UnexpandedParameterPack</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name></type> <name>Unexpanded</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>collectUnexpandedParameterPacks</name><argument_list>(<argument><expr><name>Pattern</name></expr></argument>, <argument><expr><name>Unexpanded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>Unexpanded</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Pack expansion without parameter packs?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>Expand</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>RetainExpansion</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></type> <name>NumExpansions</name> <init>= <expr><name>OrigNumExpansions</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TryExpandParameterPacks</name><argument_list>(<argument><expr><name>Ellipsis</name></expr></argument>,
<argument><expr><call><name><name>Pattern</name><operator>.</operator><name>getSourceRange</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>Unexpanded</name></expr></argument>,
<argument><expr><name>Expand</name></expr></argument>,
<argument><expr><name>RetainExpansion</name></expr></argument>,
<argument><expr><name>NumExpansions</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Expand</name></expr>)</condition> <block>{<block_content>



<decl_stmt><decl><type><name>TemplateArgumentLoc</name></type> <name>OutPattern</name></decl>;</decl_stmt>
<expr_stmt><expr><name>Sema</name><operator>::</operator><name>ArgumentPackSubstitutionIndexRAII</name> <call><name>SubstIndex</name><argument_list>(<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformTemplateArgument</name><argument_list>(<argument><expr><name>Pattern</name></expr></argument>, <argument><expr><name>OutPattern</name></expr></argument>, <argument><expr><name>Uneval</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>Out</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildPackExpansion</name><argument_list>(<argument><expr><name>OutPattern</name></expr></argument>, <argument><expr><name>Ellipsis</name></expr></argument>,
<argument><expr><name>NumExpansions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Out</name><operator>.</operator><name>getArgument</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isNull</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name><name>Outputs</name><operator>.</operator><name>addArgument</name></name><argument_list>(<argument><expr><name>Out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>



<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>I</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>I</name> <operator>!=</operator> <operator>*</operator><name>NumExpansions</name></expr>;</condition> <incr><expr><operator>++</operator><name>I</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>Sema</name><operator>::</operator><name>ArgumentPackSubstitutionIndexRAII</name> <call><name>SubstIndex</name><argument_list>(<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>I</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformTemplateArgument</name><argument_list>(<argument><expr><name>Pattern</name></expr></argument>, <argument><expr><name>Out</name></expr></argument>, <argument><expr><name>Uneval</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>Out</name><operator>.</operator><name>getArgument</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>containsUnexpandedParameterPack</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Out</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildPackExpansion</name><argument_list>(<argument><expr><name>Out</name></expr></argument>, <argument><expr><name>Ellipsis</name></expr></argument>,
<argument><expr><name>OrigNumExpansions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Out</name><operator>.</operator><name>getArgument</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isNull</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name><name>Outputs</name><operator>.</operator><name>addArgument</name></name><argument_list>(<argument><expr><name>Out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>



<if_stmt><if>if <condition>(<expr><name>RetainExpansion</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ForgetPartiallySubstitutedPackRAII</name></type> <name>Forget</name><argument_list>(<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformTemplateArgument</name><argument_list>(<argument><expr><name>Pattern</name></expr></argument>, <argument><expr><name>Out</name></expr></argument>, <argument><expr><name>Uneval</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>Out</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildPackExpansion</name><argument_list>(<argument><expr><name>Out</name></expr></argument>, <argument><expr><name>Ellipsis</name></expr></argument>,
<argument><expr><name>OrigNumExpansions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Out</name><operator>.</operator><name>getArgument</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isNull</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name><name>Outputs</name><operator>.</operator><name>addArgument</name></name><argument_list>(<argument><expr><name>Out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<continue>continue;</continue>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformTemplateArgument</name><argument_list>(<argument><expr><name>In</name></expr></argument>, <argument><expr><name>Out</name></expr></argument>, <argument><expr><name>Uneval</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name><name>Outputs</name><operator>.</operator><name>addArgument</name></name><argument_list>(<argument><expr><name>Out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}

return <expr_stmt><expr><name>false</name></expr>;</expr_stmt>

}





template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformType</name><argument_list>(<argument>QualType T</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlreadyTransformed</name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>T</name></expr>;</return></block_content></block></if></if_stmt>



<name>TypeSourceInfo</name> <operator>*</operator><name>DI</name> <operator>=</operator> <call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>Context</name><operator>.</operator><name>getTrivialTypeSourceInfo</name></name><argument_list>(<argument><expr><name>T</name></expr></argument>,
<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getBaseLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>

<decl_stmt><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>NewDI</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>DI</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>NewDI</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name><name>NewDI</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>TypeSourceInfo</name> <operator>*</operator><name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformType</name><argument_list>(<argument>TypeSourceInfo *DI</argument>)</argument_list></macro> <block>{

<expr><name>TemporaryBase</name> <call><name>Rebase</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><call><name><name>DI</name><operator>-&gt;</operator><name>getTypeLoc</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getBeginLoc</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getBaseEntity</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlreadyTransformed</name><argument_list>(<argument><expr><call><name><name>DI</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>DI</name></expr>;</return></block_content></block></if></if_stmt>

<name>TypeLocBuilder</name> <name>TLB</name></block></expr>;</expr_stmt>

<decl_stmt><decl><type><name>TypeLoc</name></type> <name>TL</name> <init>= <expr><call><name><name>DI</name><operator>-&gt;</operator><name>getTypeLoc</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>TLB</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getFullDataSize</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>Result</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>TLB</name></expr></argument>, <argument><expr><name>TL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name><name>TLB</name><operator>.</operator><name>getTypeSourceInfo</name></name><argument_list>(<argument><expr><name><name>SemaRef</name><operator>.</operator><name>Context</name></name></expr></argument>, <argument><expr><name>Result</name></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformType</name><argument_list>(<argument>TypeLocBuilder &amp;TLB</argument>, <argument>TypeLoc T</argument>)</argument_list></macro> <block>{
<switch>switch <condition>(<expr><call><name><name>T</name><operator>.</operator><name>getTypeLocClass</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ABSTRACT_TYPELOC</name><parameter_list>(<parameter><type><name>CLASS</name></type></parameter>, <parameter><type><name>PARENT</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPELOC</name><parameter_list>(<parameter><type><name>CLASS</name></type></parameter>, <parameter><type><name>PARENT</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case TypeLoc::CLASS: return getDerived().Transform##CLASS##Type(TLB, T.castAs&lt;CLASS##TypeLoc&gt;());</cpp:value></cpp:define>



<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/TypeLocNodes.def"</cpp:file></cpp:include>
<expr_stmt/></block_content></block></switch>}</block>

<call><name>llvm_unreachable</name><argument_list>(<argument><expr><literal type="string">"unhandled type loc!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformTypeWithDeducedTST</name><argument_list>(<argument>QualType T</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>DependentNameType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>TransformType</name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlreadyTransformed</name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>T</name></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>DI</name> <init>= <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>Context</name><operator>.</operator><name>getTrivialTypeSourceInfo</name></name><argument_list>(<argument><expr><name>T</name></expr></argument>,
<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getBaseLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>NewDI</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformTypeWithDeducedTST</name><argument_list>(<argument><expr><name>DI</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><ternary><condition><expr><name>NewDI</name></expr> ?</condition><then> <expr><call><name><name>NewDI</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr> </then><else>: <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>TypeSourceInfo</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformTypeWithDeducedTST</name><argument_list>(<argument>TypeSourceInfo *DI</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>DependentNameType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>DI</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>TransformType</name><argument_list>(<argument><expr><name>DI</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<name>TemporaryBase</name> <call><name>Rebase</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><call><name><name>DI</name><operator>-&gt;</operator><name>getTypeLoc</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getBeginLoc</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getBaseEntity</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlreadyTransformed</name><argument_list>(<argument><expr><call><name><name>DI</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>DI</name></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>TypeLocBuilder</name></type> <name>TLB</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>TypeLoc</name></type> <name>TL</name> <init>= <expr><call><name><name>DI</name><operator>-&gt;</operator><name>getTypeLoc</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>TLB</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getFullDataSize</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>auto</name></type> <name>QTL</name> <init>= <expr><name><name>TL</name><operator>.</operator><name>getAs</name></name><operator>&lt;</operator><name>QualifiedTypeLoc</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>QTL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>TL</name> <operator>=</operator> <call><name><name>QTL</name><operator>.</operator><name>getUnqualifiedLoc</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>auto</name></type> <name>DNTL</name> <init>= <expr><name><name>TL</name><operator>.</operator><name>castAs</name></name><operator>&lt;</operator><name>DependentNameTypeLoc</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>Result</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDependentNameType</name><argument_list>(
<argument><expr><name>TLB</name></expr></argument>, <argument><expr><name>DNTL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>QTL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Result</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildQualifiedType</name><argument_list>(<argument><expr><name>Result</name></expr></argument>, <argument><expr><name>QTL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>TLB</name><operator>.</operator><name>TypeWasModifiedSafely</name></name><argument_list>(<argument><expr><name>Result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><call><name><name>TLB</name><operator>.</operator><name>getTypeSourceInfo</name></name><argument_list>(<argument><expr><name><name>SemaRef</name><operator>.</operator><name>Context</name></name></expr></argument>, <argument><expr><name>Result</name></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformQualifiedType</name><argument_list>(<argument>TypeLocBuilder &amp;TLB</argument>,
<argument>QualifiedTypeLoc T</argument>)</argument_list></macro> <block>{
<expr><name>QualType</name> <name>Result</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>TLB</name></expr></argument>, <argument><expr><call><name><name>T</name><operator>.</operator><name>getUnqualifiedLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>Result</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildQualifiedType</name><argument_list>(<argument><expr><name>Result</name></expr></argument>, <argument><expr><name>T</name></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>




<expr_stmt><expr><call><name><name>TLB</name><operator>.</operator><name>TypeWasModifiedSafely</name></name><argument_list>(<argument><expr><name>Result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Result</name></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>RebuildQualifiedType</name><argument_list>(<argument>QualType T</argument>,
<argument>QualifiedTypeLoc TL</argument>)</argument_list></macro> <block>{

<expr><name>SourceLocation</name> <name>Loc</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr>;
<expr><name>Qualifiers</name> <name>Quals</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getLocalQualifiers</name><argument_list>()</argument_list></call></expr>;

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><call><name><name>T</name><operator>.</operator><name>getAddressSpace</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>LangAS</name><operator>::</operator><name>Default</name> <operator>&amp;&amp;</operator>
<call><name><name>Quals</name><operator>.</operator><name>getAddressSpace</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>LangAS</name><operator>::</operator><name>Default</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
<call><name><name>T</name><operator>.</operator><name>getAddressSpace</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <call><name><name>Quals</name><operator>.</operator><name>getAddressSpace</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>SemaRef</name><operator>.</operator><name>Diag</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>diag</name><operator>::</operator><name>err_address_space_mismatch_templ_inst</name></expr></argument>)</argument_list></call>
<operator>&lt;&lt;</operator> <call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call> <operator>&lt;&lt;</operator> <name>T</name></expr>;</expr_stmt>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return>
<expr_stmt/></block_content></block></if></if_stmt>}</block></expr></expr_stmt>




<if_stmt><if>if <condition>(<expr><call><name><name>T</name><operator>-&gt;</operator><name>isFunctionType</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>T</name> <operator>=</operator> <call><name><name>SemaRef</name><operator>.</operator><name>getASTContext</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getAddrSpaceQualType</name><argument_list>(<argument><expr><name>T</name></expr></argument>,
<argument><expr><call><name><name>Quals</name><operator>.</operator><name>getAddressSpace</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>T</name></expr>;</return>
</block_content>}</block></if></if_stmt>






<if_stmt><if>if <condition>(<expr><call><name><name>T</name><operator>-&gt;</operator><name>isReferenceType</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>Quals</name><operator>.</operator><name>hasRestrict</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>T</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>Quals</name> <operator>=</operator> <name>Qualifiers</name><operator>::</operator><call><name>fromCVRMask</name><argument_list>(<argument><expr><name>Qualifiers</name><operator>::</operator><name>Restrict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><call><name><name>Quals</name><operator>.</operator><name>hasObjCLifetime</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>T</name><operator>-&gt;</operator><name>isObjCLifetimeType</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>T</name><operator>-&gt;</operator><name>isDependentType</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>Quals</name><operator>.</operator><name>removeObjCLifetime</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name><name>T</name><operator>.</operator><name>getObjCLifetime</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>



<decl_stmt><decl><type><specifier>const</specifier> <name>AutoType</name> <modifier>*</modifier></type><name>AutoTy</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <name>SubstTemplateTypeParmType</name> <modifier>*</modifier></type><name>SubstTypeParam</name>
<init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>SubstTemplateTypeParmType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>QualType</name></type> <name>Replacement</name> <init>= <expr><call><name><name>SubstTypeParam</name><operator>-&gt;</operator><name>getReplacementType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Qualifiers</name></type> <name>Qs</name> <init>= <expr><call><name><name>Replacement</name><operator>.</operator><name>getQualifiers</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>Qs</name><operator>.</operator><name>removeObjCLifetime</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Replacement</name> <operator>=</operator> <call><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>getQualifiedType</name></name><argument_list>(
<argument><expr><call><name><name>Replacement</name><operator>.</operator><name>getUnqualifiedType</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Qs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>T</name> <operator>=</operator> <call><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>getSubstTemplateTypeParmType</name></name><argument_list>(
<argument><expr><call><name><name>SubstTypeParam</name><operator>-&gt;</operator><name>getReplacedParameter</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Replacement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>AutoTy</name> <operator>=</operator> <call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>AutoType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <call><name><name>AutoTy</name><operator>-&gt;</operator><name>isDeduced</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>QualType</name></type> <name>Deduced</name> <init>= <expr><call><name><name>AutoTy</name><operator>-&gt;</operator><name>getDeducedType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Qualifiers</name></type> <name>Qs</name> <init>= <expr><call><name><name>Deduced</name><operator>.</operator><name>getQualifiers</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>Qs</name><operator>.</operator><name>removeObjCLifetime</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Deduced</name> <operator>=</operator>
<call><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>getQualifiedType</name></name><argument_list>(<argument><expr><call><name><name>Deduced</name><operator>.</operator><name>getUnqualifiedType</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Qs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>T</name> <operator>=</operator> <call><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>getAutoType</name></name><argument_list>(<argument><expr><name>Deduced</name></expr></argument>, <argument><expr><call><name><name>AutoTy</name><operator>-&gt;</operator><name>getKeyword</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>AutoTy</name><operator>-&gt;</operator><name>isDependentType</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>false</name></expr></argument>,
<argument><expr><call><name><name>AutoTy</name><operator>-&gt;</operator><name>getTypeConstraintConcept</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>AutoTy</name><operator>-&gt;</operator><name>getTypeConstraintArguments</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>



<expr_stmt><expr><call><name><name>SemaRef</name><operator>.</operator><name>Diag</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>diag</name><operator>::</operator><name>err_attr_objc_ownership_redundant</name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <name>T</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Quals</name><operator>.</operator><name>removeObjCLifetime</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>BuildQualifiedType</name></name><argument_list>(<argument><expr><name>T</name></expr></argument>, <argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>Quals</name></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>TypeLoc</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformTypeInObjectScope</name><argument_list>(<argument>TypeLoc TL</argument>,
<argument>QualType ObjectType</argument>,
<argument>NamedDecl *UnqualLookup</argument>,
<argument>CXXScopeSpec &amp;SS</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlreadyTransformed</name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>TL</name></expr>;</return></block_content></block></if></if_stmt>

<name>TypeSourceInfo</name> <operator>*</operator><name>TSI</name> <operator>=</operator>
<call><name>TransformTSIInObjectScope</name><argument_list>(<argument><expr><name>TL</name></expr></argument>, <argument><expr><name>ObjectType</name></expr></argument>, <argument><expr><name>UnqualLookup</name></expr></argument>, <argument><expr><name>SS</name></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>TSI</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>TSI</name><operator>-&gt;</operator><name>getTypeLoc</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>TypeLoc</name><argument_list>()</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>TypeSourceInfo</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformTypeInObjectScope</name><argument_list>(<argument>TypeSourceInfo *TSInfo</argument>,
<argument>QualType ObjectType</argument>,
<argument>NamedDecl *UnqualLookup</argument>,
<argument>CXXScopeSpec &amp;SS</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlreadyTransformed</name><argument_list>(<argument><expr><call><name><name>TSInfo</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>TSInfo</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<return>return <expr><call><name>TransformTSIInObjectScope</name><argument_list>(<argument><expr><call><name><name>TSInfo</name><operator>-&gt;</operator><name>getTypeLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ObjectType</name></expr></argument>,
<argument><expr><name>UnqualLookup</name></expr></argument>, <argument><expr><name>SS</name></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>TypeSourceInfo</name> <operator>*</operator><name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformTSIInObjectScope</name><argument_list>(
<argument>TypeLoc TL</argument>, <argument>QualType ObjectType</argument>, <argument>NamedDecl *UnqualLookup</argument>,
<argument>CXXScopeSpec &amp;SS</argument>)</argument_list></macro> <block>{
<expr><name>QualType</name> <name>T</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlreadyTransformed</name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;

<expr><name>TypeLocBuilder</name> <name>TLB</name></expr>;
<expr><name>QualType</name> <name>Result</name></expr>;

<if_stmt><if>if <condition>(<expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>TemplateSpecializationType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>TemplateSpecializationTypeLoc</name></type> <name>SpecTL</name> <init>=
<expr><name><name>TL</name><operator>.</operator><name>castAs</name></name><operator>&lt;</operator><name>TemplateSpecializationTypeLoc</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>TemplateName</name></type> <name>Template</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformTemplateName</name><argument_list>(
<argument><expr><name>SS</name></expr></argument>, <argument><expr><call><name><name>SpecTL</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getTemplateName</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>SpecTL</name><operator>.</operator><name>getTemplateNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>ObjectType</name></expr></argument>, <argument><expr><name>UnqualLookup</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Template</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>Result</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformTemplateSpecializationType</name><argument_list>(<argument><expr><name>TLB</name></expr></argument>, <argument><expr><name>SpecTL</name></expr></argument>,
<argument><expr><name>Template</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></if></if_stmt>}</block></expr></expr_stmt> <if_stmt><if type="elseif">else if <condition>(<expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>DependentTemplateSpecializationType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>DependentTemplateSpecializationTypeLoc</name></type> <name>SpecTL</name> <init>=
<expr><name><name>TL</name><operator>.</operator><name>castAs</name></name><operator>&lt;</operator><name>DependentTemplateSpecializationTypeLoc</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>TemplateName</name></type> <name>Template</name>
<init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildTemplateName</name><argument_list>(<argument><expr><name>SS</name></expr></argument>,
<argument><expr><call><name><name>SpecTL</name><operator>.</operator><name>getTemplateKeywordLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><operator>*</operator><call><name><name>SpecTL</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getIdentifier</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>SpecTL</name><operator>.</operator><name>getTemplateNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>ObjectType</name></expr></argument>, <argument><expr><name>UnqualLookup</name></expr></argument>,
<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Template</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>Result</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDependentTemplateSpecializationType</name><argument_list>(<argument><expr><name>TLB</name></expr></argument>,
<argument><expr><name>SpecTL</name></expr></argument>,
<argument><expr><name>Template</name></expr></argument>,
<argument><expr><name>SS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>Result</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>TLB</name></expr></argument>, <argument><expr><name>TL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name><name>TLB</name><operator>.</operator><name>getTypeSourceInfo</name></name><argument_list>(<argument><expr><name><name>SemaRef</name><operator>.</operator><name>Context</name></name></expr></argument>, <argument><expr><name>Result</name></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>class</name> <name>TyLoc</name><operator>&gt;</operator> <specifier>static</specifier> <specifier>inline</specifier>
<name>QualType</name> <macro><name>TransformTypeSpecType</name><argument_list>(<argument>TypeLocBuilder &amp;TLB</argument>, <argument>TyLoc T</argument>)</argument_list></macro> <block>{
<expr><name>TyLoc</name> <name>NewT</name> <operator>=</operator> <name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>TyLoc</name><operator>&gt;</operator><operator>(</operator><call><name><name>T</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>)</operator></expr>;
<expr><call><name><name>NewT</name><operator>.</operator><name>setNameLoc</name></name><argument_list>(<argument><expr><call><name><name>T</name><operator>.</operator><name>getNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>T</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformBuiltinType</name><argument_list>(<argument>TypeLocBuilder &amp;TLB</argument>,
<argument>BuiltinTypeLoc T</argument>)</argument_list></macro> <block>{
<expr><name>BuiltinTypeLoc</name> <name>NewT</name> <operator>=</operator> <name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>BuiltinTypeLoc</name><operator>&gt;</operator><operator>(</operator><call><name><name>T</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>)</operator></expr>;
<expr><call><name><name>NewT</name><operator>.</operator><name>setBuiltinLoc</name></name><argument_list>(<argument><expr><call><name><name>T</name><operator>.</operator><name>getBuiltinLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>T</name><operator>.</operator><name>needsExtraLocalData</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>NewT</name><operator>.</operator><name>getWrittenBuiltinSpecs</name></name><argument_list>()</argument_list></call> <operator>=</operator> <call><name><name>T</name><operator>.</operator><name>getWrittenBuiltinSpecs</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name><name>T</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformComplexType</name><argument_list>(<argument>TypeLocBuilder &amp;TLB</argument>,
<argument>ComplexTypeLoc T</argument>)</argument_list></macro> <block>{

<return>return <expr><call><name>TransformTypeSpecType</name><argument_list>(<argument><expr><name>TLB</name></expr></argument>, <argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformAdjustedType</name><argument_list>(<argument>TypeLocBuilder &amp;TLB</argument>,
<argument>AdjustedTypeLoc TL</argument>)</argument_list></macro> <block>{

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>TLB</name></expr></argument>, <argument><expr><call><name><name>TL</name><operator>.</operator><name>getOriginalLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformDecayedType</name><argument_list>(<argument>TypeLocBuilder &amp;TLB</argument>,
<argument>DecayedTypeLoc TL</argument>)</argument_list></macro> <block>{
<expr><name>QualType</name> <name>OriginalType</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>TLB</name></expr></argument>, <argument><expr><call><name><name>TL</name><operator>.</operator><name>getOriginalLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>OriginalType</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>QualType</name> <name>Result</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>||</operator>
<name>OriginalType</name> <operator>!=</operator> <call><name><name>TL</name><operator>.</operator><name>getOriginalLoc</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getType</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>Result</name> <operator>=</operator> <call><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>getDecayedType</name></name><argument_list>(<argument><expr><name>OriginalType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>DecayedTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr>;</expr_stmt>

<return>return <expr><name>Result</name></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformPointerType</name><argument_list>(<argument>TypeLocBuilder &amp;TLB</argument>,
<argument>PointerTypeLoc TL</argument>)</argument_list></macro> <block>{
<expr><name>QualType</name> <name>PointeeType</name>
<operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>TLB</name></expr></argument>, <argument><expr><call><name><name>TL</name><operator>.</operator><name>getPointeeLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>PointeeType</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>QualType</name> <name>Result</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>PointeeType</name><operator>-&gt;</operator><name>getAs</name></name><operator>&lt;</operator><name>ObjCObjectType</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>)</condition> <block>{<block_content>




<expr_stmt><expr><name>Result</name> <operator>=</operator> <call><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>getObjCObjectPointerType</name></name><argument_list>(<argument><expr><name>PointeeType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ObjCObjectPointerTypeLoc</name></type> <name>NewT</name> <init>= <expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>ObjCObjectPointerTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>NewT</name><operator>.</operator><name>setStarLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getStarLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Result</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>||</operator>
<name>PointeeType</name> <operator>!=</operator> <call><name><name>TL</name><operator>.</operator><name>getPointeeLoc</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getType</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Result</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildPointerType</name><argument_list>(<argument><expr><name>PointeeType</name></expr></argument>, <argument><expr><call><name><name>TL</name><operator>.</operator><name>getSigilLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>



<expr_stmt><expr><call><name><name>TLB</name><operator>.</operator><name>TypeWasModifiedSafely</name></name><argument_list>(<argument><expr><call><name><name>Result</name><operator>-&gt;</operator><name>getPointeeType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>PointerTypeLoc</name></type> <name>NewT</name> <init>= <expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>PointerTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>NewT</name><operator>.</operator><name>setSigilLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getSigilLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Result</name></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformBlockPointerType</name><argument_list>(<argument>TypeLocBuilder &amp;TLB</argument>,
<argument>BlockPointerTypeLoc TL</argument>)</argument_list></macro> <block>{
<expr><name>QualType</name> <name>PointeeType</name>
<operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>TLB</name></expr></argument>, <argument><expr><call><name><name>TL</name><operator>.</operator><name>getPointeeLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>PointeeType</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>QualType</name> <name>Result</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>||</operator>
<name>PointeeType</name> <operator>!=</operator> <call><name><name>TL</name><operator>.</operator><name>getPointeeLoc</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getType</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Result</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildBlockPointerType</name><argument_list>(<argument><expr><name>PointeeType</name></expr></argument>,
<argument><expr><call><name><name>TL</name><operator>.</operator><name>getSigilLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>BlockPointerTypeLoc</name></type> <name>NewT</name> <init>= <expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>BlockPointerTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>NewT</name><operator>.</operator><name>setSigilLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getSigilLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Result</name></expr>;</return>
}





template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformReferenceType</name><argument_list>(<argument>TypeLocBuilder &amp;TLB</argument>,
<argument>ReferenceTypeLoc TL</argument>)</argument_list></macro> <block>{
<expr><specifier>const</specifier> <name>ReferenceType</name> <operator>*</operator><name>T</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call></expr>;


<expr><name>QualType</name> <name>PointeeType</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>TLB</name></expr></argument>, <argument><expr><call><name><name>TL</name><operator>.</operator><name>getPointeeLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>PointeeType</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>QualType</name> <name>Result</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>||</operator>
<name>PointeeType</name> <operator>!=</operator> <call><name><name>T</name><operator>-&gt;</operator><name>getPointeeTypeAsWritten</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Result</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildReferenceType</name><argument_list>(<argument><expr><name>PointeeType</name></expr></argument>,
<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>isSpelledAsLValue</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>TL</name><operator>.</operator><name>getSigilLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>



<expr_stmt><expr><call><name><name>TLB</name><operator>.</operator><name>TypeWasModifiedSafely</name></name><argument_list>(
<argument><expr><name><name>Result</name><operator>-&gt;</operator><name>castAs</name></name><operator>&lt;</operator><name>ReferenceType</name><operator>&gt;</operator><operator>(</operator><operator>)</operator><operator>-&gt;</operator><call><name>getPointeeTypeAsWritten</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><name>ReferenceTypeLoc</name></type> <name>NewTL</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>LValueReferenceType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>NewTL</name> <operator>=</operator> <name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>LValueReferenceTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>NewTL</name> <operator>=</operator> <name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>RValueReferenceTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setSigilLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getSigilLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Result</name></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformLValueReferenceType</name><argument_list>(<argument>TypeLocBuilder &amp;TLB</argument>,
<argument>LValueReferenceTypeLoc TL</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>TransformReferenceType</name><argument_list>(<argument><expr><name>TLB</name></expr></argument>, <argument><expr><name>TL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>QualType</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformRValueReferenceType</name><argument_list>(<argument>TypeLocBuilder &amp;TLB</argument>,
<argument>RValueReferenceTypeLoc TL</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>TransformReferenceType</name><argument_list>(<argument><expr><name>TLB</name></expr></argument>, <argument><expr><name>TL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>QualType</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformMemberPointerType</name><argument_list>(<argument>TypeLocBuilder &amp;TLB</argument>,
<argument>MemberPointerTypeLoc TL</argument>)</argument_list></macro> <block>{
<expr><name>QualType</name> <name>PointeeType</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>TLB</name></expr></argument>, <argument><expr><call><name><name>TL</name><operator>.</operator><name>getPointeeLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>PointeeType</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>TypeSourceInfo</name><operator>*</operator> <name>OldClsTInfo</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getClassTInfo</name></name><argument_list>()</argument_list></call></block></expr>;</expr_stmt>
<decl_stmt><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>NewClsTInfo</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>OldClsTInfo</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>NewClsTInfo</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>OldClsTInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>NewClsTInfo</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>MemberPointerType</name> <modifier>*</modifier></type><name>T</name> <init>= <expr><call><name><name>TL</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>QualType</name></type> <name>OldClsType</name> <init>= <expr><call><name>QualType</name><argument_list>(<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getClass</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>QualType</name></type> <name>NewClsType</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>NewClsTInfo</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>NewClsType</name> <operator>=</operator> <call><name><name>NewClsTInfo</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>NewClsType</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>OldClsType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>NewClsType</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>Result</name> <init>= <expr><call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>||</operator>
<name>PointeeType</name> <operator>!=</operator> <call><name><name>T</name><operator>-&gt;</operator><name>getPointeeType</name></name><argument_list>()</argument_list></call> <operator>||</operator>
<name>NewClsType</name> <operator>!=</operator> <name>OldClsType</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Result</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildMemberPointerType</name><argument_list>(<argument><expr><name>PointeeType</name></expr></argument>, <argument><expr><name>NewClsType</name></expr></argument>,
<argument><expr><call><name><name>TL</name><operator>.</operator><name>getStarLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>



<decl_stmt><decl><type><specifier>const</specifier> <name>MemberPointerType</name> <modifier>*</modifier></type><name>MPT</name> <init>= <expr><name><name>Result</name><operator>-&gt;</operator><name>getAs</name></name><operator>&lt;</operator><name>MemberPointerType</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>MPT</name> <operator>&amp;&amp;</operator> <name>PointeeType</name> <operator>!=</operator> <call><name><name>MPT</name><operator>-&gt;</operator><name>getPointeeType</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>AdjustedType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>MPT</name><operator>-&gt;</operator><name>getPointeeType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>AdjustedTypeLoc</name><operator>&gt;</operator><operator>(</operator><call><name><name>MPT</name><operator>-&gt;</operator><name>getPointeeType</name></name><argument_list>()</argument_list></call><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>MemberPointerTypeLoc</name></type> <name>NewTL</name> <init>= <expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>MemberPointerTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setSigilLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getSigilLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setClassTInfo</name></name><argument_list>(<argument><expr><name>NewClsTInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Result</name></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformConstantArrayType</name><argument_list>(<argument>TypeLocBuilder &amp;TLB</argument>,
<argument>ConstantArrayTypeLoc TL</argument>)</argument_list></macro> <block>{
<expr><specifier>const</specifier> <name>ConstantArrayType</name> <operator>*</operator><name>T</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call></expr>;
<expr><name>QualType</name> <name>ElementType</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>TLB</name></expr></argument>, <argument><expr><call><name><name>TL</name><operator>.</operator><name>getElementLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>ElementType</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<name>Expr</name> <operator>*</operator><name>OldSize</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getSizeExpr</name></name><argument_list>()</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>OldSize</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>OldSize</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getSizeExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>NewSize</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>OldSize</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>EnterExpressionEvaluationContext</name></type> <name>Unevaluated</name><argument_list>(
<argument><expr><name>SemaRef</name></expr></argument>, <argument><expr><name>Sema</name><operator>::</operator><name>ExpressionEvaluationContext</name><operator>::</operator><name>ConstantEvaluated</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<expr_stmt><expr><name>NewSize</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><name>OldSize</name></expr></argument>)</argument_list></call><operator>.</operator><name>template</name> <call><name><name>getAs</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>NewSize</name> <operator>=</operator> <call><name><name>SemaRef</name><operator>.</operator><name>ActOnConstantExpression</name></name><argument_list>(<argument><expr><name>NewSize</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>get</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>Result</name> <init>= <expr><call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>||</operator>
<name>ElementType</name> <operator>!=</operator> <call><name><name>T</name><operator>-&gt;</operator><name>getElementType</name></name><argument_list>()</argument_list></call> <operator>||</operator>
<operator>(</operator><call><name><name>T</name><operator>-&gt;</operator><name>getSizeExpr</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>NewSize</name> <operator>!=</operator> <name>OldSize</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Result</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildConstantArrayType</name><argument_list>(<argument><expr><name>ElementType</name></expr></argument>,
<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getSizeModifier</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getSize</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NewSize</name></expr></argument>,
<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getIndexTypeCVRQualifiers</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>TL</name><operator>.</operator><name>getBracketsRange</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>





<decl_stmt><decl><type><name>ArrayTypeLoc</name></type> <name>NewTL</name> <init>= <expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>ArrayTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setLBracketLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getLBracketLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setRBracketLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getRBracketLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setSizeExpr</name></name><argument_list>(<argument><expr><name>NewSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Result</name></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformIncompleteArrayType</name><argument_list>(
<argument>TypeLocBuilder &amp;TLB</argument>,
<argument>IncompleteArrayTypeLoc TL</argument>)</argument_list></macro> <block>{
<expr><specifier>const</specifier> <name>IncompleteArrayType</name> <operator>*</operator><name>T</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call></expr>;
<expr><name>QualType</name> <name>ElementType</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>TLB</name></expr></argument>, <argument><expr><call><name><name>TL</name><operator>.</operator><name>getElementLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>ElementType</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>QualType</name> <name>Result</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>||</operator>
<name>ElementType</name> <operator>!=</operator> <call><name><name>T</name><operator>-&gt;</operator><name>getElementType</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Result</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildIncompleteArrayType</name><argument_list>(<argument><expr><name>ElementType</name></expr></argument>,
<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getSizeModifier</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getIndexTypeCVRQualifiers</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>TL</name><operator>.</operator><name>getBracketsRange</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>IncompleteArrayTypeLoc</name></type> <name>NewTL</name> <init>= <expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>IncompleteArrayTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setLBracketLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getLBracketLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setRBracketLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getRBracketLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setSizeExpr</name></name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Result</name></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformVariableArrayType</name><argument_list>(<argument>TypeLocBuilder &amp;TLB</argument>,
<argument>VariableArrayTypeLoc TL</argument>)</argument_list></macro> <block>{
<expr><specifier>const</specifier> <name>VariableArrayType</name> <operator>*</operator><name>T</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call></expr>;
<expr><name>QualType</name> <name>ElementType</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>TLB</name></expr></argument>, <argument><expr><call><name><name>TL</name><operator>.</operator><name>getElementLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>ElementType</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>ExprResult</name> <name>SizeResult</name></block></expr>;</expr_stmt>
<block>{<block_content>
<decl_stmt><decl><type><name>EnterExpressionEvaluationContext</name></type> <name>Context</name><argument_list>(
<argument><expr><name>SemaRef</name></expr></argument>, <argument><expr><name>Sema</name><operator>::</operator><name>ExpressionEvaluationContext</name><operator>::</operator><name>PotentiallyEvaluated</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<expr_stmt><expr><name>SizeResult</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getSizeExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<if_stmt><if>if <condition>(<expr><call><name><name>SizeResult</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>SizeResult</name> <operator>=</operator>
<call><name><name>SemaRef</name><operator>.</operator><name>ActOnFinishFullExpr</name></name><argument_list>(<argument><expr><call><name><name>SizeResult</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>SizeResult</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Size</name> <init>= <expr><call><name><name>SizeResult</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>Result</name> <init>= <expr><call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>||</operator>
<name>ElementType</name> <operator>!=</operator> <call><name><name>T</name><operator>-&gt;</operator><name>getElementType</name></name><argument_list>()</argument_list></call> <operator>||</operator>
<name>Size</name> <operator>!=</operator> <call><name><name>T</name><operator>-&gt;</operator><name>getSizeExpr</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Result</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildVariableArrayType</name><argument_list>(<argument><expr><name>ElementType</name></expr></argument>,
<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getSizeModifier</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>Size</name></expr></argument>,
<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getIndexTypeCVRQualifiers</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>TL</name><operator>.</operator><name>getBracketsRange</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>



<decl_stmt><decl><type><name>ArrayTypeLoc</name></type> <name>NewTL</name> <init>= <expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>ArrayTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setLBracketLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getLBracketLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setRBracketLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getRBracketLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setSizeExpr</name></name><argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Result</name></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformDependentSizedArrayType</name><argument_list>(<argument>TypeLocBuilder &amp;TLB</argument>,
<argument>DependentSizedArrayTypeLoc TL</argument>)</argument_list></macro> <block>{
<expr><specifier>const</specifier> <name>DependentSizedArrayType</name> <operator>*</operator><name>T</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call></expr>;
<expr><name>QualType</name> <name>ElementType</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>TLB</name></expr></argument>, <argument><expr><call><name><name>TL</name><operator>.</operator><name>getElementLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>ElementType</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<name>EnterExpressionEvaluationContext</name> <call><name>Unevaluated</name><argument_list>(
<argument><expr><name>SemaRef</name></expr></argument>, <argument><expr><name>Sema</name><operator>::</operator><name>ExpressionEvaluationContext</name><operator>::</operator><name>ConstantEvaluated</name></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>


<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>origSize</name> <init>= <expr><call><name><name>TL</name><operator>.</operator><name>getSizeExpr</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>origSize</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>origSize</name> <operator>=</operator> <call><name><name>T</name><operator>-&gt;</operator><name>getSizeExpr</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>ExprResult</name></type> <name>sizeResult</name>
<init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><name>origSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>sizeResult</name> <operator>=</operator> <call><name><name>SemaRef</name><operator>.</operator><name>ActOnConstantExpression</name></name><argument_list>(<argument><expr><name>sizeResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>sizeResult</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>size</name> <init>= <expr><call><name><name>sizeResult</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>Result</name> <init>= <expr><call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>||</operator>
<name>ElementType</name> <operator>!=</operator> <call><name><name>T</name><operator>-&gt;</operator><name>getElementType</name></name><argument_list>()</argument_list></call> <operator>||</operator>
<name>size</name> <operator>!=</operator> <name>origSize</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Result</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildDependentSizedArrayType</name><argument_list>(<argument><expr><name>ElementType</name></expr></argument>,
<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getSizeModifier</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>size</name></expr></argument>,
<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getIndexTypeCVRQualifiers</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>TL</name><operator>.</operator><name>getBracketsRange</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>



<decl_stmt><decl><type><name>ArrayTypeLoc</name></type> <name>NewTL</name> <init>= <expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>ArrayTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setLBracketLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getLBracketLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setRBracketLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getRBracketLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setSizeExpr</name></name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Result</name></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformDependentVectorType</name><argument_list>(
<argument>TypeLocBuilder &amp;TLB</argument>, <argument>DependentVectorTypeLoc TL</argument>)</argument_list></macro> <block>{
<expr><specifier>const</specifier> <name>DependentVectorType</name> <operator>*</operator><name>T</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call></expr>;
<expr><name>QualType</name> <name>ElementType</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>TLB</name></expr></argument>, <argument><expr><call><name><name>TL</name><operator>.</operator><name>getElementLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>ElementType</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>EnterExpressionEvaluationContext</name> <call><name>Unevaluated</name><argument_list>(
<argument><expr><name>SemaRef</name></expr></argument>, <argument><expr><name>Sema</name><operator>::</operator><name>ExpressionEvaluationContext</name><operator>::</operator><name>ConstantEvaluated</name></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ExprResult</name></type> <name>Size</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getSizeExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>Size</name> <operator>=</operator> <call><name><name>SemaRef</name><operator>.</operator><name>ActOnConstantExpression</name></name><argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Size</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>Result</name> <init>= <expr><call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>||</operator> <name>ElementType</name> <operator>!=</operator> <call><name><name>T</name><operator>-&gt;</operator><name>getElementType</name></name><argument_list>()</argument_list></call> <operator>||</operator>
<call><name><name>Size</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <call><name><name>T</name><operator>-&gt;</operator><name>getSizeExpr</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Result</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildDependentVectorType</name><argument_list>(
<argument><expr><name>ElementType</name></expr></argument>, <argument><expr><call><name><name>Size</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getAttributeLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getVectorKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>DependentVectorType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Result</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>DependentVectorTypeLoc</name></type> <name>NewTL</name> <init>=
<expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>DependentVectorTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setNameLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>VectorTypeLoc</name></type> <name>NewTL</name> <init>= <expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>VectorTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setNameLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>Result</name></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformDependentSizedExtVectorType</name><argument_list>(
<argument>TypeLocBuilder &amp;TLB</argument>,
<argument>DependentSizedExtVectorTypeLoc TL</argument>)</argument_list></macro> <block>{
<expr><specifier>const</specifier> <name>DependentSizedExtVectorType</name> <operator>*</operator><name>T</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call></expr>;


<expr><name>QualType</name> <name>ElementType</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>TLB</name></expr></argument>, <argument><expr><call><name><name>TL</name><operator>.</operator><name>getElementLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>ElementType</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<name>EnterExpressionEvaluationContext</name> <call><name>Unevaluated</name><argument_list>(
<argument><expr><name>SemaRef</name></expr></argument>, <argument><expr><name>Sema</name><operator>::</operator><name>ExpressionEvaluationContext</name><operator>::</operator><name>ConstantEvaluated</name></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ExprResult</name></type> <name>Size</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getSizeExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>Size</name> <operator>=</operator> <call><name><name>SemaRef</name><operator>.</operator><name>ActOnConstantExpression</name></name><argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Size</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>Result</name> <init>= <expr><call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>||</operator>
<name>ElementType</name> <operator>!=</operator> <call><name><name>T</name><operator>-&gt;</operator><name>getElementType</name></name><argument_list>()</argument_list></call> <operator>||</operator>
<call><name><name>Size</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <call><name><name>T</name><operator>-&gt;</operator><name>getSizeExpr</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Result</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildDependentSizedExtVectorType</name><argument_list>(<argument><expr><name>ElementType</name></expr></argument>,
<argument><expr><call><name><name>Size</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getAttributeLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>DependentSizedExtVectorType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Result</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>DependentSizedExtVectorTypeLoc</name></type> <name>NewTL</name>
<init>= <expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>DependentSizedExtVectorTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setNameLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>ExtVectorTypeLoc</name></type> <name>NewTL</name> <init>= <expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>ExtVectorTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setNameLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>Result</name></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformConstantMatrixType</name><argument_list>(<argument>TypeLocBuilder &amp;TLB</argument>,
<argument>ConstantMatrixTypeLoc TL</argument>)</argument_list></macro> <block>{
<expr><specifier>const</specifier> <name>ConstantMatrixType</name> <operator>*</operator><name>T</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call></expr>;
<expr><name>QualType</name> <name>ElementType</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getElementType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>ElementType</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>QualType</name> <name>Result</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>||</operator> <name>ElementType</name> <operator>!=</operator> <call><name><name>T</name><operator>-&gt;</operator><name>getElementType</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Result</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildConstantMatrixType</name><argument_list>(
<argument><expr><name>ElementType</name></expr></argument>, <argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getNumRows</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getNumColumns</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ConstantMatrixTypeLoc</name></type> <name>NewTL</name> <init>= <expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>ConstantMatrixTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setAttrNameLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getAttrNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setAttrOperandParensRange</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getAttrOperandParensRange</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setAttrRowOperand</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getAttrRowOperand</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setAttrColumnOperand</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getAttrColumnOperand</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Result</name></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformDependentSizedMatrixType</name><argument_list>(
<argument>TypeLocBuilder &amp;TLB</argument>, <argument>DependentSizedMatrixTypeLoc TL</argument>)</argument_list></macro> <block>{
<expr><specifier>const</specifier> <name>DependentSizedMatrixType</name> <operator>*</operator><name>T</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call></expr>;

<expr><name>QualType</name> <name>ElementType</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getElementType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>ElementType</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return>
<expr_stmt/></block_content></block></if></if_stmt>}</block>


<name>EnterExpressionEvaluationContext</name> <call><name>Unevaluated</name><argument_list>(
<argument><expr><name>SemaRef</name></expr></argument>, <argument><expr><name>Sema</name><operator>::</operator><name>ExpressionEvaluationContext</name><operator>::</operator><name>ConstantEvaluated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>origRows</name> <init>= <expr><call><name><name>TL</name><operator>.</operator><name>getAttrRowOperand</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>origRows</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>origRows</name> <operator>=</operator> <call><name><name>T</name><operator>-&gt;</operator><name>getRowExpr</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>origColumns</name> <init>= <expr><call><name><name>TL</name><operator>.</operator><name>getAttrColumnOperand</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>origColumns</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>origColumns</name> <operator>=</operator> <call><name><name>T</name><operator>-&gt;</operator><name>getColumnExpr</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>ExprResult</name></type> <name>rowResult</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><name>origRows</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>rowResult</name> <operator>=</operator> <call><name><name>SemaRef</name><operator>.</operator><name>ActOnConstantExpression</name></name><argument_list>(<argument><expr><name>rowResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>rowResult</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>ExprResult</name></type> <name>columnResult</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><name>origColumns</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>columnResult</name> <operator>=</operator> <call><name><name>SemaRef</name><operator>.</operator><name>ActOnConstantExpression</name></name><argument_list>(<argument><expr><name>columnResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>columnResult</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>rows</name> <init>= <expr><call><name><name>rowResult</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>columns</name> <init>= <expr><call><name><name>columnResult</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>Result</name> <init>= <expr><call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>||</operator> <name>ElementType</name> <operator>!=</operator> <call><name><name>T</name><operator>-&gt;</operator><name>getElementType</name></name><argument_list>()</argument_list></call> <operator>||</operator>
<name>rows</name> <operator>!=</operator> <name>origRows</name> <operator>||</operator> <name>columns</name> <operator>!=</operator> <name>origColumns</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Result</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildDependentSizedMatrixType</name><argument_list>(
<argument><expr><name>ElementType</name></expr></argument>, <argument><expr><name>rows</name></expr></argument>, <argument><expr><name>columns</name></expr></argument>, <argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getAttributeLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>



<decl_stmt><decl><type><name>MatrixTypeLoc</name></type> <name>NewTL</name> <init>= <expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>MatrixTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setAttrNameLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getAttrNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setAttrOperandParensRange</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getAttrOperandParensRange</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setAttrRowOperand</name></name><argument_list>(<argument><expr><name>rows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setAttrColumnOperand</name></name><argument_list>(<argument><expr><name>columns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Result</name></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformDependentAddressSpaceType</name><argument_list>(
<argument>TypeLocBuilder &amp;TLB</argument>, <argument>DependentAddressSpaceTypeLoc TL</argument>)</argument_list></macro> <block>{
<expr><specifier>const</specifier> <name>DependentAddressSpaceType</name> <operator>*</operator><name>T</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call></expr>;

<expr><name>QualType</name> <name>pointeeType</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getPointeeType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;

<if_stmt><if>if <condition>(<expr><call><name><name>pointeeType</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<name>EnterExpressionEvaluationContext</name> <call><name>Unevaluated</name><argument_list>(
<argument><expr><name>SemaRef</name></expr></argument>, <argument><expr><name>Sema</name><operator>::</operator><name>ExpressionEvaluationContext</name><operator>::</operator><name>ConstantEvaluated</name></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ExprResult</name></type> <name>AddrSpace</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getAddrSpaceExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>AddrSpace</name> <operator>=</operator> <call><name><name>SemaRef</name><operator>.</operator><name>ActOnConstantExpression</name></name><argument_list>(<argument><expr><name>AddrSpace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>AddrSpace</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>Result</name> <init>= <expr><call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>||</operator> <name>pointeeType</name> <operator>!=</operator> <call><name><name>T</name><operator>-&gt;</operator><name>getPointeeType</name></name><argument_list>()</argument_list></call> <operator>||</operator>
<call><name><name>AddrSpace</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <call><name><name>T</name><operator>-&gt;</operator><name>getAddrSpaceExpr</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Result</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildDependentAddressSpaceType</name><argument_list>(
<argument><expr><name>pointeeType</name></expr></argument>, <argument><expr><call><name><name>AddrSpace</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getAttributeLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>DependentAddressSpaceType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Result</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>DependentAddressSpaceTypeLoc</name></type> <name>NewTL</name> <init>=
<expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>DependentAddressSpaceTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setAttrOperandParensRange</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getAttrOperandParensRange</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setAttrExprOperand</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getAttrExprOperand</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setAttrNameLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getAttrNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>DI</name> <init>= <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>Context</name><operator>.</operator><name>getTrivialTypeSourceInfo</name></name><argument_list>(
<argument><expr><name>Result</name></expr></argument>, <argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getBaseLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>TransformType</name><argument_list>(<argument><expr><name>TLB</name></expr></argument>, <argument><expr><call><name><name>DI</name><operator>-&gt;</operator><name>getTypeLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>Result</name></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformVectorType</name><argument_list>(<argument>TypeLocBuilder &amp;TLB</argument>,
<argument>VectorTypeLoc TL</argument>)</argument_list></macro> <block>{
<expr><specifier>const</specifier> <name>VectorType</name> <operator>*</operator><name>T</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call></expr>;
<expr><name>QualType</name> <name>ElementType</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>TLB</name></expr></argument>, <argument><expr><call><name><name>TL</name><operator>.</operator><name>getElementLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>ElementType</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>QualType</name> <name>Result</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>||</operator>
<name>ElementType</name> <operator>!=</operator> <call><name><name>T</name><operator>-&gt;</operator><name>getElementType</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Result</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildVectorType</name><argument_list>(<argument><expr><name>ElementType</name></expr></argument>, <argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getNumElements</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getVectorKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>VectorTypeLoc</name></type> <name>NewTL</name> <init>= <expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>VectorTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setNameLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Result</name></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformExtVectorType</name><argument_list>(<argument>TypeLocBuilder &amp;TLB</argument>,
<argument>ExtVectorTypeLoc TL</argument>)</argument_list></macro> <block>{
<expr><specifier>const</specifier> <name>VectorType</name> <operator>*</operator><name>T</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call></expr>;
<expr><name>QualType</name> <name>ElementType</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>TLB</name></expr></argument>, <argument><expr><call><name><name>TL</name><operator>.</operator><name>getElementLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>ElementType</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>QualType</name> <name>Result</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>||</operator>
<name>ElementType</name> <operator>!=</operator> <call><name><name>T</name><operator>-&gt;</operator><name>getElementType</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Result</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildExtVectorType</name><argument_list>(<argument><expr><name>ElementType</name></expr></argument>,
<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getNumElements</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ExtVectorTypeLoc</name></type> <name>NewTL</name> <init>= <expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>ExtVectorTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setNameLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Result</name></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ParmVarDecl</name> <operator>*</operator><name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformFunctionTypeParam</name><argument_list>(
<argument>ParmVarDecl *OldParm</argument>, <argument>int indexAdjustment</argument>, <argument>Optional&lt;unsigned&gt; NumExpansions</argument>,
<argument>bool ExpectParameterPack</argument>)</argument_list></macro> <block>{
<expr><name>TypeSourceInfo</name> <operator>*</operator><name>OldDI</name> <operator>=</operator> <call><name><name>OldParm</name><operator>-&gt;</operator><name>getTypeSourceInfo</name></name><argument_list>()</argument_list></call></expr>;
<expr><name>TypeSourceInfo</name> <operator>*</operator><name>NewDI</name> <operator>=</operator> <name>nullptr</name></expr>;

<if_stmt><if>if <condition>(<expr><name>NumExpansions</name> <operator>&amp;&amp;</operator> <call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>PackExpansionType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>OldDI</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>


<decl_stmt><decl><type><name>TypeLoc</name></type> <name>OldTL</name> <init>= <expr><call><name><name>OldDI</name><operator>-&gt;</operator><name>getTypeLoc</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PackExpansionTypeLoc</name></type> <name>OldExpansionTL</name> <init>= <expr><name><name>OldTL</name><operator>.</operator><name>castAs</name></name><operator>&lt;</operator><name>PackExpansionTypeLoc</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>TypeLocBuilder</name></type> <name>TLB</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TypeLoc</name></type> <name>NewTL</name> <init>= <expr><call><name><name>OldDI</name><operator>-&gt;</operator><name>getTypeLoc</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>TLB</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>NewTL</name><operator>.</operator><name>getFullDataSize</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>Result</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>TLB</name></expr></argument>,
<argument><expr><call><name><name>OldExpansionTL</name><operator>.</operator><name>getPatternLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>Result</name> <operator>=</operator> <call><name>RebuildPackExpansionType</name><argument_list>(<argument><expr><name>Result</name></expr></argument>,
<argument><expr><call><name><name>OldExpansionTL</name><operator>.</operator><name>getPatternLoc</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSourceRange</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>OldExpansionTL</name><operator>.</operator><name>getEllipsisLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>NumExpansions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>PackExpansionTypeLoc</name></type> <name>NewExpansionTL</name>
<init>= <expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>PackExpansionTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>NewExpansionTL</name><operator>.</operator><name>setEllipsisLoc</name></name><argument_list>(<argument><expr><call><name><name>OldExpansionTL</name><operator>.</operator><name>getEllipsisLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>NewDI</name> <operator>=</operator> <call><name><name>TLB</name><operator>.</operator><name>getTypeSourceInfo</name></name><argument_list>(<argument><expr><name><name>SemaRef</name><operator>.</operator><name>Context</name></name></expr></argument>, <argument><expr><name>Result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></if></if_stmt>}</block></expr></expr_stmt> <if_stmt><else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>NewDI</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>OldDI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>NewDI</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>NewDI</name> <operator>==</operator> <name>OldDI</name> <operator>&amp;&amp;</operator> <name>indexAdjustment</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>OldParm</name></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>ParmVarDecl</name> <modifier>*</modifier></type><name>newParm</name> <init>= <expr><name>ParmVarDecl</name><operator>::</operator><call><name>Create</name><argument_list>(<argument><expr><name><name>SemaRef</name><operator>.</operator><name>Context</name></name></expr></argument>,
<argument><expr><call><name><name>OldParm</name><operator>-&gt;</operator><name>getDeclContext</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>OldParm</name><operator>-&gt;</operator><name>getInnerLocStart</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>OldParm</name><operator>-&gt;</operator><name>getLocation</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>OldParm</name><operator>-&gt;</operator><name>getIdentifier</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>NewDI</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>NewDI</name></expr></argument>,
<argument><expr><call><name><name>OldParm</name><operator>-&gt;</operator><name>getStorageClass</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>newParm</name><operator>-&gt;</operator><name>setScopeInfo</name></name><argument_list>(<argument><expr><call><name><name>OldParm</name><operator>-&gt;</operator><name>getFunctionScopeDepth</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>OldParm</name><operator>-&gt;</operator><name>getFunctionScopeIndex</name></name><argument_list>()</argument_list></call> <operator>+</operator> <name>indexAdjustment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>transformedLocalDecl</name><argument_list>(<argument>OldParm</argument>, <argument>{newParm}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<return>return <expr><name>newParm</name></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>bool</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformFunctionTypeParams</name><argument_list>(
<argument>SourceLocation Loc</argument>, <argument>ArrayRef&lt;ParmVarDecl *&gt; Params</argument>,
<argument>const QualType *ParamTypes</argument>,
<argument>const FunctionProtoType::ExtParameterInfo *ParamInfos</argument>,
<argument>SmallVectorImpl&lt;QualType&gt; &amp;OutParamTypes</argument>,
<argument>SmallVectorImpl&lt;ParmVarDecl *&gt; *PVars</argument>,
<argument>Sema::ExtParameterInfoBuilder &amp;PInfos</argument>)</argument_list></macro> <block>{
<expr><name>int</name> <name>indexAdjustment</name> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>unsigned</name> <name>NumParams</name> <operator>=</operator> <call><name><name>Params</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;
<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>!=</operator> <name>NumParams</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<decl><type><name>ParmVarDecl</name> <modifier>*</modifier></type><name>OldParm</name> <init>= <expr><name><name>Params</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>OldParm</name><operator>-&gt;</operator><name>getFunctionScopeIndex</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></type> <name>NumExpansions</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ParmVarDecl</name> <modifier>*</modifier></type><name>NewParm</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>OldParm</name><operator>-&gt;</operator><name>isParameterPack</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>UnexpandedParameterPack</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name></type> <name>Unexpanded</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>TypeLoc</name></type> <name>TL</name> <init>= <expr><call><name><name>OldParm</name><operator>-&gt;</operator><name>getTypeSourceInfo</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getTypeLoc</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PackExpansionTypeLoc</name></type> <name>ExpansionTL</name> <init>= <expr><name><name>TL</name><operator>.</operator><name>castAs</name></name><operator>&lt;</operator><name>PackExpansionTypeLoc</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TypeLoc</name></type> <name>Pattern</name> <init>= <expr><call><name><name>ExpansionTL</name><operator>.</operator><name>getPatternLoc</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>SemaRef</name><operator>.</operator><name>collectUnexpandedParameterPacks</name></name><argument_list>(<argument><expr><name>Pattern</name></expr></argument>, <argument><expr><name>Unexpanded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>ShouldExpand</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>RetainExpansion</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></type> <name>OrigNumExpansions</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Unexpanded</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>OrigNumExpansions</name> <operator>=</operator> <call><name><name>ExpansionTL</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getNumExpansions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>NumExpansions</name> <operator>=</operator> <name>OrigNumExpansions</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TryExpandParameterPacks</name><argument_list>(<argument><expr><call><name><name>ExpansionTL</name><operator>.</operator><name>getEllipsisLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Pattern</name><operator>.</operator><name>getSourceRange</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>Unexpanded</name></expr></argument>,
<argument><expr><name>ShouldExpand</name></expr></argument>,
<argument><expr><name>RetainExpansion</name></expr></argument>,
<argument><expr><name>NumExpansions</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
<expr_stmt/></block_content></block></if></if_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt></block_content></block></for>}</block></expr></expr_stmt>
} else <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>AutoType</name> <modifier>*</modifier></type><name>AT</name> <init>=
<expr><call><name><name>Pattern</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getTypePtr</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getContainedAutoType</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>AT</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name><name>AT</name><operator>-&gt;</operator><name>isDeduced</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>AT</name><operator>-&gt;</operator><name>getDeducedType</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isNull</name><argument_list>()</argument_list></call><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"Could not find parameter packs or undeduced auto type!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name>ShouldExpand</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ExpandingFunctionParameterPack</name><argument_list>(<argument><expr><name>OldParm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>I</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>I</name> <operator>!=</operator> <operator>*</operator><name>NumExpansions</name></expr>;</condition> <incr><expr><operator>++</operator><name>I</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>Sema</name><operator>::</operator><name>ArgumentPackSubstitutionIndexRAII</name> <call><name>SubstIndex</name><argument_list>(<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>I</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ParmVarDecl</name> <modifier>*</modifier></type><name>NewParm</name>
<init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformFunctionTypeParam</name><argument_list>(<argument><expr><name>OldParm</name></expr></argument>,
<argument><expr><name>indexAdjustment</name><operator>++</operator></expr></argument>,
<argument><expr><name>OrigNumExpansions</name></expr></argument>,
<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>NewParm</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ParamInfos</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>PInfos</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><call><name><name>OutParamTypes</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>ParamInfos</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>OutParamTypes</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>NewParm</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>PVars</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>PVars</name><operator>-&gt;</operator><name>push_back</name></name><argument_list>(<argument><expr><name>NewParm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>



<if_stmt><if>if <condition>(<expr><name>RetainExpansion</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ForgetPartiallySubstitutedPackRAII</name></type> <name>Forget</name><argument_list>(<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ParmVarDecl</name> <modifier>*</modifier></type><name>NewParm</name>
<init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformFunctionTypeParam</name><argument_list>(<argument><expr><name>OldParm</name></expr></argument>,
<argument><expr><name>indexAdjustment</name><operator>++</operator></expr></argument>,
<argument><expr><name>OrigNumExpansions</name></expr></argument>,
<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>NewParm</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ParamInfos</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>PInfos</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><call><name><name>OutParamTypes</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>ParamInfos</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>OutParamTypes</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>NewParm</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>PVars</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>PVars</name><operator>-&gt;</operator><name>push_back</name></name><argument_list>(<argument><expr><name>NewParm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>





<expr_stmt><expr><name>indexAdjustment</name><operator>--</operator></expr>;</expr_stmt>


<continue>continue;</continue>
</block_content>}</block></if></if_stmt>



<expr_stmt><expr><name>Sema</name><operator>::</operator><name>ArgumentPackSubstitutionIndexRAII</name> <call><name>SubstIndex</name><argument_list>(<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>NewParm</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformFunctionTypeParam</name><argument_list>(<argument><expr><name>OldParm</name></expr></argument>,
<argument><expr><name>indexAdjustment</name></expr></argument>,
<argument><expr><name>NumExpansions</name></expr></argument>,
<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>NewParm</name><operator>-&gt;</operator><name>isParameterPack</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"Parameter pack no longer a parameter pack after "</literal>
<literal type="string">"transformation."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
} else <block>{<block_content>
<expr_stmt><expr><name>NewParm</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformFunctionTypeParam</name><argument_list>(
<argument><expr><name>OldParm</name></expr></argument>, <argument><expr><name>indexAdjustment</name></expr></argument>, <argument><expr><name>None</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>NewParm</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ParamInfos</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>PInfos</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><call><name><name>OutParamTypes</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>ParamInfos</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>OutParamTypes</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>NewParm</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>PVars</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>PVars</name><operator>-&gt;</operator><name>push_back</name></name><argument_list>(<argument><expr><name>NewParm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<continue>continue;</continue>
}



QualType <expr_stmt><expr><name>OldType</name> <operator>=</operator> <name><name>ParamTypes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>IsPackExpansion</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></type> <name>NumExpansions</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>QualType</name></type> <name>NewType</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <name>PackExpansionType</name> <modifier>*</modifier></type><name>Expansion</name>
<init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>PackExpansionType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>OldType</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>QualType</name></type> <name>Pattern</name> <init>= <expr><call><name><name>Expansion</name><operator>-&gt;</operator><name>getPattern</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>UnexpandedParameterPack</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name></type> <name>Unexpanded</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>collectUnexpandedParameterPacks</name><argument_list>(<argument><expr><name>Pattern</name></expr></argument>, <argument><expr><name>Unexpanded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>ShouldExpand</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>RetainExpansion</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TryExpandParameterPacks</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><call><name>SourceRange</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>Unexpanded</name></expr></argument>,
<argument><expr><name>ShouldExpand</name></expr></argument>,
<argument><expr><name>RetainExpansion</name></expr></argument>,
<argument><expr><name>NumExpansions</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ShouldExpand</name></expr>)</condition> <block>{<block_content>


<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>I</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>I</name> <operator>!=</operator> <operator>*</operator><name>NumExpansions</name></expr>;</condition> <incr><expr><operator>++</operator><name>I</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>Sema</name><operator>::</operator><name>ArgumentPackSubstitutionIndexRAII</name> <call><name>SubstIndex</name><argument_list>(<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>I</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>QualType</name></type> <name>NewType</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>Pattern</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>NewType</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>NewType</name><operator>-&gt;</operator><name>containsUnexpandedParameterPack</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>NewType</name> <operator>=</operator>
<call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getASTContext</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getPackExpansionType</name><argument_list>(<argument><expr><name>NewType</name></expr></argument>, <argument><expr><name>None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>NewType</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ParamInfos</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>PInfos</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><call><name><name>OutParamTypes</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>ParamInfos</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>OutParamTypes</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>NewType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>PVars</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>PVars</name><operator>-&gt;</operator><name>push_back</name></name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>


<continue>continue;</continue>
</block_content>}</block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><name>RetainExpansion</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ForgetPartiallySubstitutedPackRAII</name></type> <name>Forget</name><argument_list>(<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>QualType</name></type> <name>NewType</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>Pattern</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>NewType</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ParamInfos</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>PInfos</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><call><name><name>OutParamTypes</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>ParamInfos</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>OutParamTypes</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>NewType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>PVars</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>PVars</name><operator>-&gt;</operator><name>push_back</name></name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>



<expr_stmt><expr><name>OldType</name> <operator>=</operator> <call><name><name>Expansion</name><operator>-&gt;</operator><name>getPattern</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>IsPackExpansion</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name>Sema</name><operator>::</operator><name>ArgumentPackSubstitutionIndexRAII</name> <call><name>SubstIndex</name><argument_list>(<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>NewType</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>OldType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>NewType</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>OldType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>NewType</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>IsPackExpansion</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>NewType</name> <operator>=</operator> <call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>Context</name><operator>.</operator><name>getPackExpansionType</name></name><argument_list>(<argument><expr><name>NewType</name></expr></argument>,
<argument><expr><name>NumExpansions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ParamInfos</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>PInfos</name><operator>.</operator><name>set</name></name><argument_list>(<argument><expr><call><name><name>OutParamTypes</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>ParamInfos</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>OutParamTypes</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>NewType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>PVars</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>PVars</name><operator>-&gt;</operator><name>push_back</name></name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
}

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
if <expr_stmt><expr><operator>(</operator><name>PVars</name><operator>)</operator> <block>{
<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>e</name> <init>= <expr><call><name><name>PVars</name><operator>-&gt;</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>!=</operator> <name>e</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<decl><type><name>ParmVarDecl</name> <modifier>*</modifier></type><name>parm</name> <init>= <expr><operator>(</operator><operator>*</operator><name>PVars</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index></expr></init></decl>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>parm</name><operator>-&gt;</operator><name>getFunctionScopeIndex</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
}</block></expr></expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>false</name></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformFunctionProtoType</name><argument_list>(<argument>TypeLocBuilder &amp;TLB</argument>,
<argument>FunctionProtoTypeLoc TL</argument>)</argument_list></macro> <block>{
<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>ExceptionStorage</name></expr>;
<expr><name>TreeTransform</name> <operator>*</operator><name>This</name> <operator>=</operator> <name>this</name></expr>;
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformFunctionProtoType</name><argument_list>(
<argument><expr><name>TLB</name></expr></argument>, <argument><expr><name>TL</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>, <argument><expr><call><name>Qualifiers</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><index>[<expr><operator>&amp;</operator></expr>]</index><operator>(</operator><name>FunctionProtoType</name><operator>::</operator><name>ExceptionSpecInfo</name> <operator>&amp;</operator><name>ESI</name><operator>,</operator> <name>bool</name> <operator>&amp;</operator><name>Changed</name><operator>)</operator> <block>{
<return>return <expr><call><name><name>This</name><operator>-&gt;</operator><name>getDerived</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExceptionSpec</name><argument_list>(
<argument><expr><call><name><name>TL</name><operator>.</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ESI</name></expr></argument>, <argument><expr><name>ExceptionStorage</name></expr></argument>, <argument><expr><name>Changed</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name> <name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Fn</name></expr></argument>&gt;</argument_list></name>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformFunctionProtoType</name><argument_list>(
<argument>TypeLocBuilder &amp;TLB</argument>, <argument>FunctionProtoTypeLoc TL</argument>, <argument>CXXRecordDecl *ThisContext</argument>,
<argument>Qualifiers ThisTypeQuals</argument>, <argument>Fn TransformExceptionSpec</argument>)</argument_list></macro> <block>{








<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>ParamTypes</name></expr>;
<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name><operator>*</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>ParamDecls</name></expr>;
<expr><name>Sema</name><operator>::</operator><name>ExtParameterInfoBuilder</name> <name>ExtParamInfos</name></expr>;
<expr><specifier>const</specifier> <name>FunctionProtoType</name> <operator>*</operator><name>T</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call></expr>;

<expr><name>QualType</name> <name>ResultType</name></expr>;

<if_stmt><if>if <condition>(<expr><call><name><name>T</name><operator>-&gt;</operator><name>hasTrailingReturn</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformFunctionTypeParams</name><argument_list>(
<argument><expr><call><name><name>TL</name><operator>.</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>TL</name><operator>.</operator><name>getParams</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>TL</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>param_type_begin</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getExtParameterInfosOrNull</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>ParamTypes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ParamDecls</name></expr></argument>, <argument><expr><name>ExtParamInfos</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<block>{<block_content>






<expr_stmt><expr><name>Sema</name><operator>::</operator><name>CXXThisScopeRAII</name> <call><name>ThisScope</name><argument_list>(<argument><expr><name>SemaRef</name></expr></argument>, <argument><expr><name>ThisContext</name></expr></argument>, <argument><expr><name>ThisTypeQuals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ResultType</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>TLB</name></expr></argument>, <argument><expr><call><name><name>TL</name><operator>.</operator><name>getReturnLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>ResultType</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt/></block_content></block></block_content></block></if></if_stmt>}</block></expr></expr_stmt>
}
else <block>{<block_content>
<expr_stmt><expr><name>ResultType</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>TLB</name></expr></argument>, <argument><expr><call><name><name>TL</name><operator>.</operator><name>getReturnLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>ResultType</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformFunctionTypeParams</name><argument_list>(
<argument><expr><call><name><name>TL</name><operator>.</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>TL</name><operator>.</operator><name>getParams</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>TL</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>param_type_begin</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getExtParameterInfosOrNull</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>ParamTypes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ParamDecls</name></expr></argument>, <argument><expr><name>ExtParamInfos</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block>

<expr_stmt><expr><name>FunctionProtoType</name><operator>::</operator><name>ExtProtoInfo</name> <name>EPI</name> <operator>=</operator> <call><name><name>T</name><operator>-&gt;</operator><name>getExtProtoInfo</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>EPIChanged</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>TransformExceptionSpec</name><argument_list>(<argument><expr><name><name>EPI</name><operator>.</operator><name>ExceptionSpec</name></name></expr></argument>, <argument><expr><name>EPIChanged</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<decl><type><name>auto</name></type> <name>NewExtParamInfos</name> <init>=
<expr><call><name><name>ExtParamInfos</name><operator>.</operator><name>getPointerOrNull</name></name><argument_list>(<argument><expr><call><name><name>ParamTypes</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>EPI</name><operator>.</operator><name>ExtParameterInfos</name></name> <operator>||</operator>
<name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><name><name>EPI</name><operator>.</operator><name>ExtParameterInfos</name></name></expr></argument>, <argument><expr><call><name><name>TL</name><operator>.</operator><name>getNumParams</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><name>NewExtParamInfos</name></expr></argument>, <argument><expr><call><name><name>ParamTypes</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>EPIChanged</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>EPI</name><operator>.</operator><name>ExtParameterInfos</name></name> <operator>=</operator> <name>NewExtParamInfos</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>EPI</name><operator>.</operator><name>ExtParameterInfos</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>EPIChanged</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>EPI</name><operator>.</operator><name>ExtParameterInfos</name></name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>Result</name> <init>= <expr><call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>||</operator> <name>ResultType</name> <operator>!=</operator> <call><name><name>T</name><operator>-&gt;</operator><name>getReturnType</name></name><argument_list>()</argument_list></call> <operator>||</operator>
<call><name><name>T</name><operator>-&gt;</operator><name>getParamTypes</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><name>ParamTypes</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>EPIChanged</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Result</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildFunctionProtoType</name><argument_list>(<argument><expr><name>ResultType</name></expr></argument>, <argument><expr><name>ParamTypes</name></expr></argument>, <argument><expr><name>EPI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>FunctionProtoTypeLoc</name></type> <name>NewTL</name> <init>= <expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>FunctionProtoTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setLocalRangeBegin</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getLocalRangeBegin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setLParenLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setRParenLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getRParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setExceptionSpecRange</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getExceptionSpecRange</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setLocalRangeEnd</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getLocalRangeEnd</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>e</name> <init>= <expr><call><name><name>NewTL</name><operator>.</operator><name>getNumParams</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>!=</operator> <name>e</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setParam</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>ParamDecls</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<return>return <expr><name>Result</name></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>bool</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformExceptionSpec</name><argument_list>(
<argument>SourceLocation Loc</argument>, <argument>FunctionProtoType::ExceptionSpecInfo &amp;ESI</argument>,
<argument>SmallVectorImpl&lt;QualType&gt; &amp;Exceptions</argument>, <argument>bool &amp;Changed</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ESI</name><operator>.</operator><name>Type</name></name> <operator>!=</operator> <name>EST_Uninstantiated</name> <operator>&amp;&amp;</operator> <name><name>ESI</name><operator>.</operator><name>Type</name></name> <operator>!=</operator> <name>EST_Unevaluated</name></expr></argument>)</argument_list></call></expr>;


<if_stmt><if>if <condition>(<expr><call><name>isComputedNoexcept</name><argument_list>(<argument><expr><name><name>ESI</name><operator>.</operator><name>Type</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>EnterExpressionEvaluationContext</name></type> <name>Unevaluated</name><argument_list>(
<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Sema</name><operator>::</operator><name>ExpressionEvaluationContext</name><operator>::</operator><name>ConstantEvaluated</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>NoexceptExpr</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><name><name>ESI</name><operator>.</operator><name>NoexceptExpr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>NoexceptExpr</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>ExceptionSpecificationType</name></type> <name>EST</name> <init>= <expr><name><name>ESI</name><operator>.</operator><name>Type</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>NoexceptExpr</name> <operator>=</operator>
<call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnNoexceptSpec</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><call><name><name>NoexceptExpr</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>EST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>NoexceptExpr</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ESI</name><operator>.</operator><name>NoexceptExpr</name></name> <operator>!=</operator> <call><name><name>NoexceptExpr</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>||</operator> <name>EST</name> <operator>!=</operator> <name><name>ESI</name><operator>.</operator><name>Type</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>Changed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>ESI</name><operator>.</operator><name>NoexceptExpr</name></name> <operator>=</operator> <call><name><name>NoexceptExpr</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ESI</name><operator>.</operator><name>Type</name></name> <operator>=</operator> <name>EST</name></expr>;</expr_stmt>
<expr_stmt/></block_content></block></if></if_stmt>}</block></expr></expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ESI</name><operator>.</operator><name>Type</name></name> <operator>!=</operator> <name>EST_Dynamic</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>


<for>for <control>(<init><decl><type><name>QualType</name></type> <name>T</name> <range>: <expr><name><name>ESI</name><operator>.</operator><name>Exceptions</name></name></expr></range></decl></init>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <name>PackExpansionType</name> <modifier>*</modifier></type><name>PackExpansion</name> <init>=
<expr><name><name>T</name><operator>-&gt;</operator><name>getAs</name></name><operator>&lt;</operator><name>PackExpansionType</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Changed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>UnexpandedParameterPack</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name></type> <name>Unexpanded</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>SemaRef</name><operator>.</operator><name>collectUnexpandedParameterPacks</name></name><argument_list>(<argument><expr><call><name><name>PackExpansion</name><operator>-&gt;</operator><name>getPattern</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>Unexpanded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>Unexpanded</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Pack expansion without parameter packs?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<decl_stmt><decl><type><name>bool</name></type> <name>Expand</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>RetainExpansion</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></type> <name>NumExpansions</name> <init>= <expr><call><name><name>PackExpansion</name><operator>-&gt;</operator><name>getNumExpansions</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TryExpandParameterPacks</name><argument_list>(
<argument><expr><name>Loc</name></expr></argument>, <argument><expr><call><name>SourceRange</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Unexpanded</name></expr></argument>, <argument><expr><name>Expand</name></expr></argument>,
<argument><expr><name>RetainExpansion</name></expr></argument>, <argument><expr><name>NumExpansions</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Expand</name></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><name>Sema</name><operator>::</operator><name>ArgumentPackSubstitutionIndexRAII</name> <call><name>SubstIndex</name><argument_list>(<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>QualType</name></type> <name>U</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><call><name><name>PackExpansion</name><operator>-&gt;</operator><name>getPattern</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>U</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>U</name> <operator>=</operator> <call><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>getPackExpansionType</name></name><argument_list>(<argument><expr><name>U</name></expr></argument>, <argument><expr><name>NumExpansions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Exceptions</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>U</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>



<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>ArgIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>ArgIdx</name> <operator>!=</operator> <operator>*</operator><name>NumExpansions</name></expr>;</condition> <incr><expr><operator>++</operator><name>ArgIdx</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>Sema</name><operator>::</operator><name>ArgumentPackSubstitutionIndexRAII</name> <call><name>SubstIndex</name><argument_list>(<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ArgIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>U</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><call><name><name>PackExpansion</name><operator>-&gt;</operator><name>getPattern</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>U</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>SemaRef</name><operator>.</operator><name>CheckSpecifiedExceptionType</name></name><argument_list>(<argument><expr><name>U</name></expr></argument>, <argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name><name>Exceptions</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>U</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>QualType</name></type> <name>U</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>U</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>SemaRef</name><operator>.</operator><name>CheckSpecifiedExceptionType</name></name><argument_list>(<argument><expr><name>U</name></expr></argument>, <argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>T</name> <operator>!=</operator> <name>U</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>Changed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name><name>Exceptions</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>U</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name><name>ESI</name><operator>.</operator><name>Exceptions</name></name> <operator>=</operator> <name>Exceptions</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>ESI</name><operator>.</operator><name>Exceptions</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ESI</name><operator>.</operator><name>Type</name></name> <operator>=</operator> <name>EST_DynamicNone</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformFunctionNoProtoType</name><argument_list>(
<argument>TypeLocBuilder &amp;TLB</argument>,
<argument>FunctionNoProtoTypeLoc TL</argument>)</argument_list></macro> <block>{
<expr><specifier>const</specifier> <name>FunctionNoProtoType</name> <operator>*</operator><name>T</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call></expr>;
<expr><name>QualType</name> <name>ResultType</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>TLB</name></expr></argument>, <argument><expr><call><name><name>TL</name><operator>.</operator><name>getReturnLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>ResultType</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>QualType</name> <name>Result</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>||</operator> <name>ResultType</name> <operator>!=</operator> <call><name><name>T</name><operator>-&gt;</operator><name>getReturnType</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>Result</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildFunctionNoProtoType</name><argument_list>(<argument><expr><name>ResultType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>FunctionNoProtoTypeLoc</name></type> <name>NewTL</name> <init>= <expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>FunctionNoProtoTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setLocalRangeBegin</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getLocalRangeBegin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setLParenLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setRParenLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getRParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setLocalRangeEnd</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getLocalRangeEnd</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Result</name></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator> <name>QualType</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformUnresolvedUsingType</name><argument_list>(<argument>TypeLocBuilder &amp;TLB</argument>,
<argument>UnresolvedUsingTypeLoc TL</argument>)</argument_list></macro> <block>{
<expr><specifier>const</specifier> <name>UnresolvedUsingType</name> <operator>*</operator><name>T</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call></expr>;
<expr><name>Decl</name> <operator>*</operator><name>D</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDecl</name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getDecl</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>D</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>QualType</name> <name>Result</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>||</operator> <name>D</name> <operator>!=</operator> <call><name><name>T</name><operator>-&gt;</operator><name>getDecl</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Result</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildUnresolvedUsingType</name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>



<decl_stmt><decl><type><name>TypeSpecTypeLoc</name></type> <name>NewTL</name> <init>= <expr><call><name><name>TLB</name><operator>.</operator><name>pushTypeSpec</name></name><argument_list>(<argument><expr><name>Result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setNameLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Result</name></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformTypedefType</name><argument_list>(<argument>TypeLocBuilder &amp;TLB</argument>,
<argument>TypedefTypeLoc TL</argument>)</argument_list></macro> <block>{
<expr><specifier>const</specifier> <name>TypedefType</name> <operator>*</operator><name>T</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call></expr>;
<expr><name>TypedefNameDecl</name> <operator>*</operator><name>Typedef</name>
<operator>=</operator> <call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>TypedefNameDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDecl</name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getDecl</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Typedef</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>QualType</name> <name>Result</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>||</operator>
<name>Typedef</name> <operator>!=</operator> <call><name><name>T</name><operator>-&gt;</operator><name>getDecl</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Result</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildTypedefType</name><argument_list>(<argument><expr><name>Typedef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>TypedefTypeLoc</name></type> <name>NewTL</name> <init>= <expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>TypedefTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setNameLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Result</name></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformTypeOfExprType</name><argument_list>(<argument>TypeLocBuilder &amp;TLB</argument>,
<argument>TypeOfExprTypeLoc TL</argument>)</argument_list></macro> <block>{

<expr><name>EnterExpressionEvaluationContext</name> <call><name>Unevaluated</name><argument_list>(
<argument><expr><name>SemaRef</name></expr></argument>, <argument><expr><name>Sema</name><operator>::</operator><name>ExpressionEvaluationContext</name><operator>::</operator><name>Unevaluated</name></expr></argument>,
<argument><expr><name>Sema</name><operator>::</operator><name>ReuseLambdaContextDecl</name></expr></argument>)</argument_list></call></expr>;

<expr><name>ExprResult</name> <name>E</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getUnderlyingExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>E</name> <operator>=</operator> <call><name><name>SemaRef</name><operator>.</operator><name>HandleExprEvaluationContextForTypeof</name></name><argument_list>(<argument><expr><call><name><name>E</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>Result</name> <init>= <expr><call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>||</operator>
<call><name><name>E</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <call><name><name>TL</name><operator>.</operator><name>getUnderlyingExpr</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Result</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildTypeOfExprType</name><argument_list>(<argument><expr><call><name><name>E</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>TL</name><operator>.</operator><name>getTypeofLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name><name>E</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<decl_stmt><decl><type><name>TypeOfExprTypeLoc</name></type> <name>NewTL</name> <init>= <expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>TypeOfExprTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setTypeofLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getTypeofLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setLParenLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setRParenLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getRParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Result</name></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformTypeOfType</name><argument_list>(<argument>TypeLocBuilder &amp;TLB</argument>,
<argument>TypeOfTypeLoc TL</argument>)</argument_list></macro> <block>{
<expr><name>TypeSourceInfo</name><operator>*</operator> <name>Old_Under_TI</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getUnderlyingTInfo</name></name><argument_list>()</argument_list></call></expr>;
<expr><name>TypeSourceInfo</name><operator>*</operator> <name>New_Under_TI</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>Old_Under_TI</name></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>New_Under_TI</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>QualType</name> <name>Result</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>||</operator> <name>New_Under_TI</name> <operator>!=</operator> <name>Old_Under_TI</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Result</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildTypeOfType</name><argument_list>(<argument><expr><call><name><name>New_Under_TI</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>TypeOfTypeLoc</name></type> <name>NewTL</name> <init>= <expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>TypeOfTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setTypeofLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getTypeofLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setLParenLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setRParenLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getRParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setUnderlyingTInfo</name></name><argument_list>(<argument><expr><name>New_Under_TI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Result</name></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformDecltypeType</name><argument_list>(<argument>TypeLocBuilder &amp;TLB</argument>,
<argument>DecltypeTypeLoc TL</argument>)</argument_list></macro> <block>{
<expr><specifier>const</specifier> <name>DecltypeType</name> <operator>*</operator><name>T</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call></expr>;


<expr><name>EnterExpressionEvaluationContext</name> <call><name>Unevaluated</name><argument_list>(
<argument><expr><name>SemaRef</name></expr></argument>, <argument><expr><name>Sema</name><operator>::</operator><name>ExpressionEvaluationContext</name><operator>::</operator><name>Unevaluated</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><name>Sema</name><operator>::</operator><name>ExpressionEvaluationContextRecord</name><operator>::</operator><name>EK_Decltype</name></expr></argument>)</argument_list></call></expr>;

<expr><name>ExprResult</name> <name>E</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getUnderlyingExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>E</name> <operator>=</operator> <call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnDecltypeExpression</name><argument_list>(<argument><expr><call><name><name>E</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>Result</name> <init>= <expr><call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>||</operator>
<call><name><name>E</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <call><name><name>T</name><operator>-&gt;</operator><name>getUnderlyingExpr</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Result</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildDecltypeType</name><argument_list>(<argument><expr><call><name><name>E</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>TL</name><operator>.</operator><name>getNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name><name>E</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<decl_stmt><decl><type><name>DecltypeTypeLoc</name></type> <name>NewTL</name> <init>= <expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>DecltypeTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setNameLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Result</name></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformUnaryTransformType</name><argument_list>(
<argument>TypeLocBuilder &amp;TLB</argument>,
<argument>UnaryTransformTypeLoc TL</argument>)</argument_list></macro> <block>{
<expr><name>QualType</name> <name>Result</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>-&gt;</operator><name>isDependentType</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>UnaryTransformType</name> <modifier>*</modifier></type><name>T</name> <init>= <expr><call><name><name>TL</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>QualType</name></type> <name>NewBase</name> <init>=
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getUnderlyingTInfo</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getType</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>Result</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildUnaryTransformType</name><argument_list>(<argument><expr><name>NewBase</name></expr></argument>,
<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getUTTKind</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>TL</name><operator>.</operator><name>getKWLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt/></block_content></block></if></if_stmt>}</block>

<name>UnaryTransformTypeLoc</name> <name>NewTL</name> <operator>=</operator> <name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>UnaryTransformTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setKWLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getKWLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setParensRange</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getParensRange</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setUnderlyingTInfo</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getUnderlyingTInfo</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Result</name></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformDeducedTemplateSpecializationType</name><argument_list>(
<argument>TypeLocBuilder &amp;TLB</argument>, <argument>DeducedTemplateSpecializationTypeLoc TL</argument>)</argument_list></macro> <block>{
<expr><specifier>const</specifier> <name>DeducedTemplateSpecializationType</name> <operator>*</operator><name>T</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call></expr>;

<expr><name>CXXScopeSpec</name> <name>SS</name></expr>;
<expr><name>TemplateName</name> <name>TemplateName</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformTemplateName</name><argument_list>(
<argument><expr><name>SS</name></expr></argument>, <argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getTemplateName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>TL</name><operator>.</operator><name>getTemplateNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>TemplateName</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>QualType</name> <name>OldDeduced</name> <operator>=</operator> <call><name><name>T</name><operator>-&gt;</operator><name>getDeducedType</name></name><argument_list>()</argument_list></call></block></expr>;</expr_stmt>
<decl_stmt><decl><type><name>QualType</name></type> <name>NewDeduced</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>OldDeduced</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>NewDeduced</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>OldDeduced</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>NewDeduced</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>Result</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildDeducedTemplateSpecializationType</name><argument_list>(
<argument><expr><name>TemplateName</name></expr></argument>, <argument><expr><name>NewDeduced</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>DeducedTemplateSpecializationTypeLoc</name></type> <name>NewTL</name> <init>=
<expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>DeducedTemplateSpecializationTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setTemplateNameLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getTemplateNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Result</name></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformRecordType</name><argument_list>(<argument>TypeLocBuilder &amp;TLB</argument>,
<argument>RecordTypeLoc TL</argument>)</argument_list></macro> <block>{
<expr><specifier>const</specifier> <name>RecordType</name> <operator>*</operator><name>T</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call></expr>;
<expr><name>RecordDecl</name> <operator>*</operator><name>Record</name>
<operator>=</operator> <call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>RecordDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDecl</name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getDecl</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Record</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>QualType</name> <name>Result</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>||</operator>
<name>Record</name> <operator>!=</operator> <call><name><name>T</name><operator>-&gt;</operator><name>getDecl</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Result</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildRecordType</name><argument_list>(<argument><expr><name>Record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RecordTypeLoc</name></type> <name>NewTL</name> <init>= <expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>RecordTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setNameLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Result</name></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformEnumType</name><argument_list>(<argument>TypeLocBuilder &amp;TLB</argument>,
<argument>EnumTypeLoc TL</argument>)</argument_list></macro> <block>{
<expr><specifier>const</specifier> <name>EnumType</name> <operator>*</operator><name>T</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call></expr>;
<expr><name>EnumDecl</name> <operator>*</operator><name>Enum</name>
<operator>=</operator> <call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>EnumDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDecl</name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getDecl</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Enum</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>QualType</name> <name>Result</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>||</operator>
<name>Enum</name> <operator>!=</operator> <call><name><name>T</name><operator>-&gt;</operator><name>getDecl</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Result</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildEnumType</name><argument_list>(<argument><expr><name>Enum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>EnumTypeLoc</name></type> <name>NewTL</name> <init>= <expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>EnumTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setNameLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Result</name></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformInjectedClassNameType</name><argument_list>(
<argument>TypeLocBuilder &amp;TLB</argument>,
<argument>InjectedClassNameTypeLoc TL</argument>)</argument_list></macro> <block>{
<expr><name>Decl</name> <operator>*</operator><name>D</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDecl</name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>TL</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>D</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>QualType</name> <name>T</name> <operator>=</operator> <call><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>getTypeDeclType</name></name><argument_list>(<argument><expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>TypeDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>TLB</name><operator>.</operator><name>pushTypeSpec</name></name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>setNameLoc</name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>T</name></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformTemplateTypeParmType</name><argument_list>(
<argument>TypeLocBuilder &amp;TLB</argument>,
<argument>TemplateTypeParmTypeLoc TL</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>TransformTypeSpecType</name><argument_list>(<argument><expr><name>TLB</name></expr></argument>, <argument><expr><name>TL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformSubstTemplateTypeParmType</name><argument_list>(
<argument>TypeLocBuilder &amp;TLB</argument>,
<argument>SubstTemplateTypeParmTypeLoc TL</argument>)</argument_list></macro> <block>{
<expr><specifier>const</specifier> <name>SubstTemplateTypeParmType</name> <operator>*</operator><name>T</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call></expr>;




<expr><name>TemporaryBase</name> <call><name>Rebase</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><call><name><name>TL</name><operator>.</operator><name>getNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>DeclarationName</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>QualType</name> <name>Replacement</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getReplacementType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Replacement</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<name>Replacement</name> <operator>=</operator> <call><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>getCanonicalType</name></name><argument_list>(<argument><expr><name>Replacement</name></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<decl_stmt><decl><type><name>QualType</name></type> <name>Result</name>
<init>= <expr><call><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>getSubstTemplateTypeParmType</name></name><argument_list>(<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getReplacedParameter</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>Replacement</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SubstTemplateTypeParmTypeLoc</name></type> <name>NewTL</name>
<init>= <expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>SubstTemplateTypeParmTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setNameLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Result</name></expr>;</return>

}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformSubstTemplateTypeParmPackType</name><argument_list>(
<argument>TypeLocBuilder &amp;TLB</argument>,
<argument>SubstTemplateTypeParmPackTypeLoc TL</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>TransformTypeSpecType</name><argument_list>(<argument><expr><name>TLB</name></expr></argument>, <argument><expr><name>TL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformTemplateSpecializationType</name><argument_list>(
<argument>TypeLocBuilder &amp;TLB</argument>,
<argument>TemplateSpecializationTypeLoc TL</argument>)</argument_list></macro> <block>{
<expr><specifier>const</specifier> <name>TemplateSpecializationType</name> <operator>*</operator><name>T</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call></expr>;



<expr><name>CXXScopeSpec</name> <name>SS</name></expr>;
<expr><name>TemplateName</name> <name>Template</name>
<operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformTemplateName</name><argument_list>(<argument><expr><name>SS</name></expr></argument>, <argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getTemplateName</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>TL</name><operator>.</operator><name>getTemplateNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Template</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformTemplateSpecializationType</name><argument_list>(<argument><expr><name>TLB</name></expr></argument>, <argument><expr><name>TL</name></expr></argument>, <argument><expr><name>Template</name></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformAtomicType</name><argument_list>(<argument>TypeLocBuilder &amp;TLB</argument>,
<argument>AtomicTypeLoc TL</argument>)</argument_list></macro> <block>{
<expr><name>QualType</name> <name>ValueType</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>TLB</name></expr></argument>, <argument><expr><call><name><name>TL</name><operator>.</operator><name>getValueLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>ValueType</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>QualType</name> <name>Result</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>||</operator>
<name>ValueType</name> <operator>!=</operator> <call><name><name>TL</name><operator>.</operator><name>getValueLoc</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getType</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Result</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildAtomicType</name><argument_list>(<argument><expr><name>ValueType</name></expr></argument>, <argument><expr><call><name><name>TL</name><operator>.</operator><name>getKWLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>AtomicTypeLoc</name></type> <name>NewTL</name> <init>= <expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>AtomicTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setKWLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getKWLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setLParenLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setRParenLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getRParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Result</name></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformPipeType</name><argument_list>(<argument>TypeLocBuilder &amp;TLB</argument>,
<argument>PipeTypeLoc TL</argument>)</argument_list></macro> <block>{
<expr><name>QualType</name> <name>ValueType</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>TLB</name></expr></argument>, <argument><expr><call><name><name>TL</name><operator>.</operator><name>getValueLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>ValueType</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>QualType</name> <name>Result</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>||</operator> <name>ValueType</name> <operator>!=</operator> <call><name><name>TL</name><operator>.</operator><name>getValueLoc</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getType</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>PipeType</name> <modifier>*</modifier></type><name>PT</name> <init>= <expr><name><name>Result</name><operator>-&gt;</operator><name>castAs</name></name><operator>&lt;</operator><name>PipeType</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>isReadPipe</name> <init>= <expr><call><name><name>PT</name><operator>-&gt;</operator><name>isReadOnly</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>Result</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildPipeType</name><argument_list>(<argument><expr><name>ValueType</name></expr></argument>, <argument><expr><call><name><name>TL</name><operator>.</operator><name>getKWLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>isReadPipe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>PipeTypeLoc</name></type> <name>NewTL</name> <init>= <expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>PipeTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setKWLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getKWLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>Result</name></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformExtIntType</name><argument_list>(<argument>TypeLocBuilder &amp;TLB</argument>,
<argument>ExtIntTypeLoc TL</argument>)</argument_list></macro> <block>{
<expr><specifier>const</specifier> <name>ExtIntType</name> <operator>*</operator><name>EIT</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call></expr>;
<expr><name>QualType</name> <name>Result</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></expr>;

<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Result</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildExtIntType</name><argument_list>(<argument><expr><call><name><name>EIT</name><operator>-&gt;</operator><name>isUnsigned</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>EIT</name><operator>-&gt;</operator><name>getNumBits</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>TL</name><operator>.</operator><name>getNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt/></block_content></block></if></if_stmt>}</block>

<name>ExtIntTypeLoc</name> <name>NewTL</name> <operator>=</operator> <name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>ExtIntTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setNameLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Result</name></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformDependentExtIntType</name><argument_list>(
<argument>TypeLocBuilder &amp;TLB</argument>, <argument>DependentExtIntTypeLoc TL</argument>)</argument_list></macro> <block>{
<expr><specifier>const</specifier> <name>DependentExtIntType</name> <operator>*</operator><name>EIT</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call></expr>;

<expr><name>EnterExpressionEvaluationContext</name> <call><name>Unevaluated</name><argument_list>(
<argument><expr><name>SemaRef</name></expr></argument>, <argument><expr><name>Sema</name><operator>::</operator><name>ExpressionEvaluationContext</name><operator>::</operator><name>ConstantEvaluated</name></expr></argument>)</argument_list></call></expr>;
<expr><name>ExprResult</name> <name>BitsExpr</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>EIT</name><operator>-&gt;</operator><name>getNumBitsExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>BitsExpr</name> <operator>=</operator> <call><name><name>SemaRef</name><operator>.</operator><name>ActOnConstantExpression</name></name><argument_list>(<argument><expr><name>BitsExpr</name></expr></argument>)</argument_list></call></expr>;

<if_stmt><if>if <condition>(<expr><call><name><name>BitsExpr</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>QualType</name> <name>Result</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></block></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>BitsExpr</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <call><name><name>EIT</name><operator>-&gt;</operator><name>getNumBitsExpr</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Result</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildDependentExtIntType</name><argument_list>(
<argument><expr><call><name><name>EIT</name><operator>-&gt;</operator><name>isUnsigned</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>BitsExpr</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>TL</name><operator>.</operator><name>getNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>DependentExtIntType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Result</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>DependentExtIntTypeLoc</name></type> <name>NewTL</name> <init>= <expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>DependentExtIntTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setNameLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>ExtIntTypeLoc</name></type> <name>NewTL</name> <init>= <expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>ExtIntTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setNameLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>Result</name></expr>;</return>
}






template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>ArgLocContainer</name><operator>&gt;</operator>
<name>class</name> <name>TemplateArgumentLocContainerIterator</name> <block>{
<expr><name>ArgLocContainer</name> <operator>*</operator><name>Container</name></expr>;
<expr><name>unsigned</name> <name>Index</name></expr>;

<expr><name>public</name><operator>:</operator></expr>
<typedef>typedef <type><name>TemplateArgumentLoc</name></type> <name>value_type</name>;</typedef></block></expr></expr_stmt>
<typedef>typedef <type><name>TemplateArgumentLoc</name></type> <name>reference</name>;</typedef>
<typedef>typedef <type><name>int</name></type> <name>difference_type</name>;</typedef>
<typedef>typedef <expr_stmt><expr><name>std</name><operator>::</operator><name>input_iterator_tag</name> <name>iterator_category</name></expr>;</expr_stmt></typedef>

<decl_stmt><decl><type><name>class</name></type> <name>pointer</name> <block>{<block_content>
<decl_stmt><decl><type><name>TemplateArgumentLoc</name></type> <name>Arg</name></decl>;</decl_stmt>

<label><name>public</name>:</label>
<macro><name>explicit</name></macro> <macro><name>pointer</name><argument_list>(<argument>TemplateArgumentLoc Arg</argument>)</argument_list></macro> : <macro><name>Arg</name><argument_list>(<argument>Arg</argument>)</argument_list></macro> <block>{<block_content> </block_content>}</block>

<expr_stmt><expr><specifier>const</specifier> <name>TemplateArgumentLoc</name> <operator>*</operator><name><name>operator</name><operator>-&gt;</operator><name/></name>(</expr></expr_stmt>)</block_content> const <block>{<block_content>
<return>return <expr><operator>&amp;</operator><name>Arg</name></expr>;</return>
</block_content>}</block></block></decl></decl_stmt>
};


<macro><name>TemplateArgumentLocContainerIterator</name><argument_list>()</argument_list></macro> <block>{<block_content/>}</block>

<macro><name>TemplateArgumentLocContainerIterator</name><argument_list>(<argument>ArgLocContainer &amp;Container</argument>,
<argument>unsigned Index</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>Container</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Container</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Index</name><argument_list>(<argument>Index</argument>)</argument_list></macro> <expr><block>{ }</block>

<name>TemplateArgumentLocContainerIterator</name> <operator>&amp;</operator><name>operator</name><operator>++</operator><operator>(</operator><operator>)</operator> <block>{
<expr><operator>++</operator><name>Index</name></expr>;
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>TemplateArgumentLocContainerIterator</name> <name>operator</name><operator>++</operator><operator>(</operator><name>int</name><operator>)</operator> <block>{
<expr><name>TemplateArgumentLocContainerIterator</name> <call><name>Old</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>;
<expr><operator>++</operator><operator>(</operator><operator>*</operator><name>this</name><operator>)</operator></expr>;
<return>return <expr><name>Old</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>TemplateArgumentLoc</name> <name>operator</name><operator>*</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Container</name><operator>-&gt;</operator><name>getArgLoc</name></name><argument_list>(<argument><expr><name>Index</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>pointer</name> <name><name>operator</name><operator>-&gt;</operator><name/></name>(</expr></expr_stmt>) <expr_stmt><expr><specifier>const</specifier> <block>{
<return>return <expr><call><name>pointer</name><argument_list>(<argument><expr><call><name><name>Container</name><operator>-&gt;</operator><name>getArgLoc</name></name><argument_list>(<argument><expr><name>Index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>friend</name> <name>bool</name> <name>operator</name><operator>==</operator><operator>(</operator><specifier>const</specifier> <name>TemplateArgumentLocContainerIterator</name> <operator>&amp;</operator><name>X</name><operator>,</operator>
<specifier>const</specifier> <name>TemplateArgumentLocContainerIterator</name> <operator>&amp;</operator><name>Y</name><operator>)</operator> <block>{
<return>return <expr><name><name>X</name><operator>.</operator><name>Container</name></name> <operator>==</operator> <name><name>Y</name><operator>.</operator><name>Container</name></name> <operator>&amp;&amp;</operator> <name><name>X</name><operator>.</operator><name>Index</name></name> <operator>==</operator> <name><name>Y</name><operator>.</operator><name>Index</name></name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>friend</name> <name>bool</name> <name>operator</name><operator>!=</operator><operator>(</operator><specifier>const</specifier> <name>TemplateArgumentLocContainerIterator</name> <operator>&amp;</operator><name>X</name><operator>,</operator>
<specifier>const</specifier> <name>TemplateArgumentLocContainerIterator</name> <operator>&amp;</operator><name>Y</name><operator>)</operator> <block>{
<return>return <expr><operator>!</operator><operator>(</operator><name>X</name> <operator>==</operator> <name>Y</name><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>
};

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformAutoType</name><argument_list>(<argument>TypeLocBuilder &amp;TLB</argument>,
<argument>AutoTypeLoc TL</argument>)</argument_list></macro> <block>{
<expr><specifier>const</specifier> <name>AutoType</name> <operator>*</operator><name>T</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call></expr>;
<expr><name>QualType</name> <name>OldDeduced</name> <operator>=</operator> <call><name><name>T</name><operator>-&gt;</operator><name>getDeducedType</name></name><argument_list>()</argument_list></call></expr>;
<expr><name>QualType</name> <name>NewDeduced</name></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>OldDeduced</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>NewDeduced</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>OldDeduced</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>NewDeduced</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt/></block_content></block></if></if_stmt>}</block>

<name>ConceptDecl</name> <operator>*</operator><name>NewCD</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>TemplateArgumentListInfo</name></type> <name>NewTemplateArgs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>NestedNameSpecifierLoc</name></type> <name>NewNestedNameSpec</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>T</name><operator>-&gt;</operator><name>isConstrained</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>NewCD</name> <operator>=</operator> <call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>ConceptDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDecl</name><argument_list>(
<argument><expr><call><name><name>TL</name><operator>.</operator><name>getConceptNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeConstraintConcept</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name><name>NewTemplateArgs</name><operator>.</operator><name>setLAngleLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getLAngleLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTemplateArgs</name><operator>.</operator><name>setRAngleLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getRAngleLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<typedef>typedef <type><name><name>TemplateArgumentLocContainerIterator</name><argument_list type="generic">&lt;<argument><expr><name>AutoTypeLoc</name></expr></argument>&gt;</argument_list></name></type> <name>ArgIterator</name>;</typedef>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformTemplateArguments</name><argument_list>(<argument><expr><call><name>ArgIterator</name><argument_list>(<argument><expr><name>TL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>ArgIterator</name><argument_list>(<argument><expr><name>TL</name></expr></argument>,
<argument><expr><call><name><name>TL</name><operator>.</operator><name>getNumArgs</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>NewTemplateArgs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>TL</name><operator>.</operator><name>getNestedNameSpecifierLoc</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>NewNestedNameSpec</name>
<operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformNestedNameSpecifierLoc</name><argument_list>(
<argument><expr><call><name><name>TL</name><operator>.</operator><name>getNestedNameSpecifierLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>NewNestedNameSpec</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>Result</name> <init>= <expr><call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>||</operator> <name>NewDeduced</name> <operator>!=</operator> <name>OldDeduced</name> <operator>||</operator>
<call><name><name>T</name><operator>-&gt;</operator><name>isDependentType</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>T</name><operator>-&gt;</operator><name>isConstrained</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>NewArgList</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewArgList</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>NewArgList</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>&amp;</modifier></type><name>ArgLoc</name> <range>: <expr><call><name><name>NewTemplateArgs</name><operator>.</operator><name>arguments</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>NewArgList</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>ArgLoc</name><operator>.</operator><name>getArgument</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><name>Result</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildAutoType</name><argument_list>(<argument><expr><name>NewDeduced</name></expr></argument>, <argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getKeyword</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NewCD</name></expr></argument>,
<argument><expr><name>NewArgList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>AutoTypeLoc</name></type> <name>NewTL</name> <init>= <expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>AutoTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setNameLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setNestedNameSpecifierLoc</name></name><argument_list>(<argument><expr><name>NewNestedNameSpec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setTemplateKWLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getTemplateKWLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setConceptNameLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getConceptNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setFoundDecl</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getFoundDecl</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setLAngleLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getLAngleLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setRAngleLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getRAngleLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>I</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>I</name> <operator>&lt;</operator> <call><name><name>NewTL</name><operator>.</operator><name>getNumArgs</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>I</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setArgLocInfo</name></name><argument_list>(<argument><expr><name>I</name></expr></argument>, <argument><expr><call><name><name>NewTemplateArgs</name><operator>.</operator><name>arguments</name></name><argument_list>()</argument_list></call><index>[<expr><name>I</name></expr>]</index><operator>.</operator><call><name>getLocInfo</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<return>return <expr><name>Result</name></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformTemplateSpecializationType</name><argument_list>(
<argument>TypeLocBuilder &amp;TLB</argument>,
<argument>TemplateSpecializationTypeLoc TL</argument>,
<argument>TemplateName Template</argument>)</argument_list></macro> <block>{
<expr><name>TemplateArgumentListInfo</name> <name>NewTemplateArgs</name></expr>;
<expr><call><name><name>NewTemplateArgs</name><operator>.</operator><name>setLAngleLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getLAngleLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>NewTemplateArgs</name><operator>.</operator><name>setRAngleLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getRAngleLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<typedef>typedef <type><name><name>TemplateArgumentLocContainerIterator</name><argument_list type="generic">&lt;<argument><expr><name>TemplateSpecializationTypeLoc</name></expr></argument>&gt;</argument_list></name></type>
<name>ArgIterator</name>;</typedef></block></expr></expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformTemplateArguments</name><argument_list>(<argument><expr><call><name>ArgIterator</name><argument_list>(<argument><expr><name>TL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>ArgIterator</name><argument_list>(<argument><expr><name>TL</name></expr></argument>, <argument><expr><call><name><name>TL</name><operator>.</operator><name>getNumArgs</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>NewTemplateArgs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>



<decl_stmt><decl><type><name>QualType</name></type> <name>Result</name> <init>=
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildTemplateSpecializationType</name><argument_list>(<argument><expr><name>Template</name></expr></argument>,
<argument><expr><call><name><name>TL</name><operator>.</operator><name>getTemplateNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>NewTemplateArgs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>Result</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>




<if_stmt><if>if <condition>(<expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>DependentTemplateSpecializationType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Result</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>DependentTemplateSpecializationTypeLoc</name></type> <name>NewTL</name>
<init>= <expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>DependentTemplateSpecializationTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setElaboratedKeywordLoc</name></name><argument_list>(<argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setQualifierLoc</name></name><argument_list>(<argument><expr><call><name>NestedNameSpecifierLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setTemplateKeywordLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getTemplateKeywordLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setTemplateNameLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getTemplateNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setLAngleLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getLAngleLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setRAngleLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getRAngleLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>e</name> <init>= <expr><call><name><name>NewTemplateArgs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>!=</operator> <name>e</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setArgLocInfo</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>NewTemplateArgs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>getLocInfo</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<return>return <expr><name>Result</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>TemplateSpecializationTypeLoc</name></type> <name>NewTL</name>
<init>= <expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>TemplateSpecializationTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setTemplateKeywordLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getTemplateKeywordLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setTemplateNameLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getTemplateNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setLAngleLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getLAngleLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setRAngleLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getRAngleLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>e</name> <init>= <expr><call><name><name>NewTemplateArgs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>!=</operator> <name>e</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setArgLocInfo</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>NewTemplateArgs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>getLocInfo</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>Result</name></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformDependentTemplateSpecializationType</name><argument_list>(
<argument>TypeLocBuilder &amp;TLB</argument>,
<argument>DependentTemplateSpecializationTypeLoc TL</argument>,
<argument>TemplateName Template</argument>,
<argument>CXXScopeSpec &amp;SS</argument>)</argument_list></macro> <block>{
<expr><name>TemplateArgumentListInfo</name> <name>NewTemplateArgs</name></expr>;
<expr><call><name><name>NewTemplateArgs</name><operator>.</operator><name>setLAngleLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getLAngleLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>NewTemplateArgs</name><operator>.</operator><name>setRAngleLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getRAngleLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<typedef>typedef <type><name><name>TemplateArgumentLocContainerIterator</name><argument_list type="generic">&lt;
<argument><expr><name>DependentTemplateSpecializationTypeLoc</name></expr></argument>&gt;</argument_list></name></type> <name>ArgIterator</name>;</typedef></block></expr></expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformTemplateArguments</name><argument_list>(<argument><expr><call><name>ArgIterator</name><argument_list>(<argument><expr><name>TL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>ArgIterator</name><argument_list>(<argument><expr><name>TL</name></expr></argument>, <argument><expr><call><name><name>TL</name><operator>.</operator><name>getNumArgs</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>NewTemplateArgs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>



<if_stmt><if>if <condition>(<decl><type><name>DependentTemplateName</name> <modifier>*</modifier></type><name>DTN</name> <init>= <expr><call><name><name>Template</name><operator>.</operator><name>getAsDependentTemplateName</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>QualType</name></type> <name>Result</name>
<init>= <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>Context</name><operator>.</operator><name>getDependentTemplateSpecializationType</name></name><argument_list>(
<argument><expr><call><name><name>TL</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getKeyword</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>DTN</name><operator>-&gt;</operator><name>getQualifier</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>DTN</name><operator>-&gt;</operator><name>getIdentifier</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>NewTemplateArgs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>DependentTemplateSpecializationTypeLoc</name></type> <name>NewTL</name>
<init>= <expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>DependentTemplateSpecializationTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setElaboratedKeywordLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getElaboratedKeywordLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setQualifierLoc</name></name><argument_list>(<argument><expr><call><name><name>SS</name><operator>.</operator><name>getWithLocInContext</name></name><argument_list>(<argument><expr><name><name>SemaRef</name><operator>.</operator><name>Context</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setTemplateKeywordLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getTemplateKeywordLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setTemplateNameLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getTemplateNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setLAngleLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getLAngleLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setRAngleLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getRAngleLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>e</name> <init>= <expr><call><name><name>NewTemplateArgs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>!=</operator> <name>e</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setArgLocInfo</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>NewTemplateArgs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>getLocInfo</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<return>return <expr><name>Result</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>Result</name>
<init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildTemplateSpecializationType</name><argument_list>(<argument><expr><name>Template</name></expr></argument>,
<argument><expr><call><name><name>TL</name><operator>.</operator><name>getTemplateNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>NewTemplateArgs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>Result</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>TemplateSpecializationTypeLoc</name></type> <name>NewTL</name>
<init>= <expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>TemplateSpecializationTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setTemplateKeywordLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getTemplateKeywordLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setTemplateNameLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getTemplateNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setLAngleLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getLAngleLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setRAngleLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getRAngleLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>e</name> <init>= <expr><call><name><name>NewTemplateArgs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>!=</operator> <name>e</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setArgLocInfo</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>NewTemplateArgs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>getLocInfo</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>Result</name></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformElaboratedType</name><argument_list>(<argument>TypeLocBuilder &amp;TLB</argument>,
<argument>ElaboratedTypeLoc TL</argument>)</argument_list></macro> <block>{
<expr><specifier>const</specifier> <name>ElaboratedType</name> <operator>*</operator><name>T</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call></expr>;

<expr><name>NestedNameSpecifierLoc</name> <name>QualifierLoc</name></expr>;

<if_stmt><if>if <condition>(<expr><call><name><name>TL</name><operator>.</operator><name>getQualifierLoc</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>QualifierLoc</name>
<operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformNestedNameSpecifierLoc</name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getQualifierLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>QualifierLoc</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt/></block_content></block></if></if_stmt>}</block>

<name>QualType</name> <name>NamedT</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>TLB</name></expr></argument>, <argument><expr><call><name><name>TL</name><operator>.</operator><name>getNamedTypeLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>NamedT</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>





<if_stmt><if>if <condition>(<expr><call><name><name>T</name><operator>-&gt;</operator><name>getKeyword</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>ETK_None</name> <operator>&amp;&amp;</operator> <call><name><name>T</name><operator>-&gt;</operator><name>getKeyword</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>ETK_Typename</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <name>TemplateSpecializationType</name> <modifier>*</modifier></type><name>TST</name> <init>=
<expr><name><name>NamedT</name><operator>-&gt;</operator><name>getAs</name></name><operator>&lt;</operator><name>TemplateSpecializationType</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>TemplateName</name></type> <name>Template</name> <init>= <expr><call><name><name>TST</name><operator>-&gt;</operator><name>getTemplateName</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<decl><type><name>TypeAliasTemplateDecl</name> <modifier>*</modifier></type><name>TAT</name> <init>= <expr><call><name><name>dyn_cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>TypeAliasTemplateDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name><name>Template</name><operator>.</operator><name>getAsTemplateDecl</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>SemaRef</name><operator>.</operator><name>Diag</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getNamedTypeLoc</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getBeginLoc</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>diag</name><operator>::</operator><name>err_tag_reference_non_tag</name></expr></argument>)</argument_list></call>
<operator>&lt;&lt;</operator> <name>TAT</name> <operator>&lt;&lt;</operator> <name>Sema</name><operator>::</operator><name>NTK_TypeAliasTemplate</name>
<operator>&lt;&lt;</operator> <name>ElaboratedType</name><operator>::</operator><call><name>getTagTypeKindForKeyword</name><argument_list>(<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getKeyword</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>SemaRef</name><operator>.</operator><name>Diag</name></name><argument_list>(<argument><expr><call><name><name>TAT</name><operator>-&gt;</operator><name>getLocation</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>diag</name><operator>::</operator><name>note_declared_at</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>Result</name> <init>= <expr><call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>||</operator>
<name>QualifierLoc</name> <operator>!=</operator> <call><name><name>TL</name><operator>.</operator><name>getQualifierLoc</name></name><argument_list>()</argument_list></call> <operator>||</operator>
<name>NamedT</name> <operator>!=</operator> <call><name><name>T</name><operator>-&gt;</operator><name>getNamedType</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Result</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildElaboratedType</name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getElaboratedKeywordLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getKeyword</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>QualifierLoc</name></expr></argument>, <argument><expr><name>NamedT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ElaboratedTypeLoc</name></type> <name>NewTL</name> <init>= <expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>ElaboratedTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setElaboratedKeywordLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getElaboratedKeywordLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setQualifierLoc</name></name><argument_list>(<argument><expr><name>QualifierLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Result</name></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformAttributedType</name><argument_list>(
<argument>TypeLocBuilder &amp;TLB</argument>,
<argument>AttributedTypeLoc TL</argument>)</argument_list></macro> <block>{
<expr><specifier>const</specifier> <name>AttributedType</name> <operator>*</operator><name>oldType</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call></expr>;
<expr><name>QualType</name> <name>modifiedType</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>TLB</name></expr></argument>, <argument><expr><call><name><name>TL</name><operator>.</operator><name>getModifiedLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>modifiedType</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<specifier>const</specifier> <name>Attr</name> <operator>*</operator><name>oldAttr</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getAttr</name></name><argument_list>()</argument_list></call></block></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Attr</name> <modifier>*</modifier></type><name>newAttr</name> <init>= <expr><ternary><condition><expr><name>oldAttr</name></expr> ?</condition><then> <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformAttr</name><argument_list>(<argument><expr><name>oldAttr</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>nullptr</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>oldAttr</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>newAttr</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>result</name> <init>= <expr><call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>||</operator>
<name>modifiedType</name> <operator>!=</operator> <call><name><name>oldType</name><operator>-&gt;</operator><name>getModifiedType</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>


<decl_stmt><decl><type><name>QualType</name></type> <name>equivalentType</name>
<init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><call><name><name>oldType</name><operator>-&gt;</operator><name>getEquivalentType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>equivalentType</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>



<if_stmt><if>if <condition>(<decl><type><name>auto</name></type> <name>nullability</name> <init>= <expr><call><name><name>oldType</name><operator>-&gt;</operator><name>getImmediateNullability</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>modifiedType</name><operator>-&gt;</operator><name>canHaveNullability</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>SemaRef</name><operator>.</operator><name>Diag</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getAttr</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getLocation</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>diag</name><operator>::</operator><name>err_nullability_nonpointer</name></expr></argument>)</argument_list></call>
<operator>&lt;&lt;</operator> <call><name>DiagNullabilityKind</name><argument_list>(<argument><expr><operator>*</operator><name>nullability</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <name>modifiedType</name></expr>;</expr_stmt>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>getAttributedType</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getAttrKind</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>modifiedType</name></expr></argument>,
<argument><expr><name>equivalentType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>AttributedTypeLoc</name></type> <name>newTL</name> <init>= <expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>AttributedTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>result</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>newTL</name><operator>.</operator><name>setAttr</name></name><argument_list>(<argument><expr><name>newAttr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformParenType</name><argument_list>(<argument>TypeLocBuilder &amp;TLB</argument>,
<argument>ParenTypeLoc TL</argument>)</argument_list></macro> <block>{
<expr><name>QualType</name> <name>Inner</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>TLB</name></expr></argument>, <argument><expr><call><name><name>TL</name><operator>.</operator><name>getInnerLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Inner</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>QualType</name> <name>Result</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>||</operator>
<name>Inner</name> <operator>!=</operator> <call><name><name>TL</name><operator>.</operator><name>getInnerLoc</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getType</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Result</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildParenType</name><argument_list>(<argument><expr><name>Inner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ParenTypeLoc</name></type> <name>NewTL</name> <init>= <expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>ParenTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setLParenLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setRParenLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getRParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Result</name></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformMacroQualifiedType</name><argument_list>(<argument>TypeLocBuilder &amp;TLB</argument>,
<argument>MacroQualifiedTypeLoc TL</argument>)</argument_list></macro> <block>{
<expr><name>QualType</name> <name>Inner</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>TLB</name></expr></argument>, <argument><expr><call><name><name>TL</name><operator>.</operator><name>getInnerLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Inner</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>QualType</name> <name>Result</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>||</operator> <name>Inner</name> <operator>!=</operator> <call><name><name>TL</name><operator>.</operator><name>getInnerLoc</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getType</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Result</name> <operator>=</operator>
<call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildMacroQualifiedType</name><argument_list>(<argument><expr><name>Inner</name></expr></argument>, <argument><expr><call><name><name>TL</name><operator>.</operator><name>getMacroIdentifier</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>MacroQualifiedTypeLoc</name></type> <name>NewTL</name> <init>= <expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>MacroQualifiedTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setExpansionLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getExpansionLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Result</name></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformDependentNameType</name><argument_list>(
<argument>TypeLocBuilder &amp;TLB</argument>, <argument>DependentNameTypeLoc TL</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>TransformDependentNameType</name><argument_list>(<argument><expr><name>TLB</name></expr></argument>, <argument><expr><name>TL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformDependentNameType</name><argument_list>(
<argument>TypeLocBuilder &amp;TLB</argument>, <argument>DependentNameTypeLoc TL</argument>, <argument>bool DeducedTSTContext</argument>)</argument_list></macro> <block>{
<expr><specifier>const</specifier> <name>DependentNameType</name> <operator>*</operator><name>T</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call></expr>;

<expr><name>NestedNameSpecifierLoc</name> <name>QualifierLoc</name>
<operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformNestedNameSpecifierLoc</name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getQualifierLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>QualifierLoc</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>QualType</name> <name>Result</name>
<operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildDependentNameType</name><argument_list>(<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getKeyword</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>TL</name><operator>.</operator><name>getElaboratedKeywordLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>QualifierLoc</name></expr></argument>,
<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getIdentifier</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>TL</name><operator>.</operator><name>getNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>DeducedTSTContext</name></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <name>ElaboratedType</name><modifier>*</modifier></type> <name>ElabT</name> <init>= <expr><name><name>Result</name><operator>-&gt;</operator><name>getAs</name></name><operator>&lt;</operator><name>ElaboratedType</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>QualType</name></type> <name>NamedT</name> <init>= <expr><call><name><name>ElabT</name><operator>-&gt;</operator><name>getNamedType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>TLB</name><operator>.</operator><name>pushTypeSpec</name></name><argument_list>(<argument><expr><name>NamedT</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>setNameLoc</name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ElaboratedTypeLoc</name></type> <name>NewTL</name> <init>= <expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>ElaboratedTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setElaboratedKeywordLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getElaboratedKeywordLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setQualifierLoc</name></name><argument_list>(<argument><expr><name>QualifierLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>DependentNameTypeLoc</name></type> <name>NewTL</name> <init>= <expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>DependentNameTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setElaboratedKeywordLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getElaboratedKeywordLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setQualifierLoc</name></name><argument_list>(<argument><expr><name>QualifierLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setNameLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>Result</name></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator>
<macro><name>TransformDependentTemplateSpecializationType</name><argument_list>(<argument>TypeLocBuilder &amp;TLB</argument>,
<argument>DependentTemplateSpecializationTypeLoc TL</argument>)</argument_list></macro> <block>{
<expr><name>NestedNameSpecifierLoc</name> <name>QualifierLoc</name></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>TL</name><operator>.</operator><name>getQualifierLoc</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>QualifierLoc</name>
<operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformNestedNameSpecifierLoc</name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getQualifierLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>QualifierLoc</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt/></block_content></block></if></if_stmt>}</block></expr></expr_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call>
<operator>.</operator><call><name>TransformDependentTemplateSpecializationType</name><argument_list>(<argument><expr><name>TLB</name></expr></argument>, <argument><expr><name>TL</name></expr></argument>, <argument><expr><name>QualifierLoc</name></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator>
<macro><name>TransformDependentTemplateSpecializationType</name><argument_list>(<argument>TypeLocBuilder &amp;TLB</argument>,
<argument>DependentTemplateSpecializationTypeLoc TL</argument>,
<argument>NestedNameSpecifierLoc QualifierLoc</argument>)</argument_list></macro> <block>{
<expr><specifier>const</specifier> <name>DependentTemplateSpecializationType</name> <operator>*</operator><name>T</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call></expr>;

<expr><name>TemplateArgumentListInfo</name> <name>NewTemplateArgs</name></expr>;
<expr><call><name><name>NewTemplateArgs</name><operator>.</operator><name>setLAngleLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getLAngleLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>NewTemplateArgs</name><operator>.</operator><name>setRAngleLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getRAngleLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;

<typedef>typedef <type><name><name>TemplateArgumentLocContainerIterator</name><argument_list type="generic">&lt;
<argument><expr><name>DependentTemplateSpecializationTypeLoc</name></expr></argument>&gt;</argument_list></name></type> <name>ArgIterator</name>;</typedef></block></expr></expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformTemplateArguments</name><argument_list>(<argument><expr><call><name>ArgIterator</name><argument_list>(<argument><expr><name>TL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>ArgIterator</name><argument_list>(<argument><expr><name>TL</name></expr></argument>, <argument><expr><call><name><name>TL</name><operator>.</operator><name>getNumArgs</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>NewTemplateArgs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>Result</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildDependentTemplateSpecializationType</name><argument_list>(
<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getKeyword</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>QualifierLoc</name></expr></argument>, <argument><expr><call><name><name>TL</name><operator>.</operator><name>getTemplateKeywordLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getIdentifier</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>TL</name><operator>.</operator><name>getTemplateNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NewTemplateArgs</name></expr></argument>,
<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <name>ElaboratedType</name> <modifier>*</modifier></type><name>ElabT</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>ElaboratedType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Result</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>QualType</name></type> <name>NamedT</name> <init>= <expr><call><name><name>ElabT</name><operator>-&gt;</operator><name>getNamedType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>TemplateSpecializationTypeLoc</name></type> <name>NamedTL</name>
<init>= <expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>TemplateSpecializationTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>NamedT</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>NamedTL</name><operator>.</operator><name>setTemplateKeywordLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getTemplateKeywordLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NamedTL</name><operator>.</operator><name>setTemplateNameLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getTemplateNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NamedTL</name><operator>.</operator><name>setLAngleLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getLAngleLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NamedTL</name><operator>.</operator><name>setRAngleLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getRAngleLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>I</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>E</name> <init>= <expr><call><name><name>NewTemplateArgs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>I</name> <operator>!=</operator> <name>E</name></expr>;</condition> <incr><expr><operator>++</operator><name>I</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>NamedTL</name><operator>.</operator><name>setArgLocInfo</name></name><argument_list>(<argument><expr><name>I</name></expr></argument>, <argument><expr><name><name>NewTemplateArgs</name><index>[<expr><name>I</name></expr>]</index></name><operator>.</operator><call><name>getLocInfo</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>


<decl_stmt><decl><type><name>ElaboratedTypeLoc</name></type> <name>NewTL</name> <init>= <expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>ElaboratedTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setElaboratedKeywordLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getElaboratedKeywordLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setQualifierLoc</name></name><argument_list>(<argument><expr><name>QualifierLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>DependentTemplateSpecializationType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Result</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>DependentTemplateSpecializationTypeLoc</name></type> <name>SpecTL</name>
<init>= <expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>DependentTemplateSpecializationTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>SpecTL</name><operator>.</operator><name>setElaboratedKeywordLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getElaboratedKeywordLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>SpecTL</name><operator>.</operator><name>setQualifierLoc</name></name><argument_list>(<argument><expr><name>QualifierLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>SpecTL</name><operator>.</operator><name>setTemplateKeywordLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getTemplateKeywordLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>SpecTL</name><operator>.</operator><name>setTemplateNameLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getTemplateNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>SpecTL</name><operator>.</operator><name>setLAngleLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getLAngleLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>SpecTL</name><operator>.</operator><name>setRAngleLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getRAngleLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>I</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>E</name> <init>= <expr><call><name><name>NewTemplateArgs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>I</name> <operator>!=</operator> <name>E</name></expr>;</condition> <incr><expr><operator>++</operator><name>I</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>SpecTL</name><operator>.</operator><name>setArgLocInfo</name></name><argument_list>(<argument><expr><name>I</name></expr></argument>, <argument><expr><name><name>NewTemplateArgs</name><index>[<expr><name>I</name></expr>]</index></name><operator>.</operator><call><name>getLocInfo</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>TemplateSpecializationTypeLoc</name></type> <name>SpecTL</name>
<init>= <expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>TemplateSpecializationTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>SpecTL</name><operator>.</operator><name>setTemplateKeywordLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getTemplateKeywordLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>SpecTL</name><operator>.</operator><name>setTemplateNameLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getTemplateNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>SpecTL</name><operator>.</operator><name>setLAngleLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getLAngleLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>SpecTL</name><operator>.</operator><name>setRAngleLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getRAngleLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>I</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>E</name> <init>= <expr><call><name><name>NewTemplateArgs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>I</name> <operator>!=</operator> <name>E</name></expr>;</condition> <incr><expr><operator>++</operator><name>I</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>SpecTL</name><operator>.</operator><name>setArgLocInfo</name></name><argument_list>(<argument><expr><name>I</name></expr></argument>, <argument><expr><name><name>NewTemplateArgs</name><index>[<expr><name>I</name></expr>]</index></name><operator>.</operator><call><name>getLocInfo</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>Result</name></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformPackExpansionType</name><argument_list>(<argument>TypeLocBuilder &amp;TLB</argument>,
<argument>PackExpansionTypeLoc TL</argument>)</argument_list></macro> <block>{
<expr><name>QualType</name> <name>Pattern</name>
<operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>TLB</name></expr></argument>, <argument><expr><call><name><name>TL</name><operator>.</operator><name>getPatternLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Pattern</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>QualType</name> <name>Result</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>||</operator>
<name>Pattern</name> <operator>!=</operator> <call><name><name>TL</name><operator>.</operator><name>getPatternLoc</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getType</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Result</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildPackExpansionType</name><argument_list>(<argument><expr><name>Pattern</name></expr></argument>,
<argument><expr><call><name><name>TL</name><operator>.</operator><name>getPatternLoc</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSourceRange</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>TL</name><operator>.</operator><name>getEllipsisLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>TL</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getNumExpansions</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>PackExpansionTypeLoc</name></type> <name>NewT</name> <init>= <expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>PackExpansionTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>NewT</name><operator>.</operator><name>setEllipsisLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getEllipsisLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Result</name></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformObjCInterfaceType</name><argument_list>(<argument>TypeLocBuilder &amp;TLB</argument>,
<argument>ObjCInterfaceTypeLoc TL</argument>)</argument_list></macro> <block>{

<expr><call><name><name>TLB</name><operator>.</operator><name>pushFullCopy</name></name><argument_list>(<argument><expr><name>TL</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>QualType</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformObjCTypeParamType</name><argument_list>(<argument>TypeLocBuilder &amp;TLB</argument>,
<argument>ObjCTypeParamTypeLoc TL</argument>)</argument_list></macro> <block>{
<expr><specifier>const</specifier> <name>ObjCTypeParamType</name> <operator>*</operator><name>T</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call></expr>;
<expr><name>ObjCTypeParamDecl</name> <operator>*</operator><name>OTP</name> <operator>=</operator> <call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>ObjCTypeParamDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDecl</name><argument_list>(<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getDecl</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getLocation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getDecl</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>OTP</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>QualType</name> <name>Result</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>||</operator>
<name>OTP</name> <operator>!=</operator> <call><name><name>T</name><operator>-&gt;</operator><name>getDecl</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Result</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildObjCTypeParamType</name><argument_list>(<argument><expr><name>OTP</name></expr></argument>,
<argument><expr><call><name><name>TL</name><operator>.</operator><name>getProtocolLAngleLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>qual_begin</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>TL</name><operator>.</operator><name>getNumProtocols</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>TL</name><operator>.</operator><name>getProtocolLocs</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>TL</name><operator>.</operator><name>getProtocolRAngleLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ObjCTypeParamTypeLoc</name></type> <name>NewTL</name> <init>= <expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>ObjCTypeParamTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>TL</name><operator>.</operator><name>getNumProtocols</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setProtocolLAngleLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getProtocolLAngleLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><call><name><name>TL</name><operator>.</operator><name>getNumProtocols</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>!=</operator> <name>n</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setProtocolLoc</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><call><name><name>TL</name><operator>.</operator><name>getProtocolLoc</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name><name>NewTL</name><operator>.</operator><name>setProtocolRAngleLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getProtocolRAngleLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>Result</name></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformObjCObjectType</name><argument_list>(<argument>TypeLocBuilder &amp;TLB</argument>,
<argument>ObjCObjectTypeLoc TL</argument>)</argument_list></macro> <block>{

<expr><name>QualType</name> <name>BaseType</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>TLB</name></expr></argument>, <argument><expr><call><name><name>TL</name><operator>.</operator><name>getBaseLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>BaseType</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>bool</name> <name>AnyChanged</name> <operator>=</operator> <name>BaseType</name> <operator>!=</operator> <call><name><name>TL</name><operator>.</operator><name>getBaseLoc</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getType</name><argument_list>()</argument_list></call></block></expr>;</expr_stmt>


<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>TypeSourceInfo</name> <modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>NewTypeArgInfos</name></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><call><name><name>TL</name><operator>.</operator><name>getNumTypeArgs</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>!=</operator> <name>n</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TypeArgInfo</name> <init>= <expr><call><name><name>TL</name><operator>.</operator><name>getTypeArgTInfo</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TypeLoc</name></type> <name>TypeArgLoc</name> <init>= <expr><call><name><name>TypeArgInfo</name><operator>-&gt;</operator><name>getTypeLoc</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>QualType</name></type> <name>TypeArg</name> <init>= <expr><call><name><name>TypeArgInfo</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<decl><type><name>auto</name></type> <name>PackExpansionLoc</name> <init>= <expr><name><name>TypeArgLoc</name><operator>.</operator><name>getAs</name></name><operator>&lt;</operator><name>PackExpansionTypeLoc</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>)</condition> <block>{<block_content>
<expr_stmt><expr><name>AnyChanged</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>


<decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>PackExpansion</name> <init>= <expr><call><name><name>PackExpansionLoc</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call>
<operator>-&gt;</operator><call><name><name>castAs</name><argument_list type="generic">&lt;<argument><expr><name>PackExpansionType</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>UnexpandedParameterPack</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name></type> <name>Unexpanded</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>SemaRef</name><operator>.</operator><name>collectUnexpandedParameterPacks</name></name><argument_list>(<argument><expr><call><name><name>PackExpansion</name><operator>-&gt;</operator><name>getPattern</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>Unexpanded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>Unexpanded</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Pack expansion without parameter packs?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<decl_stmt><decl><type><name>TypeLoc</name></type> <name>PatternLoc</name> <init>= <expr><call><name><name>PackExpansionLoc</name><operator>.</operator><name>getPatternLoc</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>Expand</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>RetainExpansion</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></type> <name>NumExpansions</name> <init>= <expr><call><name><name>PackExpansion</name><operator>-&gt;</operator><name>getNumExpansions</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TryExpandParameterPacks</name><argument_list>(
<argument><expr><call><name><name>PackExpansionLoc</name><operator>.</operator><name>getEllipsisLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>PatternLoc</name><operator>.</operator><name>getSourceRange</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>Unexpanded</name></expr></argument>, <argument><expr><name>Expand</name></expr></argument>, <argument><expr><name>RetainExpansion</name></expr></argument>, <argument><expr><name>NumExpansions</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Expand</name></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><name>Sema</name><operator>::</operator><name>ArgumentPackSubstitutionIndexRAII</name> <call><name>SubstIndex</name><argument_list>(<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>TypeLocBuilder</name></type> <name>TypeArgBuilder</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>TypeArgBuilder</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>PatternLoc</name><operator>.</operator><name>getFullDataSize</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>QualType</name></type> <name>NewPatternType</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>TypeArgBuilder</name></expr></argument>,
<argument><expr><name>PatternLoc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>NewPatternType</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>NewExpansionType</name> <init>= <expr><call><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>getPackExpansionType</name></name><argument_list>(
<argument><expr><name>NewPatternType</name></expr></argument>, <argument><expr><name>NumExpansions</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>auto</name></type> <name>NewExpansionLoc</name> <init>= <expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>PackExpansionTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>NewExpansionType</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>NewExpansionLoc</name><operator>.</operator><name>setEllipsisLoc</name></name><argument_list>(<argument><expr><call><name><name>PackExpansionLoc</name><operator>.</operator><name>getEllipsisLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewTypeArgInfos</name><operator>.</operator><name>push_back</name></name><argument_list>(
<argument><expr><call><name><name>TypeArgBuilder</name><operator>.</operator><name>getTypeSourceInfo</name></name><argument_list>(<argument><expr><name><name>SemaRef</name><operator>.</operator><name>Context</name></name></expr></argument>, <argument><expr><name>NewExpansionType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>



<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>ArgIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>ArgIdx</name> <operator>!=</operator> <operator>*</operator><name>NumExpansions</name></expr>;</condition> <incr><expr><operator>++</operator><name>ArgIdx</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>Sema</name><operator>::</operator><name>ArgumentPackSubstitutionIndexRAII</name> <call><name>SubstIndex</name><argument_list>(<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ArgIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>TypeLocBuilder</name></type> <name>TypeArgBuilder</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>TypeArgBuilder</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>PatternLoc</name><operator>.</operator><name>getFullDataSize</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>NewTypeArg</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>TypeArgBuilder</name></expr></argument>,
<argument><expr><name>PatternLoc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>NewTypeArg</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name><name>NewTypeArgInfos</name><operator>.</operator><name>push_back</name></name><argument_list>(
<argument><expr><call><name><name>TypeArgBuilder</name><operator>.</operator><name>getTypeSourceInfo</name></name><argument_list>(<argument><expr><name><name>SemaRef</name><operator>.</operator><name>Context</name></name></expr></argument>, <argument><expr><name>NewTypeArg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>TypeLocBuilder</name></type> <name>TypeArgBuilder</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>TypeArgBuilder</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>TypeArgLoc</name><operator>.</operator><name>getFullDataSize</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>QualType</name></type> <name>NewTypeArg</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>TypeArgBuilder</name></expr></argument>, <argument><expr><name>TypeArgLoc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>NewTypeArg</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>NewTypeArg</name> <operator>==</operator> <name>TypeArg</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>NewTypeArgInfos</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>TypeArgInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name><name>NewTypeArgInfos</name><operator>.</operator><name>push_back</name></name><argument_list>(
<argument><expr><call><name><name>TypeArgBuilder</name><operator>.</operator><name>getTypeSourceInfo</name></name><argument_list>(<argument><expr><name><name>SemaRef</name><operator>.</operator><name>Context</name></name></expr></argument>, <argument><expr><name>NewTypeArg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>AnyChanged</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></for>

<decl_stmt><decl><type><name>QualType</name></type> <name>Result</name> <init>= <expr><call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>||</operator> <name>AnyChanged</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>Result</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildObjCObjectType</name><argument_list>(
<argument><expr><name>BaseType</name></expr></argument>, <argument><expr><call><name><name>TL</name><operator>.</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>TL</name><operator>.</operator><name>getTypeArgsLAngleLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NewTypeArgInfos</name></expr></argument>,
<argument><expr><call><name><name>TL</name><operator>.</operator><name>getTypeArgsRAngleLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>TL</name><operator>.</operator><name>getProtocolLAngleLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>qual_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>TL</name><operator>.</operator><name>getNumProtocols</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>TL</name><operator>.</operator><name>getProtocolLocs</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>TL</name><operator>.</operator><name>getProtocolRAngleLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ObjCObjectTypeLoc</name></type> <name>NewT</name> <init>= <expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>ObjCObjectTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>NewT</name><operator>.</operator><name>setHasBaseTypeAsWritten</name></name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewT</name><operator>.</operator><name>setTypeArgsLAngleLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getTypeArgsLAngleLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><call><name><name>TL</name><operator>.</operator><name>getNumTypeArgs</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>!=</operator> <name>n</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>NewT</name><operator>.</operator><name>setTypeArgTInfo</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>NewTypeArgInfos</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name><name>NewT</name><operator>.</operator><name>setTypeArgsRAngleLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getTypeArgsRAngleLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>NewT</name><operator>.</operator><name>setProtocolLAngleLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getProtocolLAngleLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><call><name><name>TL</name><operator>.</operator><name>getNumProtocols</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>!=</operator> <name>n</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>NewT</name><operator>.</operator><name>setProtocolLoc</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><call><name><name>TL</name><operator>.</operator><name>getProtocolLoc</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name><name>NewT</name><operator>.</operator><name>setProtocolRAngleLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getProtocolRAngleLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Result</name></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformObjCObjectPointerType</name><argument_list>(<argument>TypeLocBuilder &amp;TLB</argument>,
<argument>ObjCObjectPointerTypeLoc TL</argument>)</argument_list></macro> <block>{
<expr><name>QualType</name> <name>PointeeType</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>TLB</name></expr></argument>, <argument><expr><call><name><name>TL</name><operator>.</operator><name>getPointeeLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>PointeeType</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>QualType</name> <name>Result</name> <operator>=</operator> <call><name><name>TL</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>||</operator>
<name>PointeeType</name> <operator>!=</operator> <call><name><name>TL</name><operator>.</operator><name>getPointeeLoc</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getType</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Result</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildObjCObjectPointerType</name><argument_list>(<argument><expr><name>PointeeType</name></expr></argument>,
<argument><expr><call><name><name>TL</name><operator>.</operator><name>getStarLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ObjCObjectPointerTypeLoc</name></type> <name>NewT</name> <init>= <expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>ObjCObjectPointerTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>Result</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>NewT</name><operator>.</operator><name>setStarLoc</name></name><argument_list>(<argument><expr><call><name><name>TL</name><operator>.</operator><name>getStarLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Result</name></expr>;</return>
}




template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformNullStmt</name><argument_list>(<argument>NullStmt *S</argument>)</argument_list></macro> <block>{
<return>return <expr><name>S</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformCompoundStmt</name><argument_list>(<argument>CompoundStmt *S</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformCompoundStmt</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformCompoundStmt</name><argument_list>(<argument>CompoundStmt *S</argument>,
<argument>bool IsStmtExpr</argument>)</argument_list></macro> <block>{
<expr><name>Sema</name><operator>::</operator><name>CompoundScopeRAII</name> <call><name>CompoundScope</name><argument_list>(<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;

<expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>ExprResult</name> <operator>=</operator> <call><name><name>S</name><operator>-&gt;</operator><name>getStmtExprResult</name></name><argument_list>()</argument_list></call></expr>;
<expr><name>bool</name> <name>SubStmtInvalid</name> <operator>=</operator> <name>false</name></expr>;
<expr><name>bool</name> <name>SubStmtChanged</name> <operator>=</operator> <name>false</name></expr>;
<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name><operator>*</operator></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name> <name>Statements</name></expr>;
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>B</name> <operator>:</operator> <call><name><name>S</name><operator>-&gt;</operator><name>body</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>StmtResult</name></type> <name>Result</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformStmt</name><argument_list>(
<argument><expr><name>B</name></expr></argument>, <argument><expr><ternary><condition><expr><name>IsStmtExpr</name> <operator>&amp;&amp;</operator> <name>B</name> <operator>==</operator> <name>ExprResult</name></expr> ?</condition><then> <expr><name>SDK_StmtExprResult</name></expr> </then><else>: <expr><name>SDK_Discarded</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>DeclStmt</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name>SubStmtInvalid</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<continue>continue;</continue>
<expr_stmt/></block_content></block></if></if_stmt></block_content></block></for>}</block>

<name>SubStmtChanged</name> <operator>=</operator> <name>SubStmtChanged</name> <operator>||</operator> <call><name><name>Result</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>B</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Statements</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name><name>Result</name><operator>.</operator><name>getAs</name></name><operator>&lt;</operator><name>Stmt</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}

if <expr_stmt><expr><operator>(</operator><name>SubStmtInvalid</name><operator>)</operator></expr></expr_stmt>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><name>SubStmtChanged</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>S</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildCompoundStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getLBracLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>Statements</name></expr></argument>,
<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getRBracLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>IsStmtExpr</name></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformCaseStmt</name><argument_list>(<argument>CaseStmt *S</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>LHS</name></expr>, <expr><name>RHS</name></expr>;
<expr><block>{
<expr><name>EnterExpressionEvaluationContext</name> <call><name>Unevaluated</name><argument_list>(
<argument><expr><name>SemaRef</name></expr></argument>, <argument><expr><name>Sema</name><operator>::</operator><name>ExpressionEvaluationContext</name><operator>::</operator><name>ConstantEvaluated</name></expr></argument>)</argument_list></call></expr>;


<expr><name>LHS</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getLHS</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>LHS</name> <operator>=</operator> <call><name><name>SemaRef</name><operator>.</operator><name>ActOnCaseExpr</name></name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getCaseLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>LHS</name></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>LHS</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<name>RHS</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getRHS</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></block></expr>;
<expr><name>RHS</name> <operator>=</operator> <call><name><name>SemaRef</name><operator>.</operator><name>ActOnCaseExpr</name></name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getCaseLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>RHS</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
}</block></expr></expr_stmt>




<decl_stmt><decl><type><name>StmtResult</name></type> <name>Case</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildCaseStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getCaseLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>LHS</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getEllipsisLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>RHS</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getColonLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Case</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<decl_stmt><decl><type><name>StmtResult</name></type> <name>SubStmt</name> <init>=
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getSubStmt</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>SubStmt</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildCaseStmtBody</name><argument_list>(<argument><expr><call><name><name>Case</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>SubStmt</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>StmtResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformDefaultStmt</name><argument_list>(<argument>DefaultStmt *S</argument>)</argument_list></macro> <block>{

<expr><name>StmtResult</name> <name>SubStmt</name> <operator>=</operator>
<call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getSubStmt</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>SubStmt</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>


<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildDefaultStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getDefaultLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getColonLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>SubStmt</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformLabelStmt</name><argument_list>(<argument>LabelStmt *S</argument>, <argument>StmtDiscardKind SDK</argument>)</argument_list></macro> <block>{
<expr><name>StmtResult</name> <name>SubStmt</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getSubStmt</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SDK</name></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>SubStmt</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>Decl</name> <operator>*</operator><name>LD</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDecl</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getDecl</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getLocation</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getDecl</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>LD</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><name>LD</name> <operator>==</operator> <call><name><name>S</name><operator>-&gt;</operator><name>getDecl</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>S</name><operator>-&gt;</operator><name>getDecl</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>setStmt</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildLabelStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getIdentLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>LabelDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>LD</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>SubStmt</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<specifier>const</specifier> <name>Attr</name> <operator>*</operator><name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformAttr</name><argument_list>(<argument>const Attr *R</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>R</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>R</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<switch>switch <condition>(<expr><call><name><name>R</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ATTR</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRAGMA_SPELLING_ATTR</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case attr::X: return getDerived().Transform##X##Attr(cast&lt;X##Attr&gt;(R));</cpp:value></cpp:define>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/AttrList.inc"</cpp:file></cpp:include>
<default>default:</default>
<return>return <expr><name>R</name></expr>;</return>
</block_content>}</block></switch>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformAttributedStmt</name><argument_list>(<argument>AttributedStmt *S</argument>,
<argument>StmtDiscardKind SDK</argument>)</argument_list></macro> <block>{
<expr><name>bool</name> <name>AttrsChanged</name> <operator>=</operator> <name>false</name></expr>;
<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Attr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>&gt;</argument_list></name> <name>Attrs</name></expr>;


<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>I</name> <range>: <expr><call><name><name>S</name><operator>-&gt;</operator><name>getAttrs</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>Attr</name> <modifier>*</modifier></type><name>R</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformAttr</name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>AttrsChanged</name> <operator>|=</operator> <operator>(</operator><name>I</name> <operator>!=</operator> <name>R</name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>R</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>Attrs</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>R</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt/></block_content></block></for>}</block>

<name>StmtResult</name> <name>SubStmt</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getSubStmt</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SDK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>SubStmt</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>SubStmt</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>S</name><operator>-&gt;</operator><name>getSubStmt</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>AttrsChanged</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>S</name></expr>;</return></block_content></block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><call><name><name>Attrs</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>SubStmt</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildAttributedStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getAttrLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Attrs</name></expr></argument>,
<argument><expr><call><name><name>SubStmt</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformIfStmt</name><argument_list>(<argument>IfStmt *S</argument>)</argument_list></macro> <block>{

<expr><name>StmtResult</name> <name>Init</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getInit</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Init</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<name>Sema</name><operator>::</operator><name>ConditionResult</name> <name>Cond</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformCondition</name><argument_list>(
<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getIfLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getConditionVariable</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getCond</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><ternary><condition><expr><call><name><name>S</name><operator>-&gt;</operator><name>isConstexpr</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>Sema</name><operator>::</operator><name>ConditionKind</name><operator>::</operator><name>ConstexprIf</name></expr>
</then><else>: <expr><name>Sema</name><operator>::</operator><name>ConditionKind</name><operator>::</operator><name>Boolean</name></expr></else></ternary></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Cond</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <name>ConstexprConditionValue</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>S</name><operator>-&gt;</operator><name>isConstexpr</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ConstexprConditionValue</name> <operator>=</operator> <call><name><name>Cond</name><operator>.</operator><name>getKnownValue</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<decl_stmt><decl><type><name>StmtResult</name></type> <name>Then</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ConstexprConditionValue</name> <operator>||</operator> <operator>*</operator><name>ConstexprConditionValue</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Then</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getThen</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Then</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>Then</name> <operator>=</operator> <macro><name>new</name> <argument_list>(<argument>getSema().Context</argument>)</argument_list></macro> <call><name>NullStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getThen</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getBeginLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<decl_stmt><decl><type><name>StmtResult</name></type> <name>Else</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ConstexprConditionValue</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>ConstexprConditionValue</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Else</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getElse</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Else</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>Init</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>S</name><operator>-&gt;</operator><name>getInit</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>Cond</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>std</name><operator>::</operator><call><name>make_pair</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getConditionVariable</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getCond</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>Then</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>S</name><operator>-&gt;</operator><name>getThen</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>Else</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>S</name><operator>-&gt;</operator><name>getElse</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>S</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildIfStmt</name><argument_list>(
<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getIfLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>isConstexpr</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Cond</name></expr></argument>,
<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getRParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Init</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Then</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getElseLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Else</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformSwitchStmt</name><argument_list>(<argument>SwitchStmt *S</argument>)</argument_list></macro> <block>{

<expr><name>StmtResult</name> <name>Init</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getInit</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Init</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<name>Sema</name><operator>::</operator><name>ConditionResult</name> <name>Cond</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformCondition</name><argument_list>(
<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getSwitchLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getConditionVariable</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getCond</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>Sema</name><operator>::</operator><name>ConditionKind</name><operator>::</operator><name>Switch</name></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Cond</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<decl_stmt><decl><type><name>StmtResult</name></type> <name>Switch</name> <init>=
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildSwitchStmtStart</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getSwitchLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Init</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Cond</name></expr></argument>, <argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getRParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Switch</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<decl_stmt><decl><type><name>StmtResult</name></type> <name>Body</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getBody</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Body</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildSwitchStmtBody</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getSwitchLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Switch</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Body</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformWhileStmt</name><argument_list>(<argument>WhileStmt *S</argument>)</argument_list></macro> <block>{

<expr><name>Sema</name><operator>::</operator><name>ConditionResult</name> <name>Cond</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformCondition</name><argument_list>(
<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getWhileLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getConditionVariable</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getCond</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>Sema</name><operator>::</operator><name>ConditionKind</name><operator>::</operator><name>Boolean</name></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Cond</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<name>StmtResult</name> <name>Body</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getBody</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Body</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>Cond</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>std</name><operator>::</operator><call><name>make_pair</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getConditionVariable</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getCond</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>Body</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>S</name><operator>-&gt;</operator><name>getBody</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>Owned</name><argument_list>(<argument><expr><name>S</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildWhileStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getWhileLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>Cond</name></expr></argument>, <argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getRParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Body</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformDoStmt</name><argument_list>(<argument>DoStmt *S</argument>)</argument_list></macro> <block>{

<expr><name>StmtResult</name> <name>Body</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getBody</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Body</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<name>ExprResult</name> <name>Cond</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getCond</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Cond</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>Cond</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>S</name><operator>-&gt;</operator><name>getCond</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>Body</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>S</name><operator>-&gt;</operator><name>getBody</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>S</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildDoStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getDoLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Body</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getWhileLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getWhileLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Cond</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getRParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformForStmt</name><argument_list>(<argument>ForStmt *S</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getLangOpts</name><argument_list>()</argument_list></call><operator>.</operator><name>OpenMP</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>startOpenMPLoop</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<name>StmtResult</name> <name>Init</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getInit</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Init</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getLangOpts</name><argument_list>()</argument_list></call><operator>.</operator><name>OpenMP</name> <operator>&amp;&amp;</operator> <call><name><name>Init</name><operator>.</operator><name>isUsable</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPLoopInitialization</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getForLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Init</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><name>Sema</name><operator>::</operator><name>ConditionResult</name> <name>Cond</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformCondition</name><argument_list>(
<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getForLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getConditionVariable</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getCond</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>Sema</name><operator>::</operator><name>ConditionKind</name><operator>::</operator><name>Boolean</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Cond</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<decl_stmt><decl><type><name>ExprResult</name></type> <name>Inc</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getInc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Inc</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>Sema</name><operator>::</operator><name>FullExprArg</name> <call><name>FullInc</name><argument_list>(<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>MakeFullDiscardedValueExpr</name><argument_list>(<argument><expr><call><name><name>Inc</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>S</name><operator>-&gt;</operator><name>getInc</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>FullInc</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<decl_stmt><decl><type><name>StmtResult</name></type> <name>Body</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getBody</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Body</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>Init</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>S</name><operator>-&gt;</operator><name>getInit</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>Cond</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>std</name><operator>::</operator><call><name>make_pair</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getConditionVariable</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getCond</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>Inc</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>S</name><operator>-&gt;</operator><name>getInc</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>Body</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>S</name><operator>-&gt;</operator><name>getBody</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>S</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildForStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getForLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Init</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Cond</name></expr></argument>, <argument><expr><name>FullInc</name></expr></argument>,
<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getRParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Body</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformGotoStmt</name><argument_list>(<argument>GotoStmt *S</argument>)</argument_list></macro> <block>{
<expr><name>Decl</name> <operator>*</operator><name>LD</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDecl</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getLabel</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getLocation</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getLabel</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>LD</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>


<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildGotoStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getGotoLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getLabelLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>LabelDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>LD</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformIndirectGotoStmt</name><argument_list>(<argument>IndirectGotoStmt *S</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>Target</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getTarget</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Target</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<name>Target</name> <operator>=</operator> <call><name><name>SemaRef</name><operator>.</operator><name>MaybeCreateExprWithCleanups</name></name><argument_list>(<argument><expr><call><name><name>Target</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>Target</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>S</name><operator>-&gt;</operator><name>getTarget</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>S</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildIndirectGotoStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getGotoLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getStarLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Target</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformContinueStmt</name><argument_list>(<argument>ContinueStmt *S</argument>)</argument_list></macro> <block>{
<return>return <expr><name>S</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformBreakStmt</name><argument_list>(<argument>BreakStmt *S</argument>)</argument_list></macro> <block>{
<return>return <expr><name>S</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformReturnStmt</name><argument_list>(<argument>ReturnStmt *S</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>Result</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformInitializer</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getRetValue</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>



<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildReturnStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getReturnLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Result</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformDeclStmt</name><argument_list>(<argument>DeclStmt *S</argument>)</argument_list></macro> <block>{
<expr><name>bool</name> <name>DeclChanged</name> <operator>=</operator> <name>false</name></expr>;
<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>Decls</name></expr>;
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>D</name> <operator>:</operator> <call><name><name>S</name><operator>-&gt;</operator><name>decls</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>Decl</name> <modifier>*</modifier></type><name>Transformed</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDefinition</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getLocation</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Transformed</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>Transformed</name> <operator>!=</operator> <name>D</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>DeclChanged</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name><name>Decls</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>Transformed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></for>}</block></expr></expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>DeclChanged</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>S</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildDeclStmt</name><argument_list>(<argument><expr><name>Decls</name></expr></argument>, <argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformGCCAsmStmt</name><argument_list>(<argument>GCCAsmStmt *S</argument>)</argument_list></macro> <block>{

<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name><operator>*</operator></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name> <name>Constraints</name></expr>;
<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name><operator>*</operator></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name> <name>Exprs</name></expr>;
<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>IdentifierInfo</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>Names</name></expr>;

<expr><name>ExprResult</name> <name>AsmString</name></expr>;
<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name><operator>*</operator></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name> <name>Clobbers</name></expr>;

<expr><name>bool</name> <name>ExprsChanged</name> <operator>=</operator> <name>false</name></expr>;


<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>I</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>E</name> <init>= <expr><call><name><name>S</name><operator>-&gt;</operator><name>getNumOutputs</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>I</name> <operator>!=</operator> <name>E</name></expr>;</condition> <incr><expr><operator>++</operator><name>I</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name><name>Names</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getOutputIdentifier</name></name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name><name>Constraints</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getOutputConstraintLiteral</name></name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>OutputExpr</name> <init>= <expr><call><name><name>S</name><operator>-&gt;</operator><name>getOutputExpr</name></name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>Result</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><name>OutputExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ExprsChanged</name> <operator>|=</operator> <call><name><name>Result</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>OutputExpr</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name><name>Exprs</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>Result</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></for>}</block></expr></expr_stmt>


<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>I</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>E</name> <init>= <expr><call><name><name>S</name><operator>-&gt;</operator><name>getNumInputs</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>I</name> <operator>!=</operator> <name>E</name></expr>;</condition> <incr><expr><operator>++</operator><name>I</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name><name>Names</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getInputIdentifier</name></name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name><name>Constraints</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getInputConstraintLiteral</name></name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>InputExpr</name> <init>= <expr><call><name><name>S</name><operator>-&gt;</operator><name>getInputExpr</name></name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>Result</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><name>InputExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ExprsChanged</name> <operator>|=</operator> <call><name><name>Result</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>InputExpr</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name><name>Exprs</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>Result</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>


<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>I</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>E</name> <init>= <expr><call><name><name>S</name><operator>-&gt;</operator><name>getNumLabels</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>I</name> <operator>!=</operator> <name>E</name></expr>;</condition> <incr><expr><operator>++</operator><name>I</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name><name>Names</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getLabelIdentifier</name></name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ExprResult</name></type> <name>Result</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getLabelExpr</name></name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ExprsChanged</name> <operator>|=</operator> <call><name><name>Result</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <call><name><name>S</name><operator>-&gt;</operator><name>getLabelExpr</name></name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Exprs</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>Result</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>ExprsChanged</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>S</name></expr>;</return></block_content></block></if></if_stmt>


<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>I</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>E</name> <init>= <expr><call><name><name>S</name><operator>-&gt;</operator><name>getNumClobbers</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>I</name> <operator>!=</operator> <name>E</name></expr>;</condition> <incr><expr><operator>++</operator><name>I</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>Clobbers</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getClobberStringLiteral</name></name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>


<expr_stmt><expr><name>AsmString</name> <operator>=</operator> <call><name><name>S</name><operator>-&gt;</operator><name>getAsmString</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildGCCAsmStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getAsmLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>isSimple</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>isVolatile</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getNumOutputs</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getNumInputs</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Names</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>Constraints</name></expr></argument>, <argument><expr><name>Exprs</name></expr></argument>, <argument><expr><call><name><name>AsmString</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>Clobbers</name></expr></argument>, <argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getNumLabels</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getRParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformMSAsmStmt</name><argument_list>(<argument>MSAsmStmt *S</argument>)</argument_list></macro> <block>{
<expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Token</name></expr></argument>&gt;</argument_list></name> <name>AsmToks</name> <operator>=</operator>
<name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getAsmToks</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getNumAsmToks</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;

<expr><name>bool</name> <name>HadError</name> <operator>=</operator> <name>false</name></expr>, <expr><name>HadChange</name> <operator>=</operator> <name>false</name></expr>;

<expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <name>SrcExprs</name> <operator>=</operator> <call><name><name>S</name><operator>-&gt;</operator><name>getAllExprs</name></name><argument_list>()</argument_list></call></expr>;
<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name><operator>*</operator></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name> <name>TransformedExprs</name></expr>;
<expr><call><name><name>TransformedExprs</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>SrcExprs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>e</name> <init>= <expr><call><name><name>SrcExprs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>!=</operator> <name>e</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>Result</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><name><name>SrcExprs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>Result</name><operator>.</operator><name>isUsable</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>HadError</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt/></block_content></block></if></if_stmt></block_content></block></for>}</block></expr></expr_stmt> <if_stmt><else>else <block>{<block_content>
<expr_stmt><expr><name>HadChange</name> <operator>|=</operator> <operator>(</operator><call><name><name>Result</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name><name>SrcExprs</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>TransformedExprs</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>Result</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
}

if <expr_stmt><expr><operator>(</operator><name>HadError</name><operator>)</operator></expr></expr_stmt> <return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>HadChange</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>Owned</name><argument_list>(<argument><expr><name>S</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildMSAsmStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getAsmLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getLBraceLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>AsmToks</name></expr></argument>, <argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getAsmString</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getNumOutputs</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getNumInputs</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getAllConstraints</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getClobbers</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>TransformedExprs</name></expr></argument>, <argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}



template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformCoroutineBodyStmt</name><argument_list>(<argument>CoroutineBodyStmt *S</argument>)</argument_list></macro> <block>{
<expr><name>auto</name> <operator>*</operator><name>ScopeInfo</name> <operator>=</operator> <call><name><name>SemaRef</name><operator>.</operator><name>getCurFunction</name></name><argument_list>()</argument_list></call></expr>;
<expr><name>auto</name> <operator>*</operator><name>FD</name> <operator>=</operator> <call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>FunctionDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SemaRef</name><operator>.</operator><name>CurContext</name></name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><name>FD</name> <operator>&amp;&amp;</operator> <name>ScopeInfo</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>ScopeInfo</name><operator>-&gt;</operator><name>CoroutinePromise</name></name> <operator>&amp;&amp;</operator>
<name><name>ScopeInfo</name><operator>-&gt;</operator><name>NeedsCoroutineSuspends</name></name> <operator>&amp;&amp;</operator>
<name><name>ScopeInfo</name><operator>-&gt;</operator><name>CoroutineSuspends</name><operator>.</operator><name>first</name></name> <operator>==</operator> <name>nullptr</name> <operator>&amp;&amp;</operator>
<name><name>ScopeInfo</name><operator>-&gt;</operator><name>CoroutineSuspends</name><operator>.</operator><name>second</name></name> <operator>==</operator> <name>nullptr</name> <operator>&amp;&amp;</operator>
<literal type="string">"expected clean scope info"</literal></expr></argument>)</argument_list></call></expr>;



<expr><call><name><name>ScopeInfo</name><operator>-&gt;</operator><name>setNeedsCoroutineSuspends</name></name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;







<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>SemaRef</name><operator>.</operator><name>buildCoroutineParameterMoves</name></name><argument_list>(<argument><expr><call><name><name>FD</name><operator>-&gt;</operator><name>getLocation</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<name>auto</name> <operator>*</operator><name>Promise</name> <operator>=</operator> <call><name><name>SemaRef</name><operator>.</operator><name>buildCoroutinePromise</name></name><argument_list>(<argument><expr><call><name><name>FD</name><operator>-&gt;</operator><name>getLocation</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Promise</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><macro><name>transformedLocalDecl</name><argument_list>(<argument>S-&gt;getPromiseDecl()</argument>, <argument>{Promise}</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ScopeInfo</name><operator>-&gt;</operator><name>CoroutinePromise</name></name> <operator>=</operator> <name>Promise</name></expr>;</expr_stmt>




<decl_stmt><decl><type><name>StmtResult</name></type> <name>InitSuspend</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getInitSuspendStmt</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>InitSuspend</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>StmtResult</name></type> <name>FinalSuspend</name> <init>=
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getFinalSuspendStmt</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>FinalSuspend</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call> <operator>||</operator>
<operator>!</operator><call><name><name>SemaRef</name><operator>.</operator><name>checkFinalSuspendNoThrow</name></name><argument_list>(<argument><expr><call><name><name>FinalSuspend</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>ScopeInfo</name><operator>-&gt;</operator><name>setCoroutineSuspends</name></name><argument_list>(<argument><expr><call><name><name>InitSuspend</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>FinalSuspend</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>InitSuspend</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>FinalSuspend</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>StmtResult</name></type> <name>BodyRes</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getBody</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>BodyRes</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>CoroutineStmtBuilder</name></type> <name>Builder</name><argument_list>(<argument><expr><name>SemaRef</name></expr></argument>, <argument><expr><operator>*</operator><name>FD</name></expr></argument>, <argument><expr><operator>*</operator><name>ScopeInfo</name></expr></argument>, <argument><expr><call><name><name>BodyRes</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Builder</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>ReturnObject</name> <init>= <expr><call><name><name>S</name><operator>-&gt;</operator><name>getReturnValueInit</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ReturnObject</name> <operator>&amp;&amp;</operator> <literal type="string">"the return object is expected to be valid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>Res</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformInitializer</name><argument_list>(<argument><expr><name>ReturnObject</name></expr></argument>,
<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Res</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>Builder</name><operator>.</operator><name>ReturnValue</name></name> <operator>=</operator> <call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>




<if_stmt><if>if <condition>(<expr><call><name><name>S</name><operator>-&gt;</operator><name>hasDependentPromiseType</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>Promise</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isDependentType</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>S</name><operator>-&gt;</operator><name>getFallthroughHandler</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>S</name><operator>-&gt;</operator><name>getExceptionHandler</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name><name>S</name><operator>-&gt;</operator><name>getReturnStmtOnAllocFailure</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>S</name><operator>-&gt;</operator><name>getDeallocate</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"these nodes should not have been built yet"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>Builder</name><operator>.</operator><name>buildDependentStatements</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>OnFallthrough</name> <operator>=</operator> <call><name><name>S</name><operator>-&gt;</operator><name>getFallthroughHandler</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>StmtResult</name></type> <name>Res</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformStmt</name><argument_list>(<argument><expr><name>OnFallthrough</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Res</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>Builder</name><operator>.</operator><name>OnFallthrough</name></name> <operator>=</operator> <call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>OnException</name> <operator>=</operator> <call><name><name>S</name><operator>-&gt;</operator><name>getExceptionHandler</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>StmtResult</name></type> <name>Res</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformStmt</name><argument_list>(<argument><expr><name>OnException</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Res</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>Builder</name><operator>.</operator><name>OnException</name></name> <operator>=</operator> <call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>OnAllocFailure</name> <operator>=</operator> <call><name><name>S</name><operator>-&gt;</operator><name>getReturnStmtOnAllocFailure</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>StmtResult</name></type> <name>Res</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformStmt</name><argument_list>(<argument><expr><name>OnAllocFailure</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Res</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>Builder</name><operator>.</operator><name>ReturnStmtOnAllocFailure</name></name> <operator>=</operator> <call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getAllocate</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>S</name><operator>-&gt;</operator><name>getDeallocate</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"allocation and deallocation calls must already be built"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>AllocRes</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getAllocate</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>AllocRes</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>Builder</name><operator>.</operator><name>Allocate</name></name> <operator>=</operator> <call><name><name>AllocRes</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ExprResult</name></type> <name>DeallocRes</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getDeallocate</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>DeallocRes</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>Builder</name><operator>.</operator><name>Deallocate</name></name> <operator>=</operator> <call><name><name>DeallocRes</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getResultDecl</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"ResultDecl must already be built"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>StmtResult</name></type> <name>ResultDecl</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getResultDecl</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>ResultDecl</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>Builder</name><operator>.</operator><name>ResultDecl</name></name> <operator>=</operator> <call><name><name>ResultDecl</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>ReturnStmt</name> <operator>=</operator> <call><name><name>S</name><operator>-&gt;</operator><name>getReturnStmt</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>StmtResult</name></type> <name>Res</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformStmt</name><argument_list>(<argument><expr><name>ReturnStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Res</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>Builder</name><operator>.</operator><name>ReturnStmt</name></name> <operator>=</operator> <call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildCoroutineBodyStmt</name><argument_list>(<argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformCoreturnStmt</name><argument_list>(<argument>CoreturnStmt *S</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>Result</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformInitializer</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getOperand</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>



<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildCoreturnStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getKeywordLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Result</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>isImplicit</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformCoawaitExpr</name><argument_list>(<argument>CoawaitExpr *E</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>Result</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformInitializer</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getOperand</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>



<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildCoawaitExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getKeywordLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Result</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>isImplicit</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformDependentCoawaitExpr</name><argument_list>(<argument>DependentCoawaitExpr *E</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>OperandResult</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformInitializer</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getOperand</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>OperandResult</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>ExprResult</name> <name>LookupResult</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformUnresolvedLookupExpr</name><argument_list>(
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getOperatorCoawaitLookup</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>LookupResult</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>



<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildDependentCoawaitExpr</name><argument_list>(
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getKeywordLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>OperandResult</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>UnresolvedLookupExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>LookupResult</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformCoyieldExpr</name><argument_list>(<argument>CoyieldExpr *E</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>Result</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformInitializer</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getOperand</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>



<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildCoyieldExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getKeywordLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Result</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}



template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformObjCAtTryStmt</name><argument_list>(<argument>ObjCAtTryStmt *S</argument>)</argument_list></macro> <block>{

<expr><name>StmtResult</name> <name>TryBody</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getTryBody</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>TryBody</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<name>bool</name> <name>AnyCatchChanged</name> <operator>=</operator> <name>false</name></block></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name><modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name></type> <name>CatchStmts</name></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>I</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>N</name> <init>= <expr><call><name><name>S</name><operator>-&gt;</operator><name>getNumCatchStmts</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>I</name> <operator>!=</operator> <name>N</name></expr>;</condition> <incr><expr><operator>++</operator><name>I</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>StmtResult</name></type> <name>Catch</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getCatchStmt</name></name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Catch</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Catch</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <call><name><name>S</name><operator>-&gt;</operator><name>getCatchStmt</name></name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>AnyCatchChanged</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>CatchStmts</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>Catch</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>


<decl_stmt><decl><type><name>StmtResult</name></type> <name>Finally</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>S</name><operator>-&gt;</operator><name>getFinallyStmt</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Finally</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getFinallyStmt</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Finally</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>TryBody</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>S</name><operator>-&gt;</operator><name>getTryBody</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><name>AnyCatchChanged</name> <operator>&amp;&amp;</operator>
<call><name><name>Finally</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>S</name><operator>-&gt;</operator><name>getFinallyStmt</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>S</name></expr>;</return></block_content></block></if></if_stmt>


<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildObjCAtTryStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getAtTryLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>TryBody</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>CatchStmts</name></expr></argument>, <argument><expr><call><name><name>Finally</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformObjCAtCatchStmt</name><argument_list>(<argument>ObjCAtCatchStmt *S</argument>)</argument_list></macro> <block>{

<expr><name>VarDecl</name> <operator>*</operator><name>Var</name> <operator>=</operator> <name>nullptr</name></expr>;
<if_stmt><if>if <condition>(<decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>FromVar</name> <init>= <expr><call><name><name>S</name><operator>-&gt;</operator><name>getCatchParamDecl</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TSInfo</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>FromVar</name><operator>-&gt;</operator><name>getTypeSourceInfo</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>TSInfo</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><call><name><name>FromVar</name><operator>-&gt;</operator><name>getTypeSourceInfo</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>TSInfo</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt/></block_content></block></if></if_stmt></block_content></block></if></if_stmt>}</block>

<name>QualType</name> <name>T</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>TSInfo</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>T</name> <operator>=</operator> <call><name><name>TSInfo</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>T</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><call><name><name>FromVar</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>T</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>Var</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildObjCExceptionDecl</name><argument_list>(<argument><expr><name>FromVar</name></expr></argument>, <argument><expr><name>TSInfo</name></expr></argument>, <argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Var</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
}

StmtResult <expr_stmt><expr><name>Body</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getCatchBody</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Body</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildObjCAtCatchStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getAtCatchLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getRParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>Var</name></expr></argument>, <argument><expr><call><name><name>Body</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformObjCAtFinallyStmt</name><argument_list>(<argument>ObjCAtFinallyStmt *S</argument>)</argument_list></macro> <block>{

<expr><name>StmtResult</name> <name>Body</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getFinallyBody</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Body</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>Body</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>S</name><operator>-&gt;</operator><name>getFinallyBody</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>S</name></expr>;</return></block_content></block></if></if_stmt>


<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildObjCAtFinallyStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getAtFinallyLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Body</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformObjCAtThrowStmt</name><argument_list>(<argument>ObjCAtThrowStmt *S</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>Operand</name></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>S</name><operator>-&gt;</operator><name>getThrowExpr</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Operand</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getThrowExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Operand</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt/></block_content></block></if></if_stmt>}</block></expr></expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>Operand</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>S</name><operator>-&gt;</operator><name>getThrowExpr</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>S</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildObjCAtThrowStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getThrowLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Operand</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformObjCAtSynchronizedStmt</name><argument_list>(
<argument>ObjCAtSynchronizedStmt *S</argument>)</argument_list></macro> <block>{

<expr><name>ExprResult</name> <name>Object</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getSynchExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Object</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<name>Object</name> <operator>=</operator>
<call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildObjCAtSynchronizedOperand</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getAtSynchronizedLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Object</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Object</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<decl_stmt><decl><type><name>StmtResult</name></type> <name>Body</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getSynchBody</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Body</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>Object</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>S</name><operator>-&gt;</operator><name>getSynchExpr</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>Body</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>S</name><operator>-&gt;</operator><name>getSynchBody</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>S</name></expr>;</return></block_content></block></if></if_stmt>


<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildObjCAtSynchronizedStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getAtSynchronizedLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Object</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Body</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformObjCAutoreleasePoolStmt</name><argument_list>(
<argument>ObjCAutoreleasePoolStmt *S</argument>)</argument_list></macro> <block>{

<expr><name>StmtResult</name> <name>Body</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getSubStmt</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Body</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>Body</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>S</name><operator>-&gt;</operator><name>getSubStmt</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>S</name></expr>;</return></block_content></block></if></if_stmt>


<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildObjCAutoreleasePoolStmt</name><argument_list>(
<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getAtLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Body</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformObjCForCollectionStmt</name><argument_list>(
<argument>ObjCForCollectionStmt *S</argument>)</argument_list></macro> <block>{

<expr><name>StmtResult</name> <name>Element</name> <operator>=</operator>
<call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getElement</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SDK_NotDiscarded</name></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Element</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<name>ExprResult</name> <name>Collection</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getCollection</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Collection</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<decl_stmt><decl><type><name>StmtResult</name></type> <name>Body</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getBody</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Body</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>Element</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>S</name><operator>-&gt;</operator><name>getElement</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>Collection</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>S</name><operator>-&gt;</operator><name>getCollection</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>Body</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>S</name><operator>-&gt;</operator><name>getBody</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>S</name></expr>;</return></block_content></block></if></if_stmt>


<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildObjCForCollectionStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getForLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Element</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Collection</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getRParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Body</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>StmtResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformCXXCatchStmt</name><argument_list>(<argument>CXXCatchStmt *S</argument>)</argument_list></macro> <block>{

<expr><name>VarDecl</name> <operator>*</operator><name>Var</name> <operator>=</operator> <name>nullptr</name></expr>;
<if_stmt><if>if <condition>(<decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>ExceptionDecl</name> <init>= <expr><call><name><name>S</name><operator>-&gt;</operator><name>getExceptionDecl</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>T</name> <init>=
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><call><name><name>ExceptionDecl</name><operator>-&gt;</operator><name>getTypeSourceInfo</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>T</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>Var</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildExceptionDecl</name><argument_list>(
<argument><expr><name>ExceptionDecl</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><call><name><name>ExceptionDecl</name><operator>-&gt;</operator><name>getInnerLocStart</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>ExceptionDecl</name><operator>-&gt;</operator><name>getLocation</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>ExceptionDecl</name><operator>-&gt;</operator><name>getIdentifier</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Var</name> <operator>||</operator> <call><name><name>Var</name><operator>-&gt;</operator><name>isInvalidDecl</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt/></block_content></block></if></if_stmt>}</block>


<name>StmtResult</name> <name>Handler</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getHandlerBlock</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Handler</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>Var</name> <operator>&amp;&amp;</operator>
<call><name><name>Handler</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>S</name><operator>-&gt;</operator><name>getHandlerBlock</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>S</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildCXXCatchStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getCatchLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Var</name></expr></argument>, <argument><expr><call><name><name>Handler</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>StmtResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformCXXTryStmt</name><argument_list>(<argument>CXXTryStmt *S</argument>)</argument_list></macro> <block>{

<expr><name>StmtResult</name> <name>TryBlock</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformCompoundStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getTryBlock</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>TryBlock</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<name>bool</name> <name>HandlerChanged</name> <operator>=</operator> <name>false</name></block></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name></type> <name>Handlers</name></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>I</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>N</name> <init>= <expr><call><name><name>S</name><operator>-&gt;</operator><name>getNumHandlers</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>I</name> <operator>!=</operator> <name>N</name></expr>;</condition> <incr><expr><operator>++</operator><name>I</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>StmtResult</name></type> <name>Handler</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformCXXCatchStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getHandler</name></name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Handler</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>HandlerChanged</name> <operator>=</operator> <name>HandlerChanged</name> <operator>||</operator> <call><name><name>Handler</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <call><name><name>S</name><operator>-&gt;</operator><name>getHandler</name></name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Handlers</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name><name>Handler</name><operator>.</operator><name>getAs</name></name><operator>&lt;</operator><name>Stmt</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>TryBlock</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>S</name><operator>-&gt;</operator><name>getTryBlock</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><name>HandlerChanged</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>S</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildCXXTryStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getTryLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>TryBlock</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>Handlers</name></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformCXXForRangeStmt</name><argument_list>(<argument>CXXForRangeStmt *S</argument>)</argument_list></macro> <block>{
<expr><name>StmtResult</name> <name>Init</name> <operator>=</operator>
<call><name><name>S</name><operator>-&gt;</operator><name>getInit</name></name><argument_list>()</argument_list></call> <operator>?</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getInit</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>:</operator> <call><name>StmtResult</name><argument_list>()</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Init</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>StmtResult</name> <name>Range</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getRangeStmt</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Range</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>StmtResult</name></type> <name>Begin</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getBeginStmt</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Begin</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>StmtResult</name></type> <name>End</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getEndStmt</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>End</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>ExprResult</name></type> <name>Cond</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getCond</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Cond</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Cond</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>Cond</name> <operator>=</operator> <call><name><name>SemaRef</name><operator>.</operator><name>CheckBooleanCondition</name></name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getColonLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Cond</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Cond</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Cond</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>Cond</name> <operator>=</operator> <call><name><name>SemaRef</name><operator>.</operator><name>MaybeCreateExprWithCleanups</name></name><argument_list>(<argument><expr><call><name><name>Cond</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>ExprResult</name></type> <name>Inc</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getInc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Inc</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Inc</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>Inc</name> <operator>=</operator> <call><name><name>SemaRef</name><operator>.</operator><name>MaybeCreateExprWithCleanups</name></name><argument_list>(<argument><expr><call><name><name>Inc</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>StmtResult</name></type> <name>LoopVar</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getLoopVarStmt</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>LoopVar</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>StmtResult</name></type> <name>NewStmt</name> <init>= <expr><name>S</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>||</operator>
<call><name><name>Init</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <call><name><name>S</name><operator>-&gt;</operator><name>getInit</name></name><argument_list>()</argument_list></call> <operator>||</operator>
<call><name><name>Range</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <call><name><name>S</name><operator>-&gt;</operator><name>getRangeStmt</name></name><argument_list>()</argument_list></call> <operator>||</operator>
<call><name><name>Begin</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <call><name><name>S</name><operator>-&gt;</operator><name>getBeginStmt</name></name><argument_list>()</argument_list></call> <operator>||</operator>
<call><name><name>End</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <call><name><name>S</name><operator>-&gt;</operator><name>getEndStmt</name></name><argument_list>()</argument_list></call> <operator>||</operator>
<call><name><name>Cond</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <call><name><name>S</name><operator>-&gt;</operator><name>getCond</name></name><argument_list>()</argument_list></call> <operator>||</operator>
<call><name><name>Inc</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <call><name><name>S</name><operator>-&gt;</operator><name>getInc</name></name><argument_list>()</argument_list></call> <operator>||</operator>
<call><name><name>LoopVar</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <call><name><name>S</name><operator>-&gt;</operator><name>getLoopVarStmt</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>NewStmt</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildCXXForRangeStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getForLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getCoawaitLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Init</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getColonLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Range</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Begin</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>End</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Cond</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Inc</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>LoopVar</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getRParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>NewStmt</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>LoopVar</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <call><name><name>S</name><operator>-&gt;</operator><name>getLoopVarStmt</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnInitializerError</name><argument_list>(
<argument><expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>DeclStmt</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>LoopVar</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getSingleDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>StmtResult</name></type> <name>Body</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getBody</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Body</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><call><name><name>Body</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <call><name><name>S</name><operator>-&gt;</operator><name>getBody</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>NewStmt</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>S</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>NewStmt</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildCXXForRangeStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getForLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getCoawaitLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Init</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getColonLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Range</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Begin</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>End</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Cond</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Inc</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>LoopVar</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getRParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>NewStmt</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>NewStmt</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>S</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>S</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>FinishCXXForRangeStmt</name><argument_list>(<argument><expr><call><name><name>NewStmt</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Body</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformMSDependentExistsStmt</name><argument_list>(
<argument>MSDependentExistsStmt *S</argument>)</argument_list></macro> <block>{

<expr><name>NestedNameSpecifierLoc</name> <name>QualifierLoc</name></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>S</name><operator>-&gt;</operator><name>getQualifierLoc</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>QualifierLoc</name>
<operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformNestedNameSpecifierLoc</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getQualifierLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>QualifierLoc</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt/></block_content></block></if></if_stmt>}</block>


<name>DeclarationNameInfo</name> <name>NameInfo</name> <operator>=</operator> <call><name><name>S</name><operator>-&gt;</operator><name>getNameInfo</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>NameInfo</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>NameInfo</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDeclarationNameInfo</name><argument_list>(<argument><expr><name>NameInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>NameInfo</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<name>QualifierLoc</name> <operator>==</operator> <call><name><name>S</name><operator>-&gt;</operator><name>getQualifierLoc</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>NameInfo</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>S</name><operator>-&gt;</operator><name>getNameInfo</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getName</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>S</name></expr>;</return></block_content></block></if></if_stmt>


<decl_stmt><decl><type><name>CXXScopeSpec</name></type> <name>SS</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>SS</name><operator>.</operator><name>Adopt</name></name><argument_list>(<argument><expr><name>QualifierLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>Dependent</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>CheckMicrosoftIfExistsSymbol</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><name>NameInfo</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>Sema</name><operator>::</operator><name>IER_Exists</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name><name>S</name><operator>-&gt;</operator><name>isIfExists</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<return>return <macro><name>new</name> <argument_list>(<argument>getSema().Context</argument>)</argument_list></macro> <expr><call><name>NullStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getKeywordLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>Sema</name><operator>::</operator><name>IER_DoesNotExist</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name><name>S</name><operator>-&gt;</operator><name>isIfNotExists</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<return>return <macro><name>new</name> <argument_list>(<argument>getSema().Context</argument>)</argument_list></macro> <expr><call><name>NullStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getKeywordLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>Sema</name><operator>::</operator><name>IER_Dependent</name></expr>:</case>
<expr_stmt><expr><name>Dependent</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Sema</name><operator>::</operator><name>IER_Error</name></expr>:</case>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></switch>


<decl_stmt><decl><type><name>StmtResult</name></type> <name>SubStmt</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformCompoundStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getSubStmt</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>SubStmt</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Dependent</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>SubStmt</name></expr>;</return></block_content></block></if></if_stmt>


<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildMSDependentExistsStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getKeywordLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>isIfExists</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>QualifierLoc</name></expr></argument>,
<argument><expr><name>NameInfo</name></expr></argument>,
<argument><expr><call><name><name>SubStmt</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformMSPropertyRefExpr</name><argument_list>(<argument>MSPropertyRefExpr *E</argument>)</argument_list></macro> <block>{
<expr><name>NestedNameSpecifierLoc</name> <name>QualifierLoc</name></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>-&gt;</operator><name>getQualifierLoc</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>QualifierLoc</name>
<operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformNestedNameSpecifierLoc</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getQualifierLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>QualifierLoc</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt/></block_content></block></if></if_stmt>}</block>

<name>MSPropertyDecl</name> <operator>*</operator><name>PD</name> <operator>=</operator> <call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>MSPropertyDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDecl</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getMemberLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getPropertyDecl</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>PD</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>ExprResult</name></type> <name>Base</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBaseExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Base</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <macro><name>new</name> <argument_list>(<argument>SemaRef.getASTContext()</argument>)</argument_list></macro>
<expr><call><name>MSPropertyRefExpr</name><argument_list>(<argument><expr><call><name><name>Base</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>PD</name></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>isArrow</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>SemaRef</name><operator>.</operator><name>getASTContext</name></name><argument_list>()</argument_list></call><operator>.</operator><name>PseudoObjectTy</name></expr></argument>, <argument><expr><name>VK_LValue</name></expr></argument>,
<argument><expr><name>QualifierLoc</name></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getMemberLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformMSPropertySubscriptExpr</name><argument_list>(
<argument>MSPropertySubscriptExpr *E</argument>)</argument_list></macro> <block>{
<expr><name>auto</name> <name>BaseRes</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBase</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>BaseRes</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<name>auto</name> <name>IdxRes</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getIdx</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>IdxRes</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>BaseRes</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getBase</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>IdxRes</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getIdx</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildArraySubscriptExpr</name><argument_list>(
<argument><expr><call><name><name>BaseRes</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>IdxRes</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getRBracketLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>StmtResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformSEHTryStmt</name><argument_list>(<argument>SEHTryStmt *S</argument>)</argument_list></macro> <block>{
<expr><name>StmtResult</name> <name>TryBlock</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformCompoundStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getTryBlock</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>TryBlock</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>StmtResult</name> <name>Handler</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformSEHHandler</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getHandler</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Handler</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>TryBlock</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>S</name><operator>-&gt;</operator><name>getTryBlock</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>Handler</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>S</name><operator>-&gt;</operator><name>getHandler</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>S</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildSEHTryStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getIsCXXTry</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getTryLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>TryBlock</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Handler</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>StmtResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformSEHFinallyStmt</name><argument_list>(<argument>SEHFinallyStmt *S</argument>)</argument_list></macro> <block>{
<expr><name>StmtResult</name> <name>Block</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformCompoundStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getBlock</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Block</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildSEHFinallyStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getFinallyLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Block</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>StmtResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformSEHExceptStmt</name><argument_list>(<argument>SEHExceptStmt *S</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>FilterExpr</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getFilterExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>FilterExpr</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>StmtResult</name> <name>Block</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformCompoundStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getBlock</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Block</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildSEHExceptStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getExceptLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>FilterExpr</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Block</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>StmtResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformSEHHandler</name><argument_list>(<argument>Stmt *Handler</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>SEHFinallyStmt</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Handler</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformSEHFinallyStmt</name><argument_list>(<argument><expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>SEHFinallyStmt</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Handler</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformSEHExceptStmt</name><argument_list>(<argument><expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>SEHExceptStmt</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Handler</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformSEHLeaveStmt</name><argument_list>(<argument>SEHLeaveStmt *S</argument>)</argument_list></macro> <block>{
<return>return <expr><name>S</name></expr>;</return>
}</block></expr></expr_stmt>





<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPCanonicalLoop</name><argument_list>(<argument>OMPCanonicalLoop *L</argument>)</argument_list></macro> <block>{



<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformStmt</name><argument_list>(<argument><expr><call><name><name>L</name><operator>-&gt;</operator><name>getLoopStmt</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPExecutableDirective</name><argument_list>(
<argument>OMPExecutableDirective *D</argument>)</argument_list></macro> <block>{


<expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name> <name>TClauses</name></expr>;
<expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Clauses</name> <operator>=</operator> <call><name><name>D</name><operator>-&gt;</operator><name>clauses</name></name><argument_list>()</argument_list></call></expr>;
<expr><call><name><name>TClauses</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>Clauses</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<for>for <control>(<init><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name> <name>I</name> <operator>=</operator> <call><name><name>Clauses</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr><operator>,</operator> <expr><name>E</name> <operator>=</operator> <call><name><name>Clauses</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</init>
<condition><expr><name>I</name> <operator>!=</operator> <name>E</name></expr>;</condition> <incr><expr><operator>++</operator><name>I</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>I</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPClause</name><argument_list>(<argument><expr><call><name><operator>(</operator><operator>*</operator><name>I</name><operator>)</operator><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>Clause</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPClause</name><argument_list>(<argument><expr><operator>*</operator><name>I</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPClause</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>Clause</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>TClauses</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>Clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt/></block_content></block></if></if_stmt></block_content></block></for>}</block></expr></expr_stmt> <if_stmt><else>else <block>{<block_content>
<expr_stmt><expr><call><name><name>TClauses</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
}
StmtResult <expr_stmt><expr><name>AssociatedStmt</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>D</name><operator>-&gt;</operator><name>hasAssociatedStmt</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>D</name><operator>-&gt;</operator><name>getAssociatedStmt</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPRegionStart</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getDirectiveKind</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>StmtResult</name></type> <name>Body</name></decl>;</decl_stmt>
<block>{<block_content>
<expr_stmt><expr><name>Sema</name><operator>::</operator><name>CompoundScopeRAII</name> <call><name>CompoundScope</name><argument_list>(<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>CS</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>D</name><operator>-&gt;</operator><name>getDirectiveKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPD_atomic</name> <operator>||</operator>
<call><name><name>D</name><operator>-&gt;</operator><name>getDirectiveKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPD_critical</name> <operator>||</operator>
<call><name><name>D</name><operator>-&gt;</operator><name>getDirectiveKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPD_section</name> <operator>||</operator>
<call><name><name>D</name><operator>-&gt;</operator><name>getDirectiveKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPD_master</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>CS</name> <operator>=</operator> <call><name><name>D</name><operator>-&gt;</operator><name>getAssociatedStmt</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>CS</name> <operator>=</operator> <call><name><name>D</name><operator>-&gt;</operator><name>getRawStmt</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name>Body</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformStmt</name><argument_list>(<argument><expr><name>CS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Body</name><operator>.</operator><name>isUsable</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>isOpenMPLoopDirective</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getDirectiveKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getLangOpts</name><argument_list>()</argument_list></call><operator>.</operator><name>OpenMPIRBuilder</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>Body</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPCanonicalLoop</name><argument_list>(<argument><expr><call><name><name>Body</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
<expr_stmt><expr><name>AssociatedStmt</name> <operator>=</operator>
<call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnOpenMPRegionEnd</name><argument_list>(<argument><expr><name>Body</name></expr></argument>, <argument><expr><name>TClauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>AssociatedStmt</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>TClauses</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <call><name><name>Clauses</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>


<decl_stmt><decl><type><name>DeclarationNameInfo</name></type> <name>DirName</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>D</name><operator>-&gt;</operator><name>getDirectiveKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPD_critical</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>DirName</name> <operator>=</operator> <call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPCriticalDirective</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getDirectiveName</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>DirName</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDeclarationNameInfo</name><argument_list>(<argument><expr><name>DirName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>OpenMPDirectiveKind</name></type> <name>CancelRegion</name> <init>= <expr><name>OMPD_unknown</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>D</name><operator>-&gt;</operator><name>getDirectiveKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPD_cancellation_point</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>CancelRegion</name> <operator>=</operator> <call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPCancellationPointDirective</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getCancelRegion</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>D</name><operator>-&gt;</operator><name>getDirectiveKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OMPD_cancel</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>CancelRegion</name> <operator>=</operator> <call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPCancelDirective</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getCancelRegion</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPExecutableDirective</name><argument_list>(
<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getDirectiveKind</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>DirName</name></expr></argument>, <argument><expr><name>CancelRegion</name></expr></argument>, <argument><expr><name>TClauses</name></expr></argument>,
<argument><expr><call><name><name>AssociatedStmt</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPParallelDirective</name><argument_list>(<argument>OMPParallelDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(<argument><expr><name>OMPD_parallel</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPSimdDirective</name><argument_list>(<argument>OMPSimdDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(<argument><expr><name>OMPD_simd</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPTileDirective</name><argument_list>(<argument>OMPTileDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getDirectiveKind</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>DirName</name></expr></argument>,
<argument><expr><name>nullptr</name></expr></argument>, <argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPUnrollDirective</name><argument_list>(<argument>OMPUnrollDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getDirectiveKind</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>DirName</name></expr></argument>,
<argument><expr><name>nullptr</name></expr></argument>, <argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPForDirective</name><argument_list>(<argument>OMPForDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(<argument><expr><name>OMPD_for</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPForSimdDirective</name><argument_list>(<argument>OMPForSimdDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(<argument><expr><name>OMPD_for_simd</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPSectionsDirective</name><argument_list>(<argument>OMPSectionsDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(<argument><expr><name>OMPD_sections</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPSectionDirective</name><argument_list>(<argument>OMPSectionDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(<argument><expr><name>OMPD_section</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPSingleDirective</name><argument_list>(<argument>OMPSingleDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(<argument><expr><name>OMPD_single</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPMasterDirective</name><argument_list>(<argument>OMPMasterDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(<argument><expr><name>OMPD_master</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPCriticalDirective</name><argument_list>(<argument>OMPCriticalDirective *D</argument>)</argument_list></macro> <block>{
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(
<argument><expr><name>OMPD_critical</name></expr></argument>, <argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getDirectiveName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>, <argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPParallelForDirective</name><argument_list>(
<argument>OMPParallelForDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(<argument><expr><name>OMPD_parallel_for</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>,
<argument><expr><name>nullptr</name></expr></argument>, <argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPParallelForSimdDirective</name><argument_list>(
<argument>OMPParallelForSimdDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(<argument><expr><name>OMPD_parallel_for_simd</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>,
<argument><expr><name>nullptr</name></expr></argument>, <argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPParallelMasterDirective</name><argument_list>(
<argument>OMPParallelMasterDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(<argument><expr><name>OMPD_parallel_master</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>,
<argument><expr><name>nullptr</name></expr></argument>, <argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPParallelSectionsDirective</name><argument_list>(
<argument>OMPParallelSectionsDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(<argument><expr><name>OMPD_parallel_sections</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>,
<argument><expr><name>nullptr</name></expr></argument>, <argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPTaskDirective</name><argument_list>(<argument>OMPTaskDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(<argument><expr><name>OMPD_task</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPTaskyieldDirective</name><argument_list>(
<argument>OMPTaskyieldDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(<argument><expr><name>OMPD_taskyield</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPBarrierDirective</name><argument_list>(<argument>OMPBarrierDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(<argument><expr><name>OMPD_barrier</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPTaskwaitDirective</name><argument_list>(<argument>OMPTaskwaitDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(<argument><expr><name>OMPD_taskwait</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPTaskgroupDirective</name><argument_list>(
<argument>OMPTaskgroupDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(<argument><expr><name>OMPD_taskgroup</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPFlushDirective</name><argument_list>(<argument>OMPFlushDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(<argument><expr><name>OMPD_flush</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPDepobjDirective</name><argument_list>(<argument>OMPDepobjDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(<argument><expr><name>OMPD_depobj</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPScanDirective</name><argument_list>(<argument>OMPScanDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(<argument><expr><name>OMPD_scan</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPOrderedDirective</name><argument_list>(<argument>OMPOrderedDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(<argument><expr><name>OMPD_ordered</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPAtomicDirective</name><argument_list>(<argument>OMPAtomicDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(<argument><expr><name>OMPD_atomic</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPTargetDirective</name><argument_list>(<argument>OMPTargetDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(<argument><expr><name>OMPD_target</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPTargetDataDirective</name><argument_list>(
<argument>OMPTargetDataDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(<argument><expr><name>OMPD_target_data</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPTargetEnterDataDirective</name><argument_list>(
<argument>OMPTargetEnterDataDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(<argument><expr><name>OMPD_target_enter_data</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>,
<argument><expr><name>nullptr</name></expr></argument>, <argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPTargetExitDataDirective</name><argument_list>(
<argument>OMPTargetExitDataDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(<argument><expr><name>OMPD_target_exit_data</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>,
<argument><expr><name>nullptr</name></expr></argument>, <argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPTargetParallelDirective</name><argument_list>(
<argument>OMPTargetParallelDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(<argument><expr><name>OMPD_target_parallel</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>,
<argument><expr><name>nullptr</name></expr></argument>, <argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPTargetParallelForDirective</name><argument_list>(
<argument>OMPTargetParallelForDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(<argument><expr><name>OMPD_target_parallel_for</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>,
<argument><expr><name>nullptr</name></expr></argument>, <argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPTargetUpdateDirective</name><argument_list>(
<argument>OMPTargetUpdateDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(<argument><expr><name>OMPD_target_update</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>,
<argument><expr><name>nullptr</name></expr></argument>, <argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPTeamsDirective</name><argument_list>(<argument>OMPTeamsDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(<argument><expr><name>OMPD_teams</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPCancellationPointDirective</name><argument_list>(
<argument>OMPCancellationPointDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(<argument><expr><name>OMPD_cancellation_point</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>,
<argument><expr><name>nullptr</name></expr></argument>, <argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPCancelDirective</name><argument_list>(<argument>OMPCancelDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(<argument><expr><name>OMPD_cancel</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPTaskLoopDirective</name><argument_list>(<argument>OMPTaskLoopDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(<argument><expr><name>OMPD_taskloop</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPTaskLoopSimdDirective</name><argument_list>(
<argument>OMPTaskLoopSimdDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(<argument><expr><name>OMPD_taskloop_simd</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>,
<argument><expr><name>nullptr</name></expr></argument>, <argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPMasterTaskLoopDirective</name><argument_list>(
<argument>OMPMasterTaskLoopDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(<argument><expr><name>OMPD_master_taskloop</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>,
<argument><expr><name>nullptr</name></expr></argument>, <argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPMasterTaskLoopSimdDirective</name><argument_list>(
<argument>OMPMasterTaskLoopSimdDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(<argument><expr><name>OMPD_master_taskloop_simd</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>,
<argument><expr><name>nullptr</name></expr></argument>, <argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPParallelMasterTaskLoopDirective</name><argument_list>(
<argument>OMPParallelMasterTaskLoopDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(
<argument><expr><name>OMPD_parallel_master_taskloop</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>, <argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPParallelMasterTaskLoopSimdDirective</name><argument_list>(
<argument>OMPParallelMasterTaskLoopSimdDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(
<argument><expr><name>OMPD_parallel_master_taskloop_simd</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>, <argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPDistributeDirective</name><argument_list>(
<argument>OMPDistributeDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(<argument><expr><name>OMPD_distribute</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPDistributeParallelForDirective</name><argument_list>(
<argument>OMPDistributeParallelForDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(
<argument><expr><name>OMPD_distribute_parallel_for</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>, <argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPDistributeParallelForSimdDirective</name><argument_list>(
<argument>OMPDistributeParallelForSimdDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(
<argument><expr><name>OMPD_distribute_parallel_for_simd</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>, <argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPDistributeSimdDirective</name><argument_list>(
<argument>OMPDistributeSimdDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(<argument><expr><name>OMPD_distribute_simd</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>,
<argument><expr><name>nullptr</name></expr></argument>, <argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPTargetParallelForSimdDirective</name><argument_list>(
<argument>OMPTargetParallelForSimdDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(
<argument><expr><name>OMPD_target_parallel_for_simd</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>, <argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPTargetSimdDirective</name><argument_list>(
<argument>OMPTargetSimdDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(<argument><expr><name>OMPD_target_simd</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPTeamsDistributeDirective</name><argument_list>(
<argument>OMPTeamsDistributeDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(<argument><expr><name>OMPD_teams_distribute</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>,
<argument><expr><name>nullptr</name></expr></argument>, <argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPTeamsDistributeSimdDirective</name><argument_list>(
<argument>OMPTeamsDistributeSimdDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(
<argument><expr><name>OMPD_teams_distribute_simd</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>, <argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPTeamsDistributeParallelForSimdDirective</name><argument_list>(
<argument>OMPTeamsDistributeParallelForSimdDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(
<argument><expr><name>OMPD_teams_distribute_parallel_for_simd</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPTeamsDistributeParallelForDirective</name><argument_list>(
<argument>OMPTeamsDistributeParallelForDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(
<argument><expr><name>OMPD_teams_distribute_parallel_for</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>, <argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPTargetTeamsDirective</name><argument_list>(
<argument>OMPTargetTeamsDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(<argument><expr><name>OMPD_target_teams</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>,
<argument><expr><name>nullptr</name></expr></argument>, <argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>auto</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPTargetTeamsDistributeDirective</name><argument_list>(
<argument>OMPTargetTeamsDistributeDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(
<argument><expr><name>OMPD_target_teams_distribute</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>, <argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>auto</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPTargetTeamsDistributeParallelForDirective</name><argument_list>(
<argument>OMPTargetTeamsDistributeParallelForDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(
<argument><expr><name>OMPD_target_teams_distribute_parallel_for</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>auto</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator>
<macro><name>TransformOMPTargetTeamsDistributeParallelForSimdDirective</name><argument_list>(
<argument>OMPTargetTeamsDistributeParallelForSimdDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(
<argument><expr><name>OMPD_target_teams_distribute_parallel_for_simd</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>auto</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPTargetTeamsDistributeSimdDirective</name><argument_list>(
<argument>OMPTargetTeamsDistributeSimdDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(
<argument><expr><name>OMPD_target_teams_distribute_simd</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>, <argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>auto</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPInteropDirective</name><argument_list>(<argument>OMPInteropDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(<argument><expr><name>OMPD_interop</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPDispatchDirective</name><argument_list>(<argument>OMPDispatchDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(<argument><expr><name>OMPD_dispatch</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPMaskedDirective</name><argument_list>(<argument>OMPMaskedDirective *D</argument>)</argument_list></macro> <block>{
<expr><name>DeclarationNameInfo</name> <name>DirName</name></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>StartOpenMPDSABlock</name><argument_list>(<argument><expr><name>OMPD_masked</name></expr></argument>, <argument><expr><name>DirName</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>Res</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformOMPExecutableDirective</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>EndOpenMPDSABlock</name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Res</name></expr>;</return>
}</block></expr></expr_stmt>




<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>OMPClause</name> <operator>*</operator><name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPIfClause</name><argument_list>(<argument>OMPIfClause *C</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>Cond</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getCondition</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Cond</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPIfClause</name><argument_list>(
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getNameModifier</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Cond</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getNameModifierLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getColonLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>OMPClause</name> <operator>*</operator><name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPFinalClause</name><argument_list>(<argument>OMPFinalClause *C</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>Cond</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getCondition</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Cond</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPFinalClause</name><argument_list>(<argument><expr><call><name><name>Cond</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>OMPClause</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPNumThreadsClause</name><argument_list>(<argument>OMPNumThreadsClause *C</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>NumThreads</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getNumThreads</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>NumThreads</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPNumThreadsClause</name><argument_list>(
<argument><expr><call><name><name>NumThreads</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>OMPClause</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPSafelenClause</name><argument_list>(<argument>OMPSafelenClause *C</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>E</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getSafelen</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPSafelenClause</name><argument_list>(
<argument><expr><call><name><name>E</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>OMPClause</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPAllocatorClause</name><argument_list>(<argument>OMPAllocatorClause *C</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>E</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getAllocator</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPAllocatorClause</name><argument_list>(
<argument><expr><call><name><name>E</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>OMPClause</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPSimdlenClause</name><argument_list>(<argument>OMPSimdlenClause *C</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>E</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getSimdlen</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPSimdlenClause</name><argument_list>(
<argument><expr><call><name><name>E</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>OMPClause</name> <operator>*</operator><name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPSizesClause</name><argument_list>(<argument>OMPSizesClause *C</argument>)</argument_list></macro> <block>{
<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>TransformedSizes</name></expr>;
<expr><call><name><name>TransformedSizes</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getNumSizes</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>bool</name> <name>Changed</name> <operator>=</operator> <name>false</name></expr>;
<for>for <control>(<init><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name> <range>: <expr><call><name><name>C</name><operator>-&gt;</operator><name>getSizesRefs</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>E</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>TransformedSizes</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
<expr_stmt/></block_content></block></if></if_stmt></block_content></block></for>}</block>

<name>ExprResult</name> <name>T</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>T</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>E</name> <operator>!=</operator> <call><name><name>T</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>Changed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>TransformedSizes</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>T</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}

if <expr_stmt><expr><operator>(</operator><operator>!</operator><name>Changed</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call><operator>)</operator></expr></expr_stmt>
<return>return <expr><name>C</name></expr>;</return>
<return>return <expr><call><name>RebuildOMPSizesClause</name><argument_list>(<argument><expr><name>TransformedSizes</name></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>OMPClause</name> <operator>*</operator><name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPFullClause</name><argument_list>(<argument>OMPFullClause *C</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>C</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name>RebuildOMPFullClause</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>OMPClause</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPPartialClause</name><argument_list>(<argument>OMPPartialClause *C</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>T</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getFactor</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>T</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>
<name>Expr</name> <operator>*</operator><name>Factor</name> <operator>=</operator> <call><name><name>T</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></block></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>Changed</name> <init>= <expr><name>Factor</name> <operator>!=</operator> <call><name><name>C</name><operator>-&gt;</operator><name>getFactor</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Changed</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>C</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>RebuildOMPPartialClause</name><argument_list>(<argument><expr><name>Factor</name></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>OMPClause</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPCollapseClause</name><argument_list>(<argument>OMPCollapseClause *C</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>E</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getNumForLoops</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPCollapseClause</name><argument_list>(
<argument><expr><call><name><name>E</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>OMPClause</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPDefaultClause</name><argument_list>(<argument>OMPDefaultClause *C</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPDefaultClause</name><argument_list>(
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getDefaultKind</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getDefaultKindKwLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>OMPClause</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPProcBindClause</name><argument_list>(<argument>OMPProcBindClause *C</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPProcBindClause</name><argument_list>(
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getProcBindKind</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getProcBindKindKwLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>OMPClause</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPScheduleClause</name><argument_list>(<argument>OMPScheduleClause *C</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>E</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getChunkSize</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPScheduleClause</name><argument_list>(
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getFirstScheduleModifier</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getSecondScheduleModifier</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getScheduleKind</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getFirstScheduleModifierLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getSecondScheduleModifierLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getScheduleKindLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getCommaLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>OMPClause</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPOrderedClause</name><argument_list>(<argument>OMPOrderedClause *C</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>E</name></expr>;
<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>Num</name> <operator>=</operator> <call><name><name>C</name><operator>-&gt;</operator><name>getNumForLoops</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>E</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><name>Num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt/></block_content></block></if></if_stmt>}</block></expr></expr_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPOrderedClause</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>OMPClause</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPDetachClause</name><argument_list>(<argument>OMPDetachClause *C</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>E</name></expr>;
<if_stmt><if>if <condition>(<decl><type><name>Expr</name> <modifier>*</modifier></type><name>Evt</name> <init>= <expr><call><name><name>C</name><operator>-&gt;</operator><name>getEventHandler</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<expr_stmt><expr><name>E</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><name>Evt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt/></block_content></block></if></if_stmt>}</block></expr></expr_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPDetachClause</name><argument_list>(<argument><expr><call><name><name>E</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>OMPClause</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPNowaitClause</name><argument_list>(<argument>OMPNowaitClause *C</argument>)</argument_list></macro> <block>{

<return>return <expr><name>C</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>OMPClause</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPUntiedClause</name><argument_list>(<argument>OMPUntiedClause *C</argument>)</argument_list></macro> <block>{

<return>return <expr><name>C</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>OMPClause</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPMergeableClause</name><argument_list>(<argument>OMPMergeableClause *C</argument>)</argument_list></macro> <block>{

<return>return <expr><name>C</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>OMPClause</name> <operator>*</operator><name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPReadClause</name><argument_list>(<argument>OMPReadClause *C</argument>)</argument_list></macro> <block>{

<return>return <expr><name>C</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>OMPClause</name> <operator>*</operator><name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPWriteClause</name><argument_list>(<argument>OMPWriteClause *C</argument>)</argument_list></macro> <block>{

<return>return <expr><name>C</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>OMPClause</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPUpdateClause</name><argument_list>(<argument>OMPUpdateClause *C</argument>)</argument_list></macro> <block>{

<return>return <expr><name>C</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>OMPClause</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPCaptureClause</name><argument_list>(<argument>OMPCaptureClause *C</argument>)</argument_list></macro> <block>{

<return>return <expr><name>C</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>OMPClause</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPSeqCstClause</name><argument_list>(<argument>OMPSeqCstClause *C</argument>)</argument_list></macro> <block>{

<return>return <expr><name>C</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>OMPClause</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPAcqRelClause</name><argument_list>(<argument>OMPAcqRelClause *C</argument>)</argument_list></macro> <block>{

<return>return <expr><name>C</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>OMPClause</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPAcquireClause</name><argument_list>(<argument>OMPAcquireClause *C</argument>)</argument_list></macro> <block>{

<return>return <expr><name>C</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>OMPClause</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPReleaseClause</name><argument_list>(<argument>OMPReleaseClause *C</argument>)</argument_list></macro> <block>{

<return>return <expr><name>C</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>OMPClause</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPRelaxedClause</name><argument_list>(<argument>OMPRelaxedClause *C</argument>)</argument_list></macro> <block>{

<return>return <expr><name>C</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>OMPClause</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPThreadsClause</name><argument_list>(<argument>OMPThreadsClause *C</argument>)</argument_list></macro> <block>{

<return>return <expr><name>C</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>OMPClause</name> <operator>*</operator><name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPSIMDClause</name><argument_list>(<argument>OMPSIMDClause *C</argument>)</argument_list></macro> <block>{

<return>return <expr><name>C</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>OMPClause</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPNogroupClause</name><argument_list>(<argument>OMPNogroupClause *C</argument>)</argument_list></macro> <block>{

<return>return <expr><name>C</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>OMPClause</name> <operator>*</operator><name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPInitClause</name><argument_list>(<argument>OMPInitClause *C</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>IVR</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getInteropVar</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>IVR</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>

<name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name> <name>PrefExprs</name></block></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>PrefExprs</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>varlist_size</name></name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name> <range>: <expr><name>llvm</name><operator>::</operator><call><name>drop_begin</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>varlists</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>ER</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>ER</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>PrefExprs</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>ER</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPInitClause</name><argument_list>(
<argument><expr><call><name><name>IVR</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>PrefExprs</name></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getIsTarget</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getIsTargetSync</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getVarLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>OMPClause</name> <operator>*</operator><name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPUseClause</name><argument_list>(<argument>OMPUseClause *C</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>ER</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getInteropVar</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>ER</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPUseClause</name><argument_list>(<argument><expr><call><name><name>ER</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getVarLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>OMPClause</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPDestroyClause</name><argument_list>(<argument>OMPDestroyClause *C</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>ER</name></expr>;
<if_stmt><if>if <condition>(<decl><type><name>Expr</name> <modifier>*</modifier></type><name>IV</name> <init>= <expr><call><name><name>C</name><operator>-&gt;</operator><name>getInteropVar</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ER</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><name>IV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>ER</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt/></block_content></block></if></if_stmt>}</block></expr></expr_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPDestroyClause</name><argument_list>(<argument><expr><call><name><name>ER</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getVarLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>OMPClause</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPNovariantsClause</name><argument_list>(<argument>OMPNovariantsClause *C</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>Cond</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getCondition</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Cond</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPNovariantsClause</name><argument_list>(
<argument><expr><call><name><name>Cond</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>OMPClause</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPNocontextClause</name><argument_list>(<argument>OMPNocontextClause *C</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>Cond</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getCondition</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Cond</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPNocontextClause</name><argument_list>(
<argument><expr><call><name><name>Cond</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>OMPClause</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPFilterClause</name><argument_list>(<argument>OMPFilterClause *C</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>ThreadID</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getThreadID</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>ThreadID</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPFilterClause</name><argument_list>(<argument><expr><call><name><name>ThreadID</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>OMPClause</name> <operator>*</operator><name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPUnifiedAddressClause</name><argument_list>(
<argument>OMPUnifiedAddressClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>llvm_unreachable</name><argument_list>(<argument><expr><literal type="string">"unified_address clause cannot appear in dependent context"</literal></expr></argument>)</argument_list></call></expr>;
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>OMPClause</name> <operator>*</operator><name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPUnifiedSharedMemoryClause</name><argument_list>(
<argument>OMPUnifiedSharedMemoryClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>llvm_unreachable</name><argument_list>(
<argument><expr><literal type="string">"unified_shared_memory clause cannot appear in dependent context"</literal></expr></argument>)</argument_list></call></expr>;
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>OMPClause</name> <operator>*</operator><name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPReverseOffloadClause</name><argument_list>(
<argument>OMPReverseOffloadClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>llvm_unreachable</name><argument_list>(<argument><expr><literal type="string">"reverse_offload clause cannot appear in dependent context"</literal></expr></argument>)</argument_list></call></expr>;
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>OMPClause</name> <operator>*</operator><name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPDynamicAllocatorsClause</name><argument_list>(
<argument>OMPDynamicAllocatorsClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>llvm_unreachable</name><argument_list>(
<argument><expr><literal type="string">"dynamic_allocators clause cannot appear in dependent context"</literal></expr></argument>)</argument_list></call></expr>;
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>OMPClause</name> <operator>*</operator><name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPAtomicDefaultMemOrderClause</name><argument_list>(
<argument>OMPAtomicDefaultMemOrderClause *C</argument>)</argument_list></macro> <block>{
<expr><call><name>llvm_unreachable</name><argument_list>(
<argument><expr><literal type="string">"atomic_default_mem_order clause cannot appear in dependent context"</literal></expr></argument>)</argument_list></call></expr>;
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>OMPClause</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPPrivateClause</name><argument_list>(<argument>OMPPrivateClause *C</argument>)</argument_list></macro> <block>{
<expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name> <name>Vars</name></expr>;
<expr><call><name><name>Vars</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>varlist_size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>VE</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>varlists</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>EVar</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>VE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>EVar</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>Vars</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>EVar</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></for>}</block></expr></expr_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPPrivateClause</name><argument_list>(
<argument><expr><name>Vars</name></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>OMPClause</name> <operator>*</operator><name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPFirstprivateClause</name><argument_list>(
<argument>OMPFirstprivateClause *C</argument>)</argument_list></macro> <block>{
<expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name> <name>Vars</name></expr>;
<expr><call><name><name>Vars</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>varlist_size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>VE</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>varlists</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>EVar</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>VE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>EVar</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>Vars</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>EVar</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></for>}</block></expr></expr_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPFirstprivateClause</name><argument_list>(
<argument><expr><name>Vars</name></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>OMPClause</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPLastprivateClause</name><argument_list>(<argument>OMPLastprivateClause *C</argument>)</argument_list></macro> <block>{
<expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name> <name>Vars</name></expr>;
<expr><call><name><name>Vars</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>varlist_size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>VE</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>varlists</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>EVar</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>VE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>EVar</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>Vars</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>EVar</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></for>}</block></expr></expr_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPLastprivateClause</name><argument_list>(
<argument><expr><name>Vars</name></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getKindLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getColonLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>OMPClause</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPSharedClause</name><argument_list>(<argument>OMPSharedClause *C</argument>)</argument_list></macro> <block>{
<expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name> <name>Vars</name></expr>;
<expr><call><name><name>Vars</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>varlist_size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>VE</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>varlists</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>EVar</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>VE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>EVar</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>Vars</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>EVar</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></for>}</block></expr></expr_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPSharedClause</name><argument_list>(<argument><expr><name>Vars</name></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>OMPClause</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPReductionClause</name><argument_list>(<argument>OMPReductionClause *C</argument>)</argument_list></macro> <block>{
<expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name> <name>Vars</name></expr>;
<expr><call><name><name>Vars</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>varlist_size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>VE</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>varlists</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>EVar</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>VE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>EVar</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>Vars</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>EVar</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></for>}</block>
<name>CXXScopeSpec</name> <name>ReductionIdScopeSpec</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ReductionIdScopeSpec</name><operator>.</operator><name>Adopt</name></name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getQualifierLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>DeclarationNameInfo</name></type> <name>NameInfo</name> <init>= <expr><call><name><name>C</name><operator>-&gt;</operator><name>getNameInfo</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>NameInfo</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>NameInfo</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDeclarationNameInfo</name><argument_list>(<argument><expr><name>NameInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>NameInfo</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name> <name>UnresolvedReductions</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>E</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>reduction_ops</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>E</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>auto</name> <operator>*</operator><name>ULE</name> <operator>=</operator> <call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>UnresolvedLookupExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>UnresolvedSet</name><argument_list type="generic">&lt;<argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name></type> <name>Decls</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>D</name> <operator>:</operator> <call><name><name>ULE</name><operator>-&gt;</operator><name>decls</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>InstD</name> <init>=
<expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDecl</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getExprLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>Decls</name><operator>.</operator><name>addDecl</name></name><argument_list>(<argument><expr><name>InstD</name></expr></argument>, <argument><expr><call><name><name>InstD</name><operator>-&gt;</operator><name>getAccess</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name><name>UnresolvedReductions</name><operator>.</operator><name>push_back</name></name><argument_list>(
<argument><expr><name>UnresolvedLookupExpr</name><operator>::</operator><call><name>Create</name><argument_list>(
<argument><expr><name><name>SemaRef</name><operator>.</operator><name>Context</name></name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><call><name><name>ReductionIdScopeSpec</name><operator>.</operator><name>getWithLocInContext</name></name><argument_list>(<argument><expr><name><name>SemaRef</name><operator>.</operator><name>Context</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>NameInfo</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><call><name><name>ULE</name><operator>-&gt;</operator><name>isOverloaded</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Decls</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Decls</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>UnresolvedReductions</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></for>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPReductionClause</name><argument_list>(
<argument><expr><name>Vars</name></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getModifier</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getModifierLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getColonLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>ReductionIdScopeSpec</name></expr></argument>, <argument><expr><name>NameInfo</name></expr></argument>, <argument><expr><name>UnresolvedReductions</name></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>OMPClause</name> <operator>*</operator><name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPTaskReductionClause</name><argument_list>(
<argument>OMPTaskReductionClause *C</argument>)</argument_list></macro> <block>{
<expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name> <name>Vars</name></expr>;
<expr><call><name><name>Vars</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>varlist_size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>VE</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>varlists</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>EVar</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>VE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>EVar</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>Vars</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>EVar</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></for>}</block>
<name>CXXScopeSpec</name> <name>ReductionIdScopeSpec</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ReductionIdScopeSpec</name><operator>.</operator><name>Adopt</name></name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getQualifierLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>DeclarationNameInfo</name></type> <name>NameInfo</name> <init>= <expr><call><name><name>C</name><operator>-&gt;</operator><name>getNameInfo</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>NameInfo</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>NameInfo</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDeclarationNameInfo</name><argument_list>(<argument><expr><name>NameInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>NameInfo</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name> <name>UnresolvedReductions</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>E</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>reduction_ops</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>E</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>auto</name> <operator>*</operator><name>ULE</name> <operator>=</operator> <call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>UnresolvedLookupExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>UnresolvedSet</name><argument_list type="generic">&lt;<argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name></type> <name>Decls</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>D</name> <operator>:</operator> <call><name><name>ULE</name><operator>-&gt;</operator><name>decls</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>InstD</name> <init>=
<expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDecl</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getExprLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>Decls</name><operator>.</operator><name>addDecl</name></name><argument_list>(<argument><expr><name>InstD</name></expr></argument>, <argument><expr><call><name><name>InstD</name><operator>-&gt;</operator><name>getAccess</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name><name>UnresolvedReductions</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>UnresolvedLookupExpr</name><operator>::</operator><call><name>Create</name><argument_list>(
<argument><expr><name><name>SemaRef</name><operator>.</operator><name>Context</name></name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><call><name><name>ReductionIdScopeSpec</name><operator>.</operator><name>getWithLocInContext</name></name><argument_list>(<argument><expr><name><name>SemaRef</name><operator>.</operator><name>Context</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NameInfo</name></expr></argument>,
<argument><expr><name>true</name></expr></argument>, <argument><expr><call><name><name>ULE</name><operator>-&gt;</operator><name>isOverloaded</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Decls</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Decls</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>UnresolvedReductions</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></for>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPTaskReductionClause</name><argument_list>(
<argument><expr><name>Vars</name></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getColonLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ReductionIdScopeSpec</name></expr></argument>, <argument><expr><name>NameInfo</name></expr></argument>, <argument><expr><name>UnresolvedReductions</name></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>OMPClause</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPInReductionClause</name><argument_list>(<argument>OMPInReductionClause *C</argument>)</argument_list></macro> <block>{
<expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name> <name>Vars</name></expr>;
<expr><call><name><name>Vars</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>varlist_size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>VE</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>varlists</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>EVar</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>VE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>EVar</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>Vars</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>EVar</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></for>}</block>
<name>CXXScopeSpec</name> <name>ReductionIdScopeSpec</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ReductionIdScopeSpec</name><operator>.</operator><name>Adopt</name></name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getQualifierLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>DeclarationNameInfo</name></type> <name>NameInfo</name> <init>= <expr><call><name><name>C</name><operator>-&gt;</operator><name>getNameInfo</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>NameInfo</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>NameInfo</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDeclarationNameInfo</name><argument_list>(<argument><expr><name>NameInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>NameInfo</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name> <name>UnresolvedReductions</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>E</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>reduction_ops</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>E</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>auto</name> <operator>*</operator><name>ULE</name> <operator>=</operator> <call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>UnresolvedLookupExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>UnresolvedSet</name><argument_list type="generic">&lt;<argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name></type> <name>Decls</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>D</name> <operator>:</operator> <call><name><name>ULE</name><operator>-&gt;</operator><name>decls</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>InstD</name> <init>=
<expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDecl</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getExprLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>Decls</name><operator>.</operator><name>addDecl</name></name><argument_list>(<argument><expr><name>InstD</name></expr></argument>, <argument><expr><call><name><name>InstD</name><operator>-&gt;</operator><name>getAccess</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name><name>UnresolvedReductions</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>UnresolvedLookupExpr</name><operator>::</operator><call><name>Create</name><argument_list>(
<argument><expr><name><name>SemaRef</name><operator>.</operator><name>Context</name></name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><call><name><name>ReductionIdScopeSpec</name><operator>.</operator><name>getWithLocInContext</name></name><argument_list>(<argument><expr><name><name>SemaRef</name><operator>.</operator><name>Context</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NameInfo</name></expr></argument>,
<argument><expr><name>true</name></expr></argument>, <argument><expr><call><name><name>ULE</name><operator>-&gt;</operator><name>isOverloaded</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Decls</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Decls</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>UnresolvedReductions</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></for>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPInReductionClause</name><argument_list>(
<argument><expr><name>Vars</name></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getColonLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ReductionIdScopeSpec</name></expr></argument>, <argument><expr><name>NameInfo</name></expr></argument>, <argument><expr><name>UnresolvedReductions</name></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>OMPClause</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPLinearClause</name><argument_list>(<argument>OMPLinearClause *C</argument>)</argument_list></macro> <block>{
<expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name> <name>Vars</name></expr>;
<expr><call><name><name>Vars</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>varlist_size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>VE</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>varlists</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>EVar</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>VE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>EVar</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>Vars</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>EVar</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></for>}</block>
<name>ExprResult</name> <name>Step</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getStep</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Step</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPLinearClause</name><argument_list>(
<argument><expr><name>Vars</name></expr></argument>, <argument><expr><call><name><name>Step</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getModifier</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getModifierLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getColonLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>OMPClause</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPAlignedClause</name><argument_list>(<argument>OMPAlignedClause *C</argument>)</argument_list></macro> <block>{
<expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name> <name>Vars</name></expr>;
<expr><call><name><name>Vars</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>varlist_size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>VE</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>varlists</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>EVar</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>VE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>EVar</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>Vars</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>EVar</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></for>}</block>
<name>ExprResult</name> <name>Alignment</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getAlignment</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Alignment</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPAlignedClause</name><argument_list>(
<argument><expr><name>Vars</name></expr></argument>, <argument><expr><call><name><name>Alignment</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getColonLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>OMPClause</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPCopyinClause</name><argument_list>(<argument>OMPCopyinClause *C</argument>)</argument_list></macro> <block>{
<expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name> <name>Vars</name></expr>;
<expr><call><name><name>Vars</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>varlist_size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>VE</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>varlists</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>EVar</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>VE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>EVar</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>Vars</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>EVar</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></for>}</block></expr></expr_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPCopyinClause</name><argument_list>(<argument><expr><name>Vars</name></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>OMPClause</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPCopyprivateClause</name><argument_list>(<argument>OMPCopyprivateClause *C</argument>)</argument_list></macro> <block>{
<expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name> <name>Vars</name></expr>;
<expr><call><name><name>Vars</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>varlist_size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>VE</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>varlists</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>EVar</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>VE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>EVar</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>Vars</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>EVar</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></for>}</block></expr></expr_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPCopyprivateClause</name><argument_list>(
<argument><expr><name>Vars</name></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>OMPClause</name> <operator>*</operator><name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPFlushClause</name><argument_list>(<argument>OMPFlushClause *C</argument>)</argument_list></macro> <block>{
<expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name> <name>Vars</name></expr>;
<expr><call><name><name>Vars</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>varlist_size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>VE</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>varlists</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>EVar</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>VE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>EVar</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>Vars</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>EVar</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></for>}</block></expr></expr_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPFlushClause</name><argument_list>(<argument><expr><name>Vars</name></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>OMPClause</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPDepobjClause</name><argument_list>(<argument>OMPDepobjClause *C</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>E</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getDepobj</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPDepobjClause</name><argument_list>(<argument><expr><call><name><name>E</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>OMPClause</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPDependClause</name><argument_list>(<argument>OMPDependClause *C</argument>)</argument_list></macro> <block>{
<expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name> <name>Vars</name></expr>;
<expr><name>Expr</name> <operator>*</operator><name>DepModifier</name> <operator>=</operator> <call><name><name>C</name><operator>-&gt;</operator><name>getModifier</name></name><argument_list>()</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><name>DepModifier</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>DepModRes</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><name>DepModifier</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>DepModRes</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>DepModifier</name> <operator>=</operator> <call><name><name>DepModRes</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></if></if_stmt>}</block>
<call><name><name>Vars</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>varlist_size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>VE</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>varlists</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>EVar</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>VE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>EVar</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>Vars</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>EVar</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPDependClause</name><argument_list>(
<argument><expr><name>DepModifier</name></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getDependencyKind</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getDependencyLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getColonLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Vars</name></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>OMPClause</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPDeviceClause</name><argument_list>(<argument>OMPDeviceClause *C</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>E</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getDevice</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPDeviceClause</name><argument_list>(
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getModifier</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getModifierLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name></expr><operator>,</operator> <expr><name>class</name> <name>T</name><operator>&gt;</operator>
<name>bool</name> <macro><name>transformOMPMappableExprListClause</name><argument_list>(
<argument>TreeTransform&lt;Derived&gt; &amp;TT</argument>, <argument>OMPMappableExprListClause&lt;T&gt; *C</argument>,
<argument>llvm::SmallVectorImpl&lt;Expr *&gt; &amp;Vars</argument>, <argument>CXXScopeSpec &amp;MapperIdScopeSpec</argument>,
<argument>DeclarationNameInfo &amp;MapperIdInfo</argument>,
<argument>llvm::SmallVectorImpl&lt;Expr *&gt; &amp;UnresolvedMappers</argument>)</argument_list></macro> <block>{

<expr><call><name><name>Vars</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>varlist_size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>VE</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>varlists</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>EVar</name> <init>= <expr><call><name><name>TT</name><operator>.</operator><name>getDerived</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>VE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>EVar</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>Vars</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>EVar</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></for>}</block>

<name>NestedNameSpecifierLoc</name> <name>QualifierLoc</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>C</name><operator>-&gt;</operator><name>getMapperQualifierLoc</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>QualifierLoc</name> <operator>=</operator> <call><name><name>TT</name><operator>.</operator><name>getDerived</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformNestedNameSpecifierLoc</name><argument_list>(
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getMapperQualifierLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>QualifierLoc</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name><name>MapperIdScopeSpec</name><operator>.</operator><name>Adopt</name></name><argument_list>(<argument><expr><name>QualifierLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>MapperIdInfo</name> <operator>=</operator> <call><name><name>C</name><operator>-&gt;</operator><name>getMapperIdInfo</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>MapperIdInfo</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>MapperIdInfo</name> <operator>=</operator> <call><name><name>TT</name><operator>.</operator><name>getDerived</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDeclarationNameInfo</name><argument_list>(<argument><expr><name>MapperIdInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>MapperIdInfo</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>E</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>mapperlists</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>E</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>auto</name> <operator>*</operator><name>ULE</name> <operator>=</operator> <call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>UnresolvedLookupExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>UnresolvedSet</name><argument_list type="generic">&lt;<argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name></type> <name>Decls</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>D</name> <operator>:</operator> <call><name><name>ULE</name><operator>-&gt;</operator><name>decls</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>InstD</name> <init>=
<expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>TT</name><operator>.</operator><name>getDerived</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDecl</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getExprLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>Decls</name><operator>.</operator><name>addDecl</name></name><argument_list>(<argument><expr><name>InstD</name></expr></argument>, <argument><expr><call><name><name>InstD</name><operator>-&gt;</operator><name>getAccess</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name><name>UnresolvedMappers</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>UnresolvedLookupExpr</name><operator>::</operator><call><name>Create</name><argument_list>(
<argument><expr><call><name><name>TT</name><operator>.</operator><name>getSema</name></name><argument_list>()</argument_list></call><operator>.</operator><name>Context</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><call><name><name>MapperIdScopeSpec</name><operator>.</operator><name>getWithLocInContext</name></name><argument_list>(<argument><expr><call><name><name>TT</name><operator>.</operator><name>getSema</name></name><argument_list>()</argument_list></call><operator>.</operator><name>Context</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>MapperIdInfo</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><call><name><name>ULE</name><operator>-&gt;</operator><name>isOverloaded</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Decls</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Decls</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name><name>UnresolvedMappers</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>false</name></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>OMPClause</name> <operator>*</operator><name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPMapClause</name><argument_list>(<argument>OMPMapClause *C</argument>)</argument_list></macro> <block>{
<expr><name>OMPVarListLocTy</name> <call><name>Locs</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name> <name>Vars</name></expr>;
<expr><name>CXXScopeSpec</name> <name>MapperIdScopeSpec</name></expr>;
<expr><name>DeclarationNameInfo</name> <name>MapperIdInfo</name></expr>;
<expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name> <name>UnresolvedMappers</name></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>transformOMPMappableExprListClause</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>, <argument><expr><name>OMPMapClause</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><name>C</name></expr></argument>, <argument><expr><name>Vars</name></expr></argument>, <argument><expr><name>MapperIdScopeSpec</name></expr></argument>, <argument><expr><name>MapperIdInfo</name></expr></argument>, <argument><expr><name>UnresolvedMappers</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPMapClause</name><argument_list>(
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getMapTypeModifiers</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getMapTypeModifiersLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>MapperIdScopeSpec</name></expr></argument>,
<argument><expr><name>MapperIdInfo</name></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getMapType</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>isImplicitMapType</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getMapLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getColonLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Vars</name></expr></argument>, <argument><expr><name>Locs</name></expr></argument>, <argument><expr><name>UnresolvedMappers</name></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>OMPClause</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPAllocateClause</name><argument_list>(<argument>OMPAllocateClause *C</argument>)</argument_list></macro> <block>{
<expr><name>Expr</name> <operator>*</operator><name>Allocator</name> <operator>=</operator> <call><name><name>C</name><operator>-&gt;</operator><name>getAllocator</name></name><argument_list>()</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><name>Allocator</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>AllocatorRes</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><name>Allocator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>AllocatorRes</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>Allocator</name> <operator>=</operator> <call><name><name>AllocatorRes</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></if></if_stmt>}</block>
<name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name> <name>Vars</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Vars</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>varlist_size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>VE</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>varlists</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>EVar</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>VE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>EVar</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>Vars</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>EVar</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPAllocateClause</name><argument_list>(
<argument><expr><name>Allocator</name></expr></argument>, <argument><expr><name>Vars</name></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getColonLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>OMPClause</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPNumTeamsClause</name><argument_list>(<argument>OMPNumTeamsClause *C</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>E</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getNumTeams</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPNumTeamsClause</name><argument_list>(
<argument><expr><call><name><name>E</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>OMPClause</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPThreadLimitClause</name><argument_list>(<argument>OMPThreadLimitClause *C</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>E</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getThreadLimit</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPThreadLimitClause</name><argument_list>(
<argument><expr><call><name><name>E</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>OMPClause</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPPriorityClause</name><argument_list>(<argument>OMPPriorityClause *C</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>E</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getPriority</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPPriorityClause</name><argument_list>(
<argument><expr><call><name><name>E</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>OMPClause</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPGrainsizeClause</name><argument_list>(<argument>OMPGrainsizeClause *C</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>E</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getGrainsize</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPGrainsizeClause</name><argument_list>(
<argument><expr><call><name><name>E</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>OMPClause</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPNumTasksClause</name><argument_list>(<argument>OMPNumTasksClause *C</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>E</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getNumTasks</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPNumTasksClause</name><argument_list>(
<argument><expr><call><name><name>E</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>OMPClause</name> <operator>*</operator><name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPHintClause</name><argument_list>(<argument>OMPHintClause *C</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>E</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getHint</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPHintClause</name><argument_list>(<argument><expr><call><name><name>E</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>OMPClause</name> <operator>*</operator><name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPDistScheduleClause</name><argument_list>(
<argument>OMPDistScheduleClause *C</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>E</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getChunkSize</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPDistScheduleClause</name><argument_list>(
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getDistScheduleKind</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getDistScheduleKindLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getCommaLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>OMPClause</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPDefaultmapClause</name><argument_list>(<argument>OMPDefaultmapClause *C</argument>)</argument_list></macro> <block>{


<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPDefaultmapClause</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getDefaultmapModifier</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getDefaultmapKind</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getDefaultmapModifierLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getDefaultmapKindLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>OMPClause</name> <operator>*</operator><name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPToClause</name><argument_list>(<argument>OMPToClause *C</argument>)</argument_list></macro> <block>{
<expr><name>OMPVarListLocTy</name> <call><name>Locs</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name> <name>Vars</name></expr>;
<expr><name>CXXScopeSpec</name> <name>MapperIdScopeSpec</name></expr>;
<expr><name>DeclarationNameInfo</name> <name>MapperIdInfo</name></expr>;
<expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name> <name>UnresolvedMappers</name></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>transformOMPMappableExprListClause</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>, <argument><expr><name>OMPToClause</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><name>C</name></expr></argument>, <argument><expr><name>Vars</name></expr></argument>, <argument><expr><name>MapperIdScopeSpec</name></expr></argument>, <argument><expr><name>MapperIdInfo</name></expr></argument>, <argument><expr><name>UnresolvedMappers</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPToClause</name><argument_list>(
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getMotionModifiers</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getMotionModifiersLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>MapperIdScopeSpec</name></expr></argument>,
<argument><expr><name>MapperIdInfo</name></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getColonLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Vars</name></expr></argument>, <argument><expr><name>Locs</name></expr></argument>, <argument><expr><name>UnresolvedMappers</name></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>OMPClause</name> <operator>*</operator><name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPFromClause</name><argument_list>(<argument>OMPFromClause *C</argument>)</argument_list></macro> <block>{
<expr><name>OMPVarListLocTy</name> <call><name>Locs</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name> <name>Vars</name></expr>;
<expr><name>CXXScopeSpec</name> <name>MapperIdScopeSpec</name></expr>;
<expr><name>DeclarationNameInfo</name> <name>MapperIdInfo</name></expr>;
<expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name> <name>UnresolvedMappers</name></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>transformOMPMappableExprListClause</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>, <argument><expr><name>OMPFromClause</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><name>C</name></expr></argument>, <argument><expr><name>Vars</name></expr></argument>, <argument><expr><name>MapperIdScopeSpec</name></expr></argument>, <argument><expr><name>MapperIdInfo</name></expr></argument>, <argument><expr><name>UnresolvedMappers</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPFromClause</name><argument_list>(
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getMotionModifiers</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getMotionModifiersLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>MapperIdScopeSpec</name></expr></argument>,
<argument><expr><name>MapperIdInfo</name></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getColonLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Vars</name></expr></argument>, <argument><expr><name>Locs</name></expr></argument>, <argument><expr><name>UnresolvedMappers</name></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>OMPClause</name> <operator>*</operator><name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPUseDevicePtrClause</name><argument_list>(
<argument>OMPUseDevicePtrClause *C</argument>)</argument_list></macro> <block>{
<expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name> <name>Vars</name></expr>;
<expr><call><name><name>Vars</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>varlist_size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>VE</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>varlists</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>EVar</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>VE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>EVar</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>Vars</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>EVar</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></for>}</block>
<name>OMPVarListLocTy</name> <call><name>Locs</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPUseDevicePtrClause</name><argument_list>(<argument><expr><name>Vars</name></expr></argument>, <argument><expr><name>Locs</name></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>OMPClause</name> <operator>*</operator><name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPUseDeviceAddrClause</name><argument_list>(
<argument>OMPUseDeviceAddrClause *C</argument>)</argument_list></macro> <block>{
<expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name> <name>Vars</name></expr>;
<expr><call><name><name>Vars</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>varlist_size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>VE</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>varlists</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>EVar</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>VE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>EVar</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>Vars</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>EVar</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></for>}</block>
<name>OMPVarListLocTy</name> <call><name>Locs</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPUseDeviceAddrClause</name><argument_list>(<argument><expr><name>Vars</name></expr></argument>, <argument><expr><name>Locs</name></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>OMPClause</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPIsDevicePtrClause</name><argument_list>(<argument>OMPIsDevicePtrClause *C</argument>)</argument_list></macro> <block>{
<expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name> <name>Vars</name></expr>;
<expr><call><name><name>Vars</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>varlist_size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>VE</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>varlists</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>EVar</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>VE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>EVar</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>Vars</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>EVar</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></for>}</block>
<name>OMPVarListLocTy</name> <call><name>Locs</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPIsDevicePtrClause</name><argument_list>(<argument><expr><name>Vars</name></expr></argument>, <argument><expr><name>Locs</name></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>OMPClause</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPNontemporalClause</name><argument_list>(<argument>OMPNontemporalClause *C</argument>)</argument_list></macro> <block>{
<expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name> <name>Vars</name></expr>;
<expr><call><name><name>Vars</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>varlist_size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>VE</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>varlists</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>EVar</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>VE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>EVar</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>Vars</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>EVar</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></for>}</block></expr></expr_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPNontemporalClause</name><argument_list>(
<argument><expr><name>Vars</name></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>OMPClause</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPInclusiveClause</name><argument_list>(<argument>OMPInclusiveClause *C</argument>)</argument_list></macro> <block>{
<expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name> <name>Vars</name></expr>;
<expr><call><name><name>Vars</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>varlist_size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>VE</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>varlists</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>EVar</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>VE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>EVar</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>Vars</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>EVar</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></for>}</block></expr></expr_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPInclusiveClause</name><argument_list>(
<argument><expr><name>Vars</name></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>OMPClause</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPExclusiveClause</name><argument_list>(<argument>OMPExclusiveClause *C</argument>)</argument_list></macro> <block>{
<expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name> <name>Vars</name></expr>;
<expr><call><name><name>Vars</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>varlist_size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>VE</name> <operator>:</operator> <call><name><name>C</name><operator>-&gt;</operator><name>varlists</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>EVar</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>VE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>EVar</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>Vars</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>EVar</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></for>}</block></expr></expr_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPExclusiveClause</name><argument_list>(
<argument><expr><name>Vars</name></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>OMPClause</name> <operator>*</operator><name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPUsesAllocatorsClause</name><argument_list>(
<argument>OMPUsesAllocatorsClause *C</argument>)</argument_list></macro> <block>{
<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Sema</name><operator>::</operator><name>UsesAllocatorsData</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name> <name>Data</name></expr>;
<expr><call><name><name>Data</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getNumberOfAllocators</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>I</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>E</name> <init>= <expr><call><name><name>C</name><operator>-&gt;</operator><name>getNumberOfAllocators</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>I</name> <operator>&lt;</operator> <name>E</name></expr>;</condition> <incr><expr><operator>++</operator><name>I</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>OMPUsesAllocatorsClause</name><operator>::</operator><name>Data</name> <name>D</name> <operator>=</operator> <call><name><name>C</name><operator>-&gt;</operator><name>getAllocatorData</name></name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>Allocator</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><name><name>D</name><operator>.</operator><name>Allocator</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Allocator</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>AllocatorTraits</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<decl><type><name>Expr</name> <modifier>*</modifier></type><name>AT</name> <init>= <expr><name><name>D</name><operator>.</operator><name>AllocatorTraits</name></name></expr></init></decl>)</condition> <block>{<block_content>
<expr_stmt><expr><name>AllocatorTraits</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><name>AT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>AllocatorTraits</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt/></block_content></block></if></if_stmt></block_content></block></for>}</block>
<name>Sema</name><operator>::</operator><name>UsesAllocatorsData</name> <operator>&amp;</operator><name>NewD</name> <operator>=</operator> <call><name><name>Data</name><operator>.</operator><name>emplace_back</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>NewD</name><operator>.</operator><name>Allocator</name></name> <operator>=</operator> <call><name><name>Allocator</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>NewD</name><operator>.</operator><name>AllocatorTraits</name></name> <operator>=</operator> <call><name><name>AllocatorTraits</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>NewD</name><operator>.</operator><name>LParenLoc</name></name> <operator>=</operator> <name><name>D</name><operator>.</operator><name>LParenLoc</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>NewD</name><operator>.</operator><name>RParenLoc</name></name> <operator>=</operator> <name><name>D</name><operator>.</operator><name>RParenLoc</name></name></expr>;</expr_stmt>
}
return <expr_stmt><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPUsesAllocatorsClause</name><argument_list>(
<argument><expr><name>Data</name></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>OMPClause</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPAffinityClause</name><argument_list>(<argument>OMPAffinityClause *C</argument>)</argument_list></macro> <block>{
<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>Locators</name></expr>;
<expr><call><name><name>Locators</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>varlist_size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>ExprResult</name> <name>ModifierRes</name></expr>;
<if_stmt><if>if <condition>(<decl><type><name>Expr</name> <modifier>*</modifier></type><name>Modifier</name> <init>= <expr><call><name><name>C</name><operator>-&gt;</operator><name>getModifier</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ModifierRes</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><name>Modifier</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>ModifierRes</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt/></block_content></block></if></if_stmt>}</block></expr></expr_stmt>
<for>for <control>(<init><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name> <range>: <expr><call><name><name>C</name><operator>-&gt;</operator><name>varlists</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>Locator</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Locator</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>Locators</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>Locator</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPAffinityClause</name><argument_list>(
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getColonLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>ModifierRes</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Locators</name></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>OMPClause</name> <operator>*</operator><name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPOrderClause</name><argument_list>(<argument>OMPOrderClause *C</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPOrderClause</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getKindKwLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>




<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformConstantExpr</name><argument_list>(<argument>ConstantExpr *E</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getSubExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>ExprResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformSYCLUniqueStableNameExpr</name><argument_list>(
<argument>SYCLUniqueStableNameExpr *E</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>E</name><operator>-&gt;</operator><name>isTypeDependent</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt>

<name>TypeSourceInfo</name> <operator>*</operator><name>NewT</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getTypeSourceInfo</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>NewT</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getTypeSourceInfo</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>NewT</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildSYCLUniqueStableNameExpr</name><argument_list>(
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getLocation</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getLParenLocation</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getRParenLocation</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NewT</name></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformPredefinedExpr</name><argument_list>(<argument>PredefinedExpr *E</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>E</name><operator>-&gt;</operator><name>isTypeDependent</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildPredefinedExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getLocation</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getIdentKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformDeclRefExpr</name><argument_list>(<argument>DeclRefExpr *E</argument>)</argument_list></macro> <block>{
<expr><name>NestedNameSpecifierLoc</name> <name>QualifierLoc</name></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>-&gt;</operator><name>getQualifierLoc</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>QualifierLoc</name>
<operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformNestedNameSpecifierLoc</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getQualifierLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>QualifierLoc</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt/></block_content></block></if></if_stmt>}</block>

<name>ValueDecl</name> <operator>*</operator><name>ND</name>
<operator>=</operator> <call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>ValueDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDecl</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getLocation</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getDecl</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ND</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>Found</name> <init>= <expr><name>ND</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>-&gt;</operator><name>getFoundDecl</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getDecl</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Found</name> <operator>=</operator> <call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDecl</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getLocation</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getFoundDecl</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Found</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>DeclarationNameInfo</name></type> <name>NameInfo</name> <init>= <expr><call><name><name>E</name><operator>-&gt;</operator><name>getNameInfo</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>NameInfo</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>NameInfo</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDeclarationNameInfo</name><argument_list>(<argument><expr><name>NameInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>NameInfo</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<name>QualifierLoc</name> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getQualifierLoc</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<name>ND</name> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getDecl</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<name>Found</name> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getFoundDecl</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>NameInfo</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getDecl</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getDeclName</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name><name>E</name><operator>-&gt;</operator><name>hasExplicitTemplateArgs</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><call><name><name>SemaRef</name><operator>.</operator><name>MarkDeclRefReferenced</name></name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>E</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>TemplateArgumentListInfo</name></type> <name>TransArgs</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>TemplateArgs</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>-&gt;</operator><name>hasExplicitTemplateArgs</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>TemplateArgs</name> <operator>=</operator> <operator>&amp;</operator><name>TransArgs</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>TransArgs</name><operator>.</operator><name>setLAngleLoc</name></name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getLAngleLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>TransArgs</name><operator>.</operator><name>setRAngleLoc</name></name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getRAngleLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformTemplateArguments</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getTemplateArgs</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getNumTemplateArgs</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>TransArgs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildDeclRefExpr</name><argument_list>(<argument><expr><name>QualifierLoc</name></expr></argument>, <argument><expr><name>ND</name></expr></argument>, <argument><expr><name>NameInfo</name></expr></argument>,
<argument><expr><name>Found</name></expr></argument>, <argument><expr><name>TemplateArgs</name></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformIntegerLiteral</name><argument_list>(<argument>IntegerLiteral *E</argument>)</argument_list></macro> <block>{
<return>return <expr><name>E</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>ExprResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformFixedPointLiteral</name><argument_list>(
<argument>FixedPointLiteral *E</argument>)</argument_list></macro> <block>{
<return>return <expr><name>E</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformFloatingLiteral</name><argument_list>(<argument>FloatingLiteral *E</argument>)</argument_list></macro> <block>{
<return>return <expr><name>E</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformImaginaryLiteral</name><argument_list>(<argument>ImaginaryLiteral *E</argument>)</argument_list></macro> <block>{
<return>return <expr><name>E</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformStringLiteral</name><argument_list>(<argument>StringLiteral *E</argument>)</argument_list></macro> <block>{
<return>return <expr><name>E</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformCharacterLiteral</name><argument_list>(<argument>CharacterLiteral *E</argument>)</argument_list></macro> <block>{
<return>return <expr><name>E</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformUserDefinedLiteral</name><argument_list>(<argument>UserDefinedLiteral *E</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>FD</name> <init>= <expr><call><name><name>E</name><operator>-&gt;</operator><name>getDirectCallee</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>SemaRef</name><operator>.</operator><name>MarkFunctionReferenced</name></name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>FD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>MaybeBindToTemporary</name></name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformGenericSelectionExpr</name><argument_list>(<argument>GenericSelectionExpr *E</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>ControllingExpr</name> <operator>=</operator>
<call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getControllingExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>ControllingExpr</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>AssocExprs</name></block></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>TypeSourceInfo</name> <modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>AssocTypes</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><specifier>const</specifier> <name>GenericSelectionExpr</name><operator>::</operator><name>Association</name> <name>Assoc</name> <operator>:</operator> <call><name><name>E</name><operator>-&gt;</operator><name>associations</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TSI</name> <init>= <expr><call><name><name>Assoc</name><operator>.</operator><name>getTypeSourceInfo</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>TSI</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>AssocType</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>TSI</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>AssocType</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>AssocTypes</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>AssocType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name><name>AssocTypes</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<decl_stmt><decl><type><name>ExprResult</name></type> <name>AssocExpr</name> <init>=
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>Assoc</name><operator>.</operator><name>getAssociationExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>AssocExpr</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>AssocExprs</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>AssocExpr</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildGenericSelectionExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getGenericLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getDefaultLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getRParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>ControllingExpr</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>AssocTypes</name></expr></argument>,
<argument><expr><name>AssocExprs</name></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformParenExpr</name><argument_list>(<argument>ParenExpr *E</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>SubExpr</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getSubExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>SubExpr</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>SubExpr</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getSubExpr</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildParenExpr</name><argument_list>(<argument><expr><call><name><name>SubExpr</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getLParen</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getRParen</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}




template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformAddressOfOperand</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<decl><type><name>DependentScopeDeclRefExpr</name> <modifier>*</modifier></type><name>DRE</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>DependentScopeDeclRefExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDependentScopeDeclRefExpr</name><argument_list>(<argument><expr><name>DRE</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformUnaryOperator</name><argument_list>(<argument>UnaryOperator *E</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>SubExpr</name></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>-&gt;</operator><name>getOpcode</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>UO_AddrOf</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>SubExpr</name> <operator>=</operator> <call><name>TransformAddressOfOperand</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getSubExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>SubExpr</name> <operator>=</operator> <call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getSubExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt></block></expr></expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>SubExpr</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>SubExpr</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getSubExpr</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildUnaryOperator</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getOperatorLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getOpcode</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>SubExpr</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOffsetOfExpr</name><argument_list>(<argument>OffsetOfExpr *E</argument>)</argument_list></macro> <block>{

<expr><name>TypeSourceInfo</name> <operator>*</operator><name>Type</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getTypeSourceInfo</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Type</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>







<name>bool</name> <name>ExprChanged</name> <operator>=</operator> <name>false</name></block></expr>;</expr_stmt>
<typedef>typedef <expr_stmt><expr><name>Sema</name><operator>::</operator><name>OffsetOfComponent</name> <name>Component</name></expr>;</expr_stmt></typedef>
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Component</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>Components</name></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>I</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>N</name> <init>= <expr><call><name><name>E</name><operator>-&gt;</operator><name>getNumComponents</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>I</name> <operator>!=</operator> <name>N</name></expr>;</condition> <incr><expr><operator>++</operator><name>I</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>OffsetOfNode</name> <modifier>&amp;</modifier></type><name>ON</name> <init>= <expr><call><name><name>E</name><operator>-&gt;</operator><name>getComponent</name></name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Component</name></type> <name>Comp</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>Comp</name><operator>.</operator><name>isBrackets</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Comp</name><operator>.</operator><name>LocStart</name></name> <operator>=</operator> <call><name><name>ON</name><operator>.</operator><name>getSourceRange</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getBegin</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Comp</name><operator>.</operator><name>LocEnd</name></name> <operator>=</operator> <call><name><name>ON</name><operator>.</operator><name>getSourceRange</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getEnd</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><call><name><name>ON</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>OffsetOfNode</name><operator>::</operator><name>Array</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>FromIndex</name> <init>= <expr><call><name><name>E</name><operator>-&gt;</operator><name>getIndexExpr</name></name><argument_list>(<argument><expr><call><name><name>ON</name><operator>.</operator><name>getArrayExprIndex</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>Index</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><name>FromIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Index</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ExprChanged</name> <operator>=</operator> <name>ExprChanged</name> <operator>||</operator> <call><name><name>Index</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>FromIndex</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Comp</name><operator>.</operator><name>isBrackets</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Comp</name><operator>.</operator><name>U</name><operator>.</operator><name>E</name></name> <operator>=</operator> <call><name><name>Index</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>

<case>case <expr><name>OffsetOfNode</name><operator>::</operator><name>Field</name></expr>:</case>
<case>case <expr><name>OffsetOfNode</name><operator>::</operator><name>Identifier</name></expr>:</case>
<expr_stmt><expr><name><name>Comp</name><operator>.</operator><name>isBrackets</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Comp</name><operator>.</operator><name>U</name><operator>.</operator><name>IdentInfo</name></name> <operator>=</operator> <call><name><name>ON</name><operator>.</operator><name>getFieldName</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>Comp</name><operator>.</operator><name>U</name><operator>.</operator><name>IdentInfo</name></name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>OffsetOfNode</name><operator>::</operator><name>Base</name></expr>:</case>

<continue>continue;</continue>
</block_content>}</block></switch>

<expr_stmt><expr><call><name><name>Components</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>Comp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<name>Type</name> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getTypeSourceInfo</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><name>ExprChanged</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt>


<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOffsetOfExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getOperatorLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Type</name></expr></argument>,
<argument><expr><name>Components</name></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getRParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOpaqueValueExpr</name><argument_list>(<argument>OpaqueValueExpr *E</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><operator>!</operator><call><name><name>E</name><operator>-&gt;</operator><name>getSourceExpr</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlreadyTransformed</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"opaque value expression requires transformation"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>E</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformTypoExpr</name><argument_list>(<argument>TypoExpr *E</argument>)</argument_list></macro> <block>{
<return>return <expr><name>E</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>ExprResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformRecoveryExpr</name><argument_list>(<argument>RecoveryExpr *E</argument>)</argument_list></macro> <block>{
<expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name> <name>Children</name></expr>;
<expr><name>bool</name> <name>Changed</name> <operator>=</operator> <name>false</name></expr>;
<for>for <control>(<init><decl><type><name>Expr</name> <modifier>*</modifier></type><name>C</name> <range>: <expr><call><name><name>E</name><operator>-&gt;</operator><name>subExpressions</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>NewC</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>NewC</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>Children</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>NewC</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>Changed</name> <operator>|=</operator> <call><name><name>NewC</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>C</name></expr>;</expr_stmt>
<expr_stmt/></block_content></block></for>}</block></expr></expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>Changed</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildRecoveryExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>Children</name></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformPseudoObjectExpr</name><argument_list>(<argument>PseudoObjectExpr *E</argument>)</argument_list></macro> <block>{






<expr><name>Expr</name> <operator>*</operator><name>newSyntacticForm</name> <operator>=</operator> <call><name><name>SemaRef</name><operator>.</operator><name>recreateSyntacticForm</name></name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>;
<expr><name>ExprResult</name> <name>result</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><name>newSyntacticForm</name></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>result</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>




<if_stmt><if>if <condition>(<expr><call><name><name>result</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>hasPlaceholderType</name><argument_list>(<argument><expr><name>BuiltinType</name><operator>::</operator><name>PseudoObject</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name><name>SemaRef</name><operator>.</operator><name>checkPseudoObjectRValue</name></name><argument_list>(<argument><expr><call><name><name>result</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>result</name></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformUnaryExprOrTypeTraitExpr</name><argument_list>(
<argument>UnaryExprOrTypeTraitExpr *E</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>-&gt;</operator><name>isArgumentType</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>OldT</name> <init>= <expr><call><name><name>E</name><operator>-&gt;</operator><name>getArgumentTypeInfo</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>NewT</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>OldT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>NewT</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>OldT</name> <operator>==</operator> <name>NewT</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildUnaryExprOrTypeTrait</name><argument_list>(<argument><expr><name>NewT</name></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getOperatorLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getSourceRange</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<expr_stmt/></block_content></block></if></if_stmt>}</block>




<name>EnterExpressionEvaluationContext</name> <call><name>Unevaluated</name><argument_list>(
<argument><expr><name>SemaRef</name></expr></argument>, <argument><expr><name>Sema</name><operator>::</operator><name>ExpressionEvaluationContext</name><operator>::</operator><name>Unevaluated</name></expr></argument>,
<argument><expr><name>Sema</name><operator>::</operator><name>ReuseLambdaContextDecl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<decl_stmt><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>RecoveryTSI</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>SubExpr</name></decl>;</decl_stmt>
<expr_stmt><expr><name>auto</name> <operator>*</operator><name>PE</name> <operator>=</operator> <call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>ParenExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getArgumentExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>DRE</name> <operator>=</operator>
<ternary><condition><expr><name>PE</name></expr> ?</condition><then> <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>DependentScopeDeclRefExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>PE</name><operator>-&gt;</operator><name>getSubExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>nullptr</name></expr></else></ternary></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>SubExpr</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformParenDependentScopeDeclRefExpr</name><argument_list>(
<argument><expr><name>PE</name></expr></argument>, <argument><expr><name>DRE</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>RecoveryTSI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>SubExpr</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getArgumentExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>RecoveryTSI</name></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildUnaryExprOrTypeTrait</name><argument_list>(
<argument><expr><name>RecoveryTSI</name></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getOperatorLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getSourceRange</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>SubExpr</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>SubExpr</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getArgumentExpr</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildUnaryExprOrTypeTrait</name><argument_list>(<argument><expr><call><name><name>SubExpr</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getOperatorLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getSourceRange</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformArraySubscriptExpr</name><argument_list>(<argument>ArraySubscriptExpr *E</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>LHS</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getLHS</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>LHS</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>ExprResult</name> <name>RHS</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getRHS</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>RHS</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>LHS</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getLHS</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>RHS</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getRHS</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildArraySubscriptExpr</name><argument_list>(
<argument><expr><call><name><name>LHS</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getLHS</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getBeginLoc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>RHS</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getRBracketLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformMatrixSubscriptExpr</name><argument_list>(<argument>MatrixSubscriptExpr *E</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>Base</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBase</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Base</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>ExprResult</name> <name>RowIdx</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getRowIdx</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>RowIdx</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>ExprResult</name></type> <name>ColumnIdx</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getColumnIdx</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>ColumnIdx</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>Base</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getBase</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>RowIdx</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getRowIdx</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>ColumnIdx</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getColumnIdx</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildMatrixSubscriptExpr</name><argument_list>(
<argument><expr><call><name><name>Base</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>RowIdx</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>ColumnIdx</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getRBracketLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPArraySectionExpr</name><argument_list>(<argument>OMPArraySectionExpr *E</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>Base</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBase</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Base</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>ExprResult</name> <name>LowerBound</name></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>-&gt;</operator><name>getLowerBound</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>LowerBound</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getLowerBound</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>LowerBound</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ExprResult</name></type> <name>Length</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>-&gt;</operator><name>getLength</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Length</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getLength</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Length</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ExprResult</name></type> <name>Stride</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<decl><type><name>Expr</name> <modifier>*</modifier></type><name>Str</name> <init>= <expr><call><name><name>E</name><operator>-&gt;</operator><name>getStride</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Stride</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><name>Str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Stride</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>Base</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getBase</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>LowerBound</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getLowerBound</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>Length</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getLength</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPArraySectionExpr</name><argument_list>(
<argument><expr><call><name><name>Base</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBase</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getEndLoc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>LowerBound</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getColonLocFirst</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getColonLocSecond</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Length</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Stride</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getRBracketLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPArrayShapingExpr</name><argument_list>(<argument>OMPArrayShapingExpr *E</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>Base</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBase</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Base</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>Dims</name></block></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>ErrorFound</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Dim</name> <range>: <expr><call><name><name>E</name><operator>-&gt;</operator><name>getDimensions</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>DimRes</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><name>Dim</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>DimRes</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ErrorFound</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name><name>Dims</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>DimRes</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>ErrorFound</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPArrayShapingExpr</name><argument_list>(<argument><expr><call><name><name>Base</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getRParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Dims</name></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBracketsRanges</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOMPIteratorExpr</name><argument_list>(<argument>OMPIteratorExpr *E</argument>)</argument_list></macro> <block>{
<expr><name>unsigned</name> <name>NumIterators</name> <operator>=</operator> <call><name><name>E</name><operator>-&gt;</operator><name>numOfIterators</name></name><argument_list>()</argument_list></call></expr>;
<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Sema</name><operator>::</operator><name>OMPIteratorData</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <call><name>Data</name><argument_list>(<argument><expr><name>NumIterators</name></expr></argument>)</argument_list></call></expr>;

<expr><name>bool</name> <name>ErrorFound</name> <operator>=</operator> <name>false</name></expr>;
<expr><name>bool</name> <name>NeedToRebuild</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call></expr>;
<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>I</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>I</name> <operator>&lt;</operator> <name>NumIterators</name></expr>;</condition> <incr><expr><operator>++</operator><name>I</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>auto</name> <operator>*</operator><name>D</name> <operator>=</operator> <call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>VarDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getIteratorDecl</name></name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Data</name><index>[<expr><name>I</name></expr>]</index></name><operator>.</operator><name>DeclIdent</name> <operator>=</operator> <call><name><name>D</name><operator>-&gt;</operator><name>getIdentifier</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Data</name><index>[<expr><name>I</name></expr>]</index></name><operator>.</operator><name>DeclIdentLoc</name> <operator>=</operator> <call><name><name>D</name><operator>-&gt;</operator><name>getLocation</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>D</name><operator>-&gt;</operator><name>getLocation</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>D</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>hasSameType</name></name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>IntTy</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"Implicit type must be int."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></if></if_stmt></block_content></block></for>}</block></expr></expr_stmt> <if_stmt><else>else <block>{<block_content>
<decl_stmt><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TSI</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getTypeSourceInfo</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>QualType</name></type> <name>DeclTy</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>Data</name><index>[<expr><name>I</name></expr>]</index></name><operator>.</operator><name>Type</name> <operator>=</operator> <call><name><name>SemaRef</name><operator>.</operator><name>CreateParsedType</name></name><argument_list>(<argument><expr><name>DeclTy</name></expr></argument>, <argument><expr><name>TSI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>OMPIteratorExpr</name><operator>::</operator><name>IteratorRange</name> <name>Range</name> <operator>=</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getIteratorRange</name></name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>Begin</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><name><name>Range</name><operator>.</operator><name>Begin</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>End</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><name><name>Range</name><operator>.</operator><name>End</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>Step</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><name><name>Range</name><operator>.</operator><name>Step</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>ErrorFound</name> <operator>=</operator> <name>ErrorFound</name> <operator>||</operator>
<operator>!</operator><operator>(</operator><operator>!</operator><call><name><name>D</name><operator>-&gt;</operator><name>getTypeSourceInfo</name></name><argument_list>()</argument_list></call> <operator>||</operator> <operator>(</operator><name><name>Data</name><index>[<expr><name>I</name></expr>]</index></name><operator>.</operator><call><name><name>Type</name><operator>.</operator><name>getAsOpaquePtr</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><name><name>Data</name><index>[<expr><name>I</name></expr>]</index></name><operator>.</operator><call><name><name>Type</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isNull</name><argument_list>()</argument_list></call><operator>)</operator><operator>)</operator> <operator>||</operator>
<call><name><name>Begin</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>End</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>Step</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ErrorFound</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>Data</name><index>[<expr><name>I</name></expr>]</index></name><operator>.</operator><name><name>Range</name><operator>.</operator><name>Begin</name></name> <operator>=</operator> <call><name><name>Begin</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Data</name><index>[<expr><name>I</name></expr>]</index></name><operator>.</operator><name><name>Range</name><operator>.</operator><name>End</name></name> <operator>=</operator> <call><name><name>End</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Data</name><index>[<expr><name>I</name></expr>]</index></name><operator>.</operator><name><name>Range</name><operator>.</operator><name>Step</name></name> <operator>=</operator> <call><name><name>Step</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Data</name><index>[<expr><name>I</name></expr>]</index></name><operator>.</operator><name>AssignLoc</name> <operator>=</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getAssignLoc</name></name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Data</name><index>[<expr><name>I</name></expr>]</index></name><operator>.</operator><name>ColonLoc</name> <operator>=</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getColonLoc</name></name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Data</name><index>[<expr><name>I</name></expr>]</index></name><operator>.</operator><name>SecColonLoc</name> <operator>=</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getSecondColonLoc</name></name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>NeedToRebuild</name> <operator>=</operator>
<name>NeedToRebuild</name> <operator>||</operator>
<operator>(</operator><call><name><name>D</name><operator>-&gt;</operator><name>getTypeSourceInfo</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name><name>Data</name><index>[<expr><name>I</name></expr>]</index></name><operator>.</operator><call><name><name>Type</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getTypePtrOrNull</name><argument_list>()</argument_list></call> <operator>!=</operator>
<call><name><name>D</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getTypePtrOrNull</name><argument_list>()</argument_list></call><operator>)</operator> <operator>||</operator>
<name><name>Range</name><operator>.</operator><name>Begin</name></name> <operator>!=</operator> <name><name>Data</name><index>[<expr><name>I</name></expr>]</index></name><operator>.</operator><name><name>Range</name><operator>.</operator><name>Begin</name></name> <operator>||</operator> <name><name>Range</name><operator>.</operator><name>End</name></name> <operator>!=</operator> <name><name>Data</name><index>[<expr><name>I</name></expr>]</index></name><operator>.</operator><name><name>Range</name><operator>.</operator><name>End</name></name> <operator>||</operator>
<name><name>Range</name><operator>.</operator><name>Step</name></name> <operator>!=</operator> <name><name>Data</name><index>[<expr><name>I</name></expr>]</index></name><operator>.</operator><name><name>Range</name><operator>.</operator><name>Step</name></name></expr>;</expr_stmt>
}
if <expr_stmt><expr><operator>(</operator><name>ErrorFound</name><operator>)</operator></expr></expr_stmt>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>NeedToRebuild</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>ExprResult</name></type> <name>Res</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildOMPIteratorExpr</name><argument_list>(
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getIteratorKwLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getRParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Data</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>Res</name><operator>.</operator><name>isUsable</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>Res</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>auto</name> <operator>*</operator><name>IE</name> <operator>=</operator> <call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPIteratorExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Res</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>I</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>I</name> <operator>&lt;</operator> <name>NumIterators</name></expr>;</condition> <incr><expr><operator>++</operator><name>I</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>transformedLocalDecl</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getIteratorDecl</name></name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>IE</name><operator>-&gt;</operator><name>getIteratorDecl</name></name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<return>return <expr><name>Res</name></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformCallExpr</name><argument_list>(<argument>CallExpr *E</argument>)</argument_list></macro> <block>{

<expr><name>ExprResult</name> <name>Callee</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getCallee</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Callee</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<name>bool</name> <name>ArgChanged</name> <operator>=</operator> <name>false</name></block></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name><modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name></type> <name>Args</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExprs</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getArgs</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getNumArgs</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>Args</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>ArgChanged</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>Callee</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getCallee</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><name>ArgChanged</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>MaybeBindToTemporary</name></name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>FakeLParenLoc</name>
<init>= <expr><operator>(</operator><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><call><name><name>Callee</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call><operator>)</operator><operator>-&gt;</operator><call><name>getSourceRange</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getBegin</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>Sema</name><operator>::</operator><name>FPFeaturesStateRAII</name> <call><name>FPFeaturesState</name><argument_list>(<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>-&gt;</operator><name>hasStoredFPFeatures</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>FPOptionsOverride</name></type> <name>NewOverrides</name> <init>= <expr><call><name><name>E</name><operator>-&gt;</operator><name>getFPFeatures</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><name>CurFPFeatures</name> <operator>=</operator>
<call><name><name>NewOverrides</name><operator>.</operator><name>applyOverrides</name></name><argument_list>(<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getLangOpts</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><name><name>FpPragmaStack</name><operator>.</operator><name>CurrentValue</name></name> <operator>=</operator> <name>NewOverrides</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildCallExpr</name><argument_list>(<argument><expr><call><name><name>Callee</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>FakeLParenLoc</name></expr></argument>,
<argument><expr><name>Args</name></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getRParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformMemberExpr</name><argument_list>(<argument>MemberExpr *E</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>Base</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBase</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Base</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>NestedNameSpecifierLoc</name> <name>QualifierLoc</name></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>-&gt;</operator><name>hasQualifier</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>QualifierLoc</name>
<operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformNestedNameSpecifierLoc</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getQualifierLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>QualifierLoc</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>TemplateKWLoc</name> <init>= <expr><call><name><name>E</name><operator>-&gt;</operator><name>getTemplateKeywordLoc</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ValueDecl</name> <modifier>*</modifier></type><name>Member</name>
<init>= <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>ValueDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDecl</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getMemberLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getMemberDecl</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Member</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>FoundDecl</name> <init>= <expr><call><name><name>E</name><operator>-&gt;</operator><name>getFoundDecl</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>FoundDecl</name> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getMemberDecl</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>FoundDecl</name> <operator>=</operator> <name>Member</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>FoundDecl</name> <operator>=</operator> <call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDecl</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getMemberLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>FoundDecl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>FoundDecl</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>Base</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getBase</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<name>QualifierLoc</name> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getQualifierLoc</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<name>Member</name> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getMemberDecl</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<name>FoundDecl</name> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getFoundDecl</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name><name>E</name><operator>-&gt;</operator><name>hasExplicitTemplateArgs</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><call><name><name>SemaRef</name><operator>.</operator><name>MarkMemberReferenced</name></name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>E</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>TemplateArgumentListInfo</name></type> <name>TransArgs</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>-&gt;</operator><name>hasExplicitTemplateArgs</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>TransArgs</name><operator>.</operator><name>setLAngleLoc</name></name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getLAngleLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>TransArgs</name><operator>.</operator><name>setRAngleLoc</name></name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getRAngleLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformTemplateArguments</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getTemplateArgs</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getNumTemplateArgs</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>TransArgs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>FakeOperatorLoc</name> <init>=
<expr><call><name><name>SemaRef</name><operator>.</operator><name>getLocForEndOfToken</name></name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBase</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getSourceRange</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getEnd</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>





<decl_stmt><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>FirstQualifierInScope</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DeclarationNameInfo</name></type> <name>MemberNameInfo</name> <init>= <expr><call><name><name>E</name><operator>-&gt;</operator><name>getMemberNameInfo</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>MemberNameInfo</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>MemberNameInfo</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDeclarationNameInfo</name><argument_list>(<argument><expr><name>MemberNameInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>MemberNameInfo</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildMemberExpr</name><argument_list>(<argument><expr><call><name><name>Base</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>FakeOperatorLoc</name></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>isArrow</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>QualifierLoc</name></expr></argument>,
<argument><expr><name>TemplateKWLoc</name></expr></argument>,
<argument><expr><name>MemberNameInfo</name></expr></argument>,
<argument><expr><name>Member</name></expr></argument>,
<argument><expr><name>FoundDecl</name></expr></argument>,
<argument><expr><operator>(</operator><ternary><condition><expr><call><name><name>E</name><operator>-&gt;</operator><name>hasExplicitTemplateArgs</name></name><argument_list>()</argument_list></call></expr>
?</condition><then> <expr><operator>&amp;</operator><name>TransArgs</name></expr> </then><else>: <expr><name>nullptr</name></expr></else></ternary><operator>)</operator></expr></argument>,
<argument><expr><name>FirstQualifierInScope</name></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformBinaryOperator</name><argument_list>(<argument>BinaryOperator *E</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>LHS</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getLHS</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>LHS</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>ExprResult</name> <name>RHS</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getRHS</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>RHS</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>LHS</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getLHS</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>RHS</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getRHS</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>-&gt;</operator><name>isCompoundAssignmentOp</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildBinaryOperator</name><argument_list>(
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getOperatorLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getOpcode</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>LHS</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>RHS</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>Sema</name><operator>::</operator><name>FPFeaturesStateRAII</name> <call><name>FPFeaturesState</name><argument_list>(<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>FPOptionsOverride</name></type> <name>NewOverrides</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getFPFeatures</name></name><argument_list>(<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getLangOpts</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
<expr_stmt><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><name>CurFPFeatures</name> <operator>=</operator>
<call><name><name>NewOverrides</name><operator>.</operator><name>applyOverrides</name></name><argument_list>(<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getLangOpts</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><name><name>FpPragmaStack</name><operator>.</operator><name>CurrentValue</name></name> <operator>=</operator> <name>NewOverrides</name></expr>;</expr_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildBinaryOperator</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getOperatorLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getOpcode</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>LHS</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>RHS</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformCXXRewrittenBinaryOperator</name><argument_list>(
<argument>CXXRewrittenBinaryOperator *E</argument>)</argument_list></macro> <block>{
<expr><name>CXXRewrittenBinaryOperator</name><operator>::</operator><name>DecomposedForm</name> <name>Decomp</name> <operator>=</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getDecomposedForm</name></name><argument_list>()</argument_list></call></expr>;

<expr><name>ExprResult</name> <name>LHS</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>Decomp</name><operator>.</operator><name>LHS</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>LHS</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>ExprResult</name> <name>RHS</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>Decomp</name><operator>.</operator><name>RHS</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>RHS</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>LHS</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name><name>Decomp</name><operator>.</operator><name>LHS</name></name> <operator>&amp;&amp;</operator>
<call><name><name>RHS</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name><name>Decomp</name><operator>.</operator><name>RHS</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt>



<decl_stmt><decl><type><name><name>UnresolvedSet</name><argument_list type="generic">&lt;<argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name></type> <name>UnqualLookups</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name><name>PossibleBinOps</name><index>[]</index></name> <init>= <expr><block>{<expr><call><name><name>E</name><operator>-&gt;</operator><name>getSemanticForm</name></name><argument_list>()</argument_list></call></expr>,
<macro><name>const_cast</name></macro><expr><operator>&lt;</operator><name>Expr</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><name><name>Decomp</name><operator>.</operator><name>InnerBinOp</name></name><operator>)</operator></expr>}</block></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>Expr</name> <modifier>*</modifier></type><name>PossibleBinOp</name> <range>: <expr><name>PossibleBinOps</name></expr></range></decl></init>)</control> <block>{<block_content>
<expr_stmt><expr><name>auto</name> <operator>*</operator><name>Op</name> <operator>=</operator> <call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXOperatorCallExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>PossibleBinOp</name><operator>-&gt;</operator><name>IgnoreImplicit</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Op</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name>auto</name> <operator>*</operator><name>Callee</name> <operator>=</operator> <call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>DeclRefExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Op</name><operator>-&gt;</operator><name>getCallee</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>IgnoreImplicit</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Callee</name> <operator>||</operator> <call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>CXXMethodDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Callee</name><operator>-&gt;</operator><name>getDecl</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>



<decl_stmt><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>Found</name> <init>= <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDecl</name><argument_list>(
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getOperatorLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Callee</name><operator>-&gt;</operator><name>getFoundDecl</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Found</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>UnqualLookups</name><operator>.</operator><name>addDecl</name></name><argument_list>(<argument><expr><name>Found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildCXXRewrittenBinaryOperator</name><argument_list>(
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getOperatorLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>Decomp</name><operator>.</operator><name>Opcode</name></name></expr></argument>, <argument><expr><name>UnqualLookups</name></expr></argument>, <argument><expr><call><name><name>LHS</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>RHS</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformCompoundAssignOperator</name><argument_list>(
<argument>CompoundAssignOperator *E</argument>)</argument_list></macro> <block>{
<expr><name>Sema</name><operator>::</operator><name>FPFeaturesStateRAII</name> <call><name>FPFeaturesState</name><argument_list>(<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>FPOptionsOverride</name> <call><name>NewOverrides</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getFPFeatures</name></name><argument_list>(<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getLangOpts</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><name>CurFPFeatures</name> <operator>=</operator>
<call><name><name>NewOverrides</name><operator>.</operator><name>applyOverrides</name></name><argument_list>(<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getLangOpts</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><name><name>FpPragmaStack</name><operator>.</operator><name>CurrentValue</name></name> <operator>=</operator> <name>NewOverrides</name></expr>;
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformBinaryOperator</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>ExprResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator>
<macro><name>TransformBinaryConditionalOperator</name><argument_list>(<argument>BinaryConditionalOperator *e</argument>)</argument_list></macro> <block>{



<expr><name>ExprResult</name> <name>commonExpr</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>e</name><operator>-&gt;</operator><name>getCommon</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>commonExpr</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>ExprResult</name> <name>rhs</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>e</name><operator>-&gt;</operator><name>getFalseExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>rhs</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>commonExpr</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>e</name><operator>-&gt;</operator><name>getCommon</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>rhs</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>e</name><operator>-&gt;</operator><name>getFalseExpr</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>e</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildConditionalOperator</name><argument_list>(<argument><expr><call><name><name>commonExpr</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>e</name><operator>-&gt;</operator><name>getQuestionLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><call><name><name>e</name><operator>-&gt;</operator><name>getColonLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>rhs</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformConditionalOperator</name><argument_list>(<argument>ConditionalOperator *E</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>Cond</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getCond</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Cond</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>ExprResult</name> <name>LHS</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getLHS</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>LHS</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>ExprResult</name></type> <name>RHS</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getRHS</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>RHS</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>Cond</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getCond</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>LHS</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getLHS</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>RHS</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getRHS</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildConditionalOperator</name><argument_list>(<argument><expr><call><name><name>Cond</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getQuestionLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>LHS</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getColonLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>RHS</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformImplicitCastExpr</name><argument_list>(<argument>ImplicitCastExpr *E</argument>)</argument_list></macro> <block>{


<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getSubExprAsWritten</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformCStyleCastExpr</name><argument_list>(<argument>CStyleCastExpr *E</argument>)</argument_list></macro> <block>{
<expr><name>TypeSourceInfo</name> <operator>*</operator><name>Type</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getTypeInfoAsWritten</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Type</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>ExprResult</name> <name>SubExpr</name>
<operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getSubExprAsWritten</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>SubExpr</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<name>Type</name> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getTypeInfoAsWritten</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>SubExpr</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getSubExpr</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildCStyleCastExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>Type</name></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getRParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>SubExpr</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformCompoundLiteralExpr</name><argument_list>(<argument>CompoundLiteralExpr *E</argument>)</argument_list></macro> <block>{
<expr><name>TypeSourceInfo</name> <operator>*</operator><name>OldT</name> <operator>=</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getTypeSourceInfo</name></name><argument_list>()</argument_list></call></expr>;
<expr><name>TypeSourceInfo</name> <operator>*</operator><name>NewT</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>OldT</name></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>NewT</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>ExprResult</name> <name>Init</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getInitializer</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Init</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<name>OldT</name> <operator>==</operator> <name>NewT</name> <operator>&amp;&amp;</operator>
<call><name><name>Init</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getInitializer</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>MaybeBindToTemporary</name></name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>





<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildCompoundLiteralExpr</name><argument_list>(
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NewT</name></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getInitializer</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getEndLoc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Init</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformExtVectorElementExpr</name><argument_list>(<argument>ExtVectorElementExpr *E</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>Base</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBase</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Base</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>Base</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getBase</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>FakeOperatorLoc</name> <init>=
<expr><call><name><name>SemaRef</name><operator>.</operator><name>getLocForEndOfToken</name></name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBase</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getEndLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildExtVectorElementExpr</name><argument_list>(<argument><expr><call><name><name>Base</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>FakeOperatorLoc</name></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getAccessorLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getAccessor</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformInitListExpr</name><argument_list>(<argument>InitListExpr *E</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<decl><type><name>InitListExpr</name> <modifier>*</modifier></type><name>Syntactic</name> <init>= <expr><call><name><name>E</name><operator>-&gt;</operator><name>getSyntacticForm</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>E</name> <operator>=</operator> <name>Syntactic</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<name>bool</name> <name>InitChanged</name> <operator>=</operator> <name>false</name></block></expr>;</expr_stmt>

<decl_stmt><decl><type><name>EnterExpressionEvaluationContext</name></type> <name>Context</name><argument_list>(
<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>EnterExpressionEvaluationContext</name><operator>::</operator><name>InitList</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name><modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>Inits</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExprs</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getInits</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getNumInits</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>,
<argument><expr><name>Inits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>InitChanged</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>InitChanged</name></expr>)</condition> <block>{<block_content>




</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildInitList</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getLBraceLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Inits</name></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getRBraceLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformDesignatedInitExpr</name><argument_list>(<argument>DesignatedInitExpr *E</argument>)</argument_list></macro> <block>{
<expr><name>Designation</name> <name>Desig</name></expr>;


<expr><name>ExprResult</name> <name>Init</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getInit</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Init</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name><operator>*</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>ArrayExprs</name></block></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>ExprChanged</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><specifier>const</specifier> <name>DesignatedInitExpr</name><operator>::</operator><name>Designator</name> <operator>&amp;</operator><name>D</name> <operator>:</operator> <call><name><name>E</name><operator>-&gt;</operator><name>designators</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>D</name><operator>.</operator><name>isFieldDesignator</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>Desig</name><operator>.</operator><name>AddDesignator</name></name><argument_list>(<argument><expr><name>Designator</name><operator>::</operator><call><name>getField</name><argument_list>(<argument><expr><call><name><name>D</name><operator>.</operator><name>getFieldName</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>D</name><operator>.</operator><name>getDotLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>D</name><operator>.</operator><name>getFieldLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>D</name><operator>.</operator><name>getField</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>FieldDecl</name> <modifier>*</modifier></type><name>Field</name> <init>= <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>FieldDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDecl</name><argument_list>(<argument><expr><call><name><name>D</name><operator>.</operator><name>getFieldLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>D</name><operator>.</operator><name>getField</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>Field</name> <operator>!=</operator> <call><name><name>D</name><operator>.</operator><name>getField</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>


<expr_stmt><expr><name>ExprChanged</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>



<expr_stmt><expr><name>ExprChanged</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>D</name><operator>.</operator><name>isArrayDesignator</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>Index</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getArrayIndex</name></name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Index</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name><name>Desig</name><operator>.</operator><name>AddDesignator</name></name><argument_list>(
<argument><expr><name>Designator</name><operator>::</operator><call><name>getArray</name><argument_list>(<argument><expr><call><name><name>Index</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>D</name><operator>.</operator><name>getLBracketLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ExprChanged</name> <operator>=</operator> <name>ExprChanged</name> <operator>||</operator> <call><name><name>Init</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getArrayIndex</name></name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ArrayExprs</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>Index</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>D</name><operator>.</operator><name>isArrayRangeDesignator</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"New kind of designator?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>Start</name>
<init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getArrayRangeStart</name></name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Start</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>ExprResult</name></type> <name>End</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getArrayRangeEnd</name></name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>End</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name><name>Desig</name><operator>.</operator><name>AddDesignator</name></name><argument_list>(<argument><expr><name>Designator</name><operator>::</operator><call><name>getArrayRange</name><argument_list>(<argument><expr><call><name><name>Start</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>End</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>D</name><operator>.</operator><name>getLBracketLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>D</name><operator>.</operator><name>getEllipsisLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ExprChanged</name> <operator>=</operator> <name>ExprChanged</name> <operator>||</operator> <call><name><name>Start</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getArrayRangeStart</name></name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name><name>End</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getArrayRangeEnd</name></name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name><name>ArrayExprs</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>Start</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ArrayExprs</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>End</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>Init</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getInit</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><name>ExprChanged</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildDesignatedInitExpr</name><argument_list>(<argument><expr><name>Desig</name></expr></argument>, <argument><expr><name>ArrayExprs</name></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getEqualOrColonLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>usesGNUSyntax</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Init</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}



template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformDesignatedInitUpdateExpr</name><argument_list>(
<argument>DesignatedInitUpdateExpr *E</argument>)</argument_list></macro> <block>{
<expr><call><name>llvm_unreachable</name><argument_list>(<argument><expr><literal type="string">"Unexpected DesignatedInitUpdateExpr in syntactic form of "</literal>
<literal type="string">"initializer"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformNoInitExpr</name><argument_list>(
<argument>NoInitExpr *E</argument>)</argument_list></macro> <block>{
<expr><call><name>llvm_unreachable</name><argument_list>(<argument><expr><literal type="string">"Unexpected NoInitExpr in syntactic form of initializer"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformArrayInitLoopExpr</name><argument_list>(<argument>ArrayInitLoopExpr *E</argument>)</argument_list></macro> <block>{
<expr><call><name>llvm_unreachable</name><argument_list>(<argument><expr><literal type="string">"Unexpected ArrayInitLoopExpr outside of initializer"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformArrayInitIndexExpr</name><argument_list>(<argument>ArrayInitIndexExpr *E</argument>)</argument_list></macro> <block>{
<expr><call><name>llvm_unreachable</name><argument_list>(<argument><expr><literal type="string">"Unexpected ArrayInitIndexExpr outside of initializer"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformImplicitValueInitExpr</name><argument_list>(
<argument>ImplicitValueInitExpr *E</argument>)</argument_list></macro> <block>{
<expr><name>TemporaryBase</name> <call><name>Rebase</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>DeclarationName</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;



<expr><name>QualType</name> <name>T</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>T</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<name>T</name> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildImplicitValueInitExpr</name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformVAArgExpr</name><argument_list>(<argument>VAArgExpr *E</argument>)</argument_list></macro> <block>{
<expr><name>TypeSourceInfo</name> <operator>*</operator><name>TInfo</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getWrittenTypeInfo</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>TInfo</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>ExprResult</name> <name>SubExpr</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getSubExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>SubExpr</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<name>TInfo</name> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getWrittenTypeInfo</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>SubExpr</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getSubExpr</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildVAArgExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBuiltinLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>SubExpr</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>TInfo</name></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getRParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformParenListExpr</name><argument_list>(<argument>ParenListExpr *E</argument>)</argument_list></macro> <block>{
<expr><name>bool</name> <name>ArgumentChanged</name> <operator>=</operator> <name>false</name></expr>;
<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name><operator>*</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>Inits</name></expr>;
<if_stmt><if>if <condition>(<expr><call><name>TransformExprs</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getExprs</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getNumExprs</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>Inits</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>ArgumentChanged</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildParenListExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>Inits</name></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getRParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}






template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformAddrLabelExpr</name><argument_list>(<argument>AddrLabelExpr *E</argument>)</argument_list></macro> <block>{
<expr><name>Decl</name> <operator>*</operator><name>LD</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDecl</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getLabel</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getLocation</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getLabel</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>LD</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildAddrLabelExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getAmpAmpLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getLabelLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>LabelDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>LD</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformStmtExpr</name><argument_list>(<argument>StmtExpr *E</argument>)</argument_list></macro> <block>{
<expr><call><name><name>SemaRef</name><operator>.</operator><name>ActOnStartStmtExpr</name></name><argument_list>()</argument_list></call></expr>;
<expr><name>StmtResult</name> <name>SubStmt</name>
<operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformCompoundStmt</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getSubStmt</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>SubStmt</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>SemaRef</name><operator>.</operator><name>ActOnStmtExprError</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return>
<expr_stmt/></block_content></block></if></if_stmt>}</block>

<name>unsigned</name> <name>OldDepth</name> <operator>=</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getTemplateDepth</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>NewDepth</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformTemplateDepth</name><argument_list>(<argument><expr><name>OldDepth</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>OldDepth</name> <operator>==</operator> <name>NewDepth</name> <operator>&amp;&amp;</operator>
<call><name><name>SubStmt</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getSubStmt</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name><name>SemaRef</name><operator>.</operator><name>ActOnStmtExprError</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>MaybeBindToTemporary</name></name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildStmtExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>SubStmt</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getRParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NewDepth</name></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformChooseExpr</name><argument_list>(<argument>ChooseExpr *E</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>Cond</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getCond</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Cond</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>ExprResult</name> <name>LHS</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getLHS</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>LHS</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>ExprResult</name></type> <name>RHS</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getRHS</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>RHS</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>Cond</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getCond</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>LHS</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getLHS</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>RHS</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getRHS</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildChooseExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBuiltinLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Cond</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>LHS</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>RHS</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getRParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformGNUNullExpr</name><argument_list>(<argument>GNUNullExpr *E</argument>)</argument_list></macro> <block>{
<return>return <expr><name>E</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformCXXOperatorCallExpr</name><argument_list>(<argument>CXXOperatorCallExpr *E</argument>)</argument_list></macro> <block>{
<switch>switch <condition>(<expr><call><name><name>E</name><operator>-&gt;</operator><name>getOperator</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>OO_New</name></expr>:</case>
<case>case <expr><name>OO_Delete</name></expr>:</case>
<case>case <expr><name>OO_Array_New</name></expr>:</case>
<case>case <expr><name>OO_Array_Delete</name></expr>:</case>
<expr_stmt><expr><call><name>llvm_unreachable</name><argument_list>(<argument><expr><literal type="string">"new and delete operators cannot use CXXOperatorCallExpr"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>OO_Call</name></expr>:</case> <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getNumArgs</name></name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <literal type="string">"Object call is missing arguments"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><name>ExprResult</name></type> <name>Object</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getArg</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Object</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>FakeLParenLoc</name> <init>= <expr><call><name><name>SemaRef</name><operator>.</operator><name>getLocForEndOfToken</name></name><argument_list>(
<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Object</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getEndLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name><operator>*</operator></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name></type> <name>Args</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExprs</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getArgs</name></name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getNumArgs</name></name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>,
<argument><expr><name>Args</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildCallExpr</name><argument_list>(<argument><expr><call><name><name>Object</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>FakeLParenLoc</name></expr></argument>, <argument><expr><name>Args</name></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<expr_stmt/></block_content></block></block_content></block></switch>}</block></expr></expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OVERLOADED_OPERATOR</name><parameter_list>(<parameter><type><name>Name</name></type></parameter>,<parameter><type><name>Spelling</name></type></parameter>,<parameter><type><name>Token</name></type></parameter>,<parameter><type><name>Unary</name></type></parameter>,<parameter><type><name>Binary</name></type></parameter>,<parameter><type><name>MemberOnly</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case OO_##Name:</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OVERLOADED_OPERATOR_MULTI</name><parameter_list>(<parameter><type><name>Name</name></type></parameter>,<parameter><type><name>Spelling</name></type></parameter>,<parameter><type><name>Unary</name></type></parameter>,<parameter><type><name>Binary</name></type></parameter>,<parameter><type><name>MemberOnly</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/OperatorKinds.def"</cpp:file></cpp:include>
<case>case <expr><name>OO_Subscript</name></expr>:</case>

<break>break;</break>

<case>case <expr><name>OO_Conditional</name></expr>:</case>
<expr_stmt><expr><call><name>llvm_unreachable</name><argument_list>(<argument><expr><literal type="string">"conditional operator is not actually overloadable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>OO_None</name></expr>:</case>
<case>case <expr><name>NUM_OVERLOADED_OPERATORS</name></expr>:</case>
<expr_stmt><expr><call><name>llvm_unreachable</name><argument_list>(<argument><expr><literal type="string">"not an overloaded operator?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}

ExprResult <expr_stmt><expr><name>Callee</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getCallee</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Callee</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>ExprResult</name></type> <name>First</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>-&gt;</operator><name>getOperator</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OO_Amp</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>First</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformAddressOfOperand</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getArg</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>First</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getArg</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>First</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>ExprResult</name></type> <name>Second</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>-&gt;</operator><name>getNumArgs</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Second</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getArg</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Second</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>Callee</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getCallee</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>First</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getArg</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>(</operator><call><name><name>E</name><operator>-&gt;</operator><name>getNumArgs</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">2</literal> <operator>||</operator> <call><name><name>Second</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getArg</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>MaybeBindToTemporary</name></name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>Sema</name><operator>::</operator><name>FPFeaturesStateRAII</name> <call><name>FPFeaturesState</name><argument_list>(<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>FPOptionsOverride</name></type> <name>NewOverrides</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getFPFeatures</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
<expr_stmt><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><name>CurFPFeatures</name> <operator>=</operator>
<call><name><name>NewOverrides</name><operator>.</operator><name>applyOverrides</name></name><argument_list>(<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getLangOpts</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><name><name>FpPragmaStack</name><operator>.</operator><name>CurrentValue</name></name> <operator>=</operator> <name>NewOverrides</name></expr>;</expr_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildCXXOperatorCallExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getOperator</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getOperatorLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Callee</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>First</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Second</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformCXXMemberCallExpr</name><argument_list>(<argument>CXXMemberCallExpr *E</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformCallExpr</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>ExprResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformSourceLocExpr</name><argument_list>(<argument>SourceLocExpr *E</argument>)</argument_list></macro> <block>{
<expr><name>bool</name> <name>NeedRebuildFunc</name> <operator>=</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getIdentKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>SourceLocExpr</name><operator>::</operator><name>Function</name> <operator>&amp;&amp;</operator>
<call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><name>CurContext</name> <operator>!=</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getParentContext</name></name><argument_list>()</argument_list></call></expr>;

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>NeedRebuildFunc</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildSourceLocExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getIdentKind</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><name>CurContext</name></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformCUDAKernelCallExpr</name><argument_list>(<argument>CUDAKernelCallExpr *E</argument>)</argument_list></macro> <block>{

<expr><name>ExprResult</name> <name>Callee</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getCallee</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Callee</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<name>ExprResult</name> <name>EC</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformCallExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getConfig</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>EC</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>ArgChanged</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name><modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name></type> <name>Args</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExprs</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getArgs</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getNumArgs</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>Args</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>ArgChanged</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>Callee</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getCallee</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><name>ArgChanged</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>MaybeBindToTemporary</name></name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>FakeLParenLoc</name>
<init>= <expr><operator>(</operator><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><call><name><name>Callee</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call><operator>)</operator><operator>-&gt;</operator><call><name>getSourceRange</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getBegin</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildCallExpr</name><argument_list>(<argument><expr><call><name><name>Callee</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>FakeLParenLoc</name></expr></argument>,
<argument><expr><name>Args</name></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getRParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>EC</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformCXXNamedCastExpr</name><argument_list>(<argument>CXXNamedCastExpr *E</argument>)</argument_list></macro> <block>{
<expr><name>TypeSourceInfo</name> <operator>*</operator><name>Type</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getTypeInfoAsWritten</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Type</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>ExprResult</name> <name>SubExpr</name>
<operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getSubExprAsWritten</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>SubExpr</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<name>Type</name> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getTypeInfoAsWritten</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>SubExpr</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getSubExpr</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildCXXNamedCastExpr</name><argument_list>(
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getOperatorLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getAngleBrackets</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getBegin</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>Type</name></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getAngleBrackets</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getEnd</name><argument_list>()</argument_list></call></expr></argument>,

<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getAngleBrackets</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getEnd</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>SubExpr</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getRParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformBuiltinBitCastExpr</name><argument_list>(<argument>BuiltinBitCastExpr *BCE</argument>)</argument_list></macro> <block>{
<expr><name>TypeSourceInfo</name> <operator>*</operator><name>TSI</name> <operator>=</operator>
<call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><call><name><name>BCE</name><operator>-&gt;</operator><name>getTypeInfoAsWritten</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>TSI</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>ExprResult</name> <name>Sub</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>BCE</name><operator>-&gt;</operator><name>getSubExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Sub</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildBuiltinBitCastExpr</name><argument_list>(<argument><expr><call><name><name>BCE</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>TSI</name></expr></argument>,
<argument><expr><call><name><name>Sub</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>BCE</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformCXXStaticCastExpr</name><argument_list>(<argument>CXXStaticCastExpr *E</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformCXXNamedCastExpr</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformCXXDynamicCastExpr</name><argument_list>(<argument>CXXDynamicCastExpr *E</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformCXXNamedCastExpr</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformCXXReinterpretCastExpr</name><argument_list>(
<argument>CXXReinterpretCastExpr *E</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformCXXNamedCastExpr</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformCXXConstCastExpr</name><argument_list>(<argument>CXXConstCastExpr *E</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformCXXNamedCastExpr</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformCXXAddrspaceCastExpr</name><argument_list>(<argument>CXXAddrspaceCastExpr *E</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformCXXNamedCastExpr</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformCXXFunctionalCastExpr</name><argument_list>(
<argument>CXXFunctionalCastExpr *E</argument>)</argument_list></macro> <block>{
<expr><name>TypeSourceInfo</name> <operator>*</operator><name>Type</name> <operator>=</operator>
<call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformTypeWithDeducedTST</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getTypeInfoAsWritten</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Type</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>ExprResult</name> <name>SubExpr</name>
<operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getSubExprAsWritten</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>SubExpr</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<name>Type</name> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getTypeInfoAsWritten</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>SubExpr</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getSubExpr</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildCXXFunctionalCastExpr</name><argument_list>(<argument><expr><name>Type</name></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>SubExpr</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getRParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>isListInitialization</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformCXXTypeidExpr</name><argument_list>(<argument>CXXTypeidExpr *E</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>-&gt;</operator><name>isTypeOperand</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TInfo</name>
<init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getTypeOperandSourceInfo</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>TInfo</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<name>TInfo</name> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getTypeOperandSourceInfo</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildCXXTypeidExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>TInfo</name></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<expr_stmt/></block_content></block></if></if_stmt>}</block>




<name>Expr</name> <operator>*</operator><name>Op</name> <operator>=</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getExprOperand</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>auto</name></type> <name>EvalCtx</name> <init>= <expr><name>Sema</name><operator>::</operator><name>ExpressionEvaluationContext</name><operator>::</operator><name>Unevaluated</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>-&gt;</operator><name>isGLValue</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>RecordT</name> <operator>=</operator> <call><name><name>Op</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name><name>getAs</name><argument_list type="generic">&lt;<argument><expr><name>RecordType</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXRecordDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>RecordT</name><operator>-&gt;</operator><name>getDecl</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>isPolymorphic</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>EvalCtx</name> <operator>=</operator> <call><name><name>SemaRef</name><operator>.</operator><name>ExprEvalContexts</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call><operator>.</operator><name>Context</name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>EnterExpressionEvaluationContext</name></type> <name>Unevaluated</name><argument_list>(<argument><expr><name>SemaRef</name></expr></argument>, <argument><expr><name>EvalCtx</name></expr></argument>,
<argument><expr><name>Sema</name><operator>::</operator><name>ReuseLambdaContextDecl</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ExprResult</name></type> <name>SubExpr</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><name>Op</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>SubExpr</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>SubExpr</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getExprOperand</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildCXXTypeidExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>SubExpr</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformCXXUuidofExpr</name><argument_list>(<argument>CXXUuidofExpr *E</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>-&gt;</operator><name>isTypeOperand</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TInfo</name>
<init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getTypeOperandSourceInfo</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>TInfo</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<name>TInfo</name> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getTypeOperandSourceInfo</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildCXXUuidofExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>TInfo</name></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<expr_stmt/></block_content></block></if></if_stmt>}</block>

<name>EnterExpressionEvaluationContext</name> <call><name>Unevaluated</name><argument_list>(
<argument><expr><name>SemaRef</name></expr></argument>, <argument><expr><name>Sema</name><operator>::</operator><name>ExpressionEvaluationContext</name><operator>::</operator><name>Unevaluated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ExprResult</name></type> <name>SubExpr</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getExprOperand</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>SubExpr</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>SubExpr</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getExprOperand</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildCXXUuidofExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>SubExpr</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformCXXBoolLiteralExpr</name><argument_list>(<argument>CXXBoolLiteralExpr *E</argument>)</argument_list></macro> <block>{
<return>return <expr><name>E</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformCXXNullPtrLiteralExpr</name><argument_list>(
<argument>CXXNullPtrLiteralExpr *E</argument>)</argument_list></macro> <block>{
<return>return <expr><name>E</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformCXXThisExpr</name><argument_list>(<argument>CXXThisExpr *E</argument>)</argument_list></macro> <block>{
<expr><name>QualType</name> <name>T</name> <operator>=</operator> <call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getCurrentThisType</name><argument_list>()</argument_list></call></expr>;

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>T</name> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>MarkThisReferenced</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>E</name></expr>;</return>
<expr_stmt/></block_content></block></if></if_stmt>}</block></expr></expr_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildCXXThisExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>isImplicit</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformCXXThrowExpr</name><argument_list>(<argument>CXXThrowExpr *E</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>SubExpr</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getSubExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>SubExpr</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>SubExpr</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getSubExpr</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildCXXThrowExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getThrowLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>SubExpr</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>isThrownVariableInScope</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformCXXDefaultArgExpr</name><argument_list>(<argument>CXXDefaultArgExpr *E</argument>)</argument_list></macro> <block>{
<expr><name>ParmVarDecl</name> <operator>*</operator><name>Param</name> <operator>=</operator> <call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDecl</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getParam</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Param</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>Param</name> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getParam</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>E</name><operator>-&gt;</operator><name>getUsedContext</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name><name>SemaRef</name><operator>.</operator><name>CurContext</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildCXXDefaultArgExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getUsedLocation</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformCXXDefaultInitExpr</name><argument_list>(<argument>CXXDefaultInitExpr *E</argument>)</argument_list></macro> <block>{
<expr><name>FieldDecl</name> <operator>*</operator><name>Field</name> <operator>=</operator> <call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>FieldDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDecl</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getField</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Field</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>Field</name> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getField</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>E</name><operator>-&gt;</operator><name>getUsedContext</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name><name>SemaRef</name><operator>.</operator><name>CurContext</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildCXXDefaultInitExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getExprLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Field</name></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformCXXScalarValueInitExpr</name><argument_list>(
<argument>CXXScalarValueInitExpr *E</argument>)</argument_list></macro> <block>{
<expr><name>TypeSourceInfo</name> <operator>*</operator><name>T</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getTypeSourceInfo</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>T</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<name>T</name> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getTypeSourceInfo</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildCXXScalarValueInitExpr</name><argument_list>(<argument><expr><name>T</name></expr></argument>,
<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeLoc</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getEndLoc</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getRParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformCXXNewExpr</name><argument_list>(<argument>CXXNewExpr *E</argument>)</argument_list></macro> <block>{

<expr><name>TypeSourceInfo</name> <operator>*</operator><name>AllocTypeInfo</name> <operator>=</operator>
<call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformTypeWithDeducedTST</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getAllocatedTypeSourceInfo</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>AllocTypeInfo</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>ArraySize</name></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></type> <name>OldArraySize</name> <init>= <expr><call><name><name>E</name><operator>-&gt;</operator><name>getArraySize</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>NewArraySize</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>OldArraySize</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>NewArraySize</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><operator>*</operator><name>OldArraySize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>NewArraySize</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ArraySize</name> <operator>=</operator> <call><name><name>NewArraySize</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>ArgumentChanged</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name><modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name></type> <name>PlacementArgs</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExprs</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getPlacementArgs</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getNumPlacementArgs</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>,
<argument><expr><name>PlacementArgs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ArgumentChanged</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>OldInit</name> <init>= <expr><call><name><name>E</name><operator>-&gt;</operator><name>getInitializer</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>NewInit</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>OldInit</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>NewInit</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformInitializer</name><argument_list>(<argument><expr><name>OldInit</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>NewInit</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<decl_stmt><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>OperatorNew</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>-&gt;</operator><name>getOperatorNew</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>OperatorNew</name> <operator>=</operator> <call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>FunctionDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDecl</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getOperatorNew</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>OperatorNew</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>OperatorDelete</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>-&gt;</operator><name>getOperatorDelete</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>OperatorDelete</name> <operator>=</operator> <call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>FunctionDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDecl</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getOperatorDelete</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>OperatorDelete</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<name>AllocTypeInfo</name> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getAllocatedTypeSourceInfo</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<name>ArraySize</name> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getArraySize</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>NewInit</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OldInit</name> <operator>&amp;&amp;</operator>
<name>OperatorNew</name> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getOperatorNew</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<name>OperatorDelete</name> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getOperatorDelete</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><name>ArgumentChanged</name></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><name>OperatorNew</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>SemaRef</name><operator>.</operator><name>MarkFunctionReferenced</name></name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>OperatorNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>OperatorDelete</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>SemaRef</name><operator>.</operator><name>MarkFunctionReferenced</name></name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>OperatorDelete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>-&gt;</operator><name>isArray</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>E</name><operator>-&gt;</operator><name>getAllocatedType</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isDependentType</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>QualType</name></type> <name>ElementType</name>
<init>= <expr><call><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>getBaseElementType</name></name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getAllocatedType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <name>RecordType</name> <modifier>*</modifier></type><name>RecordT</name> <init>= <expr><name><name>ElementType</name><operator>-&gt;</operator><name>getAs</name></name><operator>&lt;</operator><name>RecordType</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>Record</name> <init>= <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXRecordDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>RecordT</name><operator>-&gt;</operator><name>getDecl</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<decl><type><name>CXXDestructorDecl</name> <modifier>*</modifier></type><name>Destructor</name> <init>= <expr><call><name><name>SemaRef</name><operator>.</operator><name>LookupDestructor</name></name><argument_list>(<argument><expr><name>Record</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>SemaRef</name><operator>.</operator><name>MarkFunctionReferenced</name></name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Destructor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>E</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>AllocType</name> <init>= <expr><call><name><name>AllocTypeInfo</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ArraySize</name></expr>)</condition> <block>{<block_content>





<decl_stmt><decl><type><specifier>const</specifier> <name>ArrayType</name> <modifier>*</modifier></type><name>ArrayT</name> <init>= <expr><call><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>getAsArrayType</name></name><argument_list>(<argument><expr><name>AllocType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ArrayT</name></expr>)</condition> <block>{<block_content>

</block_content>}</block></if> <if type="elseif">else if <condition>(<decl><type><specifier>const</specifier> <name>ConstantArrayType</name> <modifier>*</modifier></type><name>ConsArrayT</name>
<init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>ConstantArrayType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>ArrayT</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ArraySize</name> <operator>=</operator> <name>IntegerLiteral</name><operator>::</operator><call><name>Create</name><argument_list>(<argument><expr><name><name>SemaRef</name><operator>.</operator><name>Context</name></name></expr></argument>, <argument><expr><call><name><name>ConsArrayT</name><operator>-&gt;</operator><name>getSize</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>getSizeType</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>AllocType</name> <operator>=</operator> <call><name><name>ConsArrayT</name><operator>-&gt;</operator><name>getElementType</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<decl><type><specifier>const</specifier> <name>DependentSizedArrayType</name> <modifier>*</modifier></type><name>DepArrayT</name>
<init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>DependentSizedArrayType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>ArrayT</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>DepArrayT</name><operator>-&gt;</operator><name>getSizeExpr</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ArraySize</name> <operator>=</operator> <call><name><name>DepArrayT</name><operator>-&gt;</operator><name>getSizeExpr</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>AllocType</name> <operator>=</operator> <call><name><name>DepArrayT</name><operator>-&gt;</operator><name>getElementType</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildCXXNewExpr</name><argument_list>(
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>isGlobalNew</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>PlacementArgs</name></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getTypeIdParens</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>AllocType</name></expr></argument>,
<argument><expr><name>AllocTypeInfo</name></expr></argument>, <argument><expr><name>ArraySize</name></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getDirectInitRange</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>NewInit</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformCXXDeleteExpr</name><argument_list>(<argument>CXXDeleteExpr *E</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>Operand</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getArgument</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Operand</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<name>FunctionDecl</name> <operator>*</operator><name>OperatorDelete</name> <operator>=</operator> <name>nullptr</name></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>-&gt;</operator><name>getOperatorDelete</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>OperatorDelete</name> <operator>=</operator> <call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>FunctionDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDecl</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getOperatorDelete</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>OperatorDelete</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>Operand</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getArgument</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<name>OperatorDelete</name> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getOperatorDelete</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><name>OperatorDelete</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>SemaRef</name><operator>.</operator><name>MarkFunctionReferenced</name></name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>OperatorDelete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>E</name><operator>-&gt;</operator><name>getArgument</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isTypeDependent</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>QualType</name></type> <name>Destroyed</name> <init>= <expr><call><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>getBaseElementType</name></name><argument_list>(
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getDestroyedType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <name>RecordType</name> <modifier>*</modifier></type><name>DestroyedRec</name> <init>= <expr><name><name>Destroyed</name><operator>-&gt;</operator><name>getAs</name></name><operator>&lt;</operator><name>RecordType</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>Record</name> <init>= <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXRecordDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>DestroyedRec</name><operator>-&gt;</operator><name>getDecl</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>SemaRef</name><operator>.</operator><name>MarkFunctionReferenced</name></name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>SemaRef</name><operator>.</operator><name>LookupDestructor</name></name><argument_list>(<argument><expr><name>Record</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>E</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildCXXDeleteExpr</name><argument_list>(
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>isGlobalDelete</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>isArrayForm</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Operand</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformCXXPseudoDestructorExpr</name><argument_list>(
<argument>CXXPseudoDestructorExpr *E</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>Base</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBase</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Base</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>ParsedType</name> <name>ObjectTypePtr</name></block></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>MayBePseudoDestructor</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>Base</name> <operator>=</operator> <call><name><name>SemaRef</name><operator>.</operator><name>ActOnStartCXXMemberReference</name></name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>, <argument><expr><call><name><name>Base</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getOperatorLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><ternary><condition><expr><call><name><name>E</name><operator>-&gt;</operator><name>isArrow</name></name><argument_list>()</argument_list></call></expr>?</condition><then> <expr><name>tok</name><operator>::</operator><name>arrow</name></expr> </then><else>: <expr><name>tok</name><operator>::</operator><name>period</name></expr></else></ternary></expr></argument>,
<argument><expr><name>ObjectTypePtr</name></expr></argument>,
<argument><expr><name>MayBePseudoDestructor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Base</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>ObjectType</name> <init>= <expr><call><name><name>ObjectTypePtr</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>NestedNameSpecifierLoc</name></type> <name>QualifierLoc</name> <init>= <expr><call><name><name>E</name><operator>-&gt;</operator><name>getQualifierLoc</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>QualifierLoc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>QualifierLoc</name>
<operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformNestedNameSpecifierLoc</name><argument_list>(<argument><expr><name>QualifierLoc</name></expr></argument>, <argument><expr><name>ObjectType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>QualifierLoc</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>CXXScopeSpec</name></type> <name>SS</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>SS</name><operator>.</operator><name>Adopt</name></name><argument_list>(<argument><expr><name>QualifierLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>PseudoDestructorTypeStorage</name></type> <name>Destroyed</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>-&gt;</operator><name>getDestroyedTypeInfo</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>DestroyedTypeInfo</name>
<init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformTypeInObjectScope</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getDestroyedTypeInfo</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>ObjectType</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>, <argument><expr><name>SS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>DestroyedTypeInfo</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>Destroyed</name> <operator>=</operator> <name>DestroyedTypeInfo</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name><name>ObjectType</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>ObjectType</name><operator>-&gt;</operator><name>isDependentType</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name>Destroyed</name> <operator>=</operator> <call><name>PseudoDestructorTypeStorage</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getDestroyedTypeIdentifier</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getDestroyedTypeLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>ParsedType</name></type> <name>T</name> <init>= <expr><call><name><name>SemaRef</name><operator>.</operator><name>getDestructorName</name></name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getTildeLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><operator>*</operator><call><name><name>E</name><operator>-&gt;</operator><name>getDestroyedTypeIdentifier</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getDestroyedTypeLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><name>SS</name></expr></argument>, <argument><expr><name>ObjectTypePtr</name></expr></argument>,
<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>T</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>Destroyed</name>
<operator>=</operator> <call><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>getTrivialTypeSourceInfo</name></name><argument_list>(<argument><expr><call><name><name>SemaRef</name><operator>.</operator><name>GetTypeFromParser</name></name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getDestroyedTypeLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<decl_stmt><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>ScopeTypeInfo</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>-&gt;</operator><name>getScopeTypeInfo</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>CXXScopeSpec</name></type> <name>EmptySS</name></decl>;</decl_stmt>
<expr_stmt><expr><name>ScopeTypeInfo</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformTypeInObjectScope</name><argument_list>(
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getScopeTypeInfo</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ObjectType</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>, <argument><expr><name>EmptySS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ScopeTypeInfo</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildCXXPseudoDestructorExpr</name><argument_list>(<argument><expr><call><name><name>Base</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getOperatorLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>isArrow</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>SS</name></expr></argument>,
<argument><expr><name>ScopeTypeInfo</name></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getColonColonLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getTildeLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>Destroyed</name></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>bool</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformOverloadExprDecls</name><argument_list>(<argument>OverloadExpr *Old</argument>,
<argument>bool RequiresADL</argument>,
<argument>LookupResult &amp;R</argument>)</argument_list></macro> <block>{

<expr><name>bool</name> <name>AllEmptyPacks</name> <operator>=</operator> <name>true</name></expr>;
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>OldD</name> <operator>:</operator> <call><name><name>Old</name><operator>-&gt;</operator><name>decls</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>Decl</name> <modifier>*</modifier></type><name>InstD</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDecl</name><argument_list>(<argument><expr><call><name><name>Old</name><operator>-&gt;</operator><name>getNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>OldD</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>InstD</name></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>UsingShadowDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>OldD</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name><name>R</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
<expr_stmt/></block_content></block></else></if_stmt></block_content></block></if></if_stmt></block_content></block></for>}</block></expr></expr_stmt>
}


NamedDecl <expr_stmt><expr><operator>*</operator><name>SingleDecl</name> <operator>=</operator> <call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>InstD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name><modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Decls</name> <init>= <expr><name>SingleDecl</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>UPD</name> <operator>=</operator> <call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>UsingPackDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>InstD</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>Decls</name> <operator>=</operator> <call><name><name>UPD</name><operator>-&gt;</operator><name>expansions</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>D</name> <operator>:</operator> <name>Decls</name></expr></init>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>UD</name> <operator>=</operator> <call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>UsingDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>SD</name> <operator>:</operator> <call><name><name>UD</name><operator>-&gt;</operator><name>shadows</name></name><argument_list>()</argument_list></call></expr></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>R</name><operator>.</operator><name>addDecl</name></name><argument_list>(<argument><expr><name>SD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name><name>R</name><operator>.</operator><name>addDecl</name></name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>AllEmptyPacks</name> <operator>&amp;=</operator> <call><name><name>Decls</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
};







<if_stmt><if>if <condition>(<expr><name>AllEmptyPacks</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>RequiresADL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>Diag</name><argument_list>(<argument><expr><call><name><name>Old</name><operator>-&gt;</operator><name>getNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>diag</name><operator>::</operator><name>err_using_pack_expansion_empty</name></expr></argument>)</argument_list></call>
<operator>&lt;&lt;</operator> <call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>UnresolvedMemberExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Old</name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <call><name><name>Old</name><operator>-&gt;</operator><name>getName</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>



<expr_stmt><expr><call><name><name>R</name><operator>.</operator><name>resolveKind</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformUnresolvedLookupExpr</name><argument_list>(
<argument>UnresolvedLookupExpr *Old</argument>)</argument_list></macro> <block>{
<expr><name>LookupResult</name> <call><name>R</name><argument_list>(<argument><expr><name>SemaRef</name></expr></argument>, <argument><expr><call><name><name>Old</name><operator>-&gt;</operator><name>getName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Old</name><operator>-&gt;</operator><name>getNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>Sema</name><operator>::</operator><name>LookupOrdinaryName</name></expr></argument>)</argument_list></call></expr>;


<if_stmt><if>if <condition>(<expr><call><name>TransformOverloadExprDecls</name><argument_list>(<argument><expr><name>Old</name></expr></argument>, <argument><expr><call><name><name>Old</name><operator>-&gt;</operator><name>requiresADL</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>R</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<name>CXXScopeSpec</name> <name>SS</name></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Old</name><operator>-&gt;</operator><name>getQualifierLoc</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>NestedNameSpecifierLoc</name></type> <name>QualifierLoc</name>
<init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformNestedNameSpecifierLoc</name><argument_list>(<argument><expr><call><name><name>Old</name><operator>-&gt;</operator><name>getQualifierLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>QualifierLoc</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name><name>SS</name><operator>.</operator><name>Adopt</name></name><argument_list>(<argument><expr><name>QualifierLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>Old</name><operator>-&gt;</operator><name>getNamingClass</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>NamingClass</name>
<init>= <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>CXXRecordDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDecl</name><argument_list>(
<argument><expr><call><name><name>Old</name><operator>-&gt;</operator><name>getNameLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Old</name><operator>-&gt;</operator><name>getNamingClass</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>NamingClass</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>R</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name><name>R</name><operator>.</operator><name>setNamingClass</name></name><argument_list>(<argument><expr><name>NamingClass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>SourceLocation</name></type> <name>TemplateKWLoc</name> <init>= <expr><call><name><name>Old</name><operator>-&gt;</operator><name>getTemplateKeywordLoc</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>



<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>Old</name><operator>-&gt;</operator><name>hasExplicitTemplateArgs</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>TemplateKWLoc</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>D</name> <init>= <expr><name><name>R</name><operator>.</operator><name>getAsSingle</name></name><operator>&lt;</operator><name>NamedDecl</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>



<if_stmt><if>if <condition>(<expr><name>D</name> <operator>&amp;&amp;</operator> <call><name><name>D</name><operator>-&gt;</operator><name>isCXXInstanceMember</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>BuildPossibleImplicitMemberExpr</name></name><argument_list>(<argument><expr><name>SS</name></expr></argument>, <argument><expr><name>TemplateKWLoc</name></expr></argument>, <argument><expr><name>R</name></expr></argument>,
<argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildDeclarationNameExpr</name><argument_list>(<argument><expr><name>SS</name></expr></argument>, <argument><expr><name>R</name></expr></argument>, <argument><expr><call><name><name>Old</name><operator>-&gt;</operator><name>requiresADL</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>



<decl_stmt><decl><type><name>TemplateArgumentListInfo</name></type> <name>TransArgs</name><argument_list>(<argument><expr><call><name><name>Old</name><operator>-&gt;</operator><name>getLAngleLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Old</name><operator>-&gt;</operator><name>getRAngleLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Old</name><operator>-&gt;</operator><name>hasExplicitTemplateArgs</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformTemplateArguments</name><argument_list>(<argument><expr><call><name><name>Old</name><operator>-&gt;</operator><name>getTemplateArgs</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Old</name><operator>-&gt;</operator><name>getNumTemplateArgs</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>TransArgs</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>R</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildTemplateIdExpr</name><argument_list>(<argument><expr><name>SS</name></expr></argument>, <argument><expr><name>TemplateKWLoc</name></expr></argument>, <argument><expr><name>R</name></expr></argument>,
<argument><expr><call><name><name>Old</name><operator>-&gt;</operator><name>requiresADL</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>TransArgs</name></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformTypeTraitExpr</name><argument_list>(<argument>TypeTraitExpr *E</argument>)</argument_list></macro> <block>{
<expr><name>bool</name> <name>ArgChanged</name> <operator>=</operator> <name>false</name></expr>;
<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>TypeSourceInfo</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>Args</name></expr>;
<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>I</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>N</name> <init>= <expr><call><name><name>E</name><operator>-&gt;</operator><name>getNumArgs</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>I</name> <operator>!=</operator> <name>N</name></expr>;</condition> <incr><expr><operator>++</operator><name>I</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>From</name> <init>= <expr><call><name><name>E</name><operator>-&gt;</operator><name>getArg</name></name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TypeLoc</name></type> <name>FromTL</name> <init>= <expr><call><name><name>From</name><operator>-&gt;</operator><name>getTypeLoc</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>FromTL</name><operator>.</operator><name>getAs</name></name><operator>&lt;</operator><name>PackExpansionTypeLoc</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>TypeLocBuilder</name></type> <name>TLB</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>TLB</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>FromTL</name><operator>.</operator><name>getFullDataSize</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>QualType</name></type> <name>To</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>TLB</name></expr></argument>, <argument><expr><name>FromTL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>To</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>To</name> <operator>==</operator> <call><name><name>From</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>Args</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>From</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name><name>Args</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>TLB</name><operator>.</operator><name>getTypeSourceInfo</name></name><argument_list>(<argument><expr><name><name>SemaRef</name><operator>.</operator><name>Context</name></name></expr></argument>, <argument><expr><name>To</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ArgChanged</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt/></block_content></block></else></if_stmt></block_content></block></if></if_stmt></block_content></block></for>}</block></expr></expr_stmt>
<continue>continue;</continue>
}

ArgChanged <expr_stmt><expr><operator>=</operator> <name>true</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>PackExpansionTypeLoc</name></type> <name>ExpansionTL</name> <init>= <expr><name><name>FromTL</name><operator>.</operator><name>castAs</name></name><operator>&lt;</operator><name>PackExpansionTypeLoc</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TypeLoc</name></type> <name>PatternTL</name> <init>= <expr><call><name><name>ExpansionTL</name><operator>.</operator><name>getPatternLoc</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>UnexpandedParameterPack</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name></type> <name>Unexpanded</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>SemaRef</name><operator>.</operator><name>collectUnexpandedParameterPacks</name></name><argument_list>(<argument><expr><name>PatternTL</name></expr></argument>, <argument><expr><name>Unexpanded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>Expand</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>RetainExpansion</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></type> <name>OrigNumExpansions</name> <init>=
<expr><call><name><name>ExpansionTL</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getNumExpansions</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></type> <name>NumExpansions</name> <init>= <expr><name>OrigNumExpansions</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TryExpandParameterPacks</name><argument_list>(<argument><expr><call><name><name>ExpansionTL</name><operator>.</operator><name>getEllipsisLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>PatternTL</name><operator>.</operator><name>getSourceRange</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>Unexpanded</name></expr></argument>,
<argument><expr><name>Expand</name></expr></argument>, <argument><expr><name>RetainExpansion</name></expr></argument>,
<argument><expr><name>NumExpansions</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Expand</name></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><name>Sema</name><operator>::</operator><name>ArgumentPackSubstitutionIndexRAII</name> <call><name>SubstIndex</name><argument_list>(<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>TypeLocBuilder</name></type> <name>TLB</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>TLB</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>From</name><operator>-&gt;</operator><name>getTypeLoc</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getFullDataSize</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>To</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>TLB</name></expr></argument>, <argument><expr><name>PatternTL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>To</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>To</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildPackExpansionType</name><argument_list>(<argument><expr><name>To</name></expr></argument>,
<argument><expr><call><name><name>PatternTL</name><operator>.</operator><name>getSourceRange</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>ExpansionTL</name><operator>.</operator><name>getEllipsisLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>NumExpansions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>To</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>PackExpansionTypeLoc</name></type> <name>ToExpansionTL</name>
<init>= <expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>PackExpansionTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>To</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>ToExpansionTL</name><operator>.</operator><name>setEllipsisLoc</name></name><argument_list>(<argument><expr><call><name><name>ExpansionTL</name><operator>.</operator><name>getEllipsisLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Args</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>TLB</name><operator>.</operator><name>getTypeSourceInfo</name></name><argument_list>(<argument><expr><name><name>SemaRef</name><operator>.</operator><name>Context</name></name></expr></argument>, <argument><expr><name>To</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>



<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>I</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>I</name> <operator>!=</operator> <operator>*</operator><name>NumExpansions</name></expr>;</condition> <incr><expr><operator>++</operator><name>I</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>Sema</name><operator>::</operator><name>ArgumentPackSubstitutionIndexRAII</name> <call><name>SubstIndex</name><argument_list>(<argument><expr><name>SemaRef</name></expr></argument>, <argument><expr><name>I</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>TypeLocBuilder</name></type> <name>TLB</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>TLB</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>PatternTL</name><operator>.</operator><name>getFullDataSize</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>QualType</name></type> <name>To</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>TLB</name></expr></argument>, <argument><expr><name>PatternTL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>To</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>To</name><operator>-&gt;</operator><name>containsUnexpandedParameterPack</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>To</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildPackExpansionType</name><argument_list>(<argument><expr><name>To</name></expr></argument>,
<argument><expr><call><name><name>PatternTL</name><operator>.</operator><name>getSourceRange</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>ExpansionTL</name><operator>.</operator><name>getEllipsisLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>NumExpansions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>To</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>PackExpansionTypeLoc</name></type> <name>ToExpansionTL</name>
<init>= <expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>PackExpansionTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>To</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>ToExpansionTL</name><operator>.</operator><name>setEllipsisLoc</name></name><argument_list>(<argument><expr><call><name><name>ExpansionTL</name><operator>.</operator><name>getEllipsisLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name><name>Args</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>TLB</name><operator>.</operator><name>getTypeSourceInfo</name></name><argument_list>(<argument><expr><name><name>SemaRef</name><operator>.</operator><name>Context</name></name></expr></argument>, <argument><expr><name>To</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>RetainExpansion</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>



<decl_stmt><decl><type><name>ForgetPartiallySubstitutedPackRAII</name></type> <name>Forget</name><argument_list>(<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>TypeLocBuilder</name></type> <name>TLB</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>TLB</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>From</name><operator>-&gt;</operator><name>getTypeLoc</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getFullDataSize</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>To</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><name>TLB</name></expr></argument>, <argument><expr><name>PatternTL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>To</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>To</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildPackExpansionType</name><argument_list>(<argument><expr><name>To</name></expr></argument>,
<argument><expr><call><name><name>PatternTL</name><operator>.</operator><name>getSourceRange</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>ExpansionTL</name><operator>.</operator><name>getEllipsisLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>NumExpansions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>To</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>PackExpansionTypeLoc</name></type> <name>ToExpansionTL</name>
<init>= <expr><name><name>TLB</name><operator>.</operator><name>push</name></name><operator>&lt;</operator><name>PackExpansionTypeLoc</name><operator>&gt;</operator><operator>(</operator><name>To</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>ToExpansionTL</name><operator>.</operator><name>setEllipsisLoc</name></name><argument_list>(<argument><expr><call><name><name>ExpansionTL</name><operator>.</operator><name>getEllipsisLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Args</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>TLB</name><operator>.</operator><name>getTypeSourceInfo</name></name><argument_list>(<argument><expr><name><name>SemaRef</name><operator>.</operator><name>Context</name></name></expr></argument>, <argument><expr><name>To</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}

if <expr_stmt><expr><operator>(</operator><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>ArgChanged</name><operator>)</operator></expr></expr_stmt>
<return>return <expr><name>E</name></expr>;</return>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildTypeTrait</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getTrait</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Args</name></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformConceptSpecializationExpr</name><argument_list>(
<argument>ConceptSpecializationExpr *E</argument>)</argument_list></macro> <block>{
<expr><specifier>const</specifier> <name>ASTTemplateArgumentListInfo</name> <operator>*</operator><name>Old</name> <operator>=</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getTemplateArgsAsWritten</name></name><argument_list>()</argument_list></call></expr>;
<expr><name>TemplateArgumentListInfo</name> <call><name>TransArgs</name><argument_list>(<argument><expr><name><name>Old</name><operator>-&gt;</operator><name>LAngleLoc</name></name></expr></argument>, <argument><expr><name><name>Old</name><operator>-&gt;</operator><name>RAngleLoc</name></name></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformTemplateArguments</name><argument_list>(<argument><expr><call><name><name>Old</name><operator>-&gt;</operator><name>getTemplateArgs</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name><name>Old</name><operator>-&gt;</operator><name>NumTemplateArgs</name></name></expr></argument>, <argument><expr><name>TransArgs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildConceptSpecializationExpr</name><argument_list>(
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getNestedNameSpecifierLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getTemplateKWLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getConceptNameInfo</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getFoundDecl</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getNamedConcept</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><operator>&amp;</operator><name>TransArgs</name></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformRequiresExpr</name><argument_list>(<argument>RequiresExpr *E</argument>)</argument_list></macro> <block>{
<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name><operator>*</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>TransParams</name></expr>;
<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>TransParamTypes</name></expr>;
<expr><name>Sema</name><operator>::</operator><name>ExtParameterInfoBuilder</name> <name>ExtParamInfos</name></expr>;



<expr><name>EnterExpressionEvaluationContext</name> <call><name>Ctx</name><argument_list>(
<argument><expr><name>SemaRef</name></expr></argument>, <argument><expr><name>Sema</name><operator>::</operator><name>ExpressionEvaluationContext</name><operator>::</operator><name>Unevaluated</name></expr></argument>)</argument_list></call></expr>;

<expr><name>RequiresExprBodyDecl</name> <operator>*</operator><name>Body</name> <operator>=</operator> <name>RequiresExprBodyDecl</name><operator>::</operator><call><name>Create</name><argument_list>(
<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><name>Context</name></expr></argument>, <argument><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><name>CurContext</name></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBody</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getBeginLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;

<expr><name>Sema</name><operator>::</operator><name>ContextRAII</name> <call><name>SavedContext</name><argument_list>(<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Body</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;

<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformFunctionTypeParams</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getRequiresKWLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getLocalParameters</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><name>TransParamTypes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TransParams</name></expr></argument>,
<argument><expr><name>ExtParamInfos</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<for>for <control>(<init><decl><type><name>ParmVarDecl</name> <modifier>*</modifier></type><name>Param</name> <range>: <expr><name>TransParams</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>Param</name><operator>-&gt;</operator><name>setDeclContext</name></name><argument_list>(<argument><expr><name>Body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>concepts</name><operator>::</operator><name>Requirement</name> <modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>TransReqs</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformRequiresExprRequirements</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getRequirements</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>TransReqs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>concepts</name><operator>::</operator><name>Requirement</name> <operator>*</operator><name>Req</name> <operator>:</operator> <name>TransReqs</name></expr></init>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>ER</name> <operator>=</operator> <call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>concepts</name><operator>::</operator><name>ExprRequirement</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Req</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>ER</name><operator>-&gt;</operator><name>getReturnTypeRequirement</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isTypeConstraint</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>ER</name><operator>-&gt;</operator><name>getReturnTypeRequirement</name></name><argument_list>()</argument_list></call>
<operator>.</operator><call><name>getTypeConstraintTemplateParameterList</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getParam</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call>
<operator>-&gt;</operator><call><name>setDeclContext</name><argument_list>(<argument><expr><name>Body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildRequiresExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getRequiresKWLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Body</name></expr></argument>,
<argument><expr><name>TransParams</name></expr></argument>, <argument><expr><name>TransReqs</name></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getRBraceLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>bool</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformRequiresExprRequirements</name><argument_list>(
<argument>ArrayRef&lt;concepts::Requirement *&gt; Reqs</argument>,
<argument>SmallVectorImpl&lt;concepts::Requirement *&gt; &amp;Transformed</argument>)</argument_list></macro> <block>{
<for>for <control>(<init><expr><name>concepts</name><operator>::</operator><name>Requirement</name> <operator>*</operator><name>Req</name> <operator>:</operator> <name>Reqs</name></expr></init>)</control> <block>{<block_content>
<expr_stmt><expr><name>concepts</name><operator>::</operator><name>Requirement</name> <operator>*</operator><name>TransReq</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>TypeReq</name> <operator>=</operator> <call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>concepts</name><operator>::</operator><name>TypeRequirement</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Req</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>TransReq</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformTypeRequirement</name><argument_list>(<argument><expr><name>TypeReq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>auto</name> <operator>*</operator><name>ExprReq</name> <operator>=</operator> <call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>concepts</name><operator>::</operator><name>ExprRequirement</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Req</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>TransReq</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExprRequirement</name><argument_list>(<argument><expr><name>ExprReq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>TransReq</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformNestedRequirement</name><argument_list>(
<argument><expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>concepts</name><operator>::</operator><name>NestedRequirement</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Req</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>TransReq</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>Transformed</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>TransReq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></for>}</block></expr></expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>concepts</name><operator>::</operator><name>TypeRequirement</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformTypeRequirement</name><argument_list>(
<argument>concepts::TypeRequirement *Req</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>Req</name><operator>-&gt;</operator><name>isSubstitutionFailure</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildTypeRequirement</name><argument_list>(
<argument><expr><call><name><name>Req</name><operator>-&gt;</operator><name>getSubstitutionDiagnostic</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>Req</name></expr>;</return>
<expr_stmt/></block_content></block></if></if_stmt>}</block>
<name>TypeSourceInfo</name> <operator>*</operator><name>TransType</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><call><name><name>Req</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>TransType</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildTypeRequirement</name><argument_list>(<argument><expr><name>TransType</name></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>concepts</name><operator>::</operator><name>ExprRequirement</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformExprRequirement</name><argument_list>(<argument>concepts::ExprRequirement *Req</argument>)</argument_list></macro> <block>{
<expr><name>llvm</name><operator>::</operator><name><name>PointerUnion</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><name>concepts</name><operator>::</operator><name>Requirement</name><operator>::</operator><name>SubstitutionDiagnostic</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>TransExpr</name></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Req</name><operator>-&gt;</operator><name>isExprSubstitutionFailure</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>TransExpr</name> <operator>=</operator> <call><name><name>Req</name><operator>-&gt;</operator><name>getExprSubstitutionDiagnostic</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>TransExprRes</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>Req</name><operator>-&gt;</operator><name>getExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>TransExprRes</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>TransExpr</name> <operator>=</operator> <call><name><name>TransExprRes</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></else></if_stmt>}</block>

<name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>concepts</name><operator>::</operator><name>ExprRequirement</name><operator>::</operator><name>ReturnTypeRequirement</name></expr></argument>&gt;</argument_list></name> <name>TransRetReq</name></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>&amp;</modifier></type><name>RetReq</name> <init>= <expr><call><name><name>Req</name><operator>-&gt;</operator><name>getReturnTypeRequirement</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>RetReq</name><operator>.</operator><name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>TransRetReq</name><operator>.</operator><name>emplace</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name><name>RetReq</name><operator>.</operator><name>isSubstitutionFailure</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>TransRetReq</name><operator>.</operator><name>emplace</name></name><argument_list>(<argument><expr><call><name><name>RetReq</name><operator>.</operator><name>getSubstitutionDiagnostic</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name><name>RetReq</name><operator>.</operator><name>isTypeConstraint</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>TemplateParameterList</name> <modifier>*</modifier></type><name>OrigTPL</name> <init>=
<expr><call><name><name>RetReq</name><operator>.</operator><name>getTypeConstraintTemplateParameterList</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TemplateParameterList</name> <modifier>*</modifier></type><name>TPL</name> <init>=
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformTemplateParameterList</name><argument_list>(<argument><expr><name>OrigTPL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>TPL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>TransRetReq</name><operator>.</operator><name>emplace</name></name><argument_list>(<argument><expr><name>TPL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>TransRetReq</name><operator>.</operator><name>hasValue</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"All code paths leading here must set TransRetReq"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name> <init>= <expr><name><name>TransExpr</name><operator>.</operator><name>dyn_cast</name></name><operator>&lt;</operator><name>Expr</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildExprRequirement</name><argument_list>(<argument><expr><name>E</name></expr></argument>, <argument><expr><call><name><name>Req</name><operator>-&gt;</operator><name>isSimple</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Req</name><operator>-&gt;</operator><name>getNoexceptLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><operator>*</operator><name>TransRetReq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildExprRequirement</name><argument_list>(
<argument><expr><name><name>TransExpr</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><name>concepts</name><operator>::</operator><name>Requirement</name><operator>::</operator><name>SubstitutionDiagnostic</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></argument>,
<argument><expr><call><name><name>Req</name><operator>-&gt;</operator><name>isSimple</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Req</name><operator>-&gt;</operator><name>getNoexceptLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><operator>*</operator><name>TransRetReq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>concepts</name><operator>::</operator><name>NestedRequirement</name> <operator>*</operator>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformNestedRequirement</name><argument_list>(
<argument>concepts::NestedRequirement *Req</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>Req</name><operator>-&gt;</operator><name>isSubstitutionFailure</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildNestedRequirement</name><argument_list>(
<argument><expr><call><name><name>Req</name><operator>-&gt;</operator><name>getSubstitutionDiagnostic</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>Req</name></expr>;</return>
<expr_stmt/></block_content></block></if></if_stmt>}</block>
<name>ExprResult</name> <name>TransConstraint</name> <operator>=</operator>
<call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>Req</name><operator>-&gt;</operator><name>getConstraintExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>TransConstraint</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildNestedRequirement</name><argument_list>(<argument><expr><call><name><name>TransConstraint</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformArrayTypeTraitExpr</name><argument_list>(<argument>ArrayTypeTraitExpr *E</argument>)</argument_list></macro> <block>{
<expr><name>TypeSourceInfo</name> <operator>*</operator><name>T</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getQueriedTypeSourceInfo</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>T</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<name>T</name> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getQueriedTypeSourceInfo</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>ExprResult</name></type> <name>SubExpr</name></decl>;</decl_stmt>
<block>{<block_content>
<decl_stmt><decl><type><name>EnterExpressionEvaluationContext</name></type> <name>Unevaluated</name><argument_list>(
<argument><expr><name>SemaRef</name></expr></argument>, <argument><expr><name>Sema</name><operator>::</operator><name>ExpressionEvaluationContext</name><operator>::</operator><name>Unevaluated</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<expr_stmt><expr><name>SubExpr</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getDimensionExpression</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>SubExpr</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>SubExpr</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getDimensionExpression</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildArrayTypeTrait</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getTrait</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>T</name></expr></argument>,
<argument><expr><call><name><name>SubExpr</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformExpressionTraitExpr</name><argument_list>(<argument>ExpressionTraitExpr *E</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>SubExpr</name></expr>;
<expr><block>{
<expr><name>EnterExpressionEvaluationContext</name> <call><name>Unevaluated</name><argument_list>(
<argument><expr><name>SemaRef</name></expr></argument>, <argument><expr><name>Sema</name><operator>::</operator><name>ExpressionEvaluationContext</name><operator>::</operator><name>Unevaluated</name></expr></argument>)</argument_list></call></expr>;
<expr><name>SubExpr</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getQueriedExpression</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>SubExpr</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>SubExpr</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getQueriedExpression</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt>
}</block></expr></expr_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildExpressionTrait</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getTrait</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>SubExpr</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformParenDependentScopeDeclRefExpr</name><argument_list>(
<argument>ParenExpr *PE</argument>, <argument>DependentScopeDeclRefExpr *DRE</argument>, <argument>bool AddrTaken</argument>,
<argument>TypeSourceInfo **RecoveryTSI</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>NewDRE</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDependentScopeDeclRefExpr</name><argument_list>(
<argument><expr><name>DRE</name></expr></argument>, <argument><expr><name>AddrTaken</name></expr></argument>, <argument><expr><name>RecoveryTSI</name></expr></argument>)</argument_list></call></expr>;


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>NewDRE</name><operator>.</operator><name>isUsable</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NewDRE</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>NewDRE</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>DRE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>PE</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildParenExpr</name><argument_list>(<argument><expr><call><name><name>NewDRE</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>PE</name><operator>-&gt;</operator><name>getLParen</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>PE</name><operator>-&gt;</operator><name>getRParen</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformDependentScopeDeclRefExpr</name><argument_list>(
<argument>DependentScopeDeclRefExpr *E</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>TransformDependentScopeDeclRefExpr</name><argument_list>(<argument><expr><name>E</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>ExprResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformDependentScopeDeclRefExpr</name><argument_list>(
<argument>DependentScopeDeclRefExpr *E</argument>, <argument>bool IsAddressOfOperand</argument>,
<argument>TypeSourceInfo **RecoveryTSI</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getQualifierLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>NestedNameSpecifierLoc</name> <name>QualifierLoc</name> <operator>=</operator>
<call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformNestedNameSpecifierLoc</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getQualifierLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>QualifierLoc</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<name>SourceLocation</name> <name>TemplateKWLoc</name> <operator>=</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getTemplateKeywordLoc</name></name><argument_list>()</argument_list></call></block></expr>;</expr_stmt>





<decl_stmt><decl><type><name>DeclarationNameInfo</name></type> <name>NameInfo</name> <init>=
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDeclarationNameInfo</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getNameInfo</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>NameInfo</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>E</name><operator>-&gt;</operator><name>hasExplicitTemplateArgs</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>QualifierLoc</name> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getQualifierLoc</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>


<call><name><name>NameInfo</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getDeclName</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildDependentScopeDeclRefExpr</name><argument_list>(
<argument><expr><name>QualifierLoc</name></expr></argument>, <argument><expr><name>TemplateKWLoc</name></expr></argument>, <argument><expr><name>NameInfo</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><name>IsAddressOfOperand</name></expr></argument>, <argument><expr><name>RecoveryTSI</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>TemplateArgumentListInfo</name></type> <name>TransArgs</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getLAngleLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getRAngleLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformTemplateArguments</name><argument_list>(
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getTemplateArgs</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getNumTemplateArgs</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>TransArgs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildDependentScopeDeclRefExpr</name><argument_list>(
<argument><expr><name>QualifierLoc</name></expr></argument>, <argument><expr><name>TemplateKWLoc</name></expr></argument>, <argument><expr><name>NameInfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TransArgs</name></expr></argument>, <argument><expr><name>IsAddressOfOperand</name></expr></argument>,
<argument><expr><name>RecoveryTSI</name></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformCXXConstructExpr</name><argument_list>(<argument>CXXConstructExpr *E</argument>)</argument_list></macro> <block>{



<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AllowSkippingCXXConstructExpr</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>(</operator><operator>(</operator><call><name><name>E</name><operator>-&gt;</operator><name>getNumArgs</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator>
<operator>(</operator><call><name><name>E</name><operator>-&gt;</operator><name>getNumArgs</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>DropCallArgument</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getArg</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>DropCallArgument</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getArg</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name><name>E</name><operator>-&gt;</operator><name>isListInitialization</name></name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformInitializer</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getArg</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>TemporaryBase</name> <call><name>Rebase</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>DeclarationName</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>T</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>T</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>CXXConstructorDecl</name> <modifier>*</modifier></type><name>Constructor</name> <init>= <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>CXXConstructorDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDecl</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getConstructor</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Constructor</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>ArgumentChanged</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name><modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name></type> <name>Args</name></decl>;</decl_stmt>
<block>{<block_content>
<decl_stmt><decl><type><name>EnterExpressionEvaluationContext</name></type> <name>Context</name><argument_list>(
<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>EnterExpressionEvaluationContext</name><operator>::</operator><name>InitList</name></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>isListInitialization</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExprs</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getArgs</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getNumArgs</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>Args</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>ArgumentChanged</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<name>T</name> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<name>Constructor</name> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getConstructor</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><name>ArgumentChanged</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><call><name><name>SemaRef</name><operator>.</operator><name>MarkFunctionReferenced</name></name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Constructor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>E</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildCXXConstructExpr</name><argument_list>(
<argument><expr><name>T</name></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Constructor</name></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>isElidable</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Args</name></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>hadMultipleCandidates</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>isListInitialization</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>isStdInitListInitialization</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>requiresZeroInitialization</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getConstructionKind</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getParenOrBraceRange</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformCXXInheritedCtorInitExpr</name><argument_list>(
<argument>CXXInheritedCtorInitExpr *E</argument>)</argument_list></macro> <block>{
<expr><name>QualType</name> <name>T</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>T</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>CXXConstructorDecl</name> <operator>*</operator><name>Constructor</name> <operator>=</operator> <call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>CXXConstructorDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDecl</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getConstructor</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Constructor</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<name>T</name> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<name>Constructor</name> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getConstructor</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><call><name><name>SemaRef</name><operator>.</operator><name>MarkFunctionReferenced</name></name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Constructor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>E</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildCXXInheritedCtorInitExpr</name><argument_list>(
<argument><expr><name>T</name></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getLocation</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Constructor</name></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>constructsVBase</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>inheritedFromVBase</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}





template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformCXXBindTemporaryExpr</name><argument_list>(<argument>CXXBindTemporaryExpr *E</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getSubExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>






<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformExprWithCleanups</name><argument_list>(<argument>ExprWithCleanups *E</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getSubExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformCXXTemporaryObjectExpr</name><argument_list>(
<argument>CXXTemporaryObjectExpr *E</argument>)</argument_list></macro> <block>{
<expr><name>TypeSourceInfo</name> <operator>*</operator><name>T</name> <operator>=</operator>
<call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformTypeWithDeducedTST</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getTypeSourceInfo</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>T</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>CXXConstructorDecl</name> <operator>*</operator><name>Constructor</name> <operator>=</operator> <call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>CXXConstructorDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDecl</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getConstructor</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Constructor</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>ArgumentChanged</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name><modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name></type> <name>Args</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>Args</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getNumArgs</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>
<decl_stmt><decl><type><name>EnterExpressionEvaluationContext</name></type> <name>Context</name><argument_list>(
<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>EnterExpressionEvaluationContext</name><operator>::</operator><name>InitList</name></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>isListInitialization</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>TransformExprs</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getArgs</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getNumArgs</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>Args</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>ArgumentChanged</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<name>T</name> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getTypeSourceInfo</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<name>Constructor</name> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getConstructor</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><name>ArgumentChanged</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name><name>SemaRef</name><operator>.</operator><name>MarkFunctionReferenced</name></name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Constructor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>MaybeBindToTemporary</name></name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>



<decl_stmt><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name> <init>= <expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeLoc</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getEndLoc</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildCXXTemporaryObjectExpr</name><argument_list>(
<argument><expr><name>T</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>Args</name></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>LParenLoc</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformLambdaExpr</name><argument_list>(<argument>LambdaExpr *E</argument>)</argument_list></macro> <block>{


<typedef>typedef <expr_stmt><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>ExprResult</name></expr></argument>, <argument><expr><name>QualType</name></expr></argument>&gt;</argument_list></name> <name>InitCaptureInfoTy</name></expr>;</expr_stmt></typedef>
struct <name>TransformedInitCapture</name> <block>{

<expr><name>SourceLocation</name> <name>EllipsisLoc</name></expr>;

<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>InitCaptureInfoTy</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>Expansions</name></expr>;
}</block></block></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>TransformedInitCapture</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>InitCaptures</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>InitCaptures</name><operator>.</operator><name>resize</name></name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>explicit_capture_end</name></name><argument_list>()</argument_list></call> <operator>-</operator> <call><name><name>E</name><operator>-&gt;</operator><name>explicit_capture_begin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>LambdaExpr</name><operator>::</operator><name>capture_iterator</name> <name>C</name> <operator>=</operator> <call><name><name>E</name><operator>-&gt;</operator><name>capture_begin</name></name><argument_list>()</argument_list></call></expr><operator>,</operator>
<expr><name>CEnd</name> <operator>=</operator> <call><name><name>E</name><operator>-&gt;</operator><name>capture_end</name></name><argument_list>()</argument_list></call></expr>;</init>
<condition><expr><name>C</name> <operator>!=</operator> <name>CEnd</name></expr>;</condition> <incr><expr><operator>++</operator><name>C</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>E</name><operator>-&gt;</operator><name>isInitCapture</name></name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>TransformedInitCapture</name> <modifier>&amp;</modifier></type><name>Result</name> <init>= <expr><name><name>InitCaptures</name><index>[<expr><name>C</name> <operator>-</operator> <call><name><name>E</name><operator>-&gt;</operator><name>capture_begin</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>OldVD</name> <init>= <expr><call><name><name>C</name><operator>-&gt;</operator><name>getCapturedVar</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>auto</name></type> <name>SubstInitCapture</name> <init>= <expr><index>[<expr><operator>&amp;</operator></expr>]</index><operator>(</operator><name>SourceLocation</name> <name>EllipsisLoc</name>,
<name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name> <name>NumExpansions</name><operator>)</operator> <block>{
<expr><name>ExprResult</name> <name>NewExprInitResult</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformInitializer</name><argument_list>(
<argument><expr><call><name><name>OldVD</name><operator>-&gt;</operator><name>getInit</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>OldVD</name><operator>-&gt;</operator><name>getInitStyle</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>VarDecl</name><operator>::</operator><name>CallInit</name></expr></argument>)</argument_list></call></expr>;

<if_stmt><if>if <condition>(<expr><call><name><name>NewExprInitResult</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>Result</name><operator>.</operator><name>Expansions</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>InitCaptureInfoTy</name><argument_list>(<argument><expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>QualType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
<expr_stmt/>}</block_content>
Expr *NewExprInit = NewExprInitResult.get(</block></if></if_stmt>)</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>NewInitCaptureType</name> <init>=
<expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>buildLambdaInitCaptureInitialization</name><argument_list>(
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLocation</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>OldVD</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isReferenceType</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>EllipsisLoc</name></expr></argument>, <argument><expr><name>NumExpansions</name></expr></argument>, <argument><expr><call><name><name>OldVD</name><operator>-&gt;</operator><name>getIdentifier</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getCapturedVar</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getInitStyle</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>VarDecl</name><operator>::</operator><name>CInit</name></expr></argument>,
<argument><expr><name>NewExprInit</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>Result</name><operator>.</operator><name>Expansions</name><operator>.</operator><name>push_back</name></name><argument_list>(
<argument><expr><call><name>InitCaptureInfoTy</name><argument_list>(<argument><expr><name>NewExprInit</name></expr></argument>, <argument><expr><name>NewInitCaptureType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for><empty_stmt>;</empty_stmt>


<if_stmt><if>if <condition>(<expr><call><name><name>OldVD</name><operator>-&gt;</operator><name>isParameterPack</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>PackExpansionTypeLoc</name></type> <name>ExpansionTL</name> <init>= <expr><call><name><name>OldVD</name><operator>-&gt;</operator><name>getTypeSourceInfo</name></name><argument_list>()</argument_list></call>
<operator>-&gt;</operator><call><name>getTypeLoc</name><argument_list>()</argument_list></call>
<operator>.</operator><call><name><name>castAs</name><argument_list type="generic">&lt;<argument><expr><name>PackExpansionTypeLoc</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>UnexpandedParameterPack</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name></type> <name>Unexpanded</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>SemaRef</name><operator>.</operator><name>collectUnexpandedParameterPacks</name></name><argument_list>(<argument><expr><call><name><name>OldVD</name><operator>-&gt;</operator><name>getInit</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Unexpanded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>Expand</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>RetainExpansion</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></type> <name>OrigNumExpansions</name> <init>=
<expr><call><name><name>ExpansionTL</name><operator>.</operator><name>getTypePtr</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getNumExpansions</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></type> <name>NumExpansions</name> <init>= <expr><name>OrigNumExpansions</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TryExpandParameterPacks</name><argument_list>(
<argument><expr><call><name><name>ExpansionTL</name><operator>.</operator><name>getEllipsisLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>OldVD</name><operator>-&gt;</operator><name>getInit</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getSourceRange</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Unexpanded</name></expr></argument>, <argument><expr><name>Expand</name></expr></argument>,
<argument><expr><name>RetainExpansion</name></expr></argument>, <argument><expr><name>NumExpansions</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>Expand</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>I</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>I</name> <operator>!=</operator> <operator>*</operator><name>NumExpansions</name></expr>;</condition> <incr><expr><operator>++</operator><name>I</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>Sema</name><operator>::</operator><name>ArgumentPackSubstitutionIndexRAII</name> <call><name>SubstIndex</name><argument_list>(<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>I</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SubstInitCapture</name><argument_list>(<argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Expand</name> <operator>||</operator> <name>RetainExpansion</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ForgetPartiallySubstitutedPackRAII</name></type> <name>Forget</name><argument_list>(<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SubstInitCapture</name><argument_list>(<argument><expr><call><name><name>ExpansionTL</name><operator>.</operator><name>getEllipsisLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NumExpansions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Result</name><operator>.</operator><name>EllipsisLoc</name></name> <operator>=</operator> <call><name><name>ExpansionTL</name><operator>.</operator><name>getEllipsisLoc</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>SubstInitCapture</name><argument_list>(<argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
}

LambdaScopeInfo <expr_stmt><expr><operator>*</operator><name>LSI</name> <operator>=</operator> <call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>PushLambdaScope</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Sema</name><operator>::</operator><name>FunctionScopeRAII</name> <call><name>FuncScopeCleanup</name><argument_list>(<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<decl_stmt><decl><type><name>auto</name></type> <name>TPL</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformTemplateParameterList</name><argument_list>(
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getTemplateParameterList</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>LSI</name><operator>-&gt;</operator><name>GLTemplateParameterList</name></name> <operator>=</operator> <name>TPL</name></expr>;</expr_stmt>





<decl_stmt><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>NewCallOpTSI</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
<block>{<block_content>
<decl_stmt><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>OldCallOpTSI</name> <init>= <expr><call><name><name>E</name><operator>-&gt;</operator><name>getCallOperator</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getTypeSourceInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FunctionProtoTypeLoc</name></type> <name>OldCallOpFPTL</name> <init>=
<expr><call><name><name>OldCallOpTSI</name><operator>-&gt;</operator><name>getTypeLoc</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>getAs</name><argument_list type="generic">&lt;<argument><expr><name>FunctionProtoTypeLoc</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>TypeLocBuilder</name></type> <name>NewCallOpTLBuilder</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>ExceptionStorage</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TreeTransform</name> <modifier>*</modifier></type><name>This</name> <init>= <expr><name>this</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>QualType</name></type> <name>NewCallOpType</name> <init>= <expr><call><name>TransformFunctionProtoType</name><argument_list>(
<argument><expr><name>NewCallOpTLBuilder</name></expr></argument>, <argument><expr><name>OldCallOpFPTL</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>, <argument><expr><call><name>Qualifiers</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><index>[<expr><operator>&amp;</operator></expr>]</index><operator>(</operator><name>FunctionProtoType</name><operator>::</operator><name>ExceptionSpecInfo</name> <operator>&amp;</operator><name>ESI</name>, <name>bool</name> <operator>&amp;</operator><name>Changed</name><operator>)</operator> <block>{
<return>return <expr><call><name><name>This</name><operator>-&gt;</operator><name>TransformExceptionSpec</name></name><argument_list>(<argument><expr><call><name><name>OldCallOpFPTL</name><operator>.</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ESI</name></expr></argument>,
<argument><expr><name>ExceptionStorage</name></expr></argument>, <argument><expr><name>Changed</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></argument></argument_list></call></expr></init></decl></decl_stmt>)</block_content></block><empty_stmt>;</empty_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>NewCallOpType</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>NewCallOpTSI</name> <operator>=</operator> <call><name><name>NewCallOpTLBuilder</name><operator>.</operator><name>getTypeSourceInfo</name></name><argument_list>(<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><name>Context</name></expr></argument>,
<argument><expr><name>NewCallOpType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}


ExprResult <expr_stmt><expr><name>NewTrailingRequiresClause</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<decl><type><name>Expr</name> <modifier>*</modifier></type><name>TRC</name> <init>= <expr><call><name><name>E</name><operator>-&gt;</operator><name>getCallOperator</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getTrailingRequiresClause</name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>


<expr_stmt><expr><name>NewTrailingRequiresClause</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><name>TRC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>




<decl_stmt><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>OldClass</name> <init>= <expr><call><name><name>E</name><operator>-&gt;</operator><name>getLambdaClass</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>Class</name>
<init>= <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>createLambdaClosureType</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getIntroducerRange</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>NewCallOpTSI</name></expr></argument>,
<argument><expr><name>false</name></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getCaptureDefault</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><macro><name>transformedLocalDecl</name><argument_list>(<argument>OldClass</argument>, <argument>{Class}</argument>)</argument_list></macro></expr>;</expr_stmt>

<decl_stmt><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;<argument><expr><name>bool</name></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>, <argument><expr><name>Decl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></type> <name>Mangling</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ReplacingOriginal</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>Mangling</name> <operator>=</operator> <name>std</name><operator>::</operator><call><name>make_tuple</name><argument_list>(<argument><expr><call><name><name>OldClass</name><operator>-&gt;</operator><name>hasKnownLambdaInternalLinkage</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>OldClass</name><operator>-&gt;</operator><name>getLambdaManglingNumber</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>OldClass</name><operator>-&gt;</operator><name>getDeviceLambdaManglingNumber</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>OldClass</name><operator>-&gt;</operator><name>getLambdaContextDecl</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<decl_stmt><decl><type><name>CXXMethodDecl</name> <modifier>*</modifier></type><name>NewCallOperator</name> <init>= <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>startLambdaDefinition</name><argument_list>(
<argument><expr><name>Class</name></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getIntroducerRange</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NewCallOpTSI</name></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getCallOperator</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getEndLoc</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>NewCallOpTSI</name><operator>-&gt;</operator><name>getTypeLoc</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>castAs</name><argument_list type="generic">&lt;<argument><expr><name>FunctionProtoTypeLoc</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getParams</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getCallOperator</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getConstexprKind</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>NewTrailingRequiresClause</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>LSI</name><operator>-&gt;</operator><name>CallOperator</name></name> <operator>=</operator> <name>NewCallOperator</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>transformAttrs</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getCallOperator</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NewCallOperator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><macro><name>transformedLocalDecl</name><argument_list>(<argument>E-&gt;getCallOperator()</argument>, <argument>{NewCallOperator}</argument>)</argument_list></macro></expr>;</expr_stmt>


<expr_stmt><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>handleLambdaNumbering</name><argument_list>(<argument><expr><name>Class</name></expr></argument>, <argument><expr><name>NewCallOperator</name></expr></argument>, <argument><expr><name>Mangling</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>Sema</name><operator>::</operator><name>ContextRAII</name> <call><name>SavedContext</name><argument_list>(<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NewCallOperator</name></expr></argument>,
<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>buildLambdaScope</name><argument_list>(<argument><expr><name>LSI</name></expr></argument>, <argument><expr><name>NewCallOperator</name></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getIntroducerRange</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getCaptureDefault</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getCaptureDefaultLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>hasExplicitParameters</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>hasExplicitResultType</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>isMutable</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>Invalid</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>


<for>for <control>(<init><expr><name>LambdaExpr</name><operator>::</operator><name>capture_iterator</name> <name>C</name> <operator>=</operator> <call><name><name>E</name><operator>-&gt;</operator><name>capture_begin</name></name><argument_list>()</argument_list></call></expr><operator>,</operator>
<expr><name>CEnd</name> <operator>=</operator> <call><name><name>E</name><operator>-&gt;</operator><name>capture_end</name></name><argument_list>()</argument_list></call></expr>;</init>
<condition><expr><name>C</name> <operator>!=</operator> <name>CEnd</name></expr>;</condition> <incr><expr><operator>++</operator><name>C</name></expr></incr>)</control> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><call><name><name>C</name><operator>-&gt;</operator><name>isImplicit</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name><name>C</name><operator>-&gt;</operator><name>capturesThis</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>CheckCXXThisCapture</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLocation</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>isExplicit</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>true</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getCaptureKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>LCK_StarThis</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name><name>C</name><operator>-&gt;</operator><name>capturesVLAType</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>-&gt;</operator><name>isInitCapture</name></name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>TransformedInitCapture</name> <modifier>&amp;</modifier></type><name>NewC</name> <init>= <expr><name><name>InitCaptures</name><index>[<expr><name>C</name> <operator>-</operator> <call><name><name>E</name><operator>-&gt;</operator><name>capture_begin</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>OldVD</name> <init>= <expr><call><name><name>C</name><operator>-&gt;</operator><name>getCapturedVar</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name><operator>*</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>NewVDs</name></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>InitCaptureInfoTy</name> <modifier>&amp;</modifier></type><name>Info</name> <range>: <expr><name><name>NewC</name><operator>.</operator><name>Expansions</name></name></expr></range></decl></init>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>Init</name> <init>= <expr><name><name>Info</name><operator>.</operator><name>first</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>QualType</name></type> <name>InitQualType</name> <init>= <expr><name><name>Info</name><operator>.</operator><name>second</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Init</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>InitQualType</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Invalid</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>NewVD</name> <init>= <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>createLambdaInitCaptureVarDecl</name><argument_list>(
<argument><expr><call><name><name>OldVD</name><operator>-&gt;</operator><name>getLocation</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>InitQualType</name></expr></argument>, <argument><expr><name><name>NewC</name><operator>.</operator><name>EllipsisLoc</name></name></expr></argument>,
<argument><expr><call><name><name>OldVD</name><operator>-&gt;</operator><name>getIdentifier</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>OldVD</name><operator>-&gt;</operator><name>getInitStyle</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Init</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>NewVD</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Invalid</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name><name>NewVDs</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>NewVD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>addInitCapture</name><argument_list>(<argument><expr><name>LSI</name></expr></argument>, <argument><expr><name>NewVD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>Invalid</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>transformedLocalDecl</name><argument_list>(<argument><expr><name>OldVD</name></expr></argument>, <argument><expr><name>NewVDs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>capturesVariable</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"unexpected kind of lambda capture"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>Sema</name><operator>::</operator><name>TryCaptureKind</name> <name>Kind</name>
<operator>=</operator> <ternary><condition><expr><call><name><name>C</name><operator>-&gt;</operator><name>isImplicit</name></name><argument_list>()</argument_list></call></expr>?</condition><then> <expr><name>Sema</name><operator>::</operator><name>TryCapture_Implicit</name></expr>
</then><else>: <expr><ternary><condition><expr><call><name><name>C</name><operator>-&gt;</operator><name>getCaptureKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>LCK_ByCopy</name></expr>
?</condition><then> <expr><name>Sema</name><operator>::</operator><name>TryCapture_ExplicitByVal</name></expr>
</then><else>: <expr><name>Sema</name><operator>::</operator><name>TryCapture_ExplicitByRef</name></expr></else></ternary></expr></else></ternary></expr>;</expr_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>EllipsisLoc</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>C</name><operator>-&gt;</operator><name>isPackExpansion</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>UnexpandedParameterPack</name></type> <name>Unexpanded</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getCapturedVar</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLocation</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>ShouldExpand</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>RetainExpansion</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></type> <name>NumExpansions</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TryExpandParameterPacks</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getEllipsisLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLocation</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>Unexpanded</name></expr></argument>,
<argument><expr><name>ShouldExpand</name></expr></argument>, <argument><expr><name>RetainExpansion</name></expr></argument>,
<argument><expr><name>NumExpansions</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Invalid</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ShouldExpand</name></expr>)</condition> <block>{<block_content>



<decl_stmt><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>Pack</name> <init>= <expr><call><name><name>C</name><operator>-&gt;</operator><name>getCapturedVar</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>I</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>I</name> <operator>!=</operator> <operator>*</operator><name>NumExpansions</name></expr>;</condition> <incr><expr><operator>++</operator><name>I</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>Sema</name><operator>::</operator><name>ArgumentPackSubstitutionIndexRAII</name> <call><name>SubstIndex</name><argument_list>(<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>I</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>CapturedVar</name>
<init>= <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>VarDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDecl</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLocation</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>Pack</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>CapturedVar</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Invalid</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>tryCaptureVariable</name><argument_list>(<argument><expr><name>CapturedVar</name></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLocation</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>



<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>EllipsisLoc</name> <operator>=</operator> <call><name><name>C</name><operator>-&gt;</operator><name>getEllipsisLoc</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<decl_stmt><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>CapturedVar</name>
<init>= <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>VarDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDecl</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLocation</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getCapturedVar</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>CapturedVar</name> <operator>||</operator> <call><name><name>CapturedVar</name><operator>-&gt;</operator><name>isInvalidDecl</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Invalid</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>tryCaptureVariable</name><argument_list>(<argument><expr><name>CapturedVar</name></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLocation</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Kind</name></expr></argument>,
<argument><expr><name>EllipsisLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>finishLambdaExplicitCaptures</name><argument_list>(<argument><expr><name>LSI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>PushExpressionEvaluationContext</name><argument_list>(
<argument><expr><name>Sema</name><operator>::</operator><name>ExpressionEvaluationContext</name><operator>::</operator><name>PotentiallyEvaluated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><name>StmtResult</name></type> <name>Body</name> <init>=
<expr><ternary><condition><expr><name>Invalid</name></expr> ?</condition><then> <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformLambdaBody</name><argument_list>(<argument><expr><name>E</name></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBody</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><call><name><name>FuncScopeCleanup</name><operator>.</operator><name>disable</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>Body</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>SavedContext</name><operator>.</operator><name>pop</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnLambdaError</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>




<decl_stmt><decl><type><name>auto</name></type> <name>LSICopy</name> <init>= <expr><operator>*</operator><name>LSI</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnFinishFunctionBody</name><argument_list>(<argument><expr><name>NewCallOperator</name></expr></argument>, <argument><expr><call><name><name>Body</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>SavedContext</name><operator>.</operator><name>pop</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildLambdaExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Body</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getEndLoc</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><operator>&amp;</operator><name>LSICopy</name></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformLambdaBody</name><argument_list>(<argument>LambdaExpr *E</argument>, <argument>Stmt *S</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>TransformStmt</name><argument_list>(<argument><expr><name>S</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>SkipLambdaBody</name><argument_list>(<argument>LambdaExpr *E</argument>, <argument>Stmt *S</argument>)</argument_list></macro> <block>{

<for>for <control>(<init><expr><name>LambdaExpr</name><operator>::</operator><name>capture_iterator</name> <name>C</name> <operator>=</operator> <call><name><name>E</name><operator>-&gt;</operator><name>capture_begin</name></name><argument_list>()</argument_list></call></expr><operator>,</operator>
<expr><name>CEnd</name> <operator>=</operator> <call><name><name>E</name><operator>-&gt;</operator><name>capture_end</name></name><argument_list>()</argument_list></call></expr>;</init>
<condition><expr><name>C</name> <operator>!=</operator> <name>CEnd</name></expr>;</condition> <incr><expr><operator>++</operator><name>C</name></expr></incr>)</control> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>C</name><operator>-&gt;</operator><name>isImplicit</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name><name>C</name><operator>-&gt;</operator><name>capturesThis</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>CheckCXXThisCapture</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLocation</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>isExplicit</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>true</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getCaptureKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>LCK_StarThis</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
<expr_stmt/></block_content></block></if></if_stmt></block_content></block></for>}</block></expr></expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name><name>C</name><operator>-&gt;</operator><name>capturesVLAType</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>capturesVariable</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"unexpected kind of lambda capture"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>E</name><operator>-&gt;</operator><name>isInitCapture</name></name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"implicit init-capture?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>CapturedVar</name> <init>= <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>VarDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDecl</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLocation</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getCapturedVar</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>CapturedVar</name> <operator>||</operator> <call><name><name>CapturedVar</name><operator>-&gt;</operator><name>isInvalidDecl</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>tryCaptureVariable</name><argument_list>(<argument><expr><name>CapturedVar</name></expr></argument>, <argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getLocation</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}

return <expr_stmt><expr><name>S</name></expr>;</expr_stmt>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformCXXUnresolvedConstructExpr</name><argument_list>(
<argument>CXXUnresolvedConstructExpr *E</argument>)</argument_list></macro> <block>{
<expr><name>TypeSourceInfo</name> <operator>*</operator><name>T</name> <operator>=</operator>
<call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformTypeWithDeducedTST</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getTypeSourceInfo</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>T</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>bool</name> <name>ArgumentChanged</name> <operator>=</operator> <name>false</name></block></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name><modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name></type> <name>Args</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>Args</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getNumArgs</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>
<decl_stmt><decl><type><name>EnterExpressionEvaluationContext</name></type> <name>Context</name><argument_list>(
<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>EnterExpressionEvaluationContext</name><operator>::</operator><name>InitList</name></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>isListInitialization</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExprs</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>arg_begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getNumArgs</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>Args</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>ArgumentChanged</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<name>T</name> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getTypeSourceInfo</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><name>ArgumentChanged</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt>


<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildCXXUnresolvedConstructExpr</name><argument_list>(
<argument><expr><name>T</name></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Args</name></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getRParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>isListInitialization</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformCXXDependentScopeMemberExpr</name><argument_list>(
<argument>CXXDependentScopeMemberExpr *E</argument>)</argument_list></macro> <block>{

<expr><name>ExprResult</name> <call><name>Base</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name><operator>*</operator><operator>)</operator> <name>nullptr</name></expr></argument>)</argument_list></call></expr>;
<expr><name>Expr</name> <operator>*</operator><name>OldBase</name></expr>;
<expr><name>QualType</name> <name>BaseType</name></expr>;
<expr><name>QualType</name> <name>ObjectType</name></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>E</name><operator>-&gt;</operator><name>isImplicitAccess</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>OldBase</name> <operator>=</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getBase</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Base</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><name>OldBase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Base</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<decl_stmt><decl><type><name>ParsedType</name></type> <name>ObjectTy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>MayBePseudoDestructor</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>Base</name> <operator>=</operator> <call><name><name>SemaRef</name><operator>.</operator><name>ActOnStartCXXMemberReference</name></name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>, <argument><expr><call><name><name>Base</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getOperatorLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><ternary><condition><expr><call><name><name>E</name><operator>-&gt;</operator><name>isArrow</name></name><argument_list>()</argument_list></call></expr>?</condition><then> <expr><name>tok</name><operator>::</operator><name>arrow</name></expr> </then><else>: <expr><name>tok</name><operator>::</operator><name>period</name></expr></else></ternary></expr></argument>,
<argument><expr><name>ObjectTy</name></expr></argument>,
<argument><expr><name>MayBePseudoDestructor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Base</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ObjectType</name> <operator>=</operator> <call><name><name>ObjectTy</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>BaseType</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Expr</name><operator>*</operator><operator>)</operator> <call><name><name>Base</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call><operator>)</operator><operator>-&gt;</operator><call><name>getType</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></if></if_stmt>}</block></expr></expr_stmt> <if_stmt><else>else <block>{<block_content>
<expr_stmt><expr><name>OldBase</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>BaseType</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBaseType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ObjectType</name> <operator>=</operator> <name><name>BaseType</name><operator>-&gt;</operator><name>castAs</name></name><operator>&lt;</operator><name>PointerType</name><operator>&gt;</operator><operator>(</operator><operator>)</operator><operator>-&gt;</operator><call><name>getPointeeType</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>



<decl_stmt><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>FirstQualifierInScope</name>
<init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformFirstQualifierInScope</name><argument_list>(
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getFirstQualifierFoundInScope</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getQualifierLoc</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getBeginLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>NestedNameSpecifierLoc</name></type> <name>QualifierLoc</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>-&gt;</operator><name>getQualifier</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>QualifierLoc</name>
<operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformNestedNameSpecifierLoc</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getQualifierLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>ObjectType</name></expr></argument>,
<argument><expr><name>FirstQualifierInScope</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>QualifierLoc</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>SourceLocation</name></type> <name>TemplateKWLoc</name> <init>= <expr><call><name><name>E</name><operator>-&gt;</operator><name>getTemplateKeywordLoc</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>





<decl_stmt><decl><type><name>DeclarationNameInfo</name></type> <name>NameInfo</name>
<init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDeclarationNameInfo</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getMemberNameInfo</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>NameInfo</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>E</name><operator>-&gt;</operator><name>hasExplicitTemplateArgs</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>Base</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OldBase</name> <operator>&amp;&amp;</operator>
<name>BaseType</name> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getBaseType</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<name>QualifierLoc</name> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getQualifierLoc</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>NameInfo</name><operator>.</operator><name>getName</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getMember</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<name>FirstQualifierInScope</name> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getFirstQualifierFoundInScope</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildCXXDependentScopeMemberExpr</name><argument_list>(<argument><expr><call><name><name>Base</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>BaseType</name></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>isArrow</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getOperatorLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>QualifierLoc</name></expr></argument>,
<argument><expr><name>TemplateKWLoc</name></expr></argument>,
<argument><expr><name>FirstQualifierInScope</name></expr></argument>,
<argument><expr><name>NameInfo</name></expr></argument>,
<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>TemplateArgumentListInfo</name></type> <name>TransArgs</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getLAngleLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getRAngleLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformTemplateArguments</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getTemplateArgs</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getNumTemplateArgs</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>TransArgs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildCXXDependentScopeMemberExpr</name><argument_list>(<argument><expr><call><name><name>Base</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>BaseType</name></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>isArrow</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getOperatorLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>QualifierLoc</name></expr></argument>,
<argument><expr><name>TemplateKWLoc</name></expr></argument>,
<argument><expr><name>FirstQualifierInScope</name></expr></argument>,
<argument><expr><name>NameInfo</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>TransArgs</name></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformUnresolvedMemberExpr</name><argument_list>(
<argument>UnresolvedMemberExpr *Old</argument>)</argument_list></macro> <block>{

<expr><name>ExprResult</name> <call><name>Base</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><name>nullptr</name></expr></argument>)</argument_list></call></expr>;
<expr><name>QualType</name> <name>BaseType</name></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>Old</name><operator>-&gt;</operator><name>isImplicitAccess</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Base</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>Old</name><operator>-&gt;</operator><name>getBase</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Base</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>Base</name> <operator>=</operator>
<call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>PerformMemberExprBaseConversion</name><argument_list>(<argument><expr><call><name><name>Base</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Old</name><operator>-&gt;</operator><name>isArrow</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Base</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>BaseType</name> <operator>=</operator> <call><name><name>Base</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getType</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></if></if_stmt>}</block></expr></expr_stmt> <if_stmt><else>else <block>{<block_content>
<expr_stmt><expr><name>BaseType</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><call><name><name>Old</name><operator>-&gt;</operator><name>getBaseType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<decl_stmt><decl><type><name>NestedNameSpecifierLoc</name></type> <name>QualifierLoc</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Old</name><operator>-&gt;</operator><name>getQualifierLoc</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>QualifierLoc</name> <operator>=</operator>
<call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformNestedNameSpecifierLoc</name><argument_list>(<argument><expr><call><name><name>Old</name><operator>-&gt;</operator><name>getQualifierLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>QualifierLoc</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>SourceLocation</name></type> <name>TemplateKWLoc</name> <init>= <expr><call><name><name>Old</name><operator>-&gt;</operator><name>getTemplateKeywordLoc</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>LookupResult</name></type> <name>R</name><argument_list>(<argument><expr><name>SemaRef</name></expr></argument>, <argument><expr><call><name><name>Old</name><operator>-&gt;</operator><name>getMemberNameInfo</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Sema</name><operator>::</operator><name>LookupOrdinaryName</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><call><name>TransformOverloadExprDecls</name><argument_list>(<argument><expr><name>Old</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>R</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name><name>Old</name><operator>-&gt;</operator><name>getNamingClass</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>NamingClass</name> <init>= <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>CXXRecordDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDecl</name><argument_list>(<argument><expr><call><name><name>Old</name><operator>-&gt;</operator><name>getMemberLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Old</name><operator>-&gt;</operator><name>getNamingClass</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>NamingClass</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name><name>R</name><operator>.</operator><name>setNamingClass</name></name><argument_list>(<argument><expr><name>NamingClass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>TemplateArgumentListInfo</name></type> <name>TransArgs</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Old</name><operator>-&gt;</operator><name>hasExplicitTemplateArgs</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>TransArgs</name><operator>.</operator><name>setLAngleLoc</name></name><argument_list>(<argument><expr><call><name><name>Old</name><operator>-&gt;</operator><name>getLAngleLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>TransArgs</name><operator>.</operator><name>setRAngleLoc</name></name><argument_list>(<argument><expr><call><name><name>Old</name><operator>-&gt;</operator><name>getRAngleLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformTemplateArguments</name><argument_list>(
<argument><expr><call><name><name>Old</name><operator>-&gt;</operator><name>getTemplateArgs</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Old</name><operator>-&gt;</operator><name>getNumTemplateArgs</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>TransArgs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>





<decl_stmt><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>FirstQualifierInScope</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildUnresolvedMemberExpr</name><argument_list>(
<argument><expr><call><name><name>Base</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>BaseType</name></expr></argument>, <argument><expr><call><name><name>Old</name><operator>-&gt;</operator><name>getOperatorLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Old</name><operator>-&gt;</operator><name>isArrow</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>QualifierLoc</name></expr></argument>,
<argument><expr><name>TemplateKWLoc</name></expr></argument>, <argument><expr><name>FirstQualifierInScope</name></expr></argument>, <argument><expr><name>R</name></expr></argument>,
<argument><expr><operator>(</operator><ternary><condition><expr><call><name><name>Old</name><operator>-&gt;</operator><name>hasExplicitTemplateArgs</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><operator>&amp;</operator><name>TransArgs</name></expr> </then><else>: <expr><name>nullptr</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformCXXNoexceptExpr</name><argument_list>(<argument>CXXNoexceptExpr *E</argument>)</argument_list></macro> <block>{
<expr><name>EnterExpressionEvaluationContext</name> <call><name>Unevaluated</name><argument_list>(
<argument><expr><name>SemaRef</name></expr></argument>, <argument><expr><name>Sema</name><operator>::</operator><name>ExpressionEvaluationContext</name><operator>::</operator><name>Unevaluated</name></expr></argument>)</argument_list></call></expr>;
<expr><name>ExprResult</name> <name>SubExpr</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getOperand</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>SubExpr</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>SubExpr</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getOperand</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildCXXNoexceptExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getSourceRange</name></name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><call><name><name>SubExpr</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformPackExpansionExpr</name><argument_list>(<argument>PackExpansionExpr *E</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>Pattern</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getPattern</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Pattern</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>Pattern</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getPattern</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildPackExpansion</name><argument_list>(<argument><expr><call><name><name>Pattern</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getEllipsisLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getNumExpansions</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformSizeOfPackExpr</name><argument_list>(<argument>SizeOfPackExpr *E</argument>)</argument_list></macro> <block>{


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>E</name><operator>-&gt;</operator><name>isValueDependent</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt>

<name>EnterExpressionEvaluationContext</name> <call><name>Unevaluated</name><argument_list>(
<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Sema</name><operator>::</operator><name>ExpressionEvaluationContext</name><operator>::</operator><name>Unevaluated</name></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>

<decl_stmt><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name></expr></argument>&gt;</argument_list></name></type> <name>PackArgs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TemplateArgument</name></type> <name>ArgStorage</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>-&gt;</operator><name>isPartiallySubstituted</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>PackArgs</name> <operator>=</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getPartialArguments</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>E</name><operator>-&gt;</operator><name>isValueDependent</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>UnexpandedParameterPack</name></type> <name>Unexpanded</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getPack</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getPackLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>ShouldExpand</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>RetainExpansion</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></type> <name>NumExpansions</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TryExpandParameterPacks</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getOperatorLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getPackLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>Unexpanded</name></expr></argument>,
<argument><expr><name>ShouldExpand</name></expr></argument>, <argument><expr><name>RetainExpansion</name></expr></argument>,
<argument><expr><name>NumExpansions</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><name>ShouldExpand</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>auto</name> <operator>*</operator><name>Pack</name> <operator>=</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getPack</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>TTPD</name> <operator>=</operator> <call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>TemplateTypeParmDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Pack</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ArgStorage</name> <operator>=</operator> <call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>Context</name><operator>.</operator><name>getPackExpansionType</name></name><argument_list>(
<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>Context</name><operator>.</operator><name>getTypeDeclType</name></name><argument_list>(<argument><expr><name>TTPD</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>auto</name> <operator>*</operator><name>TTPD</name> <operator>=</operator> <call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>TemplateTemplateParmDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Pack</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ArgStorage</name> <operator>=</operator> <call><name>TemplateArgument</name><argument_list>(<argument><expr><call><name>TemplateName</name><argument_list>(<argument><expr><name>TTPD</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>auto</name> <operator>*</operator><name>VD</name> <operator>=</operator> <call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>ValueDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Pack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>DRE</name> <init>= <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildDeclRefExpr</name><argument_list>(
<argument><expr><name>VD</name></expr></argument>, <argument><expr><call><name><name>VD</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getNonLValueExprType</name><argument_list>(<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><name>Context</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><ternary><condition><expr><call><name><name>VD</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isReferenceType</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>VK_LValue</name></expr> </then><else>: <expr><name>VK_PRValue</name></expr></else></ternary></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getPackLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>DRE</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ArgStorage</name> <operator>=</operator> <macro><name>new</name> <argument_list>(<argument>getSema().Context</argument>)</argument_list></macro> <call><name>PackExpansionExpr</name><argument_list>(
<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><name><name>Context</name><operator>.</operator><name>DependentTy</name></name></expr></argument>, <argument><expr><call><name><name>DRE</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getPackLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>PackArgs</name> <operator>=</operator> <name>ArgStorage</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>PackArgs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>auto</name> <operator>*</operator><name>Pack</name> <operator>=</operator> <call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDecl</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getPackLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getPack</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Pack</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildSizeOfPackExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getOperatorLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Pack</name></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getPackLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getRParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>None</name></expr></argument>, <argument><expr><name>None</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>


<decl_stmt><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></type> <name>Result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><specifier>const</specifier> <name>TemplateArgument</name> <modifier>&amp;</modifier></type><name>Arg</name> <range>: <expr><name>PackArgs</name></expr></range></decl></init>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>Arg</name><operator>.</operator><name>isPackExpansion</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Result</name> <operator>=</operator> <operator>*</operator><name>Result</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>TemplateArgumentLoc</name></type> <name>ArgLoc</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>InventTemplateArgumentLoc</name><argument_list>(<argument><expr><name>Arg</name></expr></argument>, <argument><expr><name>ArgLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>Ellipsis</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></type> <name>OrigNumExpansions</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TemplateArgumentLoc</name></type> <name>Pattern</name> <init>=
<expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getTemplateArgumentPackExpansionPattern</name><argument_list>(<argument><expr><name>ArgLoc</name></expr></argument>, <argument><expr><name>Ellipsis</name></expr></argument>,
<argument><expr><name>OrigNumExpansions</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>TemplateArgumentLoc</name></type> <name>OutPattern</name></decl>;</decl_stmt>
<expr_stmt><expr><name>Sema</name><operator>::</operator><name>ArgumentPackSubstitutionIndexRAII</name> <call><name>SubstIndex</name><argument_list>(<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformTemplateArgument</name><argument_list>(<argument><expr><name>Pattern</name></expr></argument>, <argument><expr><name>OutPattern</name></expr></argument>,
<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>


<decl_stmt><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></type> <name>NumExpansions</name> <init>=
<expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getFullyPackExpandedSize</name><argument_list>(<argument><expr><call><name><name>OutPattern</name><operator>.</operator><name>getArgument</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>NumExpansions</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name>Result</name> <operator>=</operator> <name>None</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>Result</name> <operator>=</operator> <operator>*</operator><name>Result</name> <operator>+</operator> <operator>*</operator><name>NumExpansions</name></expr>;</expr_stmt>
</block_content>}</block></for>



<if_stmt><if>if <condition>(<expr><name>Result</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildSizeOfPackExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getOperatorLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getPack</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getPackLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getRParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>*</operator><name>Result</name></expr></argument>, <argument><expr><name>None</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>TemplateArgumentListInfo</name></type> <name>TransformedPackArgs</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getPackLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getPackLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
<block>{<block_content>
<decl_stmt><decl><type><name>TemporaryBase</name></type> <name>Rebase</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getPackLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getBaseEntity</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
<typedef>typedef <type><name><name>TemplateArgumentLocInventIterator</name><argument_list type="generic">&lt;
<argument><expr><name>Derived</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>TemplateArgument</name><modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>PackLocIterator</name>;</typedef>
<if_stmt><if>if <condition>(<expr><call><name>TransformTemplateArguments</name><argument_list>(<argument><expr><call><name>PackLocIterator</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><call><name><name>PackArgs</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>PackLocIterator</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>, <argument><expr><call><name><name>PackArgs</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>TransformedPackArgs</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block>



<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name></type> <name>Args</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>PartialSubstitution</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>auto</name> <operator>&amp;</operator><name>Loc</name> <operator>:</operator> <call><name><name>TransformedPackArgs</name><operator>.</operator><name>arguments</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<expr_stmt><expr><call><name><name>Args</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>Loc</name><operator>.</operator><name>getArgument</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Loc</name><operator>.</operator><name>getArgument</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isPackExpansion</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>PartialSubstitution</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>PartialSubstitution</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildSizeOfPackExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getOperatorLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getPack</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getPackLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getRParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>None</name></expr></argument>, <argument><expr><name>Args</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildSizeOfPackExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getOperatorLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getPack</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getPackLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getRParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Args</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>None</name></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformSubstNonTypeTemplateParmPackExpr</name><argument_list>(
<argument>SubstNonTypeTemplateParmPackExpr *E</argument>)</argument_list></macro> <block>{

<return>return <expr><name>E</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformSubstNonTypeTemplateParmExpr</name><argument_list>(
<argument>SubstNonTypeTemplateParmExpr *E</argument>)</argument_list></macro> <block>{

<return>return <expr><name>E</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformFunctionParmPackExpr</name><argument_list>(<argument>FunctionParmPackExpr *E</argument>)</argument_list></macro> <block>{

<return>return <expr><name>E</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformMaterializeTemporaryExpr</name><argument_list>(
<argument>MaterializeTemporaryExpr *E</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getSubExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformCXXFoldExpr</name><argument_list>(<argument>CXXFoldExpr *E</argument>)</argument_list></macro> <block>{
<expr><name>UnresolvedLookupExpr</name> <operator>*</operator><name>Callee</name> <operator>=</operator> <name>nullptr</name></expr>;
<if_stmt><if>if <condition>(<decl><type><name>Expr</name> <modifier>*</modifier></type><name>OldCallee</name> <init>= <expr><call><name><name>E</name><operator>-&gt;</operator><name>getCallee</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>CalleeResult</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><name>OldCallee</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>CalleeResult</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>Callee</name> <operator>=</operator> <call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>UnresolvedLookupExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>CalleeResult</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></if></if_stmt>}</block>

<name>Expr</name> <operator>*</operator><name>Pattern</name> <operator>=</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getPattern</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>UnexpandedParameterPack</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name></type> <name>Unexpanded</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>collectUnexpandedParameterPacks</name><argument_list>(<argument><expr><name>Pattern</name></expr></argument>, <argument><expr><name>Unexpanded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>Unexpanded</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Pack expansion without parameter packs?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>Expand</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>RetainExpansion</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></type> <name>OrigNumExpansions</name> <init>= <expr><call><name><name>E</name><operator>-&gt;</operator><name>getNumExpansions</name></name><argument_list>()</argument_list></call></expr></init></decl>,
<decl><type ref="prev"/><name>NumExpansions</name> <init>= <expr><name>OrigNumExpansions</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TryExpandParameterPacks</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getEllipsisLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Pattern</name><operator>-&gt;</operator><name>getSourceRange</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>Unexpanded</name></expr></argument>,
<argument><expr><name>Expand</name></expr></argument>, <argument><expr><name>RetainExpansion</name></expr></argument>,
<argument><expr><name>NumExpansions</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Expand</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name>Sema</name><operator>::</operator><name>ArgumentPackSubstitutionIndexRAII</name> <call><name>SubstIndex</name><argument_list>(<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ExprResult</name></type> <name>LHS</name> <init>=
<expr><ternary><condition><expr><call><name><name>E</name><operator>-&gt;</operator><name>getLHS</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getLHS</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>ExprResult</name><argument_list>()</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>LHS</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>ExprResult</name></type> <name>RHS</name> <init>=
<expr><ternary><condition><expr><call><name><name>E</name><operator>-&gt;</operator><name>getRHS</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getRHS</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>ExprResult</name><argument_list>()</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>RHS</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>LHS</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getLHS</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>RHS</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getRHS</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildCXXFoldExpr</name><argument_list>(
<argument><expr><name>Callee</name></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>LHS</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getOperator</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getEllipsisLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>RHS</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NumExpansions</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><name>NumExpansions</name> <operator>&amp;&amp;</operator> <call><name><name>SemaRef</name><operator>.</operator><name>getLangOpts</name></name><argument_list>()</argument_list></call><operator>.</operator><name>BracketDepth</name> <operator>&lt;</operator> <name>NumExpansions</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>SemaRef</name><operator>.</operator><name>Diag</name></name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getEllipsisLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>clang</name><operator>::</operator><name>diag</name><operator>::</operator><name>err_fold_expression_limit_exceeded</name></expr></argument>)</argument_list></call>
<operator>&lt;&lt;</operator> <operator>*</operator><name>NumExpansions</name> <operator>&lt;&lt;</operator> <call><name><name>SemaRef</name><operator>.</operator><name>getLangOpts</name></name><argument_list>()</argument_list></call><operator>.</operator><name>BracketDepth</name>
<operator>&lt;&lt;</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getSourceRange</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>SemaRef</name><operator>.</operator><name>Diag</name></name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getEllipsisLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>diag</name><operator>::</operator><name>note_bracket_depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>



<decl_stmt><decl><type><name>ExprResult</name></type> <name>Result</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getInit</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>LeftFold</name> <init>= <expr><call><name><name>E</name><operator>-&gt;</operator><name>isLeftFold</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>



<if_stmt><if>if <condition>(<expr><operator>!</operator><name>LeftFold</name> <operator>&amp;&amp;</operator> <name>RetainExpansion</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ForgetPartiallySubstitutedPackRAII</name></type> <name>Forget</name><argument_list>(<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ExprResult</name></type> <name>Out</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><name>Pattern</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Out</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>Result</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildCXXFoldExpr</name><argument_list>(
<argument><expr><name>Callee</name></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Out</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getOperator</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getEllipsisLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Result</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>OrigNumExpansions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>I</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>I</name> <operator>!=</operator> <operator>*</operator><name>NumExpansions</name></expr>;</condition> <incr><expr><operator>++</operator><name>I</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>Sema</name><operator>::</operator><name>ArgumentPackSubstitutionIndexRAII</name> <call><name>SubstIndex</name><argument_list>(
<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><ternary><condition><expr><name>LeftFold</name></expr> ?</condition><then> <expr><name>I</name></expr> </then><else>: <expr><operator>*</operator><name>NumExpansions</name> <operator>-</operator> <name>I</name> <operator>-</operator> <literal type="number">1</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>Out</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><name>Pattern</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Out</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>Out</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>containsUnexpandedParameterPack</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>Result</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildCXXFoldExpr</name><argument_list>(
<argument><expr><name>Callee</name></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><ternary><condition><expr><name>LeftFold</name></expr> ?</condition><then> <expr><call><name><name>Result</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr> </then><else>: <expr><call><name><name>Out</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></else></ternary></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getOperator</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getEllipsisLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><ternary><condition><expr><name>LeftFold</name></expr> ?</condition><then> <expr><call><name><name>Out</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr> </then><else>: <expr><call><name><name>Result</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></else></ternary></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>OrigNumExpansions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isUsable</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>LHS</name> <init>= <expr><ternary><condition><expr><name>LeftFold</name></expr> ?</condition><then> <expr><call><name><name>Result</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr> </then><else>: <expr><call><name><name>Out</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>RHS</name> <init>= <expr><ternary><condition><expr><name>LeftFold</name></expr> ?</condition><then> <expr><call><name><name>Out</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr> </then><else>: <expr><call><name><name>Result</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>Callee</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>Result</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildCXXOperatorCallExpr</name><argument_list>(
<argument><expr><name>BinaryOperator</name><operator>::</operator><call><name>getOverloadedOperator</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getOperator</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getEllipsisLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Callee</name></expr></argument>, <argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>Result</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildBinaryOperator</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getEllipsisLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getOperator</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>Result</name> <operator>=</operator> <name>Out</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>



<if_stmt><if>if <condition>(<expr><name>LeftFold</name> <operator>&amp;&amp;</operator> <name>RetainExpansion</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ForgetPartiallySubstitutedPackRAII</name></type> <name>Forget</name><argument_list>(<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ExprResult</name></type> <name>Out</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><name>Pattern</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Out</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>Result</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildCXXFoldExpr</name><argument_list>(
<argument><expr><name>Callee</name></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Result</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getOperator</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getEllipsisLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Out</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>OrigNumExpansions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isUnset</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildEmptyCXXFoldExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getEllipsisLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getOperator</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>Result</name></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformCXXStdInitializerListExpr</name><argument_list>(
<argument>CXXStdInitializerListExpr *E</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getSubExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformObjCStringLiteral</name><argument_list>(<argument>ObjCStringLiteral *E</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>MaybeBindToTemporary</name></name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformObjCBoolLiteralExpr</name><argument_list>(<argument>ObjCBoolLiteralExpr *E</argument>)</argument_list></macro> <block>{
<return>return <expr><name>E</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformObjCBoxedExpr</name><argument_list>(<argument>ObjCBoxedExpr *E</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>SubExpr</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getSubExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>SubExpr</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>SubExpr</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getSubExpr</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildObjCBoxedExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getSourceRange</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>SubExpr</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformObjCArrayLiteral</name><argument_list>(<argument>ObjCArrayLiteral *E</argument>)</argument_list></macro> <block>{

<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name> <name>Elements</name></expr>;
<expr><name>bool</name> <name>ArgChanged</name> <operator>=</operator> <name>false</name></expr>;
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExprs</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getElements</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getNumElements</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>false</name></expr></argument>, <argument><expr><name>Elements</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ArgChanged</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>ArgChanged</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>MaybeBindToTemporary</name></name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildObjCArrayLiteral</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getSourceRange</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Elements</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Elements</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformObjCDictionaryLiteral</name><argument_list>(
<argument>ObjCDictionaryLiteral *E</argument>)</argument_list></macro> <block>{

<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>ObjCDictionaryElement</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name> <name>Elements</name></expr>;
<expr><name>bool</name> <name>ArgChanged</name> <operator>=</operator> <name>false</name></expr>;
<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>I</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>N</name> <init>= <expr><call><name><name>E</name><operator>-&gt;</operator><name>getNumElements</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>I</name> <operator>!=</operator> <name>N</name></expr>;</condition> <incr><expr><operator>++</operator><name>I</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>ObjCDictionaryElement</name></type> <name>OrigElement</name> <init>= <expr><call><name><name>E</name><operator>-&gt;</operator><name>getKeyValueElement</name></name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>OrigElement</name><operator>.</operator><name>isPackExpansion</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>UnexpandedParameterPack</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name></type> <name>Unexpanded</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>collectUnexpandedParameterPacks</name><argument_list>(<argument><expr><name><name>OrigElement</name><operator>.</operator><name>Key</name></name></expr></argument>, <argument><expr><name>Unexpanded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>collectUnexpandedParameterPacks</name><argument_list>(<argument><expr><name><name>OrigElement</name><operator>.</operator><name>Value</name></name></expr></argument>, <argument><expr><name>Unexpanded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>Unexpanded</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Pack expansion without parameter packs?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>Expand</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>RetainExpansion</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></type> <name>OrigNumExpansions</name> <init>= <expr><name><name>OrigElement</name><operator>.</operator><name>NumExpansions</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></type> <name>NumExpansions</name> <init>= <expr><name>OrigNumExpansions</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceRange</name></type> <name>PatternRange</name><argument_list>(<argument><expr><call><name><name>OrigElement</name><operator>.</operator><name>Key</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>OrigElement</name><operator>.</operator><name>Value</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TryExpandParameterPacks</name><argument_list>(<argument><expr><name><name>OrigElement</name><operator>.</operator><name>EllipsisLoc</name></name></expr></argument>,
<argument><expr><name>PatternRange</name></expr></argument>, <argument><expr><name>Unexpanded</name></expr></argument>, <argument><expr><name>Expand</name></expr></argument>,
<argument><expr><name>RetainExpansion</name></expr></argument>, <argument><expr><name>NumExpansions</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Expand</name></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><name>Sema</name><operator>::</operator><name>ArgumentPackSubstitutionIndexRAII</name> <call><name>SubstIndex</name><argument_list>(<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>Key</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><name><name>OrigElement</name><operator>.</operator><name>Key</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Key</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>Key</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name><name>OrigElement</name><operator>.</operator><name>Key</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ArgChanged</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>ExprResult</name></type> <name>Value</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><name><name>OrigElement</name><operator>.</operator><name>Value</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Value</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>Value</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name><name>OrigElement</name><operator>.</operator><name>Value</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ArgChanged</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>ObjCDictionaryElement</name></type> <name>Expansion</name> <init>= <expr><block>{
<expr><call><name><name>Key</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>, <expr><call><name><name>Value</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>, <expr><name><name>OrigElement</name><operator>.</operator><name>EllipsisLoc</name></name></expr>, <expr><name>NumExpansions</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>Elements</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>Expansion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
<expr_stmt/></block_content></block></if></if_stmt></block_content></block></if></if_stmt></block_content></block></for>}</block>



<name>ArgChanged</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>



<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>I</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>I</name> <operator>!=</operator> <operator>*</operator><name>NumExpansions</name></expr>;</condition> <incr><expr><operator>++</operator><name>I</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>Sema</name><operator>::</operator><name>ArgumentPackSubstitutionIndexRAII</name> <call><name>SubstIndex</name><argument_list>(<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>I</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>Key</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><name><name>OrigElement</name><operator>.</operator><name>Key</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Key</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>ExprResult</name></type> <name>Value</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><name><name>OrigElement</name><operator>.</operator><name>Value</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Value</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>ObjCDictionaryElement</name></type> <name>Element</name> <init>= <expr><block>{
<expr><call><name><name>Key</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>, <expr><call><name><name>Value</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>, <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>, <expr><name>NumExpansions</name></expr>
}</block></expr></init></decl>;</decl_stmt>




<if_stmt><if>if <condition>(<expr><call><name><name>Key</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>containsUnexpandedParameterPack</name><argument_list>()</argument_list></call> <operator>||</operator>
<call><name><name>Value</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>containsUnexpandedParameterPack</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>Element</name><operator>.</operator><name>EllipsisLoc</name></name> <operator>=</operator> <name><name>OrigElement</name><operator>.</operator><name>EllipsisLoc</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name><name>Elements</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>Element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>




<continue>continue;</continue>
}


ExprResult <expr_stmt><expr><name>Key</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><name><name>OrigElement</name><operator>.</operator><name>Key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Key</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>Key</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name><name>OrigElement</name><operator>.</operator><name>Key</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ArgChanged</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>


<decl_stmt><decl><type><name>ExprResult</name></type> <name>Value</name>
<init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><name><name>OrigElement</name><operator>.</operator><name>Value</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Value</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>Value</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name><name>OrigElement</name><operator>.</operator><name>Value</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ArgChanged</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>ObjCDictionaryElement</name></type> <name>Element</name> <init>= <expr><block>{
<expr><call><name><name>Key</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>, <expr><call><name><name>Value</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>, <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>, <expr><name>None</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>Elements</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>Element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}

if <expr_stmt><expr><operator>(</operator><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>ArgChanged</name><operator>)</operator></expr></expr_stmt>
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>MaybeBindToTemporary</name></name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>;</return>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildObjCDictionaryLiteral</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getSourceRange</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>Elements</name></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformObjCEncodeExpr</name><argument_list>(<argument>ObjCEncodeExpr *E</argument>)</argument_list></macro> <block>{
<expr><name>TypeSourceInfo</name> <operator>*</operator><name>EncodedTypeInfo</name>
<operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getEncodedTypeSourceInfo</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>EncodedTypeInfo</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<name>EncodedTypeInfo</name> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getEncodedTypeSourceInfo</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildObjCEncodeExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getAtLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>EncodedTypeInfo</name></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getRParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator>
<macro><name>TransformObjCIndirectCopyRestoreExpr</name><argument_list>(<argument>ObjCIndirectCopyRestoreExpr *E</argument>)</argument_list></macro> <block>{




<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getSubExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>ExprResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator>
<macro><name>TransformObjCBridgedCastExpr</name><argument_list>(<argument>ObjCBridgedCastExpr *E</argument>)</argument_list></macro> <block>{
<expr><name>TypeSourceInfo</name> <operator>*</operator><name>TSInfo</name>
<operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getTypeInfoAsWritten</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>TSInfo</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>ExprResult</name> <name>Result</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getSubExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<name>TSInfo</name> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getTypeInfoAsWritten</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>Result</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getSubExpr</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>BuildObjCBridgedCast</name></name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getLParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBridgeKind</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBridgeKeywordLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>TSInfo</name></expr></argument>,
<argument><expr><call><name><name>Result</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformObjCAvailabilityCheckExpr</name><argument_list>(
<argument>ObjCAvailabilityCheckExpr *E</argument>)</argument_list></macro> <block>{
<return>return <expr><name>E</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformObjCMessageExpr</name><argument_list>(<argument>ObjCMessageExpr *E</argument>)</argument_list></macro> <block>{

<expr><name>bool</name> <name>ArgChanged</name> <operator>=</operator> <name>false</name></expr>;
<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name><operator>*</operator></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name> <name>Args</name></expr>;
<expr><call><name><name>Args</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getNumArgs</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExprs</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getArgs</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getNumArgs</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>Args</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>ArgChanged</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>-&gt;</operator><name>getReceiverKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ObjCMessageExpr</name><operator>::</operator><name>Class</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>ReceiverTypeInfo</name>
<init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getClassReceiverTypeInfo</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ReceiverTypeInfo</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<name>ReceiverTypeInfo</name> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getClassReceiverTypeInfo</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>ArgChanged</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>MaybeBindToTemporary</name></name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name></type> <name>SelLocs</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>E</name><operator>-&gt;</operator><name>getSelectorLocs</name></name><argument_list>(<argument><expr><name>SelLocs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildObjCMessageExpr</name><argument_list>(<argument><expr><name>ReceiverTypeInfo</name></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getSelector</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>SelLocs</name></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getMethodDecl</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getLeftLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>Args</name></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getRightLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name><name>E</name><operator>-&gt;</operator><name>getReceiverKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ObjCMessageExpr</name><operator>::</operator><name>SuperClass</name> <operator>||</operator>
<call><name><name>E</name><operator>-&gt;</operator><name>getReceiverKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ObjCMessageExpr</name><operator>::</operator><name>SuperInstance</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>E</name><operator>-&gt;</operator><name>getMethodDecl</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name></type> <name>SelLocs</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>E</name><operator>-&gt;</operator><name>getSelectorLocs</name></name><argument_list>(<argument><expr><name>SelLocs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildObjCMessageExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getSuperLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getSelector</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>SelLocs</name></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getReceiverType</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getMethodDecl</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getLeftLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>Args</name></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getRightLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getReceiverKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ObjCMessageExpr</name><operator>::</operator><name>Instance</name> <operator>&amp;&amp;</operator>
<literal type="string">"Only class and instance messages may be instantiated"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>Receiver</name>
<init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getInstanceReceiver</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Receiver</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>Receiver</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getInstanceReceiver</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>ArgChanged</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>MaybeBindToTemporary</name></name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name></type> <name>SelLocs</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>E</name><operator>-&gt;</operator><name>getSelectorLocs</name></name><argument_list>(<argument><expr><name>SelLocs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildObjCMessageExpr</name><argument_list>(<argument><expr><call><name><name>Receiver</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getSelector</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>SelLocs</name></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getMethodDecl</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getLeftLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>Args</name></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getRightLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformObjCSelectorExpr</name><argument_list>(<argument>ObjCSelectorExpr *E</argument>)</argument_list></macro> <block>{
<return>return <expr><name>E</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformObjCProtocolExpr</name><argument_list>(<argument>ObjCProtocolExpr *E</argument>)</argument_list></macro> <block>{
<return>return <expr><name>E</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformObjCIvarRefExpr</name><argument_list>(<argument>ObjCIvarRefExpr *E</argument>)</argument_list></macro> <block>{

<expr><name>ExprResult</name> <name>Base</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBase</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Base</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>




<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>Base</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getBase</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildObjCIvarRefExpr</name><argument_list>(<argument><expr><call><name><name>Base</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getDecl</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getLocation</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>isArrow</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>isFreeIvar</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformObjCPropertyRefExpr</name><argument_list>(<argument>ObjCPropertyRefExpr *E</argument>)</argument_list></macro> <block>{


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>E</name><operator>-&gt;</operator><name>isObjectReceiver</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt>


<name>ExprResult</name> <name>Base</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBase</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Base</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>Base</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getBase</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>-&gt;</operator><name>isExplicitProperty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildObjCPropertyRefExpr</name><argument_list>(<argument><expr><call><name><name>Base</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getExplicitProperty</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getLocation</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildObjCPropertyRefExpr</name><argument_list>(<argument><expr><call><name><name>Base</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>PseudoObjectTy</name></name></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getImplicitPropertyGetter</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getImplicitPropertySetter</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getLocation</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformObjCSubscriptRefExpr</name><argument_list>(<argument>ObjCSubscriptRefExpr *E</argument>)</argument_list></macro> <block>{

<expr><name>ExprResult</name> <name>Base</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBaseExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Base</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<name>ExprResult</name> <name>Key</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getKeyExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Key</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>Key</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getKeyExpr</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>Base</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getBaseExpr</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildObjCSubscriptRefExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getRBracket</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Base</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Key</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getAtIndexMethodDecl</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>setAtIndexMethodDecl</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformObjCIsaExpr</name><argument_list>(<argument>ObjCIsaExpr *E</argument>)</argument_list></macro> <block>{

<expr><name>ExprResult</name> <name>Base</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBase</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Base</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>Base</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getBase</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildObjCIsaExpr</name><argument_list>(<argument><expr><call><name><name>Base</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getIsaMemberLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getOpLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>isArrow</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformShuffleVectorExpr</name><argument_list>(<argument>ShuffleVectorExpr *E</argument>)</argument_list></macro> <block>{
<expr><name>bool</name> <name>ArgumentChanged</name> <operator>=</operator> <name>false</name></expr>;
<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name><operator>*</operator></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name> <name>SubExprs</name></expr>;
<expr><call><name><name>SubExprs</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getNumSubExprs</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExprs</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getSubExprs</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getNumSubExprs</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>,
<argument><expr><name>SubExprs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ArgumentChanged</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><name>ArgumentChanged</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildShuffleVectorExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBuiltinLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>SubExprs</name></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getRParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformConvertVectorExpr</name><argument_list>(<argument>ConvertVectorExpr *E</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>SrcExpr</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getSrcExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>SrcExpr</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>TypeSourceInfo</name> <operator>*</operator><name>Type</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getTypeSourceInfo</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Type</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<name>Type</name> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getTypeSourceInfo</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>SrcExpr</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getSrcExpr</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildConvertVectorExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBuiltinLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>SrcExpr</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Type</name></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getRParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformBlockExpr</name><argument_list>(<argument>BlockExpr *E</argument>)</argument_list></macro> <block>{
<expr><name>BlockDecl</name> <operator>*</operator><name>oldBlock</name> <operator>=</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getBlockDecl</name></name><argument_list>()</argument_list></call></expr>;

<expr><call><name><name>SemaRef</name><operator>.</operator><name>ActOnBlockStart</name></name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getCaretLocation</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;
<expr><name>BlockScopeInfo</name> <operator>*</operator><name>blockScope</name> <operator>=</operator> <call><name><name>SemaRef</name><operator>.</operator><name>getCurBlock</name></name><argument_list>()</argument_list></call></expr>;

<expr><call><name><name>blockScope</name><operator>-&gt;</operator><name>TheDecl</name><operator>-&gt;</operator><name>setIsVariadic</name></name><argument_list>(<argument><expr><call><name><name>oldBlock</name><operator>-&gt;</operator><name>isVariadic</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>blockScope</name><operator>-&gt;</operator><name>TheDecl</name><operator>-&gt;</operator><name>setBlockMissingReturnType</name></name><argument_list>(
<argument><expr><call><name><name>oldBlock</name><operator>-&gt;</operator><name>blockMissingReturnType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;

<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name><operator>*</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>params</name></expr>;
<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>paramTypes</name></expr>;

<expr><specifier>const</specifier> <name>FunctionProtoType</name> <operator>*</operator><name>exprFunctionType</name> <operator>=</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getFunctionType</name></name><argument_list>()</argument_list></call></expr>;


<expr><name>Sema</name><operator>::</operator><name>ExtParameterInfoBuilder</name> <name>extParamInfos</name></expr>;
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformFunctionTypeParams</name><argument_list>(
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getCaretLocation</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>oldBlock</name><operator>-&gt;</operator><name>parameters</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><call><name><name>exprFunctionType</name><operator>-&gt;</operator><name>getExtParameterInfosOrNull</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>paramTypes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>params</name></expr></argument>,
<argument><expr><name>extParamInfos</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnBlockError</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getCaretLocation</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return>
<expr_stmt/></block_content></block></if></if_stmt>}</block>

<name>QualType</name> <name>exprResultType</name> <operator>=</operator>
<call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><call><name><name>exprFunctionType</name><operator>-&gt;</operator><name>getReturnType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>auto</name></type> <name>epi</name> <init>= <expr><call><name><name>exprFunctionType</name><operator>-&gt;</operator><name>getExtProtoInfo</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>epi</name><operator>.</operator><name>ExtParameterInfos</name></name> <operator>=</operator> <call><name><name>extParamInfos</name><operator>.</operator><name>getPointerOrNull</name></name><argument_list>(<argument><expr><call><name><name>paramTypes</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>functionType</name> <init>=
<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildFunctionProtoType</name><argument_list>(<argument><expr><name>exprResultType</name></expr></argument>, <argument><expr><name>paramTypes</name></expr></argument>, <argument><expr><name>epi</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>blockScope</name><operator>-&gt;</operator><name>FunctionType</name></name> <operator>=</operator> <name>functionType</name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>params</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>blockScope</name><operator>-&gt;</operator><name>TheDecl</name><operator>-&gt;</operator><name>setParams</name></name><argument_list>(<argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>oldBlock</name><operator>-&gt;</operator><name>blockMissingReturnType</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>blockScope</name><operator>-&gt;</operator><name>HasImplicitReturnType</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>blockScope</name><operator>-&gt;</operator><name>ReturnType</name></name> <operator>=</operator> <name>exprResultType</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<decl_stmt><decl><type><name>StmtResult</name></type> <name>body</name> <init>= <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformStmt</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBody</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>body</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnBlockError</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getCaretLocation</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>SemaRef</name><operator>.</operator><name>getDiagnostics</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>hasErrorOccurred</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>&amp;</modifier></type><name>I</name> <range>: <expr><call><name><name>oldBlock</name><operator>-&gt;</operator><name>captures</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>oldCapture</name> <init>= <expr><call><name><name>I</name><operator>.</operator><name>getVariable</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><call><name><name>oldCapture</name><operator>-&gt;</operator><name>isParameterPack</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>newCapture</name> <init>=
<expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>VarDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformDecl</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getCaretLocation</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>oldCapture</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>blockScope</name><operator>-&gt;</operator><name>CaptureMap</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><name>newCapture</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>oldBlock</name><operator>-&gt;</operator><name>capturesCXXThis</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>blockScope</name><operator>-&gt;</operator><name>isCXXThisCaptured</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>ActOnBlockStmtExpr</name></name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getCaretLocation</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>body</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformAsTypeExpr</name><argument_list>(<argument>AsTypeExpr *E</argument>)</argument_list></macro> <block>{
<expr><name>ExprResult</name> <name>SrcExpr</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getSrcExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>SrcExpr</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>QualType</name> <name>Type</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>

<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>BuildAsTypeExpr</name></name><argument_list>(<argument><expr><call><name><name>SrcExpr</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Type</name></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBuiltinLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getRParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformAtomicExpr</name><argument_list>(<argument>AtomicExpr *E</argument>)</argument_list></macro> <block>{
<expr><name>bool</name> <name>ArgumentChanged</name> <operator>=</operator> <name>false</name></expr>;
<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name><operator>*</operator></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name> <name>SubExprs</name></expr>;
<expr><call><name><name>SubExprs</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getNumSubExprs</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformExprs</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getSubExprs</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getNumSubExprs</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>,
<argument><expr><name>SubExprs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ArgumentChanged</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AlwaysRebuild</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><name>ArgumentChanged</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>E</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildAtomicExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getBuiltinLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SubExprs</name></expr></argument>,
<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getOp</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getRParenLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}





template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>RebuildPointerType</name><argument_list>(<argument>QualType PointeeType</argument>,
<argument>SourceLocation Star</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>BuildPointerType</name></name><argument_list>(<argument><expr><name>PointeeType</name></expr></argument>, <argument><expr><name>Star</name></expr></argument>,
<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getBaseEntity</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>RebuildBlockPointerType</name><argument_list>(<argument>QualType PointeeType</argument>,
<argument>SourceLocation Star</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>BuildBlockPointerType</name></name><argument_list>(<argument><expr><name>PointeeType</name></expr></argument>, <argument><expr><name>Star</name></expr></argument>,
<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getBaseEntity</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>QualType</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>RebuildReferenceType</name><argument_list>(<argument>QualType ReferentType</argument>,
<argument>bool WrittenAsLValue</argument>,
<argument>SourceLocation Sigil</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>BuildReferenceType</name></name><argument_list>(<argument><expr><name>ReferentType</name></expr></argument>, <argument><expr><name>WrittenAsLValue</name></expr></argument>,
<argument><expr><name>Sigil</name></expr></argument>, <argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getBaseEntity</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>QualType</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>RebuildMemberPointerType</name><argument_list>(<argument>QualType PointeeType</argument>,
<argument>QualType ClassType</argument>,
<argument>SourceLocation Sigil</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>BuildMemberPointerType</name></name><argument_list>(<argument><expr><name>PointeeType</name></expr></argument>, <argument><expr><name>ClassType</name></expr></argument>, <argument><expr><name>Sigil</name></expr></argument>,
<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getBaseEntity</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>RebuildObjCTypeParamType</name><argument_list>(
<argument>const ObjCTypeParamDecl *Decl</argument>,
<argument>SourceLocation ProtocolLAngleLoc</argument>,
<argument>ArrayRef&lt;ObjCProtocolDecl *&gt; Protocols</argument>,
<argument>ArrayRef&lt;SourceLocation&gt; ProtocolLocs</argument>,
<argument>SourceLocation ProtocolRAngleLoc</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>BuildObjCTypeParamType</name></name><argument_list>(<argument><expr><name>Decl</name></expr></argument>,
<argument><expr><name>ProtocolLAngleLoc</name></expr></argument>, <argument><expr><name>Protocols</name></expr></argument>,
<argument><expr><name>ProtocolLocs</name></expr></argument>, <argument><expr><name>ProtocolRAngleLoc</name></expr></argument>,
<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>RebuildObjCObjectType</name><argument_list>(
<argument>QualType BaseType</argument>,
<argument>SourceLocation Loc</argument>,
<argument>SourceLocation TypeArgsLAngleLoc</argument>,
<argument>ArrayRef&lt;TypeSourceInfo *&gt; TypeArgs</argument>,
<argument>SourceLocation TypeArgsRAngleLoc</argument>,
<argument>SourceLocation ProtocolLAngleLoc</argument>,
<argument>ArrayRef&lt;ObjCProtocolDecl *&gt; Protocols</argument>,
<argument>ArrayRef&lt;SourceLocation&gt; ProtocolLocs</argument>,
<argument>SourceLocation ProtocolRAngleLoc</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>BuildObjCObjectType</name></name><argument_list>(<argument><expr><name>BaseType</name></expr></argument>, <argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>TypeArgsLAngleLoc</name></expr></argument>,
<argument><expr><name>TypeArgs</name></expr></argument>, <argument><expr><name>TypeArgsRAngleLoc</name></expr></argument>,
<argument><expr><name>ProtocolLAngleLoc</name></expr></argument>, <argument><expr><name>Protocols</name></expr></argument>, <argument><expr><name>ProtocolLocs</name></expr></argument>,
<argument><expr><name>ProtocolRAngleLoc</name></expr></argument>,
<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>RebuildObjCObjectPointerType</name><argument_list>(
<argument>QualType PointeeType</argument>,
<argument>SourceLocation Star</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>getObjCObjectPointerType</name></name><argument_list>(<argument><expr><name>PointeeType</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>QualType</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>RebuildArrayType</name><argument_list>(<argument>QualType ElementType</argument>,
<argument>ArrayType::ArraySizeModifier SizeMod</argument>,
<argument>const llvm::APInt *Size</argument>,
<argument>Expr *SizeExpr</argument>,
<argument>unsigned IndexTypeQuals</argument>,
<argument>SourceRange BracketsRange</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><name>SizeExpr</name> <operator>||</operator> <operator>!</operator><name>Size</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>BuildArrayType</name></name><argument_list>(<argument><expr><name>ElementType</name></expr></argument>, <argument><expr><name>SizeMod</name></expr></argument>, <argument><expr><name>SizeExpr</name></expr></argument>,
<argument><expr><name>IndexTypeQuals</name></expr></argument>, <argument><expr><name>BracketsRange</name></expr></argument>,
<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getBaseEntity</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>QualType</name> <name><name>Types</name><index>[]</index></name> <operator>=</operator> <block>{
<expr><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>UnsignedCharTy</name></name></expr>, <expr><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>UnsignedShortTy</name></name></expr>,
<expr><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>UnsignedIntTy</name></name></expr>, <expr><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>UnsignedLongTy</name></name></expr>,
<expr><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>UnsignedLongLongTy</name></name></expr>, <expr><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>UnsignedInt128Ty</name></name></expr>
}</block></block></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name></type> <name>NumTypes</name> <init>= <expr><name>llvm</name><operator>::</operator><call><name>array_lengthof</name><argument_list>(<argument><expr><name>Types</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>QualType</name></type> <name>SizeType</name></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>I</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>I</name> <operator>!=</operator> <name>NumTypes</name></expr>;</condition> <incr><expr><operator>++</operator><name>I</name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>Size</name><operator>-&gt;</operator><name>getBitWidth</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>getIntWidth</name></name><argument_list>(<argument><expr><name><name>Types</name><index>[<expr><name>I</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>SizeType</name> <operator>=</operator> <name><name>Types</name><index>[<expr><name>I</name></expr>]</index></name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt></block_content></block></for>



<decl_stmt><decl><type><name>IntegerLiteral</name> <modifier>*</modifier></type><name>ArraySize</name>
<init>= <expr><name>IntegerLiteral</name><operator>::</operator><call><name>Create</name><argument_list>(<argument><expr><name><name>SemaRef</name><operator>.</operator><name>Context</name></name></expr></argument>, <argument><expr><operator>*</operator><name>Size</name></expr></argument>, <argument><expr><name>SizeType</name></expr></argument>,
<argument><expr><call><name><name>BracketsRange</name><operator>.</operator><name>getBegin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>BuildArrayType</name></name><argument_list>(<argument><expr><name>ElementType</name></expr></argument>, <argument><expr><name>SizeMod</name></expr></argument>, <argument><expr><name>ArraySize</name></expr></argument>,
<argument><expr><name>IndexTypeQuals</name></expr></argument>, <argument><expr><name>BracketsRange</name></expr></argument>,
<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getBaseEntity</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>RebuildConstantArrayType</name><argument_list>(<argument>QualType ElementType</argument>,
<argument>ArrayType::ArraySizeModifier SizeMod</argument>,
<argument>const llvm::APInt &amp;Size</argument>,
<argument>Expr *SizeExpr</argument>,
<argument>unsigned IndexTypeQuals</argument>,
<argument>SourceRange BracketsRange</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildArrayType</name><argument_list>(<argument><expr><name>ElementType</name></expr></argument>, <argument><expr><name>SizeMod</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Size</name></expr></argument>, <argument><expr><name>SizeExpr</name></expr></argument>,
<argument><expr><name>IndexTypeQuals</name></expr></argument>, <argument><expr><name>BracketsRange</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>QualType</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>RebuildIncompleteArrayType</name><argument_list>(<argument>QualType ElementType</argument>,
<argument>ArrayType::ArraySizeModifier SizeMod</argument>,
<argument>unsigned IndexTypeQuals</argument>,
<argument>SourceRange BracketsRange</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildArrayType</name><argument_list>(<argument><expr><name>ElementType</name></expr></argument>, <argument><expr><name>SizeMod</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><name>IndexTypeQuals</name></expr></argument>, <argument><expr><name>BracketsRange</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>QualType</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>RebuildVariableArrayType</name><argument_list>(<argument>QualType ElementType</argument>,
<argument>ArrayType::ArraySizeModifier SizeMod</argument>,
<argument>Expr *SizeExpr</argument>,
<argument>unsigned IndexTypeQuals</argument>,
<argument>SourceRange BracketsRange</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildArrayType</name><argument_list>(<argument><expr><name>ElementType</name></expr></argument>, <argument><expr><name>SizeMod</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><name>SizeExpr</name></expr></argument>,
<argument><expr><name>IndexTypeQuals</name></expr></argument>, <argument><expr><name>BracketsRange</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>QualType</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>RebuildDependentSizedArrayType</name><argument_list>(<argument>QualType ElementType</argument>,
<argument>ArrayType::ArraySizeModifier SizeMod</argument>,
<argument>Expr *SizeExpr</argument>,
<argument>unsigned IndexTypeQuals</argument>,
<argument>SourceRange BracketsRange</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>RebuildArrayType</name><argument_list>(<argument><expr><name>ElementType</name></expr></argument>, <argument><expr><name>SizeMod</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><name>SizeExpr</name></expr></argument>,
<argument><expr><name>IndexTypeQuals</name></expr></argument>, <argument><expr><name>BracketsRange</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>RebuildDependentAddressSpaceType</name><argument_list>(
<argument>QualType PointeeType</argument>, <argument>Expr *AddrSpaceExpr</argument>, <argument>SourceLocation AttributeLoc</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>BuildAddressSpaceAttr</name></name><argument_list>(<argument><expr><name>PointeeType</name></expr></argument>, <argument><expr><name>AddrSpaceExpr</name></expr></argument>,
<argument><expr><name>AttributeLoc</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>QualType</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>RebuildVectorType</name><argument_list>(<argument>QualType ElementType</argument>,
<argument>unsigned NumElements</argument>,
<argument>VectorType::VectorKind VecKind</argument>)</argument_list></macro> <block>{

<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>getVectorType</name></name><argument_list>(<argument><expr><name>ElementType</name></expr></argument>, <argument><expr><name>NumElements</name></expr></argument>, <argument><expr><name>VecKind</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>RebuildDependentVectorType</name><argument_list>(
<argument>QualType ElementType</argument>, <argument>Expr *SizeExpr</argument>, <argument>SourceLocation AttributeLoc</argument>,
<argument>VectorType::VectorKind VecKind</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>BuildVectorType</name></name><argument_list>(<argument><expr><name>ElementType</name></expr></argument>, <argument><expr><name>SizeExpr</name></expr></argument>, <argument><expr><name>AttributeLoc</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>RebuildExtVectorType</name><argument_list>(<argument>QualType ElementType</argument>,
<argument>unsigned NumElements</argument>,
<argument>SourceLocation AttributeLoc</argument>)</argument_list></macro> <block>{
<expr><name>llvm</name><operator>::</operator><name>APInt</name> <call><name>numElements</name><argument_list>(<argument><expr><call><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>getIntWidth</name></name><argument_list>(<argument><expr><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>IntTy</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>NumElements</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;
<expr><name>IntegerLiteral</name> <operator>*</operator><name>VectorSize</name>
<operator>=</operator> <name>IntegerLiteral</name><operator>::</operator><call><name>Create</name><argument_list>(<argument><expr><name><name>SemaRef</name><operator>.</operator><name>Context</name></name></expr></argument>, <argument><expr><name>numElements</name></expr></argument>, <argument><expr><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>IntTy</name></name></expr></argument>,
<argument><expr><name>AttributeLoc</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>BuildExtVectorType</name></name><argument_list>(<argument><expr><name>ElementType</name></expr></argument>, <argument><expr><name>VectorSize</name></expr></argument>, <argument><expr><name>AttributeLoc</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>QualType</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>RebuildDependentSizedExtVectorType</name><argument_list>(<argument>QualType ElementType</argument>,
<argument>Expr *SizeExpr</argument>,
<argument>SourceLocation AttributeLoc</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>BuildExtVectorType</name></name><argument_list>(<argument><expr><name>ElementType</name></expr></argument>, <argument><expr><name>SizeExpr</name></expr></argument>, <argument><expr><name>AttributeLoc</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>RebuildConstantMatrixType</name><argument_list>(
<argument>QualType ElementType</argument>, <argument>unsigned NumRows</argument>, <argument>unsigned NumColumns</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>getConstantMatrixType</name></name><argument_list>(<argument><expr><name>ElementType</name></expr></argument>, <argument><expr><name>NumRows</name></expr></argument>,
<argument><expr><name>NumColumns</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>RebuildDependentSizedMatrixType</name><argument_list>(
<argument>QualType ElementType</argument>, <argument>Expr *RowExpr</argument>, <argument>Expr *ColumnExpr</argument>,
<argument>SourceLocation AttributeLoc</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>BuildMatrixType</name></name><argument_list>(<argument><expr><name>ElementType</name></expr></argument>, <argument><expr><name>RowExpr</name></expr></argument>, <argument><expr><name>ColumnExpr</name></expr></argument>,
<argument><expr><name>AttributeLoc</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>RebuildFunctionProtoType</name><argument_list>(
<argument>QualType T</argument>,
<argument>MutableArrayRef&lt;QualType&gt; ParamTypes</argument>,
<argument>const FunctionProtoType::ExtProtoInfo &amp;EPI</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>BuildFunctionType</name></name><argument_list>(<argument><expr><name>T</name></expr></argument>, <argument><expr><name>ParamTypes</name></expr></argument>,
<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getBaseLocation</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getBaseEntity</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>EPI</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>RebuildFunctionNoProtoType</name><argument_list>(<argument>QualType T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>getFunctionNoProtoType</name></name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>RebuildUnresolvedUsingType</name><argument_list>(<argument>SourceLocation Loc</argument>,
<argument>Decl *D</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>D</name> <operator>&amp;&amp;</operator> <literal type="string">"no decl found"</literal></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>D</name><operator>-&gt;</operator><name>isInvalidDecl</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<name>TypeDecl</name> <operator>*</operator><name>Ty</name></block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>UPD</name> <operator>=</operator> <call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>UsingPackDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>



<if_stmt><if>if <condition>(<expr><call><name><name>UPD</name><operator>-&gt;</operator><name>expansions</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>empty</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>Diag</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>diag</name><operator>::</operator><name>err_using_pack_expansion_empty</name></expr></argument>)</argument_list></call>
<operator>&lt;&lt;</operator> <call><name><name>UPD</name><operator>-&gt;</operator><name>isCXXClassMember</name></name><argument_list>()</argument_list></call> <operator>&lt;&lt;</operator> <name>UPD</name></expr>;</expr_stmt>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>




<decl_stmt><decl><type><name>QualType</name></type> <name>FallbackT</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>QualType</name></type> <name>T</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>E</name> <operator>:</operator> <call><name><name>UPD</name><operator>-&gt;</operator><name>expansions</name></name><argument_list>()</argument_list></call></expr></init>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>QualType</name></type> <name>ThisT</name> <init>= <expr><call><name>RebuildUnresolvedUsingType</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>ThisT</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>ThisT</name><operator>-&gt;</operator><name>getAs</name></name><operator>&lt;</operator><name>UnresolvedUsingType</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>FallbackT</name> <operator>=</operator> <name>ThisT</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name><name>T</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>T</name> <operator>=</operator> <name>ThisT</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>Context</name><operator>.</operator><name>hasSameType</name></name><argument_list>(<argument><expr><name>ThisT</name></expr></argument>, <argument><expr><name>T</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"mismatched resolved types in using pack expansion"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></for>
<return>return <expr><ternary><condition><expr><call><name><name>T</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>FallbackT</name></expr> </then><else>: <expr><name>T</name></expr></else></ternary></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>auto</name> <operator>*</operator><name>Using</name> <operator>=</operator> <call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>UsingDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>Using</name><operator>-&gt;</operator><name>hasTypename</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"UnresolvedUsingTypenameDecl transformed to non-typename using"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>++</operator><call><name><name>Using</name><operator>-&gt;</operator><name>shadow_begin</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>Using</name><operator>-&gt;</operator><name>shadow_end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>Target</name> <init>= <expr><call><name><name>Using</name><operator>-&gt;</operator><name>shadow_begin</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getTargetDecl</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>SemaRef</name><operator>.</operator><name>DiagnoseUseOfDecl</name></name><argument_list>(<argument><expr><name>Target</name></expr></argument>, <argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>Ty</name> <operator>=</operator> <call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>TypeDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>UnresolvedUsingTypenameDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"UnresolvedUsingTypenameDecl transformed to non-using decl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Ty</name> <operator>=</operator> <call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>UnresolvedUsingTypenameDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>getTypeDeclType</name></name><argument_list>(<argument><expr><name>Ty</name></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>RebuildTypeOfExprType</name><argument_list>(<argument>Expr *E</argument>,
<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>BuildTypeofExprType</name></name><argument_list>(<argument><expr><name>E</name></expr></argument>, <argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>RebuildTypeOfType</name><argument_list>(<argument>QualType Underlying</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>getTypeOfType</name></name><argument_list>(<argument><expr><name>Underlying</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>RebuildDecltypeType</name><argument_list>(<argument>Expr *E</argument>,
<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>BuildDecltypeType</name></name><argument_list>(<argument><expr><name>E</name></expr></argument>, <argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>RebuildUnaryTransformType</name><argument_list>(<argument>QualType BaseType</argument>,
<argument>UnaryTransformType::UTTKind UKind</argument>,
<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>BuildUnaryTransformType</name></name><argument_list>(<argument><expr><name>BaseType</name></expr></argument>, <argument><expr><name>UKind</name></expr></argument>, <argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>RebuildTemplateSpecializationType</name><argument_list>(
<argument>TemplateName Template</argument>,
<argument>SourceLocation TemplateNameLoc</argument>,
<argument>TemplateArgumentListInfo &amp;TemplateArgs</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>CheckTemplateIdType</name></name><argument_list>(<argument><expr><name>Template</name></expr></argument>, <argument><expr><name>TemplateNameLoc</name></expr></argument>, <argument><expr><name>TemplateArgs</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>RebuildAtomicType</name><argument_list>(<argument>QualType ValueType</argument>,
<argument>SourceLocation KWLoc</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>BuildAtomicType</name></name><argument_list>(<argument><expr><name>ValueType</name></expr></argument>, <argument><expr><name>KWLoc</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>RebuildPipeType</name><argument_list>(<argument>QualType ValueType</argument>,
<argument>SourceLocation KWLoc</argument>,
<argument>bool isReadPipe</argument>)</argument_list></macro> <block>{
<return>return <expr><name>isReadPipe</name> <operator>?</operator> <call><name><name>SemaRef</name><operator>.</operator><name>BuildReadPipeType</name></name><argument_list>(<argument><expr><name>ValueType</name></expr></argument>, <argument><expr><name>KWLoc</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name><name>SemaRef</name><operator>.</operator><name>BuildWritePipeType</name></name><argument_list>(<argument><expr><name>ValueType</name></expr></argument>, <argument><expr><name>KWLoc</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>RebuildExtIntType</name><argument_list>(<argument>bool IsUnsigned</argument>,
<argument>unsigned NumBits</argument>,
<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><name>llvm</name><operator>::</operator><name>APInt</name> <call><name>NumBitsAP</name><argument_list>(<argument><expr><call><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>getIntWidth</name></name><argument_list>(<argument><expr><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>IntTy</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>NumBits</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;
<expr><name>IntegerLiteral</name> <operator>*</operator><name>Bits</name> <operator>=</operator> <name>IntegerLiteral</name><operator>::</operator><call><name>Create</name><argument_list>(<argument><expr><name><name>SemaRef</name><operator>.</operator><name>Context</name></name></expr></argument>, <argument><expr><name>NumBitsAP</name></expr></argument>,
<argument><expr><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>IntTy</name></name></expr></argument>, <argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>BuildExtIntType</name></name><argument_list>(<argument><expr><name>IsUnsigned</name></expr></argument>, <argument><expr><name>Bits</name></expr></argument>, <argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>QualType</name> <name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>RebuildDependentExtIntType</name><argument_list>(
<argument>bool IsUnsigned</argument>, <argument>Expr *NumBitsExpr</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>BuildExtIntType</name></name><argument_list>(<argument><expr><name>IsUnsigned</name></expr></argument>, <argument><expr><name>NumBitsExpr</name></expr></argument>, <argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>TemplateName</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>RebuildTemplateName</name><argument_list>(<argument>CXXScopeSpec &amp;SS</argument>,
<argument>bool TemplateKW</argument>,
<argument>TemplateDecl *Template</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>getQualifiedTemplateName</name></name><argument_list>(<argument><expr><call><name><name>SS</name><operator>.</operator><name>getScopeRep</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>TemplateKW</name></expr></argument>,
<argument><expr><name>Template</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>TemplateName</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>RebuildTemplateName</name><argument_list>(<argument>CXXScopeSpec &amp;SS</argument>,
<argument>SourceLocation TemplateKWLoc</argument>,
<argument>const IdentifierInfo &amp;Name</argument>,
<argument>SourceLocation NameLoc</argument>,
<argument>QualType ObjectType</argument>,
<argument>NamedDecl *FirstQualifierInScope</argument>,
<argument>bool AllowInjectedClassName</argument>)</argument_list></macro> <block>{
<expr><name>UnqualifiedId</name> <name>TemplateName</name></expr>;
<expr><call><name><name>TemplateName</name><operator>.</operator><name>setIdentifier</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>Name</name></expr></argument>, <argument><expr><name>NameLoc</name></expr></argument>)</argument_list></call></expr>;
<expr><name>Sema</name><operator>::</operator><name>TemplateTy</name> <name>Template</name></expr>;
<expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnTemplateName</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><name>TemplateKWLoc</name></expr></argument>,
<argument><expr><name>TemplateName</name></expr></argument>, <argument><expr><name>ParsedType</name><operator>::</operator><call><name>make</name><argument_list>(<argument><expr><name>ObjectType</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>false</name></expr></argument>, <argument><expr><name>Template</name></expr></argument>,
<argument><expr><name>AllowInjectedClassName</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>Template</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>TemplateName</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>RebuildTemplateName</name><argument_list>(<argument>CXXScopeSpec &amp;SS</argument>,
<argument>SourceLocation TemplateKWLoc</argument>,
<argument>OverloadedOperatorKind Operator</argument>,
<argument>SourceLocation NameLoc</argument>,
<argument>QualType ObjectType</argument>,
<argument>bool AllowInjectedClassName</argument>)</argument_list></macro> <block>{
<expr><name>UnqualifiedId</name> <name>Name</name></expr>;

<expr><name>SourceLocation</name> <name><name>SymbolLocations</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <block>{ <expr><name>NameLoc</name></expr>, <expr><name>NameLoc</name></expr>, <expr><name>NameLoc</name></expr> }</block></expr>;
<expr><call><name><name>Name</name><operator>.</operator><name>setOperatorFunctionId</name></name><argument_list>(<argument><expr><name>NameLoc</name></expr></argument>, <argument><expr><name>Operator</name></expr></argument>, <argument><expr><name>SymbolLocations</name></expr></argument>)</argument_list></call></expr>;
<expr><name>Sema</name><operator>::</operator><name>TemplateTy</name> <name>Template</name></expr>;
<expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnTemplateName</name><argument_list>(
<argument><expr><name>nullptr</name></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><name>TemplateKWLoc</name></expr></argument>, <argument><expr><name>Name</name></expr></argument>, <argument><expr><name>ParsedType</name><operator>::</operator><call><name>make</name><argument_list>(<argument><expr><name>ObjectType</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>false</name></expr></argument>, <argument><expr><name>Template</name></expr></argument>, <argument><expr><name>AllowInjectedClassName</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>Template</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>&gt;</argument_list></name>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>RebuildCXXOperatorCallExpr</name><argument_list>(<argument>OverloadedOperatorKind Op</argument>,
<argument>SourceLocation OpLoc</argument>,
<argument>Expr *OrigCallee</argument>,
<argument>Expr *First</argument>,
<argument>Expr *Second</argument>)</argument_list></macro> <block>{
<expr><name>Expr</name> <operator>*</operator><name>Callee</name> <operator>=</operator> <call><name><name>OrigCallee</name><operator>-&gt;</operator><name>IgnoreParenCasts</name></name><argument_list>()</argument_list></call></expr>;
<expr><name>bool</name> <name>isPostIncDec</name> <operator>=</operator> <name>Second</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>Op</name> <operator>==</operator> <name>OO_PlusPlus</name> <operator>||</operator> <name>Op</name> <operator>==</operator> <name>OO_MinusMinus</name><operator>)</operator></expr>;

<if_stmt><if>if <condition>(<expr><call><name><name>First</name><operator>-&gt;</operator><name>getObjectKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OK_ObjCProperty</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>BinaryOperatorKind</name></type> <name>Opc</name> <init>= <expr><name>BinaryOperator</name><operator>::</operator><call><name>getOverloadedOpcode</name><argument_list>(<argument><expr><name>Op</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>BinaryOperator</name><operator>::</operator><call><name>isAssignmentOp</name><argument_list>(<argument><expr><name>Opc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>checkPseudoObjectAssignment</name></name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>, <argument><expr><name>OpLoc</name></expr></argument>, <argument><expr><name>Opc</name></expr></argument>,
<argument><expr><name>First</name></expr></argument>, <argument><expr><name>Second</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>Result</name> <init>= <expr><call><name><name>SemaRef</name><operator>.</operator><name>CheckPlaceholderExpr</name></name><argument_list>(<argument><expr><name>First</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>First</name> <operator>=</operator> <call><name><name>Result</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></if></if_stmt>}</block></expr></expr_stmt>

<if_stmt><if>if <condition>(<expr><name>Second</name> <operator>&amp;&amp;</operator> <call><name><name>Second</name><operator>-&gt;</operator><name>getObjectKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>OK_ObjCProperty</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>Result</name> <init>= <expr><call><name><name>SemaRef</name><operator>.</operator><name>CheckPlaceholderExpr</name></name><argument_list>(<argument><expr><name>Second</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>Second</name> <operator>=</operator> <call><name><name>Result</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>Op</name> <operator>==</operator> <name>OO_Subscript</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>First</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isOverloadableType</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name><name>Second</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isOverloadableType</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>CreateBuiltinArraySubscriptExpr</name><argument_list>(
<argument><expr><name>First</name></expr></argument>, <argument><expr><call><name><name>Callee</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Second</name></expr></argument>, <argument><expr><name>OpLoc</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>Op</name> <operator>==</operator> <name>OO_Arrow</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>BuildOverloadedArrowExpr</name></name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>, <argument><expr><name>First</name></expr></argument>, <argument><expr><name>OpLoc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>Second</name> <operator>==</operator> <name>nullptr</name> <operator>||</operator> <name>isPostIncDec</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>First</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isOverloadableType</name><argument_list>()</argument_list></call> <operator>||</operator>
<operator>(</operator><name>Op</name> <operator>==</operator> <name>OO_Amp</name> <operator>&amp;&amp;</operator> <call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isQualifiedMemberAccess</name><argument_list>(<argument><expr><name>First</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>



<decl_stmt><decl><type><name>UnaryOperatorKind</name></type> <name>Opc</name>
<init>= <expr><name>UnaryOperator</name><operator>::</operator><call><name>getOverloadedOpcode</name><argument_list>(<argument><expr><name>Op</name></expr></argument>, <argument><expr><name>isPostIncDec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>CreateBuiltinUnaryOp</name><argument_list>(<argument><expr><name>OpLoc</name></expr></argument>, <argument><expr><name>Opc</name></expr></argument>, <argument><expr><name>First</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>First</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isOverloadableType</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name><name>Second</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isOverloadableType</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>


<decl_stmt><decl><type><name>BinaryOperatorKind</name></type> <name>Opc</name> <init>= <expr><name>BinaryOperator</name><operator>::</operator><call><name>getOverloadedOpcode</name><argument_list>(<argument><expr><name>Op</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>Result</name>
<init>= <expr><call><name><name>SemaRef</name><operator>.</operator><name>CreateBuiltinBinOp</name></name><argument_list>(<argument><expr><name>OpLoc</name></expr></argument>, <argument><expr><name>Opc</name></expr></argument>, <argument><expr><name>First</name></expr></argument>, <argument><expr><name>Second</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>Result</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>



<decl_stmt><decl><type><name><name>UnresolvedSet</name><argument_list type="generic">&lt;<argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name></type> <name>Functions</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>RequiresADL</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<decl><type><name>UnresolvedLookupExpr</name> <modifier>*</modifier></type><name>ULE</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>UnresolvedLookupExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Callee</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>Functions</name><operator>.</operator><name>append</name></name><argument_list>(<argument><expr><call><name><name>ULE</name><operator>-&gt;</operator><name>decls_begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>ULE</name><operator>-&gt;</operator><name>decls_end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>RequiresADL</name> <operator>=</operator> <call><name><name>ULE</name><operator>-&gt;</operator><name>requiresADL</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>



<decl_stmt><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>ND</name> <init>= <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>DeclRefExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Callee</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getDecl</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>CXXMethodDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>ND</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>Functions</name><operator>.</operator><name>addDecl</name></name><argument_list>(<argument><expr><name>ND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>RequiresADL</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name><name>Args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{ <expr><name>First</name></expr>, <expr><name>Second</name></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>NumArgs</name> <init>= <expr><literal type="number">1</literal> <operator>+</operator> <operator>(</operator><name>Second</name> <operator>!=</operator> <name>nullptr</name><operator>)</operator></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name>NumArgs</name> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator> <name>isPostIncDec</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>UnaryOperatorKind</name></type> <name>Opc</name>
<init>= <expr><name>UnaryOperator</name><operator>::</operator><call><name>getOverloadedOpcode</name><argument_list>(<argument><expr><name>Op</name></expr></argument>, <argument><expr><name>isPostIncDec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>CreateOverloadedUnaryOp</name></name><argument_list>(<argument><expr><name>OpLoc</name></expr></argument>, <argument><expr><name>Opc</name></expr></argument>, <argument><expr><name>Functions</name></expr></argument>, <argument><expr><name>First</name></expr></argument>,
<argument><expr><name>RequiresADL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>Op</name> <operator>==</operator> <name>OO_Subscript</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>LBrace</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>RBrace</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<decl><type><name>DeclRefExpr</name> <modifier>*</modifier></type><name>DRE</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>DeclRefExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Callee</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>DeclarationNameLoc</name></type> <name>NameLoc</name> <init>= <expr><call><name><name>DRE</name><operator>-&gt;</operator><name>getNameInfo</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>LBrace</name> <operator>=</operator> <call><name><name>NameLoc</name><operator>.</operator><name>getCXXOperatorNameBeginLoc</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>RBrace</name> <operator>=</operator> <call><name><name>NameLoc</name><operator>.</operator><name>getCXXOperatorNameEndLoc</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>LBrace</name> <operator>=</operator> <call><name><name>Callee</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>RBrace</name> <operator>=</operator> <name>OpLoc</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>CreateOverloadedArraySubscriptExpr</name></name><argument_list>(<argument><expr><name>LBrace</name></expr></argument>, <argument><expr><name>RBrace</name></expr></argument>,
<argument><expr><name>First</name></expr></argument>, <argument><expr><name>Second</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>


<decl_stmt><decl><type><name>BinaryOperatorKind</name></type> <name>Opc</name> <init>= <expr><name>BinaryOperator</name><operator>::</operator><call><name>getOverloadedOpcode</name><argument_list>(<argument><expr><name>Op</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>Result</name> <init>= <expr><call><name><name>SemaRef</name><operator>.</operator><name>CreateOverloadedBinOp</name></name><argument_list>(
<argument><expr><name>OpLoc</name></expr></argument>, <argument><expr><name>Opc</name></expr></argument>, <argument><expr><name>Functions</name></expr></argument>, <argument><expr><name><name>Args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>Args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>RequiresADL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Result</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>Result</name></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>ExprResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>RebuildCXXPseudoDestructorExpr</name><argument_list>(<argument>Expr *Base</argument>,
<argument>SourceLocation OperatorLoc</argument>,
<argument>bool isArrow</argument>,
<argument>CXXScopeSpec &amp;SS</argument>,
<argument>TypeSourceInfo *ScopeType</argument>,
<argument>SourceLocation CCLoc</argument>,
<argument>SourceLocation TildeLoc</argument>,
<argument>PseudoDestructorTypeStorage Destroyed</argument>)</argument_list></macro> <block>{
<expr><name>QualType</name> <name>BaseType</name> <operator>=</operator> <call><name><name>Base</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Base</name><operator>-&gt;</operator><name>isTypeDependent</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>Destroyed</name><operator>.</operator><name>getIdentifier</name></name><argument_list>()</argument_list></call> <operator>||</operator>
<operator>(</operator><operator>!</operator><name>isArrow</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>BaseType</name><operator>-&gt;</operator><name>getAs</name></name><operator>&lt;</operator><name>RecordType</name><operator>&gt;</operator><operator>(</operator><operator>)</operator><operator>)</operator> <operator>||</operator>
<operator>(</operator><name>isArrow</name> <operator>&amp;&amp;</operator> <name><name>BaseType</name><operator>-&gt;</operator><name>getAs</name></name><operator>&lt;</operator><name>PointerType</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>!</operator><name><name>BaseType</name><operator>-&gt;</operator><name>castAs</name></name><operator>&lt;</operator><name>PointerType</name><operator>&gt;</operator><operator>(</operator><operator>)</operator><operator>-&gt;</operator><call><name>getPointeeType</name><argument_list>()</argument_list></call>
<operator>-&gt;</operator><name>template</name> <call><name><name>getAs</name><argument_list type="generic">&lt;<argument><expr><name>RecordType</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition><block>{<block_content>

<return>return <expr><call><name><name>SemaRef</name><operator>.</operator><name>BuildPseudoDestructorExpr</name></name><argument_list>(
<argument><expr><name>Base</name></expr></argument>, <argument><expr><name>OperatorLoc</name></expr></argument>, <argument><expr><ternary><condition><expr><name>isArrow</name></expr> ?</condition><then> <expr><name>tok</name><operator>::</operator><name>arrow</name></expr> </then><else>: <expr><name>tok</name><operator>::</operator><name>period</name></expr></else></ternary></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><name>ScopeType</name></expr></argument>,
<argument><expr><name>CCLoc</name></expr></argument>, <argument><expr><name>TildeLoc</name></expr></argument>, <argument><expr><name>Destroyed</name></expr></argument>)</argument_list></call></expr>;</return>
<expr_stmt/></block_content></block></if></if_stmt>}</block>

<name>TypeSourceInfo</name> <operator>*</operator><name>DestroyedType</name> <operator>=</operator> <call><name><name>Destroyed</name><operator>.</operator><name>getTypeSourceInfo</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>DeclarationName</name></type> <name>Name</name><argument_list>(<argument><expr><call><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>DeclarationNames</name><operator>.</operator><name>getCXXDestructorName</name></name><argument_list>(
<argument><expr><call><name><name>SemaRef</name><operator>.</operator><name>Context</name><operator>.</operator><name>getCanonicalType</name></name><argument_list>(<argument><expr><call><name><name>DestroyedType</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DeclarationNameInfo</name></type> <name>NameInfo</name><argument_list>(<argument><expr><name>Name</name></expr></argument>, <argument><expr><call><name><name>Destroyed</name><operator>.</operator><name>getLocation</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>NameInfo</name><operator>.</operator><name>setNamedTypeInfo</name></name><argument_list>(<argument><expr><name>DestroyedType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name>ScopeType</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>ScopeType</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name><name>getAs</name><argument_list type="generic">&lt;<argument><expr><name>TagType</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>Diag</name><argument_list>(<argument><expr><call><name><name>ScopeType</name><operator>-&gt;</operator><name>getTypeLoc</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getBeginLoc</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>diag</name><operator>::</operator><name>err_expected_class_or_namespace</name></expr></argument>)</argument_list></call>
<operator>&lt;&lt;</operator> <call><name><name>ScopeType</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call> <operator>&lt;&lt;</operator> <call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getLangOpts</name><argument_list>()</argument_list></call><operator>.</operator><name>CPlusPlus</name></expr>;</expr_stmt>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name><name>SS</name><operator>.</operator><name>Extend</name></name><argument_list>(<argument><expr><name><name>SemaRef</name><operator>.</operator><name>Context</name></name></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>ScopeType</name><operator>-&gt;</operator><name>getTypeLoc</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>CCLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>SourceLocation</name></type> <name>TemplateKWLoc</name></decl>;</decl_stmt>
<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>BuildMemberReferenceExpr</name><argument_list>(<argument><expr><name>Base</name></expr></argument>, <argument><expr><name>BaseType</name></expr></argument>,
<argument><expr><name>OperatorLoc</name></expr></argument>, <argument><expr><name>isArrow</name></expr></argument>,
<argument><expr><name>SS</name></expr></argument>, <argument><expr><name>TemplateKWLoc</name></expr></argument>,
<argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><name>NameInfo</name></expr></argument>,
<argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>Derived</name><operator>&gt;</operator>
<name>StmtResult</name>
<name><name>TreeTransform</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>TransformCapturedStmt</name><argument_list>(<argument>CapturedStmt *S</argument>)</argument_list></macro> <block>{
<expr><name>SourceLocation</name> <name>Loc</name> <operator>=</operator> <call><name><name>S</name><operator>-&gt;</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr>;
<expr><name>CapturedDecl</name> <operator>*</operator><name>CD</name> <operator>=</operator> <call><name><name>S</name><operator>-&gt;</operator><name>getCapturedDecl</name></name><argument_list>()</argument_list></call></expr>;
<expr><name>unsigned</name> <name>NumParams</name> <operator>=</operator> <call><name><name>CD</name><operator>-&gt;</operator><name>getNumParams</name></name><argument_list>()</argument_list></call></expr>;
<expr><name>unsigned</name> <name>ContextParamPos</name> <operator>=</operator> <call><name><name>CD</name><operator>-&gt;</operator><name>getContextParamPosition</name></name><argument_list>()</argument_list></call></expr>;
<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Sema</name><operator>::</operator><name>CapturedParamNameType</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>Params</name></expr>;
<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>I</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>I</name> <operator>&lt;</operator> <name>NumParams</name></expr>;</condition> <incr><expr><operator>++</operator><name>I</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>I</name> <operator>!=</operator> <name>ContextParamPos</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>Params</name><operator>.</operator><name>push_back</name></name><argument_list>(
<argument><expr><name>std</name><operator>::</operator><call><name>make_pair</name><argument_list>(
<argument><expr><call><name><name>CD</name><operator>-&gt;</operator><name>getParam</name></name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getName</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformType</name><argument_list>(<argument><expr><call><name><name>CD</name><operator>-&gt;</operator><name>getParam</name></name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></if></if_stmt></block_content></block></for>}</block></expr></expr_stmt> <if_stmt><else>else <block>{<block_content>
<expr_stmt><expr><call><name><name>Params</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name>make_pair</name><argument_list>(<argument><expr><call><name>StringRef</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>QualType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
}
getSema<expr_stmt><expr><operator>(</operator><operator>)</operator><operator>.</operator><call><name>ActOnCapturedRegionStart</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>,
<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getCapturedRegionKind</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>StmtResult</name></type> <name>Body</name></decl>;</decl_stmt>
<block>{<block_content>
<expr_stmt><expr><name>Sema</name><operator>::</operator><name>CompoundScopeRAII</name> <call><name>CompoundScope</name><argument_list>(<argument><expr><call><name>getSema</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Body</name> <operator>=</operator> <call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>TransformStmt</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getCapturedStmt</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<if_stmt><if>if <condition>(<expr><call><name><name>Body</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnCapturedRegionError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>getSema</name><argument_list>()</argument_list></call><operator>.</operator><call><name>ActOnCapturedRegionEnd</name><argument_list>(<argument><expr><call><name><name>Body</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
