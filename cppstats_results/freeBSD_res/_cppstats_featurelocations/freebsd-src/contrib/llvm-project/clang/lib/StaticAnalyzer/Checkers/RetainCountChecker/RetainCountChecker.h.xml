<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.h">












<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_LIB_STATICANALYZER_CHECKERS_RETAINCOUNTCHECKER_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_LIB_STATICANALYZER_CHECKERS_RETAINCOUNTCHECKER_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/StaticAnalyzer/Checkers/BuiltinCheckerRegistration.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"RetainCountDiagnostics.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Attr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclCXX.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclObjC.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ParentMap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Analysis/DomainSpecific/CocoaConventions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Analysis/PathDiagnostic.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Analysis/RetainSummaryManager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LangOptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/SourceManager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Analysis/SelectorExtras.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/StaticAnalyzer/Core/BugReporter/BugType.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/StaticAnalyzer/Core/Checker.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/StaticAnalyzer/Core/CheckerManager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/StaticAnalyzer/Core/PathSensitive/ProgramStateTrait.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/StaticAnalyzer/Core/PathSensitive/SymbolManager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/DenseMap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/FoldingSet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/ImmutableList.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/ImmutableMap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/STLExtras.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/SmallString.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/StringExtras.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstdarg&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utility&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>
<decl_stmt><decl><type><name>namespace</name></type> <name>ento</name> <block>{<block_content>
<decl_stmt><decl><type><name>namespace</name></type> <name>retaincountchecker</name> <block>{<block_content>


<decl_stmt><decl><type><name>class</name></type> <name>RefVal</name> <block>{<block_content>
<label><name>public</name>:</label>
<enum>enum <name>Kind</name> <block>{
<decl><name>Owned</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>NotOwned</name></decl>,
<decl><name>Released</name></decl>,
<decl><name>ReturnedOwned</name></decl>,
<decl><name>ReturnedNotOwned</name></decl>,
<decl><name>ERROR_START</name></decl>,
<decl><name>ErrorDeallocNotOwned</name></decl>,
<decl><name>ErrorUseAfterRelease</name></decl>,
<decl><name>ErrorReleaseNotOwned</name></decl>,
<decl><name>ERROR_LEAK_START</name></decl>,
<decl><name>ErrorLeak</name></decl>,
<decl><name>ErrorLeakReturned</name></decl>,

<decl><name>ErrorOverAutorelease</name></decl>,
<decl><name>ErrorReturnedNotOwned</name></decl>
}</block>;</enum>





<decl_stmt><decl><type><name><name>enum</name> <name>class</name></name></type> <name>IvarAccessHistory</name> <block>{<block_content>
<expr_stmt><expr><name>None</name></expr><operator>,</operator>
<expr><name>AccessedDirectly</name></expr><operator>,</operator>
<expr><name>ReleasedAfterDirectAccess</name></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<label><name>private</name>:</label>

<decl_stmt><decl><type><name>unsigned</name></type> <name>Cnt</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>ACnt</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>T</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>unsigned</name></type> <name>RawKind</name> <range>: <expr><literal type="number">5</literal></expr></range></decl>;</decl_stmt>




<decl_stmt><decl><type><name>unsigned</name></type> <name>RawObjectKind</name> <range>: <expr><literal type="number">3</literal></expr></range></decl>;</decl_stmt>










<decl_stmt><decl><type><name>unsigned</name></type> <name>RawIvarAccessHistory</name> <range>: <expr><literal type="number">2</literal></expr></range></decl>;</decl_stmt>

<macro><name>RefVal</name><argument_list>(<argument>Kind k</argument>, <argument>ObjKind o</argument>, <argument>unsigned cnt</argument>, <argument>unsigned acnt</argument>, <argument>QualType t</argument>,
<argument>IvarAccessHistory IvarAccess</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>Cnt</name><argument_list>(<argument><expr><name>cnt</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>ACnt</name><argument_list>(<argument><expr><name>acnt</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>T</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>RawKind</name><argument_list>(<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>RawObjectKind</name><argument_list>(<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>RawIvarAccessHistory</name><argument_list>(<argument>static_cast&lt;unsigned&gt;(IvarAccess)</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>k</name> <operator>&amp;&amp;</operator> <literal type="string">"not enough bits for the kind"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getObjKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>o</name> <operator>&amp;&amp;</operator> <literal type="string">"not enough bits for the object kind"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getIvarAccessHistory</name><argument_list>()</argument_list></call> <operator>==</operator> <name>IvarAccess</name> <operator>&amp;&amp;</operator> <literal type="string">"not enough bits"</literal></expr></argument>)</argument_list></call></expr>;
}</block>

<name>public</name><operator>:</operator>
<name>Kind</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>Kind</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>RawKind</name></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>ObjKind</name> <macro><name>getObjKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>ObjKind</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>RawObjectKind</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>unsigned</name> <macro><name>getCount</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Cnt</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getAutoreleaseCount</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ACnt</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getCombinedCounts</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Cnt</name> <operator>+</operator> <name>ACnt</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>clearCounts</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>Cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>ACnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>setCount</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>Cnt</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>setAutoreleaseCount</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>ACnt</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name>QualType</name> <macro><name>getType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>T</name></expr>;</return> }</block></expr></expr_stmt>






<expr_stmt><expr><name>IvarAccessHistory</name> <macro><name>getIvarAccessHistory</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>IvarAccessHistory</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>RawIvarAccessHistory</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isOwned</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>Owned</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isNotOwned</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>NotOwned</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isReturnedOwned</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>ReturnedOwned</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isReturnedNotOwned</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>ReturnedNotOwned</name></expr>;</return>
}</block></expr></expr_stmt>





<function><type><specifier>static</specifier> <name>RefVal</name></type> <name>makeOwned</name><parameter_list>(<parameter><decl><type><name>ObjKind</name></type> <name>o</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>t</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>RefVal</name><argument_list>(<argument><expr><name>Owned</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>IvarAccessHistory</name><operator>::</operator><name>None</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>RefVal</name></type> <name>makeNotOwned</name><parameter_list>(<parameter><decl><type><name>ObjKind</name></type> <name>o</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>t</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>RefVal</name><argument_list>(<argument><expr><name>NotOwned</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>IvarAccessHistory</name><operator>::</operator><name>None</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><name>RefVal</name> <name>operator</name><operator>-</operator><operator>(</operator><name>size_t</name> <name>i</name><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><call><name>RefVal</name><argument_list>(<argument><expr><call><name>getKind</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getObjKind</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getCount</name><argument_list>()</argument_list></call> <operator>-</operator> <name>i</name></expr></argument>,
<argument><expr><call><name>getAutoreleaseCount</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getType</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getIvarAccessHistory</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>RefVal</name> <name>operator</name><operator>+</operator><operator>(</operator><name>size_t</name> <name>i</name><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><call><name>RefVal</name><argument_list>(<argument><expr><call><name>getKind</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getObjKind</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getCount</name><argument_list>()</argument_list></call> <operator>+</operator> <name>i</name></expr></argument>,
<argument><expr><call><name>getAutoreleaseCount</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getType</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getIvarAccessHistory</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<decl_stmt><decl><type><name>RefVal</name></type> <name>operator</name><modifier>^</modifier><argument_list>(<argument><expr><name>Kind</name> <name>k</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>RefVal</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><call><name>getObjKind</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getCount</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getAutoreleaseCount</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getType</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getIvarAccessHistory</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name>RefVal</name> <macro><name>autorelease</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>RefVal</name><argument_list>(<argument><expr><call><name>getKind</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getObjKind</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getCount</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getAutoreleaseCount</name><argument_list>()</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument>,
<argument><expr><call><name>getType</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getIvarAccessHistory</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>RefVal</name> <macro><name>withIvarAccess</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getIvarAccessHistory</name><argument_list>()</argument_list></call> <operator>==</operator> <name>IvarAccessHistory</name><operator>::</operator><name>None</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>RefVal</name><argument_list>(<argument><expr><call><name>getKind</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getObjKind</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getCount</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getAutoreleaseCount</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getType</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>IvarAccessHistory</name><operator>::</operator><name>AccessedDirectly</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>RefVal</name> <macro><name>releaseViaIvar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getIvarAccessHistory</name><argument_list>()</argument_list></call> <operator>==</operator> <name>IvarAccessHistory</name><operator>::</operator><name>AccessedDirectly</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>RefVal</name><argument_list>(<argument><expr><call><name>getKind</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getObjKind</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getCount</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getAutoreleaseCount</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getType</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>IvarAccessHistory</name><operator>::</operator><name>ReleasedAfterDirectAccess</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>hasSameState</name><argument_list>(<argument><expr><specifier>const</specifier> <name>RefVal</name> <operator>&amp;</operator><name>X</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>getKind</name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>X</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>Cnt</name> <operator>==</operator> <name><name>X</name><operator>.</operator><name>Cnt</name></name> <operator>&amp;&amp;</operator> <name>ACnt</name> <operator>==</operator> <name><name>X</name><operator>.</operator><name>ACnt</name></name> <operator>&amp;&amp;</operator>
<call><name>getIvarAccessHistory</name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>X</name><operator>.</operator><name>getIvarAccessHistory</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name>bool</name> <name>operator</name><operator>==</operator><operator>(</operator><specifier>const</specifier> <name>RefVal</name><operator>&amp;</operator> <name>X</name><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><name>T</name> <operator>==</operator> <name><name>X</name><operator>.</operator><name>T</name></name> <operator>&amp;&amp;</operator> <call><name>hasSameState</name><argument_list>(<argument><expr><name>X</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>getObjKind</name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>X</name><operator>.</operator><name>getObjKind</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>Profile</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>FoldingSetNodeID</name><operator>&amp;</operator> <name>ID</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><call><name><name>ID</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ID</name><operator>.</operator><name>AddInteger</name></name><argument_list>(<argument><expr><name>RawKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ID</name><operator>.</operator><name>AddInteger</name></name><argument_list>(<argument><expr><name>Cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ID</name><operator>.</operator><name>AddInteger</name></name><argument_list>(<argument><expr><name>ACnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ID</name><operator>.</operator><name>AddInteger</name></name><argument_list>(<argument><expr><name>RawObjectKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ID</name><operator>.</operator><name>AddInteger</name></name><argument_list>(<argument><expr><name>RawIvarAccessHistory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>print</name><argument_list>(<argument><expr><name>raw_ostream</name> <operator>&amp;</operator><name>Out</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>RetainCountChecker</name>
<range>: <expr><name>public</name> <name><name>Checker</name><argument_list type="generic">&lt; <argument><expr><name>check</name><operator>::</operator><name>Bind</name></expr></argument>,
<argument><expr><name>check</name><operator>::</operator><name>DeadSymbols</name></expr></argument>,
<argument><expr><name>check</name><operator>::</operator><name>BeginFunction</name></expr></argument>,
<argument><expr><name>check</name><operator>::</operator><name>EndFunction</name></expr></argument>,
<argument><expr><name>check</name><operator>::</operator><name><name>PostStmt</name><argument_list type="generic">&lt;<argument><expr><name>BlockExpr</name></expr></argument>&gt;</argument_list></name></expr></argument>,
<argument><expr><name>check</name><operator>::</operator><name><name>PostStmt</name><argument_list type="generic">&lt;<argument><expr><name>CastExpr</name></expr></argument>&gt;</argument_list></name></expr></argument>,
<argument><expr><name>check</name><operator>::</operator><name><name>PostStmt</name><argument_list type="generic">&lt;<argument><expr><name>ObjCArrayLiteral</name></expr></argument>&gt;</argument_list></name></expr></argument>,
<argument><expr><name>check</name><operator>::</operator><name><name>PostStmt</name><argument_list type="generic">&lt;<argument><expr><name>ObjCDictionaryLiteral</name></expr></argument>&gt;</argument_list></name></expr></argument>,
<argument><expr><name>check</name><operator>::</operator><name><name>PostStmt</name><argument_list type="generic">&lt;<argument><expr><name>ObjCBoxedExpr</name></expr></argument>&gt;</argument_list></name></expr></argument>,
<argument><expr><name>check</name><operator>::</operator><name><name>PostStmt</name><argument_list type="generic">&lt;<argument><expr><name>ObjCIvarRefExpr</name></expr></argument>&gt;</argument_list></name></expr></argument>,
<argument><expr><name>check</name><operator>::</operator><name>PostCall</name></expr></argument>,
<argument><expr><name>check</name><operator>::</operator><name>RegionChanges</name></expr></argument>,
<argument><expr><name>eval</name><operator>::</operator><name>Assume</name></expr></argument>,
<argument><expr><name>eval</name><operator>::</operator><name>Call</name></expr></argument> &gt;</argument_list></name> <block>{

<expr><name>public</name><operator>:</operator>
<name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>RefCountBug</name></expr></argument>&gt;</argument_list></name> <name>UseAfterRelease</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>RefCountBug</name></expr></argument>&gt;</argument_list></name> <name>ReleaseNotOwned</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>RefCountBug</name></expr></argument>&gt;</argument_list></name> <name>DeallocNotOwned</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>RefCountBug</name></expr></argument>&gt;</argument_list></name> <name>FreeNotOwned</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>RefCountBug</name></expr></argument>&gt;</argument_list></name> <name>OverAutorelease</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>RefCountBug</name></expr></argument>&gt;</argument_list></name> <name>ReturnNotOwnedForOwned</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>RefCountBug</name></expr></argument>&gt;</argument_list></name> <name>LeakWithinFunction</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>RefCountBug</name></expr></argument>&gt;</argument_list></name> <name>LeakAtReturn</name></expr>;

<expr><name>mutable</name> <name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>RetainSummaryManager</name></expr></argument>&gt;</argument_list></name> <name>Summaries</name></expr>;

<expr><specifier>static</specifier> <name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CheckerProgramPointTag</name></expr></argument>&gt;</argument_list></name> <name>DeallocSentTag</name></expr>;
<expr><specifier>static</specifier> <name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CheckerProgramPointTag</name></expr></argument>&gt;</argument_list></name> <name>CastFailTag</name></expr>;


<expr><name>bool</name> <name>TrackObjCAndCFObjects</name> <operator>=</operator> <name>false</name></expr>;


<expr><name>bool</name> <name>TrackOSObjects</name> <operator>=</operator> <name>false</name></expr>;


<expr><name>bool</name> <name>TrackNSCFStartParam</name> <operator>=</operator> <name>false</name></expr>;

<macro><name>RetainCountChecker</name><argument_list>()</argument_list></macro> <expr><block>{}</block></expr>;

<expr><name>RetainSummaryManager</name> <operator>&amp;</operator><macro><name>getSummaryManager</name><argument_list>(<argument>ASTContext &amp;Ctx</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Summaries</name></expr>)</condition><block type="pseudo"><block_content>
<macro><name>Summaries</name></macro><expr_stmt><expr><operator>.</operator><macro><name>reset</name><argument_list>(
<argument>new RetainSummaryManager(Ctx, TrackObjCAndCFObjects, TrackOSObjects)</argument>)</argument_list></macro></expr>;</expr_stmt></block_content></block></if></if_stmt></block></expr>
<return>return <expr><operator>*</operator><name>Summaries</name></expr>;</return>
}</block></expr></range></decl></decl_stmt>

<decl_stmt><decl><type><name>RetainSummaryManager</name> <modifier>&amp;</modifier></type><name>getSummaryManager</name><argument_list>(<argument><expr><name>CheckerContext</name> <operator>&amp;</operator><name>C</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>getSummaryManager</name><argument_list>(<argument><expr><call><name><name>C</name><operator>.</operator><name>getASTContext</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>printState</name><argument_list>(<argument><expr><name>raw_ostream</name> <operator>&amp;</operator><name>Out</name></expr></argument>, <argument><expr><name>ProgramStateRef</name> <name>State</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>NL</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>Sep</name></expr></argument>)</argument_list> const <name>override</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>checkBind</name><argument_list>(<argument><expr><name>SVal</name> <name>loc</name></expr></argument>, <argument><expr><name>SVal</name> <name>val</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>S</name></expr></argument>, <argument><expr><name>CheckerContext</name> <operator>&amp;</operator><name>C</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>checkPostStmt</name><argument_list>(<argument><expr><specifier>const</specifier> <name>BlockExpr</name> <operator>*</operator><name>BE</name></expr></argument>, <argument><expr><name>CheckerContext</name> <operator>&amp;</operator><name>C</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>checkPostStmt</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CastExpr</name> <operator>*</operator><name>CE</name></expr></argument>, <argument><expr><name>CheckerContext</name> <operator>&amp;</operator><name>C</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>checkPostStmt</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ObjCArrayLiteral</name> <operator>*</operator><name>AL</name></expr></argument>, <argument><expr><name>CheckerContext</name> <operator>&amp;</operator><name>C</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>checkPostStmt</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ObjCDictionaryLiteral</name> <operator>*</operator><name>DL</name></expr></argument>, <argument><expr><name>CheckerContext</name> <operator>&amp;</operator><name>C</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>checkPostStmt</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ObjCBoxedExpr</name> <operator>*</operator><name>BE</name></expr></argument>, <argument><expr><name>CheckerContext</name> <operator>&amp;</operator><name>C</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>checkPostStmt</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ObjCIvarRefExpr</name> <operator>*</operator><name>IRE</name></expr></argument>, <argument><expr><name>CheckerContext</name> <operator>&amp;</operator><name>C</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>checkPostCall</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CallEvent</name> <operator>&amp;</operator><name>Call</name></expr></argument>, <argument><expr><name>CheckerContext</name> <operator>&amp;</operator><name>C</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>checkSummary</name><argument_list>(<argument><expr><specifier>const</specifier> <name>RetainSummary</name> <operator>&amp;</operator><name>Summ</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>CallEvent</name> <operator>&amp;</operator><name>Call</name></expr></argument>,
<argument><expr><name>CheckerContext</name> <operator>&amp;</operator><name>C</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>processSummaryOfInlined</name><argument_list>(<argument><expr><specifier>const</specifier> <name>RetainSummary</name> <operator>&amp;</operator><name>Summ</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>CallEvent</name> <operator>&amp;</operator><name>Call</name></expr></argument>,
<argument><expr><name>CheckerContext</name> <operator>&amp;</operator><name>C</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>evalCall</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CallEvent</name> <operator>&amp;</operator><name>Call</name></expr></argument>, <argument><expr><name>CheckerContext</name> <operator>&amp;</operator><name>C</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>ProgramStateRef</name></type> <name>evalAssume</name><argument_list>(<argument><expr><name>ProgramStateRef</name> <name>state</name></expr></argument>, <argument><expr><name>SVal</name> <name>Cond</name></expr></argument>,
<argument><expr><name>bool</name> <name>Assumption</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>ProgramStateRef</name></type>
<name>checkRegionChanges</name><argument_list>(<argument><expr><name>ProgramStateRef</name> <name>state</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>InvalidatedSymbols</name> <operator>*</operator><name>invalidated</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>MemRegion</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>ExplicitRegions</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>MemRegion</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Regions</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>LocationContext</name><operator>*</operator> <name>LCtx</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>CallEvent</name> <operator>*</operator><name>Call</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>ExplodedNode</name><modifier>*</modifier></type> <name>checkReturnWithRetEffect</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ReturnStmt</name> <operator>*</operator><name>S</name></expr></argument>, <argument><expr><name>CheckerContext</name> <operator>&amp;</operator><name>C</name></expr></argument>,
<argument><expr><name>ExplodedNode</name> <operator>*</operator><name>Pred</name></expr></argument>, <argument><expr><name>RetEffect</name> <name>RE</name></expr></argument>, <argument><expr><name>RefVal</name> <name>X</name></expr></argument>,
<argument><expr><name>SymbolRef</name> <name>Sym</name></expr></argument>, <argument><expr><name>ProgramStateRef</name> <name>state</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>checkDeadSymbols</name><argument_list>(<argument><expr><name>SymbolReaper</name> <operator>&amp;</operator><name>SymReaper</name></expr></argument>, <argument><expr><name>CheckerContext</name> <operator>&amp;</operator><name>C</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>checkBeginFunction</name><argument_list>(<argument><expr><name>CheckerContext</name> <operator>&amp;</operator><name>C</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>checkEndFunction</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ReturnStmt</name> <operator>*</operator><name>RS</name></expr></argument>, <argument><expr><name>CheckerContext</name> <operator>&amp;</operator><name>C</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>ProgramStateRef</name></type> <name>updateSymbol</name><argument_list>(<argument><expr><name>ProgramStateRef</name> <name>state</name></expr></argument>, <argument><expr><name>SymbolRef</name> <name>sym</name></expr></argument>,
<argument><expr><name>RefVal</name> <name>V</name></expr></argument>, <argument><expr><name>ArgEffect</name> <name>E</name></expr></argument>, <argument><expr><name>RefVal</name><operator>::</operator><name>Kind</name> <operator>&amp;</operator><name>hasErr</name></expr></argument>,
<argument><expr><name>CheckerContext</name> <operator>&amp;</operator><name>C</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RefCountBug</name> <modifier>&amp;</modifier></type><name>errorKindToBugKind</name><argument_list>(<argument><expr><name>RefVal</name><operator>::</operator><name>Kind</name> <name>ErrorKind</name></expr></argument>,
<argument><expr><name>SymbolRef</name> <name>Sym</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>processNonLeakError</name><argument_list>(<argument><expr><name>ProgramStateRef</name> <name>St</name></expr></argument>, <argument><expr><name>SourceRange</name> <name>ErrorRange</name></expr></argument>,
<argument><expr><name>RefVal</name><operator>::</operator><name>Kind</name> <name>ErrorKind</name></expr></argument>, <argument><expr><name>SymbolRef</name> <name>Sym</name></expr></argument>,
<argument><expr><name>CheckerContext</name> <operator>&amp;</operator><name>C</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>processObjCLiterals</name><argument_list>(<argument><expr><name>CheckerContext</name> <operator>&amp;</operator><name>C</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>Ex</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>ProgramStateRef</name></type> <name>handleSymbolDeath</name><argument_list>(<argument><expr><name>ProgramStateRef</name> <name>state</name></expr></argument>,
<argument><expr><name>SymbolRef</name> <name>sid</name></expr></argument>, <argument><expr><name>RefVal</name> <name>V</name></expr></argument>,
<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>SymbolRef</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Leaked</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>ProgramStateRef</name></type>
<name>handleAutoreleaseCounts</name><argument_list>(<argument><expr><name>ProgramStateRef</name> <name>state</name></expr></argument>, <argument><expr><name>ExplodedNode</name> <operator>*</operator><name>Pred</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>ProgramPointTag</name> <operator>*</operator><name>Tag</name></expr></argument>, <argument><expr><name>CheckerContext</name> <operator>&amp;</operator><name>Ctx</name></expr></argument>,
<argument><expr><name>SymbolRef</name> <name>Sym</name></expr></argument>,
<argument><expr><name>RefVal</name> <name>V</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>ReturnStmt</name> <operator>*</operator><name>S</name><operator>=</operator><name>nullptr</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>ExplodedNode</name> <modifier>*</modifier></type><name>processLeaks</name><argument_list>(<argument><expr><name>ProgramStateRef</name> <name>state</name></expr></argument>,
<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>SymbolRef</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Leaked</name></expr></argument>,
<argument><expr><name>CheckerContext</name> <operator>&amp;</operator><name>Ctx</name></expr></argument>,
<argument><expr><name>ExplodedNode</name> <operator>*</operator><name>Pred</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>CheckerProgramPointTag</name> <modifier>&amp;</modifier></type><name>getDeallocSentTag</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><operator>*</operator><name>DeallocSentTag</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>CheckerProgramPointTag</name> <modifier>&amp;</modifier></type><name>getCastFailTag</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><operator>*</operator><name>CastFailTag</name></expr>;</return> </block_content>}</block></function>

<label><name>private</name>:</label>



<decl_stmt><decl><type><name>ExplodedNode</name> <modifier>*</modifier></type> <name>processReturn</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ReturnStmt</name> <operator>*</operator><name>S</name></expr></argument>, <argument><expr><name>CheckerContext</name> <operator>&amp;</operator><name>C</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>





<function_decl><type><specifier>const</specifier> <name>RefVal</name> <modifier>*</modifier></type><name>getRefBinding</name><parameter_list>(<parameter><decl><type><name>ProgramStateRef</name></type> <name>State</name></decl></parameter>, <parameter><decl><type><name>SymbolRef</name></type> <name>Sym</name></decl></parameter>)</parameter_list>;</function_decl>



<function><type><specifier>inline</specifier> <name>bool</name></type> <name>isSynthesizedAccessor</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>StackFrameContext</name> <modifier>*</modifier></type><name>SFC</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>auto</name></type> <name>Method</name> <init>= <expr><call><name><name>dyn_cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>ObjCMethodDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>SFC</name><operator>-&gt;</operator><name>getDecl</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Method</name> <operator>||</operator> <operator>!</operator><call><name><name>Method</name><operator>-&gt;</operator><name>isPropertyAccessor</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name><name>SFC</name><operator>-&gt;</operator><name>getAnalysisDeclContext</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isBodyAutosynthesized</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

</block_content>}</block></decl></decl_stmt>
</block_content>}</block></decl></decl_stmt>
}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
