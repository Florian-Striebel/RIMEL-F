<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h">

















<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_LIB_ASTMATCHERS_DYNAMIC_MARSHALLERS_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_LIB_ASTMATCHERS_DYNAMIC_MARSHALLERS_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ASTTypeTraits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/OperationKinds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/ASTMatchers/ASTMatchersInternal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/ASTMatchers/Dynamic/Diagnostics.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/ASTMatchers/Dynamic/VariantValue.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/AttrKinds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LLVM.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/OpenMPKinds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/TypeTraits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/ArrayRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/None.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/Optional.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/STLExtras.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/StringRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/StringSwitch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/Twine.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Regex.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cassert&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstddef&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;iterator&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;memory&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utility&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vector&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>
<decl_stmt><decl><type><name>namespace</name></type> <name>ast_matchers</name> <block>{<block_content>
<decl_stmt><decl><type><name>namespace</name></type> <name>dynamic</name> <block>{<block_content>
<decl_stmt><decl><type><name>namespace</name></type> <name>internal</name> <block>{<block_content>




<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>class</name> <name>T</name><operator>&gt;</operator> struct <name>ArgTypeTraits</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>T</name></expr></argument>&gt;</argument_list></name> struct</type> <name><name>ArgTypeTraits</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>T</name> <operator>&amp;</operator></expr></argument>&gt;</argument_list></name> <range>: <expr><name>public</name> <name><name>ArgTypeTraits</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <block>{
}</block></expr></range></decl>;</decl_stmt>

<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><operator>&gt;</operator> struct <name><name>ArgTypeTraits</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><specifier>static</specifier> <name>bool</name> <macro><name>hasCorrectType</name><argument_list>(<argument>const VariantValue &amp;Value</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Value</name><operator>.</operator><name>isString</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<specifier>static</specifier> <name>bool</name> <macro><name>hasCorrectValue</name><argument_list>(<argument>const VariantValue &amp;Value</argument>)</argument_list></macro> <block>{ <return>return <expr><name>true</name></expr>;</return> }</block>

<specifier>static</specifier> <specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name> <operator>&amp;</operator><macro><name>get</name><argument_list>(<argument>const VariantValue &amp;Value</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Value</name><operator>.</operator><name>getString</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>ArgKind</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>ArgKind</name><argument_list>(<argument><expr><name>ArgKind</name><operator>::</operator><name>AK_String</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <macro><name>getBestGuess</name><argument_list>(<argument>const VariantValue &amp;</argument>)</argument_list></macro> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><name>None</name></expr>;</return>
}</block>
}</expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name>
struct <name><name>ArgTypeTraits</name><argument_list type="generic">&lt;<argument><expr><name>StringRef</name></expr></argument>&gt;</argument_list></name> <operator>:</operator> <name>public</name> <name><name>ArgTypeTraits</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <block>{
}</block></expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>T</name></expr></argument>&gt;</argument_list></name> struct <name><name>ArgTypeTraits</name><argument_list type="generic">&lt;<argument><expr><name>ast_matchers</name><operator>::</operator><name>internal</name><operator>::</operator><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <block>{
<expr><specifier>static</specifier> <name>bool</name> <macro><name>hasCorrectType</name><argument_list>(<argument>const VariantValue&amp; Value</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Value</name><operator>.</operator><name>isMatcher</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<specifier>static</specifier> <name>bool</name> <macro><name>hasCorrectValue</name><argument_list>(<argument>const VariantValue &amp;Value</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Value</name><operator>.</operator><name>getMatcher</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>hasTypedMatcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>ast_matchers</name><operator>::</operator><name>internal</name><operator>::</operator><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <macro><name>get</name><argument_list>(<argument>const VariantValue &amp;Value</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Value</name><operator>.</operator><name>getMatcher</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>getTypedMatcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>ArgKind</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name>ArgKind</name><operator>::</operator><call><name>MakeMatcherArg</name><argument_list>(<argument><expr><name>ASTNodeKind</name><operator>::</operator><call><name><name>getFromNodeKind</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <macro><name>getBestGuess</name><argument_list>(<argument>const VariantValue &amp;</argument>)</argument_list></macro> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><name>None</name></expr>;</return>
}</block>
}</expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name> struct <name><name>ArgTypeTraits</name><argument_list type="generic">&lt;<argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><specifier>static</specifier> <name>bool</name> <macro><name>hasCorrectType</name><argument_list>(<argument>const VariantValue &amp;Value</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Value</name><operator>.</operator><name>isBoolean</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<specifier>static</specifier> <name>bool</name> <macro><name>hasCorrectValue</name><argument_list>(<argument>const VariantValue &amp;Value</argument>)</argument_list></macro> <block>{ <return>return <expr><name>true</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>get</name><argument_list>(<argument>const VariantValue &amp;Value</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Value</name><operator>.</operator><name>getBoolean</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>ArgKind</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>ArgKind</name><argument_list>(<argument><expr><name>ArgKind</name><operator>::</operator><name>AK_Boolean</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <macro><name>getBestGuess</name><argument_list>(<argument>const VariantValue &amp;</argument>)</argument_list></macro> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><name>None</name></expr>;</return>
}</block>
}</expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name> struct <name><name>ArgTypeTraits</name><argument_list type="generic">&lt;<argument><expr><name>double</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><specifier>static</specifier> <name>bool</name> <macro><name>hasCorrectType</name><argument_list>(<argument>const VariantValue &amp;Value</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Value</name><operator>.</operator><name>isDouble</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<specifier>static</specifier> <name>bool</name> <macro><name>hasCorrectValue</name><argument_list>(<argument>const VariantValue &amp;Value</argument>)</argument_list></macro> <block>{ <return>return <expr><name>true</name></expr>;</return> }</block>

<specifier>static</specifier> <name>double</name> <macro><name>get</name><argument_list>(<argument>const VariantValue &amp;Value</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Value</name><operator>.</operator><name>getDouble</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>ArgKind</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>ArgKind</name><argument_list>(<argument><expr><name>ArgKind</name><operator>::</operator><name>AK_Double</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <macro><name>getBestGuess</name><argument_list>(<argument>const VariantValue &amp;</argument>)</argument_list></macro> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><name>None</name></expr>;</return>
}</block>
}</expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name> struct <name><name>ArgTypeTraits</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><specifier>static</specifier> <name>bool</name> <macro><name>hasCorrectType</name><argument_list>(<argument>const VariantValue &amp;Value</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Value</name><operator>.</operator><name>isUnsigned</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<specifier>static</specifier> <name>bool</name> <macro><name>hasCorrectValue</name><argument_list>(<argument>const VariantValue &amp;Value</argument>)</argument_list></macro> <block>{ <return>return <expr><name>true</name></expr>;</return> }</block>

<specifier>static</specifier> <name>unsigned</name> <macro><name>get</name><argument_list>(<argument>const VariantValue &amp;Value</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Value</name><operator>.</operator><name>getUnsigned</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>ArgKind</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>ArgKind</name><argument_list>(<argument><expr><name>ArgKind</name><operator>::</operator><name>AK_Unsigned</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <macro><name>getBestGuess</name><argument_list>(<argument>const VariantValue &amp;</argument>)</argument_list></macro> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><name>None</name></expr>;</return>
}</block>
}</expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name> struct <name><name>ArgTypeTraits</name><argument_list type="generic">&lt;<argument><expr><name>attr</name><operator>::</operator><name>Kind</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>private</name><operator>:</operator>
<specifier>static</specifier> <name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>attr</name><operator>::</operator><name>Kind</name></expr></argument>&gt;</argument_list></name> <macro><name>getAttrKind</name><argument_list>(<argument>llvm::StringRef AttrKind</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>AttrKind</name><operator>.</operator><name>consume_front</name></name><argument_list>(<argument><expr><literal type="string">"attr::"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>llvm</name><operator>::</operator><name>None</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><name>llvm</name><operator>::</operator><call><name><name>StringSwitch</name><argument_list type="generic">&lt;<argument><expr><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>attr</name><operator>::</operator><name>Kind</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>AttrKind</name></expr></argument>)</argument_list></call>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ATTR</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>.Case(#X, attr::X)</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/AttrList.inc"</cpp:file></cpp:include>
<operator>.</operator><call><name>Default</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>None</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>public</name><operator>:</operator>
<specifier>static</specifier> <name>bool</name> <macro><name>hasCorrectType</name><argument_list>(<argument>const VariantValue &amp;Value</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Value</name><operator>.</operator><name>isString</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<specifier>static</specifier> <name>bool</name> <macro><name>hasCorrectValue</name><argument_list>(<argument>const VariantValue&amp; Value</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>getAttrKind</name><argument_list>(<argument><expr><call><name><name>Value</name><operator>.</operator><name>getString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>hasValue</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>attr</name><operator>::</operator><name>Kind</name> <macro><name>get</name><argument_list>(<argument>const VariantValue &amp;Value</argument>)</argument_list></macro> <block>{
<return>return <expr><operator>*</operator><call><name>getAttrKind</name><argument_list>(<argument><expr><call><name><name>Value</name><operator>.</operator><name>getString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>ArgKind</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>ArgKind</name><argument_list>(<argument><expr><name>ArgKind</name><operator>::</operator><name>AK_String</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <call><name>getBestGuess</name><argument_list>(<argument><expr><specifier>const</specifier> <name>VariantValue</name> <operator>&amp;</operator><name>Value</name></expr></argument>)</argument_list></call></expr>;
}</block></expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name> struct <name><name>ArgTypeTraits</name><argument_list type="generic">&lt;<argument><expr><name>CastKind</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>private</name><operator>:</operator>
<specifier>static</specifier> <name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>CastKind</name></expr></argument>&gt;</argument_list></name> <macro><name>getCastKind</name><argument_list>(<argument>llvm::StringRef AttrKind</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>AttrKind</name><operator>.</operator><name>consume_front</name></name><argument_list>(<argument><expr><literal type="string">"CK_"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>llvm</name><operator>::</operator><name>None</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><name>llvm</name><operator>::</operator><call><name><name>StringSwitch</name><argument_list type="generic">&lt;<argument><expr><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>CastKind</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>AttrKind</name></expr></argument>)</argument_list></call>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CAST_OPERATION</name><parameter_list>(<parameter><type><name>Name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>.Case(#Name, CK_##Name)</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/OperationKinds.def"</cpp:file></cpp:include>
<operator>.</operator><call><name>Default</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>None</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>public</name><operator>:</operator>
<specifier>static</specifier> <name>bool</name> <macro><name>hasCorrectType</name><argument_list>(<argument>const VariantValue &amp;Value</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Value</name><operator>.</operator><name>isString</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<specifier>static</specifier> <name>bool</name> <macro><name>hasCorrectValue</name><argument_list>(<argument>const VariantValue&amp; Value</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>getCastKind</name><argument_list>(<argument><expr><call><name><name>Value</name><operator>.</operator><name>getString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>hasValue</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>CastKind</name> <macro><name>get</name><argument_list>(<argument>const VariantValue &amp;Value</argument>)</argument_list></macro> <block>{
<return>return <expr><operator>*</operator><call><name>getCastKind</name><argument_list>(<argument><expr><call><name><name>Value</name><operator>.</operator><name>getString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>ArgKind</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>ArgKind</name><argument_list>(<argument><expr><name>ArgKind</name><operator>::</operator><name>AK_String</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <call><name>getBestGuess</name><argument_list>(<argument><expr><specifier>const</specifier> <name>VariantValue</name> <operator>&amp;</operator><name>Value</name></expr></argument>)</argument_list></call></expr>;
}</block></expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name> struct <name><name>ArgTypeTraits</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Regex</name><operator>::</operator><name>RegexFlags</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>private</name><operator>:</operator>
<specifier>static</specifier> <name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Regex</name><operator>::</operator><name>RegexFlags</name></expr></argument>&gt;</argument_list></name> <macro><name>getFlags</name><argument_list>(<argument>llvm::StringRef Flags</argument>)</argument_list></macro></expr>;

<expr><name>public</name><operator>:</operator>
<specifier>static</specifier> <name>bool</name> <macro><name>hasCorrectType</name><argument_list>(<argument>const VariantValue &amp;Value</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Value</name><operator>.</operator><name>isString</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<specifier>static</specifier> <name>bool</name> <macro><name>hasCorrectValue</name><argument_list>(<argument>const VariantValue&amp; Value</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>getFlags</name><argument_list>(<argument><expr><call><name><name>Value</name><operator>.</operator><name>getString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>hasValue</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>llvm</name><operator>::</operator><name>Regex</name><operator>::</operator><name>RegexFlags</name> <macro><name>get</name><argument_list>(<argument>const VariantValue &amp;Value</argument>)</argument_list></macro> <block>{
<return>return <expr><operator>*</operator><call><name>getFlags</name><argument_list>(<argument><expr><call><name><name>Value</name><operator>.</operator><name>getString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>ArgKind</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>ArgKind</name><argument_list>(<argument><expr><name>ArgKind</name><operator>::</operator><name>AK_String</name></expr></argument>)</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <call><name>getBestGuess</name><argument_list>(<argument><expr><specifier>const</specifier> <name>VariantValue</name> <operator>&amp;</operator><name>Value</name></expr></argument>)</argument_list></call></expr>;
}</block></expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name> struct <name><name>ArgTypeTraits</name><argument_list type="generic">&lt;<argument><expr><name>OpenMPClauseKind</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>private</name><operator>:</operator>
<specifier>static</specifier> <name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>OpenMPClauseKind</name></expr></argument>&gt;</argument_list></name> <macro><name>getClauseKind</name><argument_list>(<argument>llvm::StringRef ClauseKind</argument>)</argument_list></macro> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name><name>StringSwitch</name><argument_list type="generic">&lt;<argument><expr><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>OpenMPClauseKind</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>ClauseKind</name></expr></argument>)</argument_list></call>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GEN_CLANG_CLAUSE_CLASS</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLAUSE_CLASS</name><parameter_list>(<parameter><type><name>Enum</name></type></parameter>, <parameter><type><name>Str</name></type></parameter>, <parameter><type><name>Class</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>.Case(#Enum, llvm::omp::Clause::Enum)</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Frontend/OpenMP/OMP.inc"</cpp:file></cpp:include>
<operator>.</operator><call><name>Default</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>None</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>public</name><operator>:</operator>
<specifier>static</specifier> <name>bool</name> <macro><name>hasCorrectType</name><argument_list>(<argument>const VariantValue &amp;Value</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Value</name><operator>.</operator><name>isString</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<specifier>static</specifier> <name>bool</name> <macro><name>hasCorrectValue</name><argument_list>(<argument>const VariantValue&amp; Value</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>getClauseKind</name><argument_list>(<argument><expr><call><name><name>Value</name><operator>.</operator><name>getString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>hasValue</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>OpenMPClauseKind</name> <macro><name>get</name><argument_list>(<argument>const VariantValue &amp;Value</argument>)</argument_list></macro> <block>{
<return>return <expr><operator>*</operator><call><name>getClauseKind</name><argument_list>(<argument><expr><call><name><name>Value</name><operator>.</operator><name>getString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>ArgKind</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>ArgKind</name><argument_list>(<argument><expr><name>ArgKind</name><operator>::</operator><name>AK_String</name></expr></argument>)</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <call><name>getBestGuess</name><argument_list>(<argument><expr><specifier>const</specifier> <name>VariantValue</name> <operator>&amp;</operator><name>Value</name></expr></argument>)</argument_list></call></expr>;
}</block></expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name> struct <name><name>ArgTypeTraits</name><argument_list type="generic">&lt;<argument><expr><name>UnaryExprOrTypeTrait</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>private</name><operator>:</operator>
<specifier>static</specifier> <name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>UnaryExprOrTypeTrait</name></expr></argument>&gt;</argument_list></name>
<macro><name>getUnaryOrTypeTraitKind</name><argument_list>(<argument>llvm::StringRef ClauseKind</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>ClauseKind</name><operator>.</operator><name>consume_front</name></name><argument_list>(<argument><expr><literal type="string">"UETT_"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>llvm</name><operator>::</operator><name>None</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><name>llvm</name><operator>::</operator><call><name><name>StringSwitch</name><argument_list type="generic">&lt;<argument><expr><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>UnaryExprOrTypeTrait</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>ClauseKind</name></expr></argument>)</argument_list></call>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNARY_EXPR_OR_TYPE_TRAIT</name><parameter_list>(<parameter><type><name>Spelling</name></type></parameter>, <parameter><type><name>Name</name></type></parameter>, <parameter><type><name>Key</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>.Case(#Name, UETT_##Name)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CXX11_UNARY_EXPR_OR_TYPE_TRAIT</name><parameter_list>(<parameter><type><name>Spelling</name></type></parameter>, <parameter><type><name>Name</name></type></parameter>, <parameter><type><name>Key</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>.Case(#Name, UETT_##Name)</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/TokenKinds.def"</cpp:file></cpp:include>
<operator>.</operator><call><name>Default</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>None</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>public</name><operator>:</operator>
<specifier>static</specifier> <name>bool</name> <macro><name>hasCorrectType</name><argument_list>(<argument>const VariantValue &amp;Value</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Value</name><operator>.</operator><name>isString</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<specifier>static</specifier> <name>bool</name> <macro><name>hasCorrectValue</name><argument_list>(<argument>const VariantValue&amp; Value</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>getUnaryOrTypeTraitKind</name><argument_list>(<argument><expr><call><name><name>Value</name><operator>.</operator><name>getString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>.</operator><call><name>hasValue</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>UnaryExprOrTypeTrait</name> <macro><name>get</name><argument_list>(<argument>const VariantValue &amp;Value</argument>)</argument_list></macro> <block>{
<return>return <expr><operator>*</operator><call><name>getUnaryOrTypeTraitKind</name><argument_list>(<argument><expr><call><name><name>Value</name><operator>.</operator><name>getString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>ArgKind</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>ArgKind</name><argument_list>(<argument><expr><name>ArgKind</name><operator>::</operator><name>AK_String</name></expr></argument>)</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <call><name>getBestGuess</name><argument_list>(<argument><expr><specifier>const</specifier> <name>VariantValue</name> <operator>&amp;</operator><name>Value</name></expr></argument>)</argument_list></call></expr>;
}</block></expr>;





<expr><name>class</name> <name>MatcherDescriptor</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>virtual</name> <operator>~</operator><call><name>MatcherDescriptor</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;

<expr><name>virtual</name> <name>VariantMatcher</name> <macro><name>create</name><argument_list>(<argument>SourceRange NameRange</argument>,
<argument>ArrayRef&lt;ParserValue&gt; Args</argument>,
<argument>Diagnostics *Error</argument>)</argument_list></macro> <specifier>const</specifier> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>ASTNodeKind</name> <macro><name>nodeMatcherType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>ASTNodeKind</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>virtual</name> <name>bool</name> <macro><name>isBuilderMatcher</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block>

<name>virtual</name> <name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>MatcherDescriptor</name></expr></argument>&gt;</argument_list></name>
<macro><name>buildMatcherCtor</name><argument_list>(<argument>SourceRange NameRange</argument>, <argument>ArrayRef&lt;ParserValue&gt; Args</argument>,
<argument>Diagnostics *Error</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><block>{}</block></expr>;</return>
}</block>



<name>virtual</name> <name>bool</name> <macro><name>isVariadic</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <operator>=</operator> <literal type="number">0</literal></expr>;


<expr><name>virtual</name> <name>unsigned</name> <macro><name>getNumArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <operator>=</operator> <literal type="number">0</literal></expr>;





<expr><name>virtual</name> <name>void</name> <macro><name>getArgKinds</name><argument_list>(<argument>ASTNodeKind ThisKind</argument>, <argument>unsigned ArgNo</argument>,
<argument>std::vector&lt;ArgKind&gt; &amp;ArgKinds</argument>)</argument_list></macro> <specifier>const</specifier> <operator>=</operator> <literal type="number">0</literal></expr>;








<expr><name>virtual</name> <name>bool</name>
<macro><name>isConvertibleTo</name><argument_list>(<argument>ASTNodeKind Kind</argument>, <argument>unsigned *Specificity = nullptr</argument>,
<argument>ASTNodeKind *LeastDerivedKind = nullptr</argument>)</argument_list></macro> <specifier>const</specifier> <operator>=</operator> <literal type="number">0</literal></expr>;



<expr><name>virtual</name> <name>bool</name> <macro><name>isPolymorphic</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block>
}</expr>;

<expr><specifier>inline</specifier> <name>bool</name> <macro><name>isRetKindConvertibleTo</name><argument_list>(<argument>ArrayRef&lt;ASTNodeKind&gt; RetKinds</argument>,
<argument>ASTNodeKind Kind</argument>, <argument>unsigned *Specificity</argument>,
<argument>ASTNodeKind *LeastDerivedKind</argument>)</argument_list></macro> <block>{
<for>for <control>(<init><decl><type><specifier>const</specifier> <name>ASTNodeKind</name> <modifier>&amp;</modifier></type><name>NodeKind</name> <range>: <expr><name>RetKinds</name></expr></range></decl></init>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>ArgKind</name><operator>::</operator><call><name>MakeMatcherArg</name><argument_list>(<argument><expr><name>NodeKind</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>isConvertibleTo</name><argument_list>(
<argument><expr><name>ArgKind</name><operator>::</operator><call><name>MakeMatcherArg</name><argument_list>(<argument><expr><name>Kind</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Specificity</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>LeastDerivedKind</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>LeastDerivedKind</name> <operator>=</operator> <name>NodeKind</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
<expr_stmt/>}</block_content>
}
return false</block><empty_stmt>;</empty_stmt></if></if_stmt>
<expr_stmt/>}</block_content>







class FixedArgCountMatcherDescriptor : public MatcherDescriptor <block>{<block_content>
<label><name>public</name>:</label>
<decl_stmt><decl><type><name>using</name></type> <name>MarshallerType</name> <init>= <macro><name>VariantMatcher</name> <argument_list>(<argument>*</argument>)</argument_list></macro><expr><operator>(</operator><call><call><name>void</name> <argument_list>(<argument><expr><operator>*</operator><name>Func</name></expr></argument>)</argument_list></call><argument_list>()</argument_list></call>,
<name>StringRef</name> <name>MatcherName</name>,
<name>SourceRange</name> <name>NameRange</name>,
<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ParserValue</name></expr></argument>&gt;</argument_list></name> <name>Args</name>,
<name>Diagnostics</name> <operator>*</operator><name>Error</name><operator>)</operator></expr></init></decl>;</decl_stmt>







<macro><name>FixedArgCountMatcherDescriptor</name><argument_list>(<argument>MarshallerType Marshaller</argument>, <argument>void (*Func)()</argument>,
<argument>StringRef MatcherName</argument>,
<argument>ArrayRef&lt;ASTNodeKind&gt; RetKinds</argument>,
<argument>ArrayRef&lt;ArgKind&gt; ArgKinds</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>Marshaller</name><argument_list>(<argument><expr><name>Marshaller</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Func</name><argument_list>(<argument><expr><name>Func</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>MatcherName</name><argument_list>(<argument><expr><name>MatcherName</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>RetKinds</name><argument_list>(<argument><expr><call><name><name>RetKinds</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>RetKinds</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>ArgKinds</name><argument_list>(<argument>ArgKinds.begin()</argument>, <argument>ArgKinds.end()</argument>)</argument_list></macro> <expr><block>{}</block>

<name>VariantMatcher</name> <macro><name>create</name><argument_list>(<argument>SourceRange NameRange</argument>,
<argument>ArrayRef&lt;ParserValue&gt; Args</argument>,
<argument>Diagnostics *Error</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><call><name>Marshaller</name><argument_list>(<argument><expr><name>Func</name></expr></argument>, <argument><expr><name>MatcherName</name></expr></argument>, <argument><expr><name>NameRange</name></expr></argument>, <argument><expr><name>Args</name></expr></argument>, <argument><expr><name>Error</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>bool</name> <macro><name>isVariadic</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block>
<name>unsigned</name> <macro><name>getNumArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><call><name><name>ArgKinds</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>void</name> <macro><name>getArgKinds</name><argument_list>(<argument>ASTNodeKind ThisKind</argument>, <argument>unsigned ArgNo</argument>,
<argument>std::vector&lt;ArgKind&gt; &amp;Kinds</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<expr><call><name><name>Kinds</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name><name>ArgKinds</name><index>[<expr><name>ArgNo</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>bool</name> <macro><name>isConvertibleTo</name><argument_list>(<argument>ASTNodeKind Kind</argument>, <argument>unsigned *Specificity</argument>,
<argument>ASTNodeKind *LeastDerivedKind</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><call><name>isRetKindConvertibleTo</name><argument_list>(<argument><expr><name>RetKinds</name></expr></argument>, <argument><expr><name>Kind</name></expr></argument>, <argument><expr><name>Specificity</name></expr></argument>,
<argument><expr><name>LeastDerivedKind</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<specifier>const</specifier> <name>MarshallerType</name> <name>Marshaller</name></expr>;</expr_stmt>
<expr_stmt><expr><call><call><name>void</name> <argument_list>(<argument><expr><operator>*</operator> <specifier>const</specifier> <name>Func</name></expr></argument>)</argument_list></call><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name> <name>MatcherName</name></expr>;</expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>ASTNodeKind</name></expr></argument>&gt;</argument_list></name> <name>RetKinds</name></expr>;</expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>ArgKind</name></expr></argument>&gt;</argument_list></name> <name>ArgKinds</name></expr>;</expr_stmt>
<expr_stmt/>}</block_content></block></block><empty_stmt>;</empty_stmt></for>



<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>PolyMatcher</name></expr></argument>&gt;</argument_list></name>
<specifier>static</specifier> <name>void</name> <macro><name>mergePolyMatchers</name><argument_list>(<argument>const PolyMatcher &amp;Poly</argument>,
<argument>std::vector&lt;DynTypedMatcher&gt; &amp;Out</argument>,
<argument>ast_matchers::internal::EmptyTypeList</argument>)</argument_list></macro> <block>{}</block></block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>PolyMatcher</name></expr></argument>, <argument><expr><name>class</name> <name>TypeList</name></expr></argument>&gt;</argument_list></name>
<specifier>static</specifier> <name>void</name> <macro><name>mergePolyMatchers</name><argument_list>(<argument>const PolyMatcher &amp;Poly</argument>,
<argument>std::vector&lt;DynTypedMatcher&gt; &amp;Out</argument>, <argument>TypeList</argument>)</argument_list></macro> <block>{
<macro><name>Out</name></macro><expr><operator>.</operator><macro><name>push_back</name><argument_list>(<argument>ast_matchers::internal::Matcher&lt;typename TypeList::head&gt;(Poly)</argument>)</argument_list></macro></expr>;
<macro><name>mergePolyMatchers</name><argument_list>(<argument>Poly</argument>, <argument>Out</argument>, <argument>typename TypeList::tail()</argument>)</argument_list></macro>;
}</block>







<specifier>inline</specifier> <name>VariantMatcher</name> <macro><name>outvalueToVariantMatcher</name><argument_list>(<argument>const DynTypedMatcher &amp;Matcher</argument>)</argument_list></macro> <block>{
<return>return <expr><name>VariantMatcher</name><operator>::</operator><call><name>SingleMatcher</name><argument_list>(<argument><expr><name>Matcher</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<specifier>static</specifier> <name>VariantMatcher</name> <macro><name>outvalueToVariantMatcher</name><argument_list>(<argument>const T &amp;PolyMatcher</argument>,
<argument>typename T::ReturnTypes * =
nullptr</argument>)</argument_list></macro> <block>{
<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>DynTypedMatcher</name></expr></argument>&gt;</argument_list></name> <name>Matchers</name></expr>;
<macro><name>mergePolyMatchers</name><argument_list>(<argument>PolyMatcher</argument>, <argument>Matchers</argument>, <argument>typename T::ReturnTypes()</argument>)</argument_list></macro>;
<expr><name>VariantMatcher</name> <name>Out</name> <operator>=</operator> <name>VariantMatcher</name><operator>::</operator><call><name>PolymorphicMatcher</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>Matchers</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Out</name></expr>;</return>
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>void</name>
<macro><name>buildReturnTypeVectorFromTypeList</name><argument_list>(<argument>std::vector&lt;ASTNodeKind&gt; &amp;RetTypes</argument>)</argument_list></macro> <block>{
<macro><name>RetTypes</name></macro><expr><operator>.</operator><macro><name>push_back</name><argument_list>(<argument>ASTNodeKind::getFromNodeKind&lt;typename T::head&gt;()</argument>)</argument_list></macro></expr>;
<expr><call><name><name>buildReturnTypeVectorFromTypeList</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name><operator>::</operator><name>tail</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>RetTypes</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name>
<specifier>inline</specifier> <name>void</name>
<macro><name>buildReturnTypeVectorFromTypeList</name></macro><operator>&lt;</operator><name>ast_matchers</name><operator>::</operator><name>internal</name><operator>::</operator><name>EmptyTypeList</name><operator>&gt;</operator><operator>(</operator>
<name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>ASTNodeKind</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>RetTypes</name><operator>)</operator> <block>{}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
struct <name>BuildReturnTypeVector</name> <block>{
<expr><specifier>static</specifier> <name>void</name> <macro><name>build</name><argument_list>(<argument>std::vector&lt;ASTNodeKind&gt; &amp;RetTypes</argument>)</argument_list></macro> <block>{
<expr><call><name><name>buildReturnTypeVectorFromTypeList</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name><operator>::</operator><name>ReturnTypes</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>RetTypes</name></expr></argument>)</argument_list></call></expr>;
}</block></expr>
}</block></expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
struct <name><name>BuildReturnTypeVector</name><argument_list type="generic">&lt;<argument><expr><name>ast_matchers</name><operator>::</operator><name>internal</name><operator>::</operator><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <block>{
<expr><specifier>static</specifier> <name>void</name> <macro><name>build</name><argument_list>(<argument>std::vector&lt;ASTNodeKind&gt; &amp;RetTypes</argument>)</argument_list></macro> <block>{
<expr><call><name><name>RetTypes</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>ASTNodeKind</name><operator>::</operator><call><name><name>getFromNodeKind</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block></expr>
}</block></expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
struct <name><name>BuildReturnTypeVector</name><argument_list type="generic">&lt;<argument><expr><name>ast_matchers</name><operator>::</operator><name>internal</name><operator>::</operator><name><name>BindableMatcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <block>{
<expr><specifier>static</specifier> <name>void</name> <macro><name>build</name><argument_list>(<argument>std::vector&lt;ASTNodeKind&gt; &amp;RetTypes</argument>)</argument_list></macro> <block>{
<expr><call><name><name>RetTypes</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>ASTNodeKind</name><operator>::</operator><call><name><name>getFromNodeKind</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block></expr>
}</block></expr>;


<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>ResultT</name></expr></argument>, <argument><expr><name>typename</name> <name>ArgT</name></expr></argument>,
<argument><expr><name>ResultT</name> <operator>(</operator><operator>*</operator><name>Func</name><operator>)</operator><operator>(</operator><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ArgT</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>)</operator></expr></argument>&gt;</argument_list></name>
<name>VariantMatcher</name>
<macro><name>variadicMatcherDescriptor</name><argument_list>(<argument>StringRef MatcherName</argument>, <argument>SourceRange NameRange</argument>,
<argument>ArrayRef&lt;ParserValue&gt; Args</argument>, <argument>Diagnostics *Error</argument>)</argument_list></macro> <block>{
<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>ArgT</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name> <name>InnerArgsPtr</name></expr>;
<expr><call><name><name>InnerArgsPtr</name><operator>.</operator><name>resize_for_overwrite</name></name><argument_list>(<argument><expr><call><name><name>Args</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>ArgT</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name> <name>InnerArgs</name></expr>;
<expr><call><name><name>InnerArgs</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><call><name><name>Args</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;

<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>e</name> <init>= <expr><call><name><name>Args</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>!=</operator> <name>e</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>using</name></type> <name>ArgTraits</name> <init>= <expr><name><name>ArgTypeTraits</name><argument_list type="generic">&lt;<argument><expr><name>ArgT</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ParserValue</name> <modifier>&amp;</modifier></type><name>Arg</name> <init>= <expr><name><name>Args</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>VariantValue</name> <modifier>&amp;</modifier></type><name>Value</name> <init>= <expr><name><name>Arg</name><operator>.</operator><name>Value</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ArgTraits</name><operator>::</operator><call><name>hasCorrectType</name><argument_list>(<argument><expr><name>Value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>Error</name><operator>-&gt;</operator><name>addError</name></name><argument_list>(<argument><expr><name><name>Arg</name><operator>.</operator><name>Range</name></name></expr></argument>, <argument><expr><name><name>Error</name><operator>-&gt;</operator><name>ET_RegistryWrongArgType</name></name></expr></argument>)</argument_list></call>
<operator>&lt;&lt;</operator> <operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>ArgTraits</name><operator>::</operator><call><name>getKind</name><argument_list>()</argument_list></call><operator>.</operator><call><name>asString</name><argument_list>()</argument_list></call> <operator>&lt;&lt;</operator> <call><name><name>Value</name><operator>.</operator><name>getTypeAsString</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><block>{}</block></expr>;</return>
<expr_stmt/>}</block_content>
if (!ArgTraits::hasCorrectValue(Value</block></if></if_stmt>)</block_content></block></for>) <block>{
<if_stmt><if>if <condition>(<expr><name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <name>BestGuess</name> <operator>=</operator>
<name>ArgTraits</name><operator>::</operator><call><name>getBestGuess</name><argument_list>(<argument><expr><name>Value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>Error</name><operator>-&gt;</operator><name>addError</name></name><argument_list>(<argument><expr><name><name>Arg</name><operator>.</operator><name>Range</name></name></expr></argument>, <argument><expr><name><name>Error</name><operator>-&gt;</operator><name>ET_RegistryUnknownEnumWithReplace</name></name></expr></argument>)</argument_list></call>
<operator>&lt;&lt;</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <call><name><name>Value</name><operator>.</operator><name>getString</name></name><argument_list>()</argument_list></call> <operator>&lt;&lt;</operator> <operator>*</operator><name>BestGuess</name></expr>;</expr_stmt>
<expr_stmt/>}</block_content> else if (Value.isString(</block></if></if_stmt>))</block> <block>{
<expr><call><name><name>Error</name><operator>-&gt;</operator><name>addError</name></name><argument_list>(<argument><expr><name><name>Arg</name><operator>.</operator><name>Range</name></name></expr></argument>, <argument><expr><name><name>Error</name><operator>-&gt;</operator><name>ET_RegistryValueNotFound</name></name></expr></argument>)</argument_list></call>
<operator>&lt;&lt;</operator> <call><name><name>Value</name><operator>.</operator><name>getString</name></name><argument_list>()</argument_list></call></expr>;
}</block></block></expr> <if_stmt><else>else <block>{<block_content>


<expr_stmt><expr><call><name><name>Error</name><operator>-&gt;</operator><name>addError</name></name><argument_list>(<argument><expr><name><name>Arg</name><operator>.</operator><name>Range</name></name></expr></argument>, <argument><expr><name><name>Error</name><operator>-&gt;</operator><name>ET_RegistryWrongArgType</name></name></expr></argument>)</argument_list></call>
<operator>&lt;&lt;</operator> <operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>ArgTraits</name><operator>::</operator><call><name>getKind</name><argument_list>()</argument_list></call><operator>.</operator><call><name>asString</name><argument_list>()</argument_list></call>
<operator>&lt;&lt;</operator> <call><name><name>Value</name><operator>.</operator><name>getTypeAsString</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
return <block>{<block_content><expr_stmt/>}</block_content></block></block><empty_stmt>;</empty_stmt></else></if_stmt>
}</block>
<call><name><name>InnerArgs</name><operator>.</operator><name>set_size</name></name><argument_list>(<argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;
<expr><name><name>InnerArgsPtr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <macro><name>new</name> <argument_list>(<argument>&amp;InnerArgs[i]</argument>)</argument_list></macro> <call><name>ArgT</name><argument_list>(<argument><expr><name>ArgTraits</name><operator>::</operator><call><name>get</name><argument_list>(<argument><expr><name>Value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block></expr>
<return>return <expr><call><name>outvalueToVariantMatcher</name><argument_list>(<argument><expr><call><name>Func</name><argument_list>(<argument><expr><name>InnerArgsPtr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>








<decl_stmt><decl><type><name>class</name></type> <name>VariadicFuncMatcherDescriptor</name> <range>: <expr><name>public</name> <name>MatcherDescriptor</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>using</name> <name>RunFunc</name> <operator>=</operator> <macro><name>VariantMatcher</name> <argument_list>(<argument>*</argument>)</argument_list></macro><operator>(</operator><name>StringRef</name> <name>MatcherName</name>,
<name>SourceRange</name> <name>NameRange</name>,
<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ParserValue</name></expr></argument>&gt;</argument_list></name> <name>Args</name>,
<name>Diagnostics</name> <operator>*</operator><name>Error</name><operator>)</operator></expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>ResultT</name></expr></argument>, <argument><expr><name>typename</name> <name>ArgT</name></expr></argument>,
<argument><expr><name>ResultT</name> <operator>(</operator><operator>*</operator><name>F</name><operator>)</operator><operator>(</operator><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ArgT</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>)</operator></expr></argument>&gt;</argument_list></name>
<macro><name>VariadicFuncMatcherDescriptor</name><argument_list>(
<argument>ast_matchers::internal::VariadicFunction&lt;ResultT</argument>, <argument>ArgT</argument>, <argument>F&gt; Func</argument>,
<argument>StringRef MatcherName</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Func</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>variadicMatcherDescriptor</name><argument_list type="generic">&lt;<argument><expr><name>ResultT</name></expr></argument>, <argument><expr><name>ArgT</name></expr></argument>, <argument><expr><name>F</name></expr></argument>&gt;</argument_list></name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>MatcherName</name><argument_list>(<argument><expr><call><name><name>MatcherName</name><operator>.</operator><name>str</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
<macro><name>ArgsKind</name><argument_list>(<argument>ArgTypeTraits&lt;ArgT&gt;::getKind()</argument>)</argument_list></macro> <expr><block>{
<expr><name><name>BuildReturnTypeVector</name><argument_list type="generic">&lt;<argument><expr><name>ResultT</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>build</name><argument_list>(<argument><expr><name>RetKinds</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>VariantMatcher</name> <macro><name>create</name><argument_list>(<argument>SourceRange NameRange</argument>,
<argument>ArrayRef&lt;ParserValue&gt; Args</argument>,
<argument>Diagnostics *Error</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><call><name>Func</name><argument_list>(<argument><expr><name>MatcherName</name></expr></argument>, <argument><expr><name>NameRange</name></expr></argument>, <argument><expr><name>Args</name></expr></argument>, <argument><expr><name>Error</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>bool</name> <macro><name>isVariadic</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><name>true</name></expr>;</return> }</block>
<name>unsigned</name> <macro><name>getNumArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><literal type="number">0</literal></expr>;</return> }</block>

<name>void</name> <macro><name>getArgKinds</name><argument_list>(<argument>ASTNodeKind ThisKind</argument>, <argument>unsigned ArgNo</argument>,
<argument>std::vector&lt;ArgKind&gt; &amp;Kinds</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<expr><call><name><name>Kinds</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>ArgsKind</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>bool</name> <macro><name>isConvertibleTo</name><argument_list>(<argument>ASTNodeKind Kind</argument>, <argument>unsigned *Specificity</argument>,
<argument>ASTNodeKind *LeastDerivedKind</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><call><name>isRetKindConvertibleTo</name><argument_list>(<argument><expr><name>RetKinds</name></expr></argument>, <argument><expr><name>Kind</name></expr></argument>, <argument><expr><name>Specificity</name></expr></argument>,
<argument><expr><name>LeastDerivedKind</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>ASTNodeKind</name> <macro><name>nodeMatcherType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><name><name>RetKinds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</return> }</block>

<name>private</name><operator>:</operator>
<specifier>const</specifier> <name>RunFunc</name> <name>Func</name></expr>;
<expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name> <name>MatcherName</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>ASTNodeKind</name></expr></argument>&gt;</argument_list></name> <name>RetKinds</name></expr>;
<expr><specifier>const</specifier> <name>ArgKind</name> <name>ArgsKind</name></expr>;
}</block></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>DynCastAllOfMatcherDescriptor</name> <range>: <expr><name>public</name> <name>VariadicFuncMatcherDescriptor</name> <block>{
<expr><name>public</name><operator>:</operator>
<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>BaseT</name></expr></argument>, <argument><expr><name>typename</name> <name>DerivedT</name></expr></argument>&gt;</argument_list></name>
<macro><name>DynCastAllOfMatcherDescriptor</name><argument_list>(
<argument>ast_matchers::internal::VariadicDynCastAllOfMatcher&lt;BaseT</argument>, <argument>DerivedT&gt; Func</argument>,
<argument>StringRef MatcherName</argument>)</argument_list></macro>
<operator>:</operator> <call><name>VariadicFuncMatcherDescriptor</name><argument_list>(<argument><expr><name>Func</name></expr></argument>, <argument><expr><name>MatcherName</name></expr></argument>)</argument_list></call></expr>,
<macro><name>DerivedKind</name><argument_list>(<argument>ASTNodeKind::getFromNodeKind&lt;DerivedT&gt;()</argument>)</argument_list></macro> <expr><block>{}</block>

<name>bool</name> <macro><name>isConvertibleTo</name><argument_list>(<argument>ASTNodeKind Kind</argument>, <argument>unsigned *Specificity</argument>,
<argument>ASTNodeKind *LeastDerivedKind</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{




<if_stmt><if>if <condition>(<expr><name>VariadicFuncMatcherDescriptor</name><operator>::</operator><call><name>isConvertibleTo</name><argument_list>(<argument><expr><name>Kind</name></expr></argument>, <argument><expr><name>Specificity</name></expr></argument>,
<argument><expr><name>LeastDerivedKind</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>Kind</name><operator>.</operator><name>isSame</name></name><argument_list>(<argument><expr><name>DerivedKind</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name><name>Kind</name><operator>.</operator><name>isBaseOf</name></name><argument_list>(<argument><expr><name>DerivedKind</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>Specificity</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>Specificity</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt/>}</block_content>
return true</block><empty_stmt>;</empty_stmt></if></if_stmt>
<expr_stmt/>}</block_content> else <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
<expr_stmt/>}</block_content>
}

ASTNodeKind nodeMatcherType(</block></block></if></if_stmt>) <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><name>DerivedKind</name></expr>;</return> }</block></block>

<name>private</name><operator>:</operator>
<specifier>const</specifier> <name>ASTNodeKind</name> <name>DerivedKind</name></expr>;
}</block></expr></range></decl>;</decl_stmt>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_ARG_COUNT</name><parameter_list>(<parameter><type><name>count</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>if (Args.size() != count) { Error-&gt;addError(NameRange, Error-&gt;ET_RegistryWrongArgCount) &lt;&lt; count &lt;&lt; Args.size(); return VariantMatcher(); }</cpp:value></cpp:define>






<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_ARG_TYPE</name><parameter_list>(<parameter><type><name>index</name></type></parameter>, <parameter><type><name>type</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>if (!ArgTypeTraits&lt;type&gt;::hasCorrectType(Args[index].Value)) { Error-&gt;addError(Args[index].Range, Error-&gt;ET_RegistryWrongArgType) &lt;&lt; (index + 1) &lt;&lt; ArgTypeTraits&lt;type&gt;::getKind().asString() &lt;&lt; Args[index].Value.getTypeAsString(); return VariantMatcher(); } if (!ArgTypeTraits&lt;type&gt;::hasCorrectValue(Args[index].Value)) { if (llvm::Optional&lt;std::string&gt; BestGuess = ArgTypeTraits&lt;type&gt;::getBestGuess(Args[index].Value)) { Error-&gt;addError(Args[index].Range, Error-&gt;ET_RegistryUnknownEnumWithReplace) &lt;&lt; index + 1 &lt;&lt; Args[index].Value.getString() &lt;&lt; *BestGuess; } else if (Args[index].Value.isString()) { Error-&gt;addError(Args[index].Range, Error-&gt;ET_RegistryValueNotFound) &lt;&lt; Args[index].Value.getString(); } return VariantMatcher(); }</cpp:value></cpp:define>




















<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>ReturnType</name></expr></argument>&gt;</argument_list></name>
<specifier>static</specifier> <name>VariantMatcher</name></type> <name>matcherMarshall0</name><parameter_list>(<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>Func</name>)<parameter_list>()</parameter_list></function_decl></parameter>, <parameter><decl><type><name>StringRef</name></type> <name>MatcherName</name></decl></parameter>,
<parameter><decl><type><name>SourceRange</name></type> <name>NameRange</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ParserValue</name></expr></argument>&gt;</argument_list></name></type> <name>Args</name></decl></parameter>,
<parameter><decl><type><name>Diagnostics</name> <modifier>*</modifier></type><name>Error</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>using</name></type> <name>FuncType</name> <init>= <expr><call><call><name>ReturnType</name> <argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CHECK_ARG_COUNT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>outvalueToVariantMatcher</name><argument_list>(<argument><expr><call><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>FuncType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Func</name></expr></argument>)</argument_list></call><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>ReturnType</name></expr></argument>, <argument><expr><name>typename</name> <name>ArgType1</name></expr></argument>&gt;</argument_list></name>
<specifier>static</specifier> <name>VariantMatcher</name></type> <name>matcherMarshall1</name><parameter_list>(<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>Func</name>)<parameter_list>()</parameter_list></function_decl></parameter>, <parameter><decl><type><name>StringRef</name></type> <name>MatcherName</name></decl></parameter>,
<parameter><decl><type><name>SourceRange</name></type> <name>NameRange</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ParserValue</name></expr></argument>&gt;</argument_list></name></type> <name>Args</name></decl></parameter>,
<parameter><decl><type><name>Diagnostics</name> <modifier>*</modifier></type><name>Error</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>using</name></type> <name>FuncType</name> <init>= <expr><call><call><name>ReturnType</name> <argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>ArgType1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CHECK_ARG_COUNT</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_ARG_TYPE</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ArgType1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>outvalueToVariantMatcher</name><argument_list>(<argument><expr><call><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>FuncType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Func</name></expr></argument>)</argument_list></call><argument_list>(
<argument><expr><name><name>ArgTypeTraits</name><argument_list type="generic">&lt;<argument><expr><name>ArgType1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>get</name><argument_list>(<argument><expr><name><name>Args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>Value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>ReturnType</name></expr></argument>, <argument><expr><name>typename</name> <name>ArgType1</name></expr></argument>, <argument><expr><name>typename</name> <name>ArgType2</name></expr></argument>&gt;</argument_list></name>
<specifier>static</specifier> <name>VariantMatcher</name></type> <name>matcherMarshall2</name><parameter_list>(<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>Func</name>)<parameter_list>()</parameter_list></function_decl></parameter>, <parameter><decl><type><name>StringRef</name></type> <name>MatcherName</name></decl></parameter>,
<parameter><decl><type><name>SourceRange</name></type> <name>NameRange</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ParserValue</name></expr></argument>&gt;</argument_list></name></type> <name>Args</name></decl></parameter>,
<parameter><decl><type><name>Diagnostics</name> <modifier>*</modifier></type><name>Error</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>using</name></type> <name>FuncType</name> <init>= <expr><call><call><name>ReturnType</name> <argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>ArgType1</name></expr></argument>, <argument><expr><name>ArgType2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CHECK_ARG_COUNT</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_ARG_TYPE</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ArgType1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_ARG_TYPE</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>ArgType2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>outvalueToVariantMatcher</name><argument_list>(<argument><expr><call><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>FuncType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Func</name></expr></argument>)</argument_list></call><argument_list>(
<argument><expr><name><name>ArgTypeTraits</name><argument_list type="generic">&lt;<argument><expr><name>ArgType1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>get</name><argument_list>(<argument><expr><name><name>Args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>Value</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>ArgTypeTraits</name><argument_list type="generic">&lt;<argument><expr><name>ArgType2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>get</name><argument_list>(<argument><expr><name><name>Args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>Value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CHECK_ARG_COUNT</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CHECK_ARG_TYPE</name></cpp:undef>



<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>ToArg</name></expr></argument>, <argument><expr><name>typename</name> <name>FromArg</name></expr></argument>&gt;</argument_list></name> <name>class</name> <name>ArgumentAdapterT</name></expr></argument>,
<argument><expr><name>typename</name> <name>FromTypes</name></expr></argument>, <argument><expr><name>typename</name> <name>ToTypes</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>AdaptativeOverloadCollector</name> <block>{<block_content>
<label><name>public</name>:</label>
<macro><name>AdaptativeOverloadCollector</name><argument_list>(
<argument>StringRef Name</argument>, <argument>std::vector&lt;std::unique_ptr&lt;MatcherDescriptor&gt;&gt; &amp;Out</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>Name</name><argument_list>(<argument><expr><name>Name</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Out</name><argument_list>(<argument>Out</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>collect</name><argument_list>(<argument><expr><call><name>FromTypes</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<name>private</name><operator>:</operator>
<name>using</name> <name>AdaptativeFunc</name> <operator>=</operator> <name>ast_matchers</name><operator>::</operator><name>internal</name><operator>::</operator><name><name>ArgumentAdaptingMatcherFunc</name><argument_list type="generic">&lt;
<argument><expr><name>ArgumentAdapterT</name></expr></argument>, <argument><expr><name>FromTypes</name></expr></argument>, <argument><expr><name>ToTypes</name></expr></argument>&gt;</argument_list></name></expr>;</expr_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type> <name>collect</name><argument_list>(<argument><expr><name>ast_matchers</name><operator>::</operator><name>internal</name><operator>::</operator><name>EmptyTypeList</name></expr></argument>)</argument_list> <block>{<block_content/>}</block></decl></decl_stmt>



<function_decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>FromTypeList</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>void</name></type> <name>collect</name><parameter_list>(<parameter><decl><type><name>FromTypeList</name></type></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>StringRef</name></type> <name>Name</name></decl>;</decl_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>MatcherDescriptor</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Out</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>






<decl_stmt><decl><type><name>class</name></type> <name>OverloadedMatcherDescriptor</name> <range>: <expr><name>public</name> <name>MatcherDescriptor</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>OverloadedMatcherDescriptor</name><argument_list>(
<argument><expr><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>MatcherDescriptor</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <name>Callbacks</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>Overloads</name><argument_list>(<argument>std::make_move_iterator(Callbacks.begin())</argument>,
<argument>std::make_move_iterator(Callbacks.end())</argument>)</argument_list></macro> <block>{}</block>

<operator>~</operator><macro><name>OverloadedMatcherDescriptor</name><argument_list>()</argument_list></macro> <name>override</name> <operator>=</operator> default</expr>;

<expr><name>VariantMatcher</name> <macro><name>create</name><argument_list>(<argument>SourceRange NameRange</argument>,
<argument>ArrayRef&lt;ParserValue&gt; Args</argument>,
<argument>Diagnostics *Error</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>VariantMatcher</name></expr></argument>&gt;</argument_list></name> <name>Constructed</name></expr>;
<expr><name>Diagnostics</name><operator>::</operator><name>OverloadContext</name> <call><name>Ctx</name><argument_list>(<argument><expr><name>Error</name></expr></argument>)</argument_list></call></expr>;
<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>&amp;</modifier></type><name>O</name> <range>: <expr><name>Overloads</name></expr></range></decl></init>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>VariantMatcher</name></type> <name>SubMatcher</name> <init>= <expr><call><name><name>O</name><operator>-&gt;</operator><name>create</name></name><argument_list>(<argument><expr><name>NameRange</name></expr></argument>, <argument><expr><name>Args</name></expr></argument>, <argument><expr><name>Error</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>SubMatcher</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>Constructed</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>SubMatcher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
}

if (Constructed.empty(</block></if></if_stmt>)</block_content></block></for>)</block></expr> <return>return <expr><call><name>VariantMatcher</name><argument_list>()</argument_list></call></expr>;</return>

<call><name><name>Ctx</name><operator>.</operator><name>revertErrors</name></name><argument_list>()</argument_list></call></block></expr></range></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Constructed</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name><name>Error</name><operator>-&gt;</operator><name>addError</name></name><argument_list>(<argument><expr><name>NameRange</name></expr></argument>, <argument><expr><name><name>Error</name><operator>-&gt;</operator><name>ET_RegistryAmbiguousOverload</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>VariantMatcher</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name><name>Constructed</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isVariadic</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<expr><name>bool</name> <name>Overload0Variadic</name> <operator>=</operator> <name><name>Overloads</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><call><name>isVariadic</name><argument_list>()</argument_list></call></expr>;
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>&amp;</modifier></type><name>O</name> <range>: <expr><name>Overloads</name></expr></range></decl></init>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>Overload0Variadic</name> <operator>==</operator> <call><name><name>O</name><operator>-&gt;</operator><name>isVariadic</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
return Overload0Variadic</block><empty_stmt>;</empty_stmt></for>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>unsigned</name> <macro><name>getNumArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<expr><name>unsigned</name> <name>Overload0NumArgs</name> <operator>=</operator> <name><name>Overloads</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><call><name>getNumArgs</name><argument_list>()</argument_list></call></expr>;
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>&amp;</modifier></type><name>O</name> <range>: <expr><name>Overloads</name></expr></range></decl></init>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>Overload0NumArgs</name> <operator>==</operator> <call><name><name>O</name><operator>-&gt;</operator><name>getNumArgs</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
return Overload0NumArgs</block><empty_stmt>;</empty_stmt></for>
}</block></expr></expr_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>getArgKinds</name><argument_list>(<argument><expr><name>ASTNodeKind</name> <name>ThisKind</name></expr></argument>, <argument><expr><name>unsigned</name> <name>ArgNo</name></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>ArgKind</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Kinds</name></expr></argument>)</argument_list> const <name>override</name> <block>{<block_content>
<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>&amp;</modifier></type><name>O</name> <range>: <expr><name>Overloads</name></expr></range></decl></init>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>O</name><operator>-&gt;</operator><name>isConvertibleTo</name></name><argument_list>(<argument><expr><name>ThisKind</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>O</name><operator>-&gt;</operator><name>getArgKinds</name></name><argument_list>(<argument><expr><name>ThisKind</name></expr></argument>, <argument><expr><name>ArgNo</name></expr></argument>, <argument><expr><name>Kinds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>isConvertibleTo</name><argument_list>(<argument><expr><name>ASTNodeKind</name> <name>Kind</name></expr></argument>, <argument><expr><name>unsigned</name> <operator>*</operator><name>Specificity</name></expr></argument>,
<argument><expr><name>ASTNodeKind</name> <operator>*</operator><name>LeastDerivedKind</name></expr></argument>)</argument_list> const <name>override</name> <block>{<block_content>
<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>&amp;</modifier></type><name>O</name> <range>: <expr><name>Overloads</name></expr></range></decl></init>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>O</name><operator>-&gt;</operator><name>isConvertibleTo</name></name><argument_list>(<argument><expr><name>Kind</name></expr></argument>, <argument><expr><name>Specificity</name></expr></argument>, <argument><expr><name>LeastDerivedKind</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<label><name>private</name>:</label>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>MatcherDescriptor</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <name>Overloads</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>ReturnType</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>RegexMatcherDescriptor</name> <range>: <expr><name>public</name> <name>MatcherDescriptor</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>RegexMatcherDescriptor</name><argument_list>(<argument><expr><call><call><name>ReturnType</name> <argument_list>(<argument><expr><operator>*</operator><name>WithFlags</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>StringRef</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>Regex</name><operator>::</operator><name>RegexFlags</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><call><name>ReturnType</name> <argument_list>(<argument><expr><operator>*</operator><name>NoFlags</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>StringRef</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ASTNodeKind</name></expr></argument>&gt;</argument_list></name> <name>RetKinds</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>WithFlags</name><argument_list>(<argument><expr><name>WithFlags</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>NoFlags</name><argument_list>(<argument><expr><name>NoFlags</name></expr></argument>)</argument_list></call></expr>,
<macro><name>RetKinds</name><argument_list>(<argument>RetKinds.begin()</argument>, <argument>RetKinds.end()</argument>)</argument_list></macro> <expr><block>{}</block>
<name>bool</name> <macro><name>isVariadic</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><name>true</name></expr>;</return> }</block>
<name>unsigned</name> <macro><name>getNumArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><literal type="number">0</literal></expr>;</return> }</block>

<name>void</name> <macro><name>getArgKinds</name><argument_list>(<argument>ASTNodeKind ThisKind</argument>, <argument>unsigned ArgNo</argument>,
<argument>std::vector&lt;ArgKind&gt; &amp;Kinds</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>ArgNo</name> <operator>&lt;</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Kinds</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>ArgKind</name><operator>::</operator><name>AK_String</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>bool</name> <macro><name>isConvertibleTo</name><argument_list>(<argument>ASTNodeKind Kind</argument>, <argument>unsigned *Specificity</argument>,
<argument>ASTNodeKind *LeastDerivedKind</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><call><name>isRetKindConvertibleTo</name><argument_list>(<argument><expr><name>RetKinds</name></expr></argument>, <argument><expr><name>Kind</name></expr></argument>, <argument><expr><name>Specificity</name></expr></argument>,
<argument><expr><name>LeastDerivedKind</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>VariantMatcher</name> <macro><name>create</name><argument_list>(<argument>SourceRange NameRange</argument>, <argument>ArrayRef&lt;ParserValue&gt; Args</argument>,
<argument>Diagnostics *Error</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>Args</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <call><name><name>Args</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>Error</name><operator>-&gt;</operator><name>addError</name></name><argument_list>(<argument><expr><name>NameRange</name></expr></argument>, <argument><expr><name>Diagnostics</name><operator>::</operator><name>ET_RegistryWrongArgCount</name></expr></argument>)</argument_list></call>
<operator>&lt;&lt;</operator> <literal type="string">"1 or 2"</literal> <operator>&lt;&lt;</operator> <call><name><name>Args</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>VariantMatcher</name><argument_list>()</argument_list></call></expr>;</return>
<expr_stmt/>}</block_content>
if (!ArgTypeTraits&lt;StringRef&gt;::hasCorrectType(Args[0].Value</block></if></if_stmt>))</block> <block>{
<expr><call><name><name>Error</name><operator>-&gt;</operator><name>addError</name></name><argument_list>(<argument><expr><name><name>Args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>Range</name></expr></argument>, <argument><expr><name><name>Error</name><operator>-&gt;</operator><name>ET_RegistryWrongArgType</name></name></expr></argument>)</argument_list></call>
<operator>&lt;&lt;</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>ArgTypeTraits</name><argument_list type="generic">&lt;<argument><expr><name>StringRef</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>getKind</name><argument_list>()</argument_list></call><operator>.</operator><call><name>asString</name><argument_list>()</argument_list></call>
<operator>&lt;&lt;</operator> <name><name>Args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><call><name><name>Value</name><operator>.</operator><name>getTypeAsString</name></name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>VariantMatcher</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr>
<if_stmt><if>if <condition>(<expr><call><name><name>Args</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>outvalueToVariantMatcher</name><argument_list>(
<argument><expr><call><name>NoFlags</name><argument_list>(<argument><expr><name><name>ArgTypeTraits</name><argument_list type="generic">&lt;<argument><expr><name>StringRef</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>get</name><argument_list>(<argument><expr><name><name>Args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>Value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<expr_stmt/>}</block_content>
if (!ArgTypeTraits&lt;llvm::Regex::RegexFlags&gt;::hasCorrectType(
Args[1].Value</block></if></if_stmt>))</block> <block>{
<expr><call><name><name>Error</name><operator>-&gt;</operator><name>addError</name></name><argument_list>(<argument><expr><name><name>Args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>Range</name></expr></argument>, <argument><expr><name><name>Error</name><operator>-&gt;</operator><name>ET_RegistryWrongArgType</name></name></expr></argument>)</argument_list></call>
<operator>&lt;&lt;</operator> <literal type="number">2</literal> <operator>&lt;&lt;</operator> <name><name>ArgTypeTraits</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Regex</name><operator>::</operator><name>RegexFlags</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>getKind</name><argument_list>()</argument_list></call><operator>.</operator><call><name>asString</name><argument_list>()</argument_list></call>
<operator>&lt;&lt;</operator> <name><name>Args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><call><name><name>Value</name><operator>.</operator><name>getTypeAsString</name></name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>VariantMatcher</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></range></decl></decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ArgTypeTraits</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Regex</name><operator>::</operator><name>RegexFlags</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>hasCorrectValue</name><argument_list>(
<argument><expr><name><name>Args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>Value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <name>BestGuess</name> <operator>=</operator>
<name><name>ArgTypeTraits</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Regex</name><operator>::</operator><name>RegexFlags</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>getBestGuess</name><argument_list>(
<argument><expr><name><name>Args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>Value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>Error</name><operator>-&gt;</operator><name>addError</name></name><argument_list>(<argument><expr><name><name>Args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>Range</name></expr></argument>, <argument><expr><name><name>Error</name><operator>-&gt;</operator><name>ET_RegistryUnknownEnumWithReplace</name></name></expr></argument>)</argument_list></call>
<operator>&lt;&lt;</operator> <literal type="number">2</literal> <operator>&lt;&lt;</operator> <name><name>Args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><call><name><name>Value</name><operator>.</operator><name>getString</name></name><argument_list>()</argument_list></call> <operator>&lt;&lt;</operator> <operator>*</operator><name>BestGuess</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name><name>Error</name><operator>-&gt;</operator><name>addError</name></name><argument_list>(<argument><expr><name><name>Args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>Range</name></expr></argument>, <argument><expr><name><name>Error</name><operator>-&gt;</operator><name>ET_RegistryValueNotFound</name></name></expr></argument>)</argument_list></call>
<operator>&lt;&lt;</operator> <name><name>Args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><call><name><name>Value</name><operator>.</operator><name>getString</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><call><name>VariantMatcher</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>outvalueToVariantMatcher</name><argument_list>(
<argument><expr><call><name>WithFlags</name><argument_list>(<argument><expr><name><name>ArgTypeTraits</name><argument_list type="generic">&lt;<argument><expr><name>StringRef</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>get</name><argument_list>(<argument><expr><name><name>Args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>Value</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>ArgTypeTraits</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Regex</name><operator>::</operator><name>RegexFlags</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>get</name><argument_list>(<argument><expr><name><name>Args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>Value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<label><name>private</name>:</label>
<expr_stmt><expr><call><call><name>ReturnType</name> <argument_list>(<argument><expr><operator>*</operator><specifier>const</specifier> <name>WithFlags</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>StringRef</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>Regex</name><operator>::</operator><name>RegexFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><call><name>ReturnType</name> <argument_list>(<argument><expr><operator>*</operator><specifier>const</specifier> <name>NoFlags</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>StringRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>ASTNodeKind</name></expr></argument>&gt;</argument_list></name> <name>RetKinds</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>VariadicOperatorMatcherDescriptor</name> <range>: <expr><name>public</name> <name>MatcherDescriptor</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>using</name> <name>VarOp</name> <operator>=</operator> <name>DynTypedMatcher</name><operator>::</operator><name>VariadicOperator</name></expr>;

<macro><name>VariadicOperatorMatcherDescriptor</name><argument_list>(<argument>unsigned MinCount</argument>, <argument>unsigned MaxCount</argument>,
<argument>VarOp Op</argument>, <argument>StringRef MatcherName</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>MinCount</name><argument_list>(<argument><expr><name>MinCount</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>MaxCount</name><argument_list>(<argument><expr><name>MaxCount</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Op</name><argument_list>(<argument><expr><name>Op</name></expr></argument>)</argument_list></call></expr>,
<macro><name>MatcherName</name><argument_list>(<argument>MatcherName</argument>)</argument_list></macro> <expr><block>{}</block>

<name>VariantMatcher</name> <macro><name>create</name><argument_list>(<argument>SourceRange NameRange</argument>,
<argument>ArrayRef&lt;ParserValue&gt; Args</argument>,
<argument>Diagnostics *Error</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>Args</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;</operator> <name>MinCount</name> <operator>||</operator> <name>MaxCount</name> <operator>&lt;</operator> <call><name><name>Args</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name> <name>MaxStr</name> <operator>=</operator>
<operator>(</operator><ternary><condition><expr><name>MaxCount</name> <operator>==</operator> <name>std</name><operator>::</operator><name><name>numeric_limits</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>max</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><literal type="string">""</literal></expr>
</then><else>: <expr><call><name>Twine</name><argument_list>(<argument><expr><name>MaxCount</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator>
<operator>.</operator><call><name>str</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Error</name><operator>-&gt;</operator><name>addError</name></name><argument_list>(<argument><expr><name>NameRange</name></expr></argument>, <argument><expr><name><name>Error</name><operator>-&gt;</operator><name>ET_RegistryWrongArgCount</name></name></expr></argument>)</argument_list></call>
<operator>&lt;&lt;</operator> <operator>(</operator><literal type="string">"("</literal> <operator>+</operator> <call><name>Twine</name><argument_list>(<argument><expr><name>MinCount</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="string">", "</literal> <operator>+</operator> <name>MaxStr</name> <operator>+</operator> <literal type="string">")"</literal><operator>)</operator> <operator>&lt;&lt;</operator> <call><name><name>Args</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>VariantMatcher</name><argument_list>()</argument_list></call></expr>;</return>
<expr_stmt/>}</block_content>

std::vector&lt;VariantMatcher&gt; InnerArgs</block><empty_stmt>;</empty_stmt></if></if_stmt></block></expr>
<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>e</name> <init>= <expr><call><name><name>Args</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>!=</operator> <name>e</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>ParserValue</name> <modifier>&amp;</modifier></type><name>Arg</name> <init>= <expr><name><name>Args</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>VariantValue</name> <modifier>&amp;</modifier></type><name>Value</name> <init>= <expr><name><name>Arg</name><operator>.</operator><name>Value</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>Value</name><operator>.</operator><name>isMatcher</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>Error</name><operator>-&gt;</operator><name>addError</name></name><argument_list>(<argument><expr><name><name>Arg</name><operator>.</operator><name>Range</name></name></expr></argument>, <argument><expr><name><name>Error</name><operator>-&gt;</operator><name>ET_RegistryWrongArgType</name></name></expr></argument>)</argument_list></call>
<operator>&lt;&lt;</operator> <operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="string">"Matcher&lt;&gt;"</literal> <operator>&lt;&lt;</operator> <call><name><name>Value</name><operator>.</operator><name>getTypeAsString</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>VariantMatcher</name><argument_list>()</argument_list></call></expr>;</return>
<expr_stmt/>}</block_content>
InnerArgs.push_back(Value.getMatcher(</block></if></if_stmt>)</block_content></block></for>)</block></expr></range></decl>;</decl_stmt>
}
return <expr_stmt><expr><name>VariantMatcher</name><operator>::</operator><call><name>VariadicOperatorMatcher</name><argument_list>(<argument><expr><name>Op</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>InnerArgs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}

bool <macro><name>isVariadic</name><argument_list>()</argument_list></macro> <expr_stmt><expr><specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><name>true</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getNumArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><literal type="number">0</literal></expr>;</return> }</block></expr></expr_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>getArgKinds</name><argument_list>(<argument><expr><name>ASTNodeKind</name> <name>ThisKind</name></expr></argument>, <argument><expr><name>unsigned</name> <name>ArgNo</name></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>ArgKind</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Kinds</name></expr></argument>)</argument_list> const <name>override</name> <block>{<block_content>
<expr_stmt><expr><call><name><name>Kinds</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>ArgKind</name><operator>::</operator><call><name>MakeMatcherArg</name><argument_list>(<argument><expr><name>ThisKind</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>isConvertibleTo</name><argument_list>(<argument><expr><name>ASTNodeKind</name> <name>Kind</name></expr></argument>, <argument><expr><name>unsigned</name> <operator>*</operator><name>Specificity</name></expr></argument>,
<argument><expr><name>ASTNodeKind</name> <operator>*</operator><name>LeastDerivedKind</name></expr></argument>)</argument_list> const <name>override</name> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>Specificity</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>Specificity</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>LeastDerivedKind</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>LeastDerivedKind</name> <operator>=</operator> <name>Kind</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isPolymorphic</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><name>true</name></expr>;</return> }</block></expr></expr_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name></type> <name>MinCount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name></type> <name>MaxCount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>VarOp</name></type> <name>Op</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>StringRef</name></type> <name>MatcherName</name></decl>;</decl_stmt>
};

<decl_stmt><decl><type><name>class</name></type> <name>MapAnyOfMatcherDescriptor</name> <range>: <expr><name>public</name> <name>MatcherDescriptor</name> <block>{
<expr><name>ASTNodeKind</name> <name>CladeNodeKind</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>ASTNodeKind</name></expr></argument>&gt;</argument_list></name> <name>NodeKinds</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>MapAnyOfMatcherDescriptor</name><argument_list>(<argument>ASTNodeKind CladeNodeKind</argument>,
<argument>std::vector&lt;ASTNodeKind&gt; NodeKinds</argument>)</argument_list></macro>
<operator>:</operator> <call><name>CladeNodeKind</name><argument_list>(<argument><expr><name>CladeNodeKind</name></expr></argument>)</argument_list></call></expr>, <macro><name>NodeKinds</name><argument_list>(<argument>NodeKinds</argument>)</argument_list></macro> <expr><block>{}</block>

<name>VariantMatcher</name> <macro><name>create</name><argument_list>(<argument>SourceRange NameRange</argument>, <argument>ArrayRef&lt;ParserValue&gt; Args</argument>,
<argument>Diagnostics *Error</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{

<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>DynTypedMatcher</name></expr></argument>&gt;</argument_list></name> <name>NodeArgs</name></expr>;

<for>for <control>(<init><decl><type><name>auto</name></type> <name>NK</name> <range>: <expr><name>NodeKinds</name></expr></range></decl></init>)</control> <block>{<block_content>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>DynTypedMatcher</name></expr></argument>&gt;</argument_list></name> <name>InnerArgs</name></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>&amp;</modifier></type><name>Arg</name> <range>: <expr><name>Args</name></expr></range></decl></init>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>Arg</name><operator>.</operator><name>Value</name><operator>.</operator><name>isMatcher</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><block>{}</block></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>VariantMatcher</name> <modifier>&amp;</modifier></type><name>VM</name> <init>= <expr><call><name><name>Arg</name><operator>.</operator><name>Value</name><operator>.</operator><name>getMatcher</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>VM</name><operator>.</operator><name>hasTypedMatcher</name></name><argument_list>(<argument><expr><name>NK</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>auto</name></type> <name>DM</name> <init>= <expr><call><name><name>VM</name><operator>.</operator><name>getTypedMatcher</name></name><argument_list>(<argument><expr><name>NK</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>InnerArgs</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>DM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
}

if (InnerArgs.empty(</block></if></if_stmt>)</block_content></block></for>)</block_content> <block>{<block_content>
<expr_stmt><expr><call><name><name>NodeArgs</name><operator>.</operator><name>push_back</name></name><argument_list>(
<argument><expr><name>DynTypedMatcher</name><operator>::</operator><call><name>trueMatcher</name><argument_list>(<argument><expr><name>NK</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>dynCastTo</name><argument_list>(<argument><expr><name>CladeNodeKind</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content> else <block>{<block_content>
<expr_stmt><expr><call><name><name>NodeArgs</name><operator>.</operator><name>push_back</name></name><argument_list>(
<argument><expr><name>DynTypedMatcher</name><operator>::</operator><call><name>constructVariadic</name><argument_list>(
<argument><expr><name>ast_matchers</name><operator>::</operator><name>internal</name><operator>::</operator><name>DynTypedMatcher</name><operator>::</operator><name>VO_AllOf</name></expr></argument>, <argument><expr><name>NK</name></expr></argument>,
<argument><expr><name>InnerArgs</name></expr></argument>)</argument_list></call>
<operator>.</operator><call><name>dynCastTo</name><argument_list>(<argument><expr><name>CladeNodeKind</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
}

auto Result = DynTypedMatcher::constructVariadic(
ast_matchers::internal::DynTypedMatcher::VO_AnyOf</block></block></block><operator>,</operator> <expr_stmt><expr><name>CladeNodeKind</name></expr><operator>,</operator>
<expr><name>NodeArgs</name></expr></expr_stmt></for>)</block></expr>;
<expr><call><name><name>Result</name><operator>.</operator><name>setAllowBind</name></name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>VariantMatcher</name><operator>::</operator><call><name>SingleMatcher</name><argument_list>(<argument><expr><name>Result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></range></decl></decl_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isVariadic</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><name>true</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getNumArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><literal type="number">0</literal></expr>;</return> }</block></expr></expr_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>getArgKinds</name><argument_list>(<argument><expr><name>ASTNodeKind</name> <name>ThisKind</name></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>ArgKind</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Kinds</name></expr></argument>)</argument_list> const <name>override</name> <block>{<block_content>
<expr_stmt><expr><call><name><name>Kinds</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>ArgKind</name><operator>::</operator><call><name>MakeMatcherArg</name><argument_list>(<argument><expr><name>ThisKind</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>isConvertibleTo</name><argument_list>(<argument><expr><name>ASTNodeKind</name> <name>Kind</name></expr></argument>, <argument><expr><name>unsigned</name> <operator>*</operator><name>Specificity</name></expr></argument>,
<argument><expr><name>ASTNodeKind</name> <operator>*</operator><name>LeastDerivedKind</name></expr></argument>)</argument_list> const <name>override</name> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>Specificity</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>Specificity</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>LeastDerivedKind</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>LeastDerivedKind</name> <operator>=</operator> <name>CladeNodeKind</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>
};

<decl_stmt><decl><type><name>class</name></type> <name>MapAnyOfBuilderDescriptor</name> <range>: <expr><name>public</name> <name>MatcherDescriptor</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>VariantMatcher</name> <macro><name>create</name><argument_list>(<argument>SourceRange</argument>, <argument>ArrayRef&lt;ParserValue&gt;</argument>,
<argument>Diagnostics *</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><block>{}</block></expr>;</return>
}</block>

<name>bool</name> <macro><name>isBuilderMatcher</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><name>true</name></expr>;</return> }</block>

<name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>MatcherDescriptor</name></expr></argument>&gt;</argument_list></name>
<macro><name>buildMatcherCtor</name><argument_list>(<argument>SourceRange</argument>, <argument>ArrayRef&lt;ParserValue&gt; Args</argument>,
<argument>Diagnostics *</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{

<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>ASTNodeKind</name></expr></argument>&gt;</argument_list></name> <name>NodeKinds</name></expr>;
<for>for <control>(<init><decl><type><name>auto</name></type> <name>Arg</name> <range>: <expr><name>Args</name></expr></range></decl></init>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>Arg</name><operator>.</operator><name>Value</name><operator>.</operator><name>isNodeKind</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><block>{}</block></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>NodeKinds</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>Arg</name><operator>.</operator><name>Value</name><operator>.</operator><name>getNodeKind</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content>

if (NodeKinds.empty(</block></for>))</block></expr>
<return>return <expr><block>{}</block></expr>;</return>

<name>ASTNodeKind</name> <name>CladeNodeKind</name> <operator>=</operator> <call><name><name>NodeKinds</name><operator>.</operator><name>front</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getCladeKind</name><argument_list>()</argument_list></call></block></expr></range></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><name>auto</name></type> <name>NK</name> <range>: <expr><name>NodeKinds</name></expr></range></decl></init>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>NK</name><operator>.</operator><name>getCladeKind</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isSame</name><argument_list>(<argument><expr><name>CladeNodeKind</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><block>{}</block></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>

<return>return <expr><name>std</name><operator>::</operator><call><name><name>make_unique</name><argument_list type="generic">&lt;<argument><expr><name>MapAnyOfMatcherDescriptor</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CladeNodeKind</name></expr></argument>,
<argument><expr><name>NodeKinds</name></expr></argument>)</argument_list></call></expr>;</return>
}

bool <macro><name>isVariadic</name><argument_list>()</argument_list></macro> <expr_stmt><expr><specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><name>true</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>unsigned</name> <macro><name>getNumArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><literal type="number">0</literal></expr>;</return> }</block></expr></expr_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>getArgKinds</name><argument_list>(<argument><expr><name>ASTNodeKind</name> <name>ThisKind</name></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>ArgKind</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>ArgKinds</name></expr></argument>)</argument_list> const <name>override</name> <block>{<block_content>
<expr_stmt><expr><call><name><name>ArgKinds</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>ArgKind</name><operator>::</operator><call><name>MakeNodeArg</name><argument_list>(<argument><expr><name>ThisKind</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></decl></decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>isConvertibleTo</name><argument_list>(<argument><expr><name>ASTNodeKind</name> <name>Kind</name></expr></argument>, <argument><expr><name>unsigned</name> <operator>*</operator><name>Specificity</name> <operator>=</operator> <name>nullptr</name></expr></argument>,
<argument><expr><name>ASTNodeKind</name> <operator>*</operator><name>LeastDerivedKind</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list> const <name>override</name> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>Specificity</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>Specificity</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>LeastDerivedKind</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>LeastDerivedKind</name> <operator>=</operator> <name>Kind</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isPolymorphic</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block></expr></expr_stmt>
};





<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>ReturnType</name></expr></argument>&gt;</argument_list></name>
<name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>MatcherDescriptor</name></expr></argument>&gt;</argument_list></name>
<macro><name>makeMatcherAutoMarshall</name><argument_list>(<argument>ReturnType (*Func)()</argument>, <argument>StringRef MatcherName</argument>)</argument_list></macro> <block>{
<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>ASTNodeKind</name></expr></argument>&gt;</argument_list></name> <name>RetTypes</name></expr>;
<expr><name><name>BuildReturnTypeVector</name><argument_list type="generic">&lt;<argument><expr><name>ReturnType</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>build</name><argument_list>(<argument><expr><name>RetTypes</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>std</name><operator>::</operator><call><name><name>make_unique</name><argument_list type="generic">&lt;<argument><expr><name>FixedArgCountMatcherDescriptor</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name><name>matcherMarshall0</name><argument_list type="generic">&lt;<argument><expr><name>ReturnType</name></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>void</name> <operator>(</operator><operator>*</operator><operator>)</operator><operator>(</operator><operator>)</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Func</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>MatcherName</name></expr></argument>, <argument><expr><name>RetTypes</name></expr></argument>, <argument><expr><name>None</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>ReturnType</name></expr></argument>, <argument><expr><name>typename</name> <name>ArgType1</name></expr></argument>&gt;</argument_list></name>
<name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>MatcherDescriptor</name></expr></argument>&gt;</argument_list></name>
<macro><name>makeMatcherAutoMarshall</name><argument_list>(<argument>ReturnType (*Func)(ArgType1)</argument>, <argument>StringRef MatcherName</argument>)</argument_list></macro> <block>{
<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>ASTNodeKind</name></expr></argument>&gt;</argument_list></name> <name>RetTypes</name></expr>;
<expr><name><name>BuildReturnTypeVector</name><argument_list type="generic">&lt;<argument><expr><name>ReturnType</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>build</name><argument_list>(<argument><expr><name>RetTypes</name></expr></argument>)</argument_list></call></expr>;
<expr><name>ArgKind</name> <name>AK</name> <operator>=</operator> <name><name>ArgTypeTraits</name><argument_list type="generic">&lt;<argument><expr><name>ArgType1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>getKind</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><name>std</name><operator>::</operator><call><name><name>make_unique</name><argument_list type="generic">&lt;<argument><expr><name>FixedArgCountMatcherDescriptor</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name><name>matcherMarshall1</name><argument_list type="generic">&lt;<argument><expr><name>ReturnType</name></expr></argument>, <argument><expr><name>ArgType1</name></expr></argument>&gt;</argument_list></name></expr></argument>,
<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>void</name> <operator>(</operator><operator>*</operator><operator>)</operator><operator>(</operator><operator>)</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Func</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MatcherName</name></expr></argument>, <argument><expr><name>RetTypes</name></expr></argument>, <argument><expr><name>AK</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>ReturnType</name></expr></argument>, <argument><expr><name>typename</name> <name>ArgType1</name></expr></argument>, <argument><expr><name>typename</name> <name>ArgType2</name></expr></argument>&gt;</argument_list></name>
<name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>MatcherDescriptor</name></expr></argument>&gt;</argument_list></name>
<macro><name>makeMatcherAutoMarshall</name><argument_list>(<argument>ReturnType (*Func)(ArgType1, ArgType2)</argument>,
<argument>StringRef MatcherName</argument>)</argument_list></macro> <block>{
<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>ASTNodeKind</name></expr></argument>&gt;</argument_list></name> <name>RetTypes</name></expr>;
<expr><name><name>BuildReturnTypeVector</name><argument_list type="generic">&lt;<argument><expr><name>ReturnType</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>build</name><argument_list>(<argument><expr><name>RetTypes</name></expr></argument>)</argument_list></call></expr>;
<expr><name>ArgKind</name> <name><name>AKs</name><index>[]</index></name> <operator>=</operator> <block>{ <expr><name><name>ArgTypeTraits</name><argument_list type="generic">&lt;<argument><expr><name>ArgType1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>getKind</name><argument_list>()</argument_list></call></expr>,
<expr><name><name>ArgTypeTraits</name><argument_list type="generic">&lt;<argument><expr><name>ArgType2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>getKind</name><argument_list>()</argument_list></macro></expr> }</block></expr>;
<return>return <expr><name>std</name><operator>::</operator><call><name><name>make_unique</name><argument_list type="generic">&lt;<argument><expr><name>FixedArgCountMatcherDescriptor</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name><name>matcherMarshall2</name><argument_list type="generic">&lt;<argument><expr><name>ReturnType</name></expr></argument>, <argument><expr><name>ArgType1</name></expr></argument>, <argument><expr><name>ArgType2</name></expr></argument>&gt;</argument_list></name></expr></argument>,
<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>void</name> <operator>(</operator><operator>*</operator><operator>)</operator><operator>(</operator><operator>)</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Func</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MatcherName</name></expr></argument>, <argument><expr><name>RetTypes</name></expr></argument>, <argument><expr><name>AKs</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>ReturnType</name></expr></argument>&gt;</argument_list></name>
<name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>MatcherDescriptor</name></expr></argument>&gt;</argument_list></name> <macro><name>makeMatcherRegexMarshall</name><argument_list>(
<argument>ReturnType (*FuncFlags)(llvm::StringRef, llvm::Regex::RegexFlags)</argument>,
<argument>ReturnType (*Func)(llvm::StringRef)</argument>)</argument_list></macro> <block>{
<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>ASTNodeKind</name></expr></argument>&gt;</argument_list></name> <name>RetTypes</name></expr>;
<expr><name><name>BuildReturnTypeVector</name><argument_list type="generic">&lt;<argument><expr><name>ReturnType</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>build</name><argument_list>(<argument><expr><name>RetTypes</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>std</name><operator>::</operator><call><name><name>make_unique</name><argument_list type="generic">&lt;<argument><expr><name><name>RegexMatcherDescriptor</name><argument_list type="generic">&lt;<argument><expr><name>ReturnType</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>FuncFlags</name></expr></argument>, <argument><expr><name>Func</name></expr></argument>,
<argument><expr><name>RetTypes</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>ResultT</name></expr></argument>, <argument><expr><name>typename</name> <name>ArgT</name></expr></argument>,
<argument><expr><name>ResultT</name> <operator>(</operator><operator>*</operator><name>Func</name><operator>)</operator><operator>(</operator><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ArgT</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>)</operator></expr></argument>&gt;</argument_list></name>
<name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>MatcherDescriptor</name></expr></argument>&gt;</argument_list></name> <macro><name>makeMatcherAutoMarshall</name><argument_list>(
<argument>ast_matchers::internal::VariadicFunction&lt;ResultT</argument>, <argument>ArgT</argument>, <argument>Func&gt; VarFunc</argument>,
<argument>StringRef MatcherName</argument>)</argument_list></macro> <block>{
<return>return <expr><name>std</name><operator>::</operator><call><name><name>make_unique</name><argument_list type="generic">&lt;<argument><expr><name>VariadicFuncMatcherDescriptor</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>VarFunc</name></expr></argument>, <argument><expr><name>MatcherName</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>





<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>BaseT</name></expr></argument>, <argument><expr><name>typename</name> <name>DerivedT</name></expr></argument>&gt;</argument_list></name>
<name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>MatcherDescriptor</name></expr></argument>&gt;</argument_list></name> <macro><name>makeMatcherAutoMarshall</name><argument_list>(
<argument>ast_matchers::internal::VariadicDynCastAllOfMatcher&lt;BaseT</argument>, <argument>DerivedT&gt;
VarFunc</argument>,
<argument>StringRef MatcherName</argument>)</argument_list></macro> <block>{
<return>return <expr><name>std</name><operator>::</operator><call><name><name>make_unique</name><argument_list type="generic">&lt;<argument><expr><name>DynCastAllOfMatcherDescriptor</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>VarFunc</name></expr></argument>, <argument><expr><name>MatcherName</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>ToArg</name></expr></argument>, <argument><expr><name>typename</name> <name>FromArg</name></expr></argument>&gt;</argument_list></name> <name>class</name> <name>ArgumentAdapterT</name></expr></argument>,
<argument><expr><name>typename</name> <name>FromTypes</name></expr></argument>, <argument><expr><name>typename</name> <name>ToTypes</name></expr></argument>&gt;</argument_list></name>
<name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>MatcherDescriptor</name></expr></argument>&gt;</argument_list></name> <macro><name>makeMatcherAutoMarshall</name><argument_list>(
<argument>ast_matchers::internal::ArgumentAdaptingMatcherFunc&lt;ArgumentAdapterT</argument>,
<argument>FromTypes</argument>, <argument>ToTypes&gt;</argument>,
<argument>StringRef MatcherName</argument>)</argument_list></macro> <block>{
<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>MatcherDescriptor</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <name>Overloads</name></expr>;
<expr><call><name><name>AdaptativeOverloadCollector</name><argument_list type="generic">&lt;<argument><expr><name>ArgumentAdapterT</name></expr></argument>, <argument><expr><name>FromTypes</name></expr></argument>, <argument><expr><name>ToTypes</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>MatcherName</name></expr></argument>,
<argument><expr><name>Overloads</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>std</name><operator>::</operator><call><name><name>make_unique</name><argument_list type="generic">&lt;<argument><expr><name>OverloadedMatcherDescriptor</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Overloads</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>ToArg</name></expr></argument>, <argument><expr><name>typename</name> <name>FromArg</name></expr></argument>&gt;</argument_list></name> <name>class</name> <name>ArgumentAdapterT</name></expr></argument>,
<argument><expr><name>typename</name> <name>FromTypes</name></expr></argument>, <argument><expr><name>typename</name> <name>ToTypes</name></expr></argument>&gt;</argument_list></name>
<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>FromTypeList</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>void</name> <name><name>AdaptativeOverloadCollector</name><argument_list type="generic">&lt;<argument><expr><name>ArgumentAdapterT</name></expr></argument>, <argument><expr><name>FromTypes</name></expr></argument>,
<argument><expr><name>ToTypes</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>collect</name><argument_list>(<argument>FromTypeList</argument>)</argument_list></macro> <block>{
<expr><call><name><name>Out</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><macro><name>makeMatcherAutoMarshall</name><argument_list>(
<argument>&amp;AdaptativeFunc::template create&lt;typename FromTypeList::head&gt;</argument>, <argument>Name</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr>;
<macro><name>collect</name><argument_list>(<argument>typename FromTypeList::tail()</argument>)</argument_list></macro>;
}</block>


<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>MinCount</name></expr></argument>, <argument><expr><name>unsigned</name> <name>MaxCount</name></expr></argument>&gt;</argument_list></name>
<name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>MatcherDescriptor</name></expr></argument>&gt;</argument_list></name> <macro><name>makeMatcherAutoMarshall</name><argument_list>(
<argument>ast_matchers::internal::VariadicOperatorMatcherFunc&lt;MinCount</argument>, <argument>MaxCount&gt;
Func</argument>,
<argument>StringRef MatcherName</argument>)</argument_list></macro> <block>{
<return>return <expr><name>std</name><operator>::</operator><call><name><name>make_unique</name><argument_list type="generic">&lt;<argument><expr><name>VariadicOperatorMatcherDescriptor</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name>MinCount</name></expr></argument>, <argument><expr><name>MaxCount</name></expr></argument>, <argument><expr><name><name>Func</name><operator>.</operator><name>Op</name></name></expr></argument>, <argument><expr><name>MatcherName</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>CladeType</name></expr></argument>, <argument><expr><name>typename</name><modifier>...</modifier> <name>MatcherT</name></expr></argument>&gt;</argument_list></name>
<name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>MatcherDescriptor</name></expr></argument>&gt;</argument_list></name> <macro><name>makeMatcherAutoMarshall</name><argument_list>(
<argument>ast_matchers::internal::MapAnyOfMatcherImpl&lt;CladeType</argument>, <argument>MatcherT...&gt;</argument>,
<argument>StringRef MatcherName</argument>)</argument_list></macro> <block>{
<return>return <expr><name>std</name><operator>::</operator><macro><name>make_unique</name></macro><operator>&lt;</operator><name>MapAnyOfMatcherDescriptor</name><operator>&gt;</operator><operator>(</operator>
<name>ASTNodeKind</name><operator>::</operator><call><name><name>getFromNodeKind</name><argument_list type="generic">&lt;<argument><expr><name>CladeType</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><operator>,</operator>
<name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>ASTNodeKind</name></expr></argument>&gt;</argument_list></name><block>{<expr><name>ASTNodeKind</name><operator>::</operator><call><name><name>getFromNodeKind</name><argument_list type="generic">&lt;<argument><expr><name>MatcherT</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><operator>...</operator></expr>}</block><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>

}
}
}
}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
