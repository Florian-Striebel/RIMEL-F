<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/utils/TableGen/ASTTableGen.h">







<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>CLANG_AST_TABLEGEN_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLANG_AST_TABLEGEN_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/TableGen/Record.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/STLExtras.h"</cpp:file></cpp:include>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HasPropertiesClassName</name></cpp:macro> <cpp:value>"HasProperties"</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASTNodeClassName</name></cpp:macro> <cpp:value>"ASTNode"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BaseFieldName</name></cpp:macro> <cpp:value>"Base"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AbstractFieldName</name></cpp:macro> <cpp:value>"Abstract"</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CommentNodeClassName</name></cpp:macro> <cpp:value>"CommentNode"</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DeclNodeClassName</name></cpp:macro> <cpp:value>"DeclNode"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DeclContextNodeClassName</name></cpp:macro> <cpp:value>"DeclContext"</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>StmtNodeClassName</name></cpp:macro> <cpp:value>"StmtNode"</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TypeNodeClassName</name></cpp:macro> <cpp:value>"TypeNode"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AlwaysDependentClassName</name></cpp:macro> <cpp:value>"AlwaysDependent"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NeverCanonicalClassName</name></cpp:macro> <cpp:value>"NeverCanonical"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NeverCanonicalUnlessDependentClassName</name></cpp:macro> <cpp:value>"NeverCanonicalUnlessDependent"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LeafTypeClassName</name></cpp:macro> <cpp:value>"LeafType"</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TypeKindClassName</name></cpp:macro> <cpp:value>"PropertyTypeKind"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>KindTypeFieldName</name></cpp:macro> <cpp:value>"KindType"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>KindPropertyNameFieldName</name></cpp:macro> <cpp:value>"KindPropertyName"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TypeCaseClassName</name></cpp:macro> <cpp:value>"PropertyTypeCase"</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PropertyClassName</name></cpp:macro> <cpp:value>"Property"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ClassFieldName</name></cpp:macro> <cpp:value>"Class"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NameFieldName</name></cpp:macro> <cpp:value>"Name"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TypeFieldName</name></cpp:macro> <cpp:value>"Type"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ReadFieldName</name></cpp:macro> <cpp:value>"Read"</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PropertyTypeClassName</name></cpp:macro> <cpp:value>"PropertyType"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CXXTypeNameFieldName</name></cpp:macro> <cpp:value>"CXXName"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PassByReferenceFieldName</name></cpp:macro> <cpp:value>"PassByReference"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ConstWhenWritingFieldName</name></cpp:macro> <cpp:value>"ConstWhenWriting"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ConditionalCodeFieldName</name></cpp:macro> <cpp:value>"Conditional"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PackOptionalCodeFieldName</name></cpp:macro> <cpp:value>"PackOptional"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UnpackOptionalCodeFieldName</name></cpp:macro> <cpp:value>"UnpackOptional"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BufferElementTypesFieldName</name></cpp:macro> <cpp:value>"BufferElementTypes"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ArrayTypeClassName</name></cpp:macro> <cpp:value>"Array"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ArrayElementTypeFieldName</name></cpp:macro> <cpp:value>"Element"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OptionalTypeClassName</name></cpp:macro> <cpp:value>"Optional"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OptionalElementTypeFieldName</name></cpp:macro> <cpp:value>"Element"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SubclassPropertyTypeClassName</name></cpp:macro> <cpp:value>"SubclassPropertyType"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SubclassBaseTypeFieldName</name></cpp:macro> <cpp:value>"Base"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SubclassClassNameFieldName</name></cpp:macro> <cpp:value>"SubclassName"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EnumPropertyTypeClassName</name></cpp:macro> <cpp:value>"EnumPropertyType"</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ReadHelperRuleClassName</name></cpp:macro> <cpp:value>"ReadHelper"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HelperCodeFieldName</name></cpp:macro> <cpp:value>"Code"</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CreationRuleClassName</name></cpp:macro> <cpp:value>"Creator"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CreateFieldName</name></cpp:macro> <cpp:value>"Create"</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OverrideRuleClassName</name></cpp:macro> <cpp:value>"Override"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IgnoredPropertiesFieldName</name></cpp:macro> <cpp:value>"IgnoredProperties"</cpp:value></cpp:define>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>
<decl_stmt><decl><type><name>namespace</name></type> <name>tblgen</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>WrappedRecord</name> <block>{<block_content>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Record</name> <operator>*</operator><name>Record</name></expr>;</expr_stmt>

<label><name>protected</name>:</label>
<expr_stmt><expr><call><name>WrappedRecord</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Record</name> <operator>*</operator><name>record</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>Record</name><argument_list>(<argument>record</argument>)</argument_list></macro> <block>{}</block>

<name>llvm</name><operator>::</operator><name>Record</name> <operator>*</operator><macro><name>get</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Record</name> <operator>&amp;&amp;</operator> <literal type="string">"accessing null record"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Record</name></expr>;</return>
}</block></expr></expr_stmt>

<label><name>public</name>:</label>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Record</name> <operator>*</operator><macro><name>getRecord</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Record</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>explicit</name> <name>operator</name> <macro><name>bool</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Record</name> <operator>!=</operator> <name>nullptr</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>SMLoc</name></expr></argument>&gt;</argument_list></name> <macro><name>getLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>get</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>isSubClassOf</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>StringRef</name> <name>className</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>get</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isSubClassOf</name><argument_list>(<argument><expr><name>className</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>NodeClass</name></expr></argument>&gt;</argument_list></name>
<name>NodeClass</name> <macro><name>getAs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>(</operator><call><name>isSubClassOf</name><argument_list>(<argument><expr><name>NodeClass</name><operator>::</operator><call><name>getTableGenNodeClassName</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>
<operator>?</operator> <call><name>NodeClass</name><argument_list>(<argument><expr><call><name>get</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>:</operator> <call><name>NodeClass</name><argument_list>()</argument_list></call><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>friend</name> <name>bool</name> <name>operator</name><operator>&lt;</operator><operator>(</operator><name>WrappedRecord</name> <name>lhs</name><operator>,</operator> <name>WrappedRecord</name> <name>rhs</name><operator>)</operator> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>lhs</name> <operator>&amp;&amp;</operator> <name>rhs</name> <operator>&amp;&amp;</operator> <literal type="string">"sorting null nodes"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>lhs</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getName</name><argument_list>()</argument_list></call> <operator>&lt;</operator> <call><name><name>rhs</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getName</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>friend</name> <name>bool</name> <name>operator</name><operator>&gt;</operator><operator>(</operator><name>WrappedRecord</name> <name>lhs</name><operator>,</operator> <name>WrappedRecord</name> <name>rhs</name><operator>)</operator> <block>{
<return>return <expr><name>rhs</name> <operator>&lt;</operator> <name>lhs</name></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>friend</name> <name>bool</name> <name>operator</name><operator>&lt;=</operator><operator>(</operator><name>WrappedRecord</name> <name>lhs</name><operator>,</operator> <name>WrappedRecord</name> <name>rhs</name><operator>)</operator> <block>{
<return>return <expr><operator>!</operator><operator>(</operator><name>rhs</name> <operator>&lt;</operator> <name>lhs</name><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>friend</name> <name>bool</name> <name>operator</name><operator>&gt;=</operator><operator>(</operator><name>WrappedRecord</name> <name>lhs</name><operator>,</operator> <name>WrappedRecord</name> <name>rhs</name><operator>)</operator> <block>{
<return>return <expr><operator>!</operator><operator>(</operator><name>lhs</name> <operator>&lt;</operator> <name>rhs</name><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>friend</name> <name>bool</name> <name>operator</name><operator>==</operator><operator>(</operator><name>WrappedRecord</name> <name>lhs</name><operator>,</operator> <name>WrappedRecord</name> <name>rhs</name><operator>)</operator> <block>{

<return>return <expr><call><name><name>lhs</name><operator>.</operator><name>getRecord</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>rhs</name><operator>.</operator><name>getRecord</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>friend</name> <name>bool</name> <name>operator</name><operator>!=</operator><operator>(</operator><name>WrappedRecord</name> <name>lhs</name><operator>,</operator> <name>WrappedRecord</name> <name>rhs</name><operator>)</operator> <block>{
<return>return <expr><operator>!</operator><operator>(</operator><name>lhs</name> <operator>==</operator> <name>rhs</name><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>HasProperties</name> <range>: <expr><name>public</name> <name>WrappedRecord</name> <block>{
<expr><name>public</name><operator>:</operator>
<specifier>static</specifier> <name>constexpr</name> <name>llvm</name><operator>::</operator><name>StringRef</name> <name>ClassName</name> <operator>=</operator> <name>HasPropertiesClassName</name></expr>;

<expr><call><name>HasProperties</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Record</name> <operator>*</operator><name>record</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>WrappedRecord</name><argument_list>(<argument>record</argument>)</argument_list></macro> <block>{}</block>

<name>llvm</name><operator>::</operator><name>StringRef</name> <macro><name>getName</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><specifier>static</specifier> <name>llvm</name><operator>::</operator><name>StringRef</name> <macro><name>getTableGenNodeClassName</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name>HasPropertiesClassName</name></expr>;</return>
}</block>
}</expr>;



<expr><name>class</name> <name>ASTNode</name> <operator>:</operator> <name>public</name> <name>HasProperties</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>ASTNode</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Record</name> <operator>*</operator><name>record</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>HasProperties</name><argument_list>(<argument>record</argument>)</argument_list></macro> <block>{}</block>

<name>llvm</name><operator>::</operator><name>StringRef</name> <macro><name>getName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>get</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getName</name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>ASTNode</name> <macro><name>getBase</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>get</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getValueAsOptionalDef</name><argument_list>(<argument><expr><name>BaseFieldName</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>bool</name> <macro><name>isAbstract</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>get</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getValueAsBit</name><argument_list>(<argument><expr><name>AbstractFieldName</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>llvm</name><operator>::</operator><name>StringRef</name> <macro><name>getTableGenNodeClassName</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name>ASTNodeClassName</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>DeclNode</name> <operator>:</operator> <name>public</name> <name>ASTNode</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>DeclNode</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Record</name> <operator>*</operator><name>record</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>ASTNode</name><argument_list>(<argument>record</argument>)</argument_list></macro> <block>{}</block>

<name>llvm</name><operator>::</operator><name>StringRef</name> <macro><name>getId</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>std</name><operator>::</operator><name>string</name> <macro><name>getClassName</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>DeclNode</name> <macro><name>getBase</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>DeclNode</name><argument_list>(<argument><expr><name>ASTNode</name><operator>::</operator><call><name>getBase</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getRecord</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>llvm</name><operator>::</operator><name>StringRef</name> <macro><name>getASTHierarchyName</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><literal type="string">"Decl"</literal></expr>;</return>
}</block>
<specifier>static</specifier> <name>llvm</name><operator>::</operator><name>StringRef</name> <macro><name>getASTIdTypeName</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><literal type="string">"Decl::Kind"</literal></expr>;</return>
}</block>
<specifier>static</specifier> <name>llvm</name><operator>::</operator><name>StringRef</name> <macro><name>getASTIdAccessorName</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><literal type="string">"getKind"</literal></expr>;</return>
}</block>
<specifier>static</specifier> <name>llvm</name><operator>::</operator><name>StringRef</name> <macro><name>getTableGenNodeClassName</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name>DeclNodeClassName</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>TypeNode</name> <operator>:</operator> <name>public</name> <name>ASTNode</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>TypeNode</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Record</name> <operator>*</operator><name>record</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>ASTNode</name><argument_list>(<argument>record</argument>)</argument_list></macro> <block>{}</block>

<name>llvm</name><operator>::</operator><name>StringRef</name> <macro><name>getId</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>llvm</name><operator>::</operator><name>StringRef</name> <macro><name>getClassName</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>TypeNode</name> <macro><name>getBase</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>TypeNode</name><argument_list>(<argument><expr><name>ASTNode</name><operator>::</operator><call><name>getBase</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getRecord</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>llvm</name><operator>::</operator><name>StringRef</name> <macro><name>getASTHierarchyName</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><literal type="string">"Type"</literal></expr>;</return>
}</block>
<specifier>static</specifier> <name>llvm</name><operator>::</operator><name>StringRef</name> <macro><name>getASTIdTypeName</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><literal type="string">"Type::TypeClass"</literal></expr>;</return>
}</block>
<specifier>static</specifier> <name>llvm</name><operator>::</operator><name>StringRef</name> <macro><name>getASTIdAccessorName</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><literal type="string">"getTypeClass"</literal></expr>;</return>
}</block>
<specifier>static</specifier> <name>llvm</name><operator>::</operator><name>StringRef</name> <macro><name>getTableGenNodeClassName</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name>TypeNodeClassName</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>StmtNode</name> <operator>:</operator> <name>public</name> <name>ASTNode</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>StmtNode</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Record</name> <operator>*</operator><name>record</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>ASTNode</name><argument_list>(<argument>record</argument>)</argument_list></macro> <block>{}</block>

<name>std</name><operator>::</operator><name>string</name> <macro><name>getId</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>llvm</name><operator>::</operator><name>StringRef</name> <macro><name>getClassName</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>StmtNode</name> <macro><name>getBase</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>StmtNode</name><argument_list>(<argument><expr><name>ASTNode</name><operator>::</operator><call><name>getBase</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getRecord</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>llvm</name><operator>::</operator><name>StringRef</name> <macro><name>getASTHierarchyName</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><literal type="string">"Stmt"</literal></expr>;</return>
}</block>
<specifier>static</specifier> <name>llvm</name><operator>::</operator><name>StringRef</name> <macro><name>getASTIdTypeName</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><literal type="string">"Stmt::StmtClass"</literal></expr>;</return>
}</block>
<specifier>static</specifier> <name>llvm</name><operator>::</operator><name>StringRef</name> <macro><name>getASTIdAccessorName</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><literal type="string">"getStmtClass"</literal></expr>;</return>
}</block>
<specifier>static</specifier> <name>llvm</name><operator>::</operator><name>StringRef</name> <macro><name>getTableGenNodeClassName</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name>StmtNodeClassName</name></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>PropertyType</name> <operator>:</operator> <name>public</name> <name>WrappedRecord</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>PropertyType</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Record</name> <operator>*</operator><name>record</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>WrappedRecord</name><argument_list>(<argument>record</argument>)</argument_list></macro> <block>{}</block>


<name>bool</name> <macro><name>isGenericSpecialization</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>get</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isAnonymous</name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<name>llvm</name><operator>::</operator><name>StringRef</name> <macro><name>getAbstractTypeName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>get</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getName</name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<name>llvm</name><operator>::</operator><name>StringRef</name> <macro><name>getCXXTypeName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>get</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getValueAsString</name><argument_list>(<argument><expr><name>CXXTypeNameFieldName</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>void</name> <macro><name>emitCXXValueTypeName</name><argument_list>(<argument>bool forRead</argument>, <argument>llvm::raw_ostream &amp;out</argument>)</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>bool</name> <macro><name>shouldPassByReference</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>get</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getValueAsBit</name><argument_list>(<argument><expr><name>PassByReferenceFieldName</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<name>bool</name> <macro><name>isConstWhenWriting</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>get</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getValueAsBit</name><argument_list>(<argument><expr><name>ConstWhenWritingFieldName</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>PropertyType</name> <macro><name>getArrayElementType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>isSubClassOf</name><argument_list>(<argument><expr><name>ArrayTypeClassName</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>get</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getValueAsDef</name><argument_list>(<argument><expr><name>ArrayElementTypeFieldName</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><name>nullptr</name></expr>;</return>
}</block>


<name>PropertyType</name> <macro><name>getOptionalElementType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>isSubClassOf</name><argument_list>(<argument><expr><name>OptionalTypeClassName</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>get</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getValueAsDef</name><argument_list>(<argument><expr><name>OptionalElementTypeFieldName</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><name>nullptr</name></expr>;</return>
}</block>


<name>PropertyType</name> <macro><name>getSuperclassType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>isSubClassOf</name><argument_list>(<argument><expr><name>SubclassPropertyTypeClassName</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>get</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getValueAsDef</name><argument_list>(<argument><expr><name>SubclassBaseTypeFieldName</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><name>nullptr</name></expr>;</return>
}</block>




<name>llvm</name><operator>::</operator><name>StringRef</name> <macro><name>getSubclassClassName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>get</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getValueAsString</name><argument_list>(<argument><expr><name>SubclassClassNameFieldName</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>bool</name> <macro><name>isEnum</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isSubClassOf</name><argument_list>(<argument><expr><name>EnumPropertyTypeClassName</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>llvm</name><operator>::</operator><name>StringRef</name> <macro><name>getPackOptionalCode</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>get</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getValueAsString</name><argument_list>(<argument><expr><name>PackOptionalCodeFieldName</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>llvm</name><operator>::</operator><name>StringRef</name> <macro><name>getUnpackOptionalCode</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>get</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getValueAsString</name><argument_list>(<argument><expr><name>UnpackOptionalCodeFieldName</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Record</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getBufferElementTypes</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>get</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getValueAsListOfDefs</name><argument_list>(<argument><expr><name>BufferElementTypesFieldName</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>llvm</name><operator>::</operator><name>StringRef</name> <macro><name>getTableGenNodeClassName</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name>PropertyTypeClassName</name></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>TypeKindRule</name> <operator>:</operator> <name>public</name> <name>WrappedRecord</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>TypeKindRule</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Record</name> <operator>*</operator><name>record</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>WrappedRecord</name><argument_list>(<argument>record</argument>)</argument_list></macro> <block>{}</block>


<name>PropertyType</name> <macro><name>getParentType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>get</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getValueAsDef</name><argument_list>(<argument><expr><name>TypeFieldName</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>PropertyType</name> <macro><name>getKindType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>get</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getValueAsDef</name><argument_list>(<argument><expr><name>KindTypeFieldName</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>llvm</name><operator>::</operator><name>StringRef</name> <macro><name>getKindPropertyName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>get</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getValueAsString</name><argument_list>(<argument><expr><name>KindPropertyNameFieldName</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>llvm</name><operator>::</operator><name>StringRef</name> <macro><name>getReadCode</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>get</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getValueAsString</name><argument_list>(<argument><expr><name>ReadFieldName</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>llvm</name><operator>::</operator><name>StringRef</name> <macro><name>getTableGenNodeClassName</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name>TypeKindClassName</name></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>TypeCase</name> <operator>:</operator> <name>public</name> <name>HasProperties</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>TypeCase</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Record</name> <operator>*</operator><name>record</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>HasProperties</name><argument_list>(<argument>record</argument>)</argument_list></macro> <block>{}</block>


<name>llvm</name><operator>::</operator><name>StringRef</name> <macro><name>getCaseName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>get</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getValueAsString</name><argument_list>(<argument><expr><name>NameFieldName</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>PropertyType</name> <macro><name>getParentType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>get</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getValueAsDef</name><argument_list>(<argument><expr><name>TypeFieldName</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>llvm</name><operator>::</operator><name>StringRef</name> <macro><name>getTableGenNodeClassName</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name>TypeCaseClassName</name></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>Property</name> <operator>:</operator> <name>public</name> <name>WrappedRecord</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>Property</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Record</name> <operator>*</operator><name>record</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>WrappedRecord</name><argument_list>(<argument>record</argument>)</argument_list></macro> <block>{}</block>


<name>llvm</name><operator>::</operator><name>StringRef</name> <macro><name>getName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>get</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getValueAsString</name><argument_list>(<argument><expr><name>NameFieldName</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>PropertyType</name> <macro><name>getType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>get</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getValueAsDef</name><argument_list>(<argument><expr><name>TypeFieldName</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>HasProperties</name> <macro><name>getClass</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>get</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getValueAsDef</name><argument_list>(<argument><expr><name>ClassFieldName</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>llvm</name><operator>::</operator><name>StringRef</name> <macro><name>getReadCode</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>get</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getValueAsString</name><argument_list>(<argument><expr><name>ReadFieldName</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>llvm</name><operator>::</operator><name>StringRef</name> <macro><name>getCondition</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>get</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getValueAsString</name><argument_list>(<argument><expr><name>ConditionalCodeFieldName</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>llvm</name><operator>::</operator><name>StringRef</name> <macro><name>getTableGenNodeClassName</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name>PropertyClassName</name></expr>;</return>
}</block>
}</expr>;



<expr><name>class</name> <name>ReadHelperRule</name> <operator>:</operator> <name>public</name> <name>WrappedRecord</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>ReadHelperRule</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Record</name> <operator>*</operator><name>record</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>WrappedRecord</name><argument_list>(<argument>record</argument>)</argument_list></macro> <block>{}</block>



<name>HasProperties</name> <macro><name>getClass</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>get</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getValueAsDef</name><argument_list>(<argument><expr><name>ClassFieldName</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>llvm</name><operator>::</operator><name>StringRef</name> <macro><name>getHelperCode</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>get</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getValueAsString</name><argument_list>(<argument><expr><name>HelperCodeFieldName</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>llvm</name><operator>::</operator><name>StringRef</name> <macro><name>getTableGenNodeClassName</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name>ReadHelperRuleClassName</name></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>CreationRule</name> <operator>:</operator> <name>public</name> <name>WrappedRecord</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>CreationRule</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Record</name> <operator>*</operator><name>record</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>WrappedRecord</name><argument_list>(<argument>record</argument>)</argument_list></macro> <block>{}</block>



<name>HasProperties</name> <macro><name>getClass</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>get</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getValueAsDef</name><argument_list>(<argument><expr><name>ClassFieldName</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>llvm</name><operator>::</operator><name>StringRef</name> <macro><name>getCreationCode</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>get</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getValueAsString</name><argument_list>(<argument><expr><name>CreateFieldName</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>llvm</name><operator>::</operator><name>StringRef</name> <macro><name>getTableGenNodeClassName</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name>CreationRuleClassName</name></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>OverrideRule</name> <operator>:</operator> <name>public</name> <name>WrappedRecord</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>OverrideRule</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Record</name> <operator>*</operator><name>record</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>WrappedRecord</name><argument_list>(<argument>record</argument>)</argument_list></macro> <block>{}</block>



<name>HasProperties</name> <macro><name>getClass</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>get</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getValueAsDef</name><argument_list>(<argument><expr><name>ClassFieldName</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>




<name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>StringRef</name></expr></argument>&gt;</argument_list></name> <macro><name>getIgnoredProperties</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>get</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getValueAsListOfStrings</name><argument_list>(<argument><expr><name>IgnoredPropertiesFieldName</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>llvm</name><operator>::</operator><name>StringRef</name> <macro><name>getTableGenNodeClassName</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name>OverrideRuleClassName</name></expr>;</return>
}</block>
}</expr>;



<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>NodeClass</name></expr></argument>&gt;</argument_list></name>
<name>using</name> <name>ASTNodeHierarchyVisitor</name> <operator>=</operator>
<name>llvm</name><operator>::</operator><name><name>function_ref</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>(</operator><name>NodeClass</name> <name>node</name>, <name>NodeClass</name> <name>base</name><operator>)</operator></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>void</name> <macro><name>visitASTNodeHierarchyImpl</name><argument_list>(<argument>llvm::RecordKeeper &amp;records</argument>,
<argument>llvm::StringRef nodeClassName</argument>,
<argument>ASTNodeHierarchyVisitor&lt;ASTNode&gt; visit</argument>)</argument_list></macro></expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>NodeClass</name></expr></argument>&gt;</argument_list></name>
<name>void</name> <macro><name>visitASTNodeHierarchy</name><argument_list>(<argument>llvm::RecordKeeper &amp;records</argument>,
<argument>ASTNodeHierarchyVisitor&lt;NodeClass&gt; visit</argument>)</argument_list></macro> <block>{
<expr><call><name>visitASTNodeHierarchyImpl</name><argument_list>(<argument><expr><name>records</name></expr></argument>, <argument><expr><name>NodeClass</name><operator>::</operator><call><name>getTableGenNodeClassName</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><index>[<expr><name>visit</name></expr>]</index><operator>(</operator><name>ASTNode</name> <name>node</name>, <name>ASTNode</name> <name>base</name><operator>)</operator> <block>{
<expr><call><name>visit</name><argument_list>(<argument><expr><call><name>NodeClass</name><argument_list>(<argument><expr><call><name><name>node</name><operator>.</operator><name>getRecord</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>NodeClass</name><argument_list>(<argument><expr><call><name><name>base</name><operator>.</operator><name>getRecord</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block></expr></argument>)</argument_list></call></expr>;
}</block></expr>

}</block></expr>
}</block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></range></decl></decl_stmt></block_content></block></decl></decl_stmt></block_content></block></decl></decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
