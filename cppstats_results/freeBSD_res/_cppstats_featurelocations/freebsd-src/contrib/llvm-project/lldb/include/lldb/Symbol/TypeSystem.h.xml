<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/lldb/include/lldb/Symbol/TypeSystem.h">







<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLDB_SYMBOL_TYPESYSTEM_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLDB_SYMBOL_TYPESYSTEM_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;functional&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;map&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mutex&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/APFloat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/APSInt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/SmallBitVector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Casting.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Error.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lldb/Core/PluginInterface.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lldb/Expression/Expression.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lldb/Symbol/CompilerDecl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lldb/Symbol/CompilerDeclContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lldb/lldb-private.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><name>class</name></type> <name>DWARFDIE</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>DWARFASTParser</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>PDBASTParser</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>lldb_private</name> <block>{<block_content>






<struct>struct <name>LanguageSet</name> <block>{
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>SmallBitVector</name> <name>bitvector</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>LanguageSet</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>lldb</name><operator>::</operator><name>LanguageType</name></expr></argument>&gt;</argument_list></name> <call><name>GetSingularLanguage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>Insert</name><argument_list>(<argument><expr><name>lldb</name><operator>::</operator><name>LanguageType</name> <name>language</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>Empty</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<expr_stmt><expr><name>size_t</name> <macro><name>Size</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name><name>operator</name><index>[]</index></name><argument_list>(<argument><expr><name>unsigned</name> <name>i</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
}</block>;</struct>




















<decl_stmt><decl><type><name>class</name></type> <name>TypeSystem</name> <range>: <expr><name>public</name> <name>PluginInterface</name> <block>{
<expr><name>public</name><operator>:</operator>

<operator>~</operator><macro><name>TypeSystem</name><argument_list>()</argument_list></macro> <name>override</name></expr>;


<expr><name>virtual</name> <name>bool</name> <macro><name>isA</name><argument_list>(<argument>const void *ClassID</argument>)</argument_list></macro> <specifier>const</specifier> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><specifier>static</specifier> <name>lldb</name><operator>::</operator><name>TypeSystemSP</name> <macro><name>CreateInstance</name><argument_list>(<argument>lldb::LanguageType language</argument>,
<argument>Module *module</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>lldb</name><operator>::</operator><name>TypeSystemSP</name> <macro><name>CreateInstance</name><argument_list>(<argument>lldb::LanguageType language</argument>,
<argument>Target *target</argument>)</argument_list></macro></expr>;



<expr><name>virtual</name> <name>void</name> <macro><name>Finalize</name><argument_list>()</argument_list></macro> <block>{}</block>

<name>virtual</name> <name>DWARFASTParser</name> <operator>*</operator><macro><name>GetDWARFParser</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>nullptr</name></expr>;</return> }</block>
<name>virtual</name> <name>PDBASTParser</name> <operator>*</operator><macro><name>GetPDBParser</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>nullptr</name></expr>;</return> }</block>

<name>virtual</name> <name>SymbolFile</name> <operator>*</operator><macro><name>GetSymbolFile</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>m_sym_file</name></expr>;</return> }</block>


<name>virtual</name> <name>void</name> <macro><name>SetSymbolFile</name><argument_list>(<argument>SymbolFile *sym_file</argument>)</argument_list></macro> <block>{ <expr><name>m_sym_file</name> <operator>=</operator> <name>sym_file</name></expr>; }</block>


<name>virtual</name> <name>ConstString</name> <call><name>DeclGetName</name><argument_list>(<argument><expr><name>void</name> <operator>*</operator><name>opaque_decl</name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>ConstString</name> <call><name>DeclGetMangledName</name><argument_list>(<argument><expr><name>void</name> <operator>*</operator><name>opaque_decl</name></expr></argument>)</argument_list></call></expr>;

<expr><name>virtual</name> <name>CompilerDeclContext</name> <call><name>DeclGetDeclContext</name><argument_list>(<argument><expr><name>void</name> <operator>*</operator><name>opaque_decl</name></expr></argument>)</argument_list></call></expr>;

<expr><name>virtual</name> <name>CompilerType</name> <call><name>DeclGetFunctionReturnType</name><argument_list>(<argument><expr><name>void</name> <operator>*</operator><name>opaque_decl</name></expr></argument>)</argument_list></call></expr>;

<expr><name>virtual</name> <name>size_t</name> <call><name>DeclGetFunctionNumArguments</name><argument_list>(<argument><expr><name>void</name> <operator>*</operator><name>opaque_decl</name></expr></argument>)</argument_list></call></expr>;

<expr><name>virtual</name> <name>CompilerType</name> <macro><name>DeclGetFunctionArgumentType</name><argument_list>(<argument>void *opaque_decl</argument>,
<argument>size_t arg_idx</argument>)</argument_list></macro></expr>;

<expr><name>virtual</name> <name>CompilerType</name> <call><name>GetTypeForDecl</name><argument_list>(<argument><expr><name>void</name> <operator>*</operator><name>opaque_decl</name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">0</literal></expr>;



<expr><name>virtual</name> <name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CompilerDecl</name></expr></argument>&gt;</argument_list></name>
<macro><name>DeclContextFindDeclByName</name><argument_list>(<argument>void *opaque_decl_ctx</argument>, <argument>ConstString name</argument>,
<argument>const bool ignore_imported_decls</argument>)</argument_list></macro></expr>;

<expr><name>virtual</name> <name>ConstString</name> <call><name>DeclContextGetName</name><argument_list>(<argument><expr><name>void</name> <operator>*</operator><name>opaque_decl_ctx</name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>ConstString</name>
<call><name>DeclContextGetScopeQualifiedName</name><argument_list>(<argument><expr><name>void</name> <operator>*</operator><name>opaque_decl_ctx</name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>bool</name> <call><name>DeclContextIsClassMethod</name><argument_list>(
<argument><expr><name>void</name> <operator>*</operator><name>opaque_decl_ctx</name></expr></argument>, <argument><expr><name>lldb</name><operator>::</operator><name>LanguageType</name> <operator>*</operator><name>language_ptr</name></expr></argument>,
<argument><expr><name>bool</name> <operator>*</operator><name>is_instance_method_ptr</name></expr></argument>, <argument><expr><name>ConstString</name> <operator>*</operator><name>language_object_name_ptr</name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>bool</name> <call><name>DeclContextIsContainedInLookup</name><argument_list>(<argument><expr><name>void</name> <operator>*</operator><name>opaque_decl_ctx</name></expr></argument>,
<argument><expr><name>void</name> <operator>*</operator><name>other_opaque_decl_ctx</name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">0</literal></expr>;


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>


<expr><name>virtual</name> <name>bool</name> <macro><name>Verify</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr><name>virtual</name> <name>bool</name> <macro><name>IsArrayType</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>,
<argument>CompilerType *element_type</argument>, <argument>uint64_t *size</argument>,
<argument>bool *is_incomplete</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>bool</name> <macro><name>IsAggregateType</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>bool</name> <macro><name>IsAnonymousType</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>)</argument_list></macro></expr>;

<expr><name>virtual</name> <name>bool</name> <macro><name>IsCharType</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>bool</name> <macro><name>IsCompleteType</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>bool</name> <macro><name>IsDefined</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>bool</name> <macro><name>IsFloatingPointType</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>,
<argument>uint32_t &amp;count</argument>, <argument>bool &amp;is_complex</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>bool</name> <macro><name>IsFunctionType</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>size_t</name>
<macro><name>GetNumberOfFunctionArguments</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>CompilerType</name>
<macro><name>GetFunctionArgumentAtIndex</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>,
<argument>const size_t index</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>bool</name> <macro><name>IsFunctionPointerType</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>bool</name> <macro><name>IsBlockPointerType</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>,
<argument>CompilerType *function_pointer_type_ptr</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>bool</name> <macro><name>IsIntegerType</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>,
<argument>bool &amp;is_signed</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>bool</name> <macro><name>IsEnumerationType</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>,
<argument>bool &amp;is_signed</argument>)</argument_list></macro> <block>{
<expr><name>is_signed</name> <operator>=</operator> <name>false</name></expr>;
<return>return <expr><name>false</name></expr>;</return>
}</block>

<name>virtual</name> <name>bool</name> <macro><name>IsScopedEnumerationType</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>bool</name> <macro><name>IsPossibleDynamicType</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>,
<argument>CompilerType *target_type</argument>,
<argument>bool check_cplusplus</argument>, <argument>bool check_objc</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>bool</name> <macro><name>IsPointerType</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>,
<argument>CompilerType *pointee_type</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>bool</name> <macro><name>IsScalarType</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>bool</name> <macro><name>IsVoidType</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>bool</name> <call><name>CanPassInRegisters</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CompilerType</name> <operator>&amp;</operator><name>type</name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">0</literal></expr>;


<expr><name>virtual</name> <name>bool</name> <macro><name>SupportsLanguage</name><argument_list>(<argument>lldb::LanguageType language</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;



<expr><name>virtual</name> <name>bool</name> <macro><name>GetCompleteType</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;



<expr><name>virtual</name> <name>uint32_t</name> <call><name>GetPointerByteSize</name><argument_list>()</argument_list></call> <operator>=</operator> <literal type="number">0</literal></expr>;



<expr><name>virtual</name> <name>ConstString</name> <macro><name>GetTypeName</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>ConstString</name> <macro><name>GetDisplayTypeName</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>uint32_t</name>
<macro><name>GetTypeInfo</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>,
<argument>CompilerType *pointee_or_element_compiler_type</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>lldb</name><operator>::</operator><name>LanguageType</name>
<macro><name>GetMinimumLanguage</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>lldb</name><operator>::</operator><name>TypeClass</name> <macro><name>GetTypeClass</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;



<expr><name>virtual</name> <name>CompilerType</name>
<macro><name>GetArrayElementType</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>,
<argument>ExecutionContextScope *exe_scope</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>CompilerType</name> <macro><name>GetArrayType</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>,
<argument>uint64_t size</argument>)</argument_list></macro></expr>;

<expr><name>virtual</name> <name>CompilerType</name> <macro><name>GetCanonicalType</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>CompilerType</name>
<macro><name>GetEnumerationIntegerType</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;



<expr><name>virtual</name> <name>int</name> <macro><name>GetFunctionArgumentCount</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>CompilerType</name>
<macro><name>GetFunctionArgumentTypeAtIndex</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>,
<argument>size_t idx</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>CompilerType</name>
<macro><name>GetFunctionReturnType</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>size_t</name> <macro><name>GetNumMemberFunctions</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>TypeMemberFunctionImpl</name>
<macro><name>GetMemberFunctionAtIndex</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>, <argument>size_t idx</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>CompilerType</name> <macro><name>GetPointeeType</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>CompilerType</name> <macro><name>GetPointerType</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>CompilerType</name>
<macro><name>GetLValueReferenceType</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>)</argument_list></macro></expr>;

<expr><name>virtual</name> <name>CompilerType</name>
<macro><name>GetRValueReferenceType</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>)</argument_list></macro></expr>;

<expr><name>virtual</name> <name>CompilerType</name> <macro><name>GetAtomicType</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>)</argument_list></macro></expr>;

<expr><name>virtual</name> <name>CompilerType</name> <macro><name>AddConstModifier</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>)</argument_list></macro></expr>;

<expr><name>virtual</name> <name>CompilerType</name> <macro><name>AddVolatileModifier</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>)</argument_list></macro></expr>;

<expr><name>virtual</name> <name>CompilerType</name> <macro><name>AddRestrictModifier</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>)</argument_list></macro></expr>;



<expr><name>virtual</name> <name>CompilerType</name> <macro><name>CreateTypedef</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>,
<argument>const char *name</argument>,
<argument>const CompilerDeclContext &amp;decl_ctx</argument>,
<argument>uint32_t opaque_payload</argument>)</argument_list></macro></expr>;



<expr><name>virtual</name> <specifier>const</specifier> <name>llvm</name><operator>::</operator><name>fltSemantics</name> <operator>&amp;</operator><macro><name>GetFloatTypeSemantics</name><argument_list>(<argument>size_t byte_size</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>uint64_t</name></expr></argument>&gt;</argument_list></name>
<macro><name>GetBitSize</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>,
<argument>ExecutionContextScope *exe_scope</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>lldb</name><operator>::</operator><name>Encoding</name> <macro><name>GetEncoding</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>,
<argument>uint64_t &amp;count</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>lldb</name><operator>::</operator><name>Format</name> <macro><name>GetFormat</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>uint32_t</name> <macro><name>GetNumChildren</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>,
<argument>bool omit_empty_base_classes</argument>,
<argument>const ExecutionContext *exe_ctx</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>CompilerType</name> <macro><name>GetBuiltinTypeByName</name><argument_list>(<argument>ConstString name</argument>)</argument_list></macro></expr>;

<expr><name>virtual</name> <name>lldb</name><operator>::</operator><name>BasicType</name>
<macro><name>GetBasicTypeEnumeration</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>void</name> <macro><name>ForEachEnumerator</name><argument_list>(
<argument>lldb::opaque_compiler_type_t type</argument>,
<argument>std::function&lt;bool(const CompilerType &amp;integer_type,
ConstString name,
const llvm::APSInt &amp;value)&gt; const &amp;callback</argument>)</argument_list></macro> <block>{}</block>

<name>virtual</name> <name>uint32_t</name> <macro><name>GetNumFields</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>CompilerType</name> <macro><name>GetFieldAtIndex</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>,
<argument>size_t idx</argument>, <argument>std::string &amp;name</argument>,
<argument>uint64_t *bit_offset_ptr</argument>,
<argument>uint32_t *bitfield_bit_size_ptr</argument>,
<argument>bool *is_bitfield_ptr</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>uint32_t</name>
<macro><name>GetNumDirectBaseClasses</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>uint32_t</name>
<macro><name>GetNumVirtualBaseClasses</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>CompilerType</name>
<macro><name>GetDirectBaseClassAtIndex</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>, <argument>size_t idx</argument>,
<argument>uint32_t *bit_offset_ptr</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>CompilerType</name>
<macro><name>GetVirtualBaseClassAtIndex</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>, <argument>size_t idx</argument>,
<argument>uint32_t *bit_offset_ptr</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>CompilerType</name> <macro><name>GetChildCompilerTypeAtIndex</name><argument_list>(
<argument>lldb::opaque_compiler_type_t type</argument>, <argument>ExecutionContext *exe_ctx</argument>, <argument>size_t idx</argument>,
<argument>bool transparent_pointers</argument>, <argument>bool omit_empty_base_classes</argument>,
<argument>bool ignore_array_bounds</argument>, <argument>std::string &amp;child_name</argument>,
<argument>uint32_t &amp;child_byte_size</argument>, <argument>int32_t &amp;child_byte_offset</argument>,
<argument>uint32_t &amp;child_bitfield_bit_size</argument>, <argument>uint32_t &amp;child_bitfield_bit_offset</argument>,
<argument>bool &amp;child_is_base_class</argument>, <argument>bool &amp;child_is_deref_of_parent</argument>,
<argument>ValueObject *valobj</argument>, <argument>uint64_t &amp;language_flags</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;



<expr><name>virtual</name> <name>uint32_t</name> <macro><name>GetIndexOfChildWithName</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>,
<argument>const char *name</argument>,
<argument>bool omit_empty_base_classes</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;







<expr><name>virtual</name> <name>size_t</name>
<macro><name>GetIndexOfChildMemberWithName</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>,
<argument>const char *name</argument>, <argument>bool omit_empty_base_classes</argument>,
<argument>std::vector&lt;uint32_t&gt; &amp;child_indexes</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>size_t</name> <macro><name>GetNumTemplateArguments</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>)</argument_list></macro></expr>;

<expr><name>virtual</name> <name>lldb</name><operator>::</operator><name>TemplateArgumentKind</name>
<macro><name>GetTemplateArgumentKind</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>, <argument>size_t idx</argument>)</argument_list></macro></expr>;
<expr><name>virtual</name> <name>CompilerType</name> <macro><name>GetTypeTemplateArgument</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>,
<argument>size_t idx</argument>)</argument_list></macro></expr>;
<expr><name>virtual</name> <name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>CompilerType</name><operator>::</operator><name>IntegralTemplateArgument</name></expr></argument>&gt;</argument_list></name>
<macro><name>GetIntegralTemplateArgument</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>, <argument>size_t idx</argument>)</argument_list></macro></expr>;



<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr><name>LLVM_DUMP_METHOD</name> <name>virtual</name> <name>void</name>
<macro><name>dump</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>)</argument_list></macro> <specifier>const</specifier> <operator>=</operator> <literal type="number">0</literal></expr>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr><name>virtual</name> <name>void</name> <macro><name>DumpValue</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>,
<argument>ExecutionContext *exe_ctx</argument>, <argument>Stream *s</argument>,
<argument>lldb::Format format</argument>, <argument>const DataExtractor &amp;data</argument>,
<argument>lldb::offset_t data_offset</argument>, <argument>size_t data_byte_size</argument>,
<argument>uint32_t bitfield_bit_size</argument>,
<argument>uint32_t bitfield_bit_offset</argument>, <argument>bool show_types</argument>,
<argument>bool show_summary</argument>, <argument>bool verbose</argument>, <argument>uint32_t depth</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>bool</name> <macro><name>DumpTypeValue</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>, <argument>Stream *s</argument>,
<argument>lldb::Format format</argument>, <argument>const DataExtractor &amp;data</argument>,
<argument>lldb::offset_t data_offset</argument>, <argument>size_t data_byte_size</argument>,
<argument>uint32_t bitfield_bit_size</argument>,
<argument>uint32_t bitfield_bit_offset</argument>,
<argument>ExecutionContextScope *exe_scope</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;


<expr><name>virtual</name> <name>void</name> <macro><name>DumpTypeDescription</name><argument_list>(
<argument>lldb::opaque_compiler_type_t type</argument>,
<argument>lldb::DescriptionLevel level = lldb::eDescriptionLevelFull</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;





<expr><name>virtual</name> <name>void</name> <macro><name>DumpTypeDescription</name><argument_list>(
<argument>lldb::opaque_compiler_type_t type</argument>, <argument>Stream *s</argument>,
<argument>lldb::DescriptionLevel level = lldb::eDescriptionLevelFull</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;



<expr><name>virtual</name> <name>bool</name> <macro><name>IsRuntimeGeneratedType</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>void</name> <macro><name>DumpSummary</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>,
<argument>ExecutionContext *exe_ctx</argument>, <argument>Stream *s</argument>,
<argument>const DataExtractor &amp;data</argument>,
<argument>lldb::offset_t data_offset</argument>,
<argument>size_t data_byte_size</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;



<expr><name>virtual</name> <name>bool</name> <macro><name>IsPointerOrReferenceType</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>,
<argument>CompilerType *pointee_type</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>unsigned</name> <macro><name>GetTypeQualifiers</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>bool</name> <macro><name>IsCStringType</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>,
<argument>uint32_t &amp;length</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>size_t</name></expr></argument>&gt;</argument_list></name>
<macro><name>GetTypeBitAlign</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>,
<argument>ExecutionContextScope *exe_scope</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>CompilerType</name> <macro><name>GetBasicTypeFromAST</name><argument_list>(<argument>lldb::BasicType basic_type</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>CompilerType</name>
<macro><name>GetBuiltinTypeForEncodingAndBitSize</name><argument_list>(<argument>lldb::Encoding encoding</argument>,
<argument>size_t bit_size</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>bool</name> <macro><name>IsBeingDefined</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>bool</name> <macro><name>IsConst</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>uint32_t</name> <macro><name>IsHomogeneousAggregate</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>,
<argument>CompilerType *base_type_ptr</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>bool</name> <macro><name>IsPolymorphicClass</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>bool</name> <macro><name>IsTypedefType</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;


<expr><name>virtual</name> <name>CompilerType</name> <macro><name>GetTypedefedType</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>bool</name> <macro><name>IsVectorType</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>,
<argument>CompilerType *element_type</argument>, <argument>uint64_t *size</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>CompilerType</name>
<macro><name>GetFullyUnqualifiedType</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>CompilerType</name>
<macro><name>GetNonReferenceType</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>bool</name> <macro><name>IsReferenceType</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>,
<argument>CompilerType *pointee_type</argument>, <argument>bool *is_rvalue</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>bool</name>
<macro><name>ShouldTreatScalarValueAsAddress</name><argument_list>(<argument>lldb::opaque_compiler_type_t type</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>IsPointerOrReferenceType</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>virtual</name> <name>UserExpression</name> <operator>*</operator>
<macro><name>GetUserExpression</name><argument_list>(<argument>llvm::StringRef expr</argument>, <argument>llvm::StringRef prefix</argument>,
<argument>lldb::LanguageType language</argument>,
<argument>Expression::ResultType desired_type</argument>,
<argument>const EvaluateExpressionOptions &amp;options</argument>,
<argument>ValueObject *ctx_obj</argument>)</argument_list></macro> <block>{
<return>return <expr><name>nullptr</name></expr>;</return>
}</block>

<name>virtual</name> <name>FunctionCaller</name> <operator>*</operator><macro><name>GetFunctionCaller</name><argument_list>(<argument>const CompilerType &amp;return_type</argument>,
<argument>const Address &amp;function_address</argument>,
<argument>const ValueList &amp;arg_value_list</argument>,
<argument>const char *name</argument>)</argument_list></macro> <block>{
<return>return <expr><name>nullptr</name></expr>;</return>
}</block>

<name>virtual</name> <name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>UtilityFunction</name></expr></argument>&gt;</argument_list></name>
<macro><name>CreateUtilityFunction</name><argument_list>(<argument>std::string text</argument>, <argument>std::string name</argument>)</argument_list></macro></expr>;

<expr><name>virtual</name> <name>PersistentExpressionState</name> <operator>*</operator><macro><name>GetPersistentExpressionState</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name>nullptr</name></expr>;</return>
}</block>

<name>virtual</name> <name>CompilerType</name> <call><name>GetTypeForFormatters</name><argument_list>(<argument><expr><name>void</name> <operator>*</operator><name>type</name></expr></argument>)</argument_list></call></expr>;

<expr><name>virtual</name> <name>LazyBool</name> <call><name>ShouldPrintAsOneLiner</name><argument_list>(<argument><expr><name>void</name> <operator>*</operator><name>type</name></expr></argument>, <argument><expr><name>ValueObject</name> <operator>*</operator><name>valobj</name></expr></argument>)</argument_list></call></expr>;













<expr><name>virtual</name> <name>bool</name> <call><name>IsMeaninglessWithoutDynamicResolution</name><argument_list>(<argument><expr><name>void</name> <operator>*</operator><name>type</name></expr></argument>)</argument_list></call></expr>;

<expr><name>protected</name><operator>:</operator>
<name>SymbolFile</name> <operator>*</operator><name>m_sym_file</name> <operator>=</operator> <name>nullptr</name></expr>;
}</block></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>TypeSystemMap</name> <block>{<block_content>
<label><name>public</name>:</label>
<expr_stmt><expr><call><name>TypeSystemMap</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>~</operator><call><name>TypeSystemMap</name><argument_list>()</argument_list></call></expr>;</expr_stmt>



<function_decl><type><name>void</name></type> <name>Clear</name><parameter_list>()</parameter_list>;</function_decl>



<decl_stmt><decl><type><name>void</name></type> <name>ForEach</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name><name>function</name><argument_list type="generic">&lt;<argument><expr><name>bool</name><operator>(</operator><name>TypeSystem</name> <operator>*</operator><operator>)</operator></expr></argument>&gt;</argument_list></name> <specifier>const</specifier> <operator>&amp;</operator><name>callback</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>Expected</name><argument_list type="generic">&lt;<argument><expr><name>TypeSystem</name> <operator>&amp;</operator></expr></argument>&gt;</argument_list></name>
<macro><name>GetTypeSystemForLanguage</name><argument_list>(<argument>lldb::LanguageType language</argument>, <argument>Module *module</argument>,
<argument>bool can_create</argument>)</argument_list></macro></expr>;</expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>Expected</name><argument_list type="generic">&lt;<argument><expr><name>TypeSystem</name> <operator>&amp;</operator></expr></argument>&gt;</argument_list></name>
<macro><name>GetTypeSystemForLanguage</name><argument_list>(<argument>lldb::LanguageType language</argument>, <argument>Target *target</argument>,
<argument>bool can_create</argument>)</argument_list></macro></expr>;</expr_stmt>

<label><name>protected</name>:</label>
<typedef>typedef <expr_stmt><expr><name>std</name><operator>::</operator><name><name>map</name><argument_list type="generic">&lt;<argument><expr><name>lldb</name><operator>::</operator><name>LanguageType</name></expr></argument>, <argument><expr><name>lldb</name><operator>::</operator><name>TypeSystemSP</name></expr></argument>&gt;</argument_list></name> <name>collection</name></expr>;</expr_stmt></typedef>
<expr_stmt><expr><name>mutable</name> <name>std</name><operator>::</operator><name>mutex</name> <name>m_mutex</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>collection</name></type> <name>m_map</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>m_clear_in_progress</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<label><name>private</name>:</label>
<typedef>typedef <expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>function_ref</name><argument_list type="generic">&lt;<argument><expr><name>lldb</name><operator>::</operator><name>TypeSystemSP</name><operator>(</operator><operator>)</operator></expr></argument>&gt;</argument_list></name> <name>CreateCallback</name></expr>;</expr_stmt></typedef>










<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>Expected</name><argument_list type="generic">&lt;<argument><expr><name>TypeSystem</name> <operator>&amp;</operator></expr></argument>&gt;</argument_list></name> <macro><name>GetTypeSystemForLanguage</name><argument_list>(
<argument>lldb::LanguageType language</argument>,
<argument>llvm::Optional&lt;CreateCallback&gt; create_callback = llvm::None</argument>)</argument_list></macro></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

</block_content>}</block></decl></decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
