<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/lldb/include/lldb/Core/EmulateInstruction.h">







<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLDB_CORE_EMULATEINSTRUCTION_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLDB_CORE_EMULATEINSTRUCTION_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lldb/Core/Address.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lldb/Core/Opcode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lldb/Core/PluginInterface.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lldb/Utility/ArchSpec.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lldb/lldb-defines.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lldb/lldb-enumerations.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lldb/lldb-private-enumerations.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lldb/lldb-private-types.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lldb/lldb-types.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstddef&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstdint&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>lldb_private</name> <block>{<block_content>
<decl_stmt><decl><type><name>class</name></type> <name>OptionValueDictionary</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>RegisterContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>RegisterValue</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Stream</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Target</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>UnwindPlan</name></decl>;</decl_stmt>



























































<decl_stmt><decl><type><name>class</name></type> <name>EmulateInstruction</name> <range>: <expr><name>public</name> <name>PluginInterface</name> <block>{
<expr><name>public</name><operator>:</operator>
<specifier>static</specifier> <name>EmulateInstruction</name> <operator>*</operator><macro><name>FindPlugin</name><argument_list>(<argument>const ArchSpec &amp;arch</argument>,
<argument>InstructionType supported_inst_type</argument>,
<argument>const char *plugin_name</argument>)</argument_list></macro></expr>;

enum <expr><name>ContextType</name> <block>{
<expr><name>eContextInvalid</name> <operator>=</operator> <literal type="number">0</literal></expr>,

<expr><name>eContextReadOpcode</name></expr>,



<expr><name>eContextImmediate</name></expr>,



<expr><name>eContextPushRegisterOnStack</name></expr>,



<expr><name>eContextPopRegisterOffStack</name></expr>,


<expr><name>eContextAdjustStackPointer</name></expr>,


<expr><name>eContextSetFramePointer</name></expr>,



<expr><name>eContextRestoreStackPointer</name></expr>,


<expr><name>eContextAdjustBaseRegister</name></expr>,


<expr><name>eContextAdjustPC</name></expr>,


<expr><name>eContextRegisterPlusOffset</name></expr>,


<expr><name>eContextRegisterStore</name></expr>,

<expr><name>eContextRegisterLoad</name></expr>,


<expr><name>eContextRelativeBranchImmediate</name></expr>,


<expr><name>eContextAbsoluteBranchRegister</name></expr>,



<expr><name>eContextSupervisorCall</name></expr>,



<expr><name>eContextTableBranchReadMemory</name></expr>,


<expr><name>eContextWriteRegisterRandomBits</name></expr>,


<expr><name>eContextWriteMemoryRandomBits</name></expr>,

<expr><name>eContextArithmetic</name></expr>,

<expr><name>eContextAdvancePC</name></expr>,

<expr><name>eContextReturnFromException</name></expr>
}</block></expr>;

enum <expr><name>InfoType</name> <block>{
<expr><name>eInfoTypeRegisterPlusOffset</name></expr>,
<expr><name>eInfoTypeRegisterPlusIndirectOffset</name></expr>,
<expr><name>eInfoTypeRegisterToRegisterPlusOffset</name></expr>,
<expr><name>eInfoTypeRegisterToRegisterPlusIndirectOffset</name></expr>,
<expr><name>eInfoTypeRegisterRegisterOperands</name></expr>,
<expr><name>eInfoTypeOffset</name></expr>,
<expr><name>eInfoTypeRegister</name></expr>,
<expr><name>eInfoTypeImmediate</name></expr>,
<expr><name>eInfoTypeImmediateSigned</name></expr>,
<expr><name>eInfoTypeAddress</name></expr>,
<expr><name>eInfoTypeISAAndImmediate</name></expr>,
<expr><name>eInfoTypeISAAndImmediateSigned</name></expr>,
<expr><name>eInfoTypeISA</name></expr>,
<expr><name>eInfoTypeNoArgs</name></expr>
}</block> <name>InfoType</name></expr>;

struct <expr><name>Context</name> <block>{
<expr><name>ContextType</name> <name>type</name> <operator>=</operator> <name>eContextInvalid</name></expr>;
enum <expr><name>InfoType</name> <name>info_type</name> <operator>=</operator> <name>eInfoTypeNoArgs</name></expr>;
<expr>union <block>{
struct <expr><name>RegisterPlusOffset</name> <block>{
<expr><name>RegisterInfo</name> <name>reg</name></expr>;
<expr><name>int64_t</name> <name>signed_offset</name></expr>;
}</block> <name>RegisterPlusOffset</name></expr>;

struct <expr><name>RegisterPlusIndirectOffset</name> <block>{
<expr><name>RegisterInfo</name> <name>base_reg</name></expr>;
<expr><name>RegisterInfo</name> <name>offset_reg</name></expr>;
}</block> <name>RegisterPlusIndirectOffset</name></expr>;

struct <expr><name>RegisterToRegisterPlusOffset</name> <block>{
<expr><name>RegisterInfo</name> <name>data_reg</name></expr>;
<expr><name>RegisterInfo</name> <name>base_reg</name></expr>;
<expr><name>int64_t</name> <name>offset</name></expr>;
}</block> <name>RegisterToRegisterPlusOffset</name></expr>;

struct <expr><name>RegisterToRegisterPlusIndirectOffset</name> <block>{
<expr><name>RegisterInfo</name> <name>base_reg</name></expr>;
<expr><name>RegisterInfo</name> <name>offset_reg</name></expr>;
<expr><name>RegisterInfo</name> <name>data_reg</name></expr>;
}</block> <name>RegisterToRegisterPlusIndirectOffset</name></expr>;

struct <expr><name>RegisterRegisterOperands</name> <block>{
<expr><name>RegisterInfo</name>
<name>operand1</name></expr>;
<expr><name>RegisterInfo</name>
<name>operand2</name></expr>;
}</block> <name>RegisterRegisterOperands</name></expr>;

<expr><name>int64_t</name> <name>signed_offset</name></expr>;


<expr><name>RegisterInfo</name> <name>reg</name></expr>;

<expr><name>uint64_t</name> <name>unsigned_immediate</name></expr>;
<expr><name>int64_t</name> <name>signed_immediate</name></expr>;

<expr><name>lldb</name><operator>::</operator><name>addr_t</name> <name>address</name></expr>;

struct <expr><name>ISAAndImmediate</name> <block>{
<expr><name>uint32_t</name> <name>isa</name></expr>;
<expr><name>uint32_t</name> <name>unsigned_data32</name></expr>;
}</block> <name>ISAAndImmediate</name></expr>;

struct <expr><name>ISAAndImmediateSigned</name> <block>{
<expr><name>uint32_t</name> <name>isa</name></expr>;
<expr><name>int32_t</name> <name>signed_data32</name></expr>;
}</block> <name>ISAAndImmediateSigned</name></expr>;

<expr><name>uint32_t</name> <name>isa</name></expr>;
}</block> <name>info</name></expr>;

<expr><call><name>Context</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;

<expr><name>void</name> <macro><name>SetRegisterPlusOffset</name><argument_list>(<argument>RegisterInfo base_reg</argument>, <argument>int64_t signed_offset</argument>)</argument_list></macro> <block>{
<expr><name>info_type</name> <operator>=</operator> <name>eInfoTypeRegisterPlusOffset</name></expr>;
<expr><name><name>info</name><operator>.</operator><name>RegisterPlusOffset</name><operator>.</operator><name>reg</name></name> <operator>=</operator> <name>base_reg</name></expr>;
<expr><name><name>info</name><operator>.</operator><name>RegisterPlusOffset</name><operator>.</operator><name>signed_offset</name></name> <operator>=</operator> <name>signed_offset</name></expr>;
}</block>

<name>void</name> <macro><name>SetRegisterPlusIndirectOffset</name><argument_list>(<argument>RegisterInfo base_reg</argument>,
<argument>RegisterInfo offset_reg</argument>)</argument_list></macro> <block>{
<expr><name>info_type</name> <operator>=</operator> <name>eInfoTypeRegisterPlusIndirectOffset</name></expr>;
<expr><name><name>info</name><operator>.</operator><name>RegisterPlusIndirectOffset</name><operator>.</operator><name>base_reg</name></name> <operator>=</operator> <name>base_reg</name></expr>;
<expr><name><name>info</name><operator>.</operator><name>RegisterPlusIndirectOffset</name><operator>.</operator><name>offset_reg</name></name> <operator>=</operator> <name>offset_reg</name></expr>;
}</block>

<name>void</name> <macro><name>SetRegisterToRegisterPlusOffset</name><argument_list>(<argument>RegisterInfo data_reg</argument>,
<argument>RegisterInfo base_reg</argument>,
<argument>int64_t offset</argument>)</argument_list></macro> <block>{
<expr><name>info_type</name> <operator>=</operator> <name>eInfoTypeRegisterToRegisterPlusOffset</name></expr>;
<expr><name><name>info</name><operator>.</operator><name>RegisterToRegisterPlusOffset</name><operator>.</operator><name>data_reg</name></name> <operator>=</operator> <name>data_reg</name></expr>;
<expr><name><name>info</name><operator>.</operator><name>RegisterToRegisterPlusOffset</name><operator>.</operator><name>base_reg</name></name> <operator>=</operator> <name>base_reg</name></expr>;
<expr><name><name>info</name><operator>.</operator><name>RegisterToRegisterPlusOffset</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <name>offset</name></expr>;
}</block>

<name>void</name> <macro><name>SetRegisterToRegisterPlusIndirectOffset</name><argument_list>(<argument>RegisterInfo base_reg</argument>,
<argument>RegisterInfo offset_reg</argument>,
<argument>RegisterInfo data_reg</argument>)</argument_list></macro> <block>{
<expr><name>info_type</name> <operator>=</operator> <name>eInfoTypeRegisterToRegisterPlusIndirectOffset</name></expr>;
<expr><name><name>info</name><operator>.</operator><name>RegisterToRegisterPlusIndirectOffset</name><operator>.</operator><name>base_reg</name></name> <operator>=</operator> <name>base_reg</name></expr>;
<expr><name><name>info</name><operator>.</operator><name>RegisterToRegisterPlusIndirectOffset</name><operator>.</operator><name>offset_reg</name></name> <operator>=</operator> <name>offset_reg</name></expr>;
<expr><name><name>info</name><operator>.</operator><name>RegisterToRegisterPlusIndirectOffset</name><operator>.</operator><name>data_reg</name></name> <operator>=</operator> <name>data_reg</name></expr>;
}</block>

<name>void</name> <macro><name>SetRegisterRegisterOperands</name><argument_list>(<argument>RegisterInfo op1_reg</argument>,
<argument>RegisterInfo op2_reg</argument>)</argument_list></macro> <block>{
<expr><name>info_type</name> <operator>=</operator> <name>eInfoTypeRegisterRegisterOperands</name></expr>;
<expr><name><name>info</name><operator>.</operator><name>RegisterRegisterOperands</name><operator>.</operator><name>operand1</name></name> <operator>=</operator> <name>op1_reg</name></expr>;
<expr><name><name>info</name><operator>.</operator><name>RegisterRegisterOperands</name><operator>.</operator><name>operand2</name></name> <operator>=</operator> <name>op2_reg</name></expr>;
}</block>

<name>void</name> <macro><name>SetOffset</name><argument_list>(<argument>int64_t signed_offset</argument>)</argument_list></macro> <block>{
<expr><name>info_type</name> <operator>=</operator> <name>eInfoTypeOffset</name></expr>;
<expr><name><name>info</name><operator>.</operator><name>signed_offset</name></name> <operator>=</operator> <name>signed_offset</name></expr>;
}</block>

<name>void</name> <macro><name>SetRegister</name><argument_list>(<argument>RegisterInfo reg</argument>)</argument_list></macro> <block>{
<expr><name>info_type</name> <operator>=</operator> <name>eInfoTypeRegister</name></expr>;
<expr><name><name>info</name><operator>.</operator><name>reg</name></name> <operator>=</operator> <name>reg</name></expr>;
}</block>

<name>void</name> <macro><name>SetImmediate</name><argument_list>(<argument>uint64_t immediate</argument>)</argument_list></macro> <block>{
<expr><name>info_type</name> <operator>=</operator> <name>eInfoTypeImmediate</name></expr>;
<expr><name><name>info</name><operator>.</operator><name>unsigned_immediate</name></name> <operator>=</operator> <name>immediate</name></expr>;
}</block>

<name>void</name> <macro><name>SetImmediateSigned</name><argument_list>(<argument>int64_t signed_immediate</argument>)</argument_list></macro> <block>{
<expr><name>info_type</name> <operator>=</operator> <name>eInfoTypeImmediateSigned</name></expr>;
<expr><name><name>info</name><operator>.</operator><name>signed_immediate</name></name> <operator>=</operator> <name>signed_immediate</name></expr>;
}</block>

<name>void</name> <macro><name>SetAddress</name><argument_list>(<argument>lldb::addr_t address</argument>)</argument_list></macro> <block>{
<expr><name>info_type</name> <operator>=</operator> <name>eInfoTypeAddress</name></expr>;
<expr><name><name>info</name><operator>.</operator><name>address</name></name> <operator>=</operator> <name>address</name></expr>;
}</block>
<name>void</name> <macro><name>SetISAAndImmediate</name><argument_list>(<argument>uint32_t isa</argument>, <argument>uint32_t data</argument>)</argument_list></macro> <block>{
<expr><name>info_type</name> <operator>=</operator> <name>eInfoTypeISAAndImmediate</name></expr>;
<expr><name><name>info</name><operator>.</operator><name>ISAAndImmediate</name><operator>.</operator><name>isa</name></name> <operator>=</operator> <name>isa</name></expr>;
<expr><name><name>info</name><operator>.</operator><name>ISAAndImmediate</name><operator>.</operator><name>unsigned_data32</name></name> <operator>=</operator> <name>data</name></expr>;
}</block>

<name>void</name> <macro><name>SetISAAndImmediateSigned</name><argument_list>(<argument>uint32_t isa</argument>, <argument>int32_t data</argument>)</argument_list></macro> <block>{
<expr><name>info_type</name> <operator>=</operator> <name>eInfoTypeISAAndImmediateSigned</name></expr>;
<expr><name><name>info</name><operator>.</operator><name>ISAAndImmediateSigned</name><operator>.</operator><name>isa</name></name> <operator>=</operator> <name>isa</name></expr>;
<expr><name><name>info</name><operator>.</operator><name>ISAAndImmediateSigned</name><operator>.</operator><name>signed_data32</name></name> <operator>=</operator> <name>data</name></expr>;
}</block>

<name>void</name> <macro><name>SetISA</name><argument_list>(<argument>uint32_t isa</argument>)</argument_list></macro> <block>{
<expr><name>info_type</name> <operator>=</operator> <name>eInfoTypeISA</name></expr>;
<expr><name><name>info</name><operator>.</operator><name>isa</name></name> <operator>=</operator> <name>isa</name></expr>;
}</block>

<name>void</name> <macro><name>SetNoArgs</name><argument_list>()</argument_list></macro> <block>{ <expr><name>info_type</name> <operator>=</operator> <name>eInfoTypeNoArgs</name></expr>; }</block>

<name>void</name> <macro><name>Dump</name><argument_list>(<argument>Stream &amp;s</argument>, <argument>EmulateInstruction *instruction</argument>)</argument_list></macro> <specifier>const</specifier></expr>;
}</block></expr>;

<typedef>typedef <macro><name>size_t</name> <argument_list>(<argument>*ReadMemoryCallback</argument>)</argument_list></macro><expr_stmt><expr><operator>(</operator><name>EmulateInstruction</name> <operator>*</operator><name>instruction</name>,
<name>void</name> <operator>*</operator><name>baton</name>, <specifier>const</specifier> <name>Context</name> <operator>&amp;</operator><name>context</name>,
<name>lldb</name><operator>::</operator><name>addr_t</name> <name>addr</name>, <name>void</name> <operator>*</operator><name>dst</name>,
<name>size_t</name> <name>length</name><operator>)</operator></expr>;</expr_stmt></typedef></block></expr></range></decl></decl_stmt>

<typedef>typedef <macro><name>size_t</name> <argument_list>(<argument>*WriteMemoryCallback</argument>)</argument_list></macro><expr_stmt><expr><operator>(</operator><name>EmulateInstruction</name> <operator>*</operator><name>instruction</name><operator>,</operator>
<name>void</name> <operator>*</operator><name>baton</name><operator>,</operator> <specifier>const</specifier> <name>Context</name> <operator>&amp;</operator><name>context</name><operator>,</operator>
<name>lldb</name><operator>::</operator><name>addr_t</name> <name>addr</name><operator>,</operator> <specifier>const</specifier> <name>void</name> <operator>*</operator><name>dst</name><operator>,</operator>
<name>size_t</name> <name>length</name><operator>)</operator></expr>;</expr_stmt></typedef>

<typedef>typedef <function_decl><type><name>bool</name></type> (<modifier>*</modifier><name>ReadRegisterCallback</name>)<parameter_list>(<parameter><decl><type><name>EmulateInstruction</name> <modifier>*</modifier></type><name>instruction</name></decl></parameter>,
<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>baton</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>RegisterInfo</name> <modifier>*</modifier></type><name>reg_info</name></decl></parameter>,
<parameter><decl><type><name>RegisterValue</name> <modifier>&amp;</modifier></type><name>reg_value</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<typedef>typedef <function_decl><type><name>bool</name></type> (<modifier>*</modifier><name>WriteRegisterCallback</name>)<parameter_list>(<parameter><decl><type><name>EmulateInstruction</name> <modifier>*</modifier></type><name>instruction</name></decl></parameter>,
<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>baton</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Context</name> <modifier>&amp;</modifier></type><name>context</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>RegisterInfo</name> <modifier>*</modifier></type><name>reg_info</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>RegisterValue</name> <modifier>&amp;</modifier></type><name>reg_value</name></decl></parameter>)</parameter_list>;</function_decl></typedef>




<typedef>typedef <type><name>uint32_t</name></type> <name>InstructionCondition</name>;</typedef>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>InstructionCondition</name></type> <name>UnconditionalCondition</name> <init>= <expr><name>UINT32_MAX</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>EmulateInstruction</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ArchSpec</name> <operator>&amp;</operator><name>arch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>~</operator><macro><name>EmulateInstruction</name><argument_list>()</argument_list></macro> <name>override</name> <operator>=</operator> default</expr>;</expr_stmt>


<function_decl><type><name>virtual</name> <name>bool</name></type>
<name>SupportsEmulatingInstructionsOfType</name><parameter_list>(<parameter><decl><type><name>InstructionType</name></type> <name>inst_type</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>

<function_decl><type><name>virtual</name> <name>bool</name></type> <name>SetTargetTriple</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ArchSpec</name> <modifier>&amp;</modifier></type><name>arch</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>

<function_decl><type><name>virtual</name> <name>bool</name></type> <name>ReadInstruction</name><parameter_list>()</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>

<function_decl><type><name>virtual</name> <name>bool</name></type> <name>EvaluateInstruction</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>evaluate_options</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>

<function><type><name>virtual</name> <name>InstructionCondition</name></type> <name>GetInstructionCondition</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><name>UnconditionalCondition</name></expr>;</return>
</block_content>}</block></function>

<function_decl><type><name>virtual</name> <name>bool</name></type> <name>TestEmulation</name><parameter_list>(<parameter><decl><type><name>Stream</name> <modifier>*</modifier></type><name>out_stream</name></decl></parameter>, <parameter><decl><type><name>ArchSpec</name> <modifier>&amp;</modifier></type><name>arch</name></decl></parameter>,
<parameter><decl><type><name>OptionValueDictionary</name> <modifier>*</modifier></type><name>test_data</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>

<decl_stmt><decl><type><name>virtual</name> <name>bool</name></type> <name>GetRegisterInfo</name><argument_list>(<argument><expr><name>lldb</name><operator>::</operator><name>RegisterKind</name> <name>reg_kind</name></expr></argument>, <argument><expr><name>uint32_t</name> <name>reg_num</name></expr></argument>,
<argument><expr><name>RegisterInfo</name> <operator>&amp;</operator><name>reg_info</name></expr></argument>)</argument_list> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<function_decl><type><name>virtual</name> <name>bool</name></type> <name>SetInstruction</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Opcode</name> <modifier>&amp;</modifier></type><name>insn_opcode</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Address</name> <modifier>&amp;</modifier></type><name>inst_addr</name></decl></parameter>, <parameter><decl><type><name>Target</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>virtual</name> <name>bool</name></type> <name>CreateFunctionEntryUnwind</name><parameter_list>(<parameter><decl><type><name>UnwindPlan</name> <modifier>&amp;</modifier></type><name>unwind_plan</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>TranslateRegister</name><argument_list>(<argument><expr><name>lldb</name><operator>::</operator><name>RegisterKind</name> <name>reg_kind</name></expr></argument>,
<argument><expr><name>uint32_t</name> <name>reg_num</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name>string</name> <operator>&amp;</operator><name>reg_name</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<function_decl><type><name>bool</name></type> <name>ReadRegister</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RegisterInfo</name> <modifier>*</modifier></type><name>reg_info</name></decl></parameter>, <parameter><decl><type><name>RegisterValue</name> <modifier>&amp;</modifier></type><name>reg_value</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>uint64_t</name></type> <name>ReadRegisterUnsigned</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RegisterInfo</name> <modifier>*</modifier></type><name>reg_info</name></decl></parameter>,
<parameter><decl><type><name>uint64_t</name></type> <name>fail_value</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>success_ptr</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>WriteRegister</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Context</name> <modifier>&amp;</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RegisterInfo</name> <modifier>*</modifier></type><name>ref_info</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>RegisterValue</name> <modifier>&amp;</modifier></type><name>reg_value</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>WriteRegisterUnsigned</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Context</name> <modifier>&amp;</modifier></type><name>context</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>RegisterInfo</name> <modifier>*</modifier></type><name>reg_info</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>reg_value</name></decl></parameter>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><name>bool</name></type> <name>ReadRegister</name><argument_list>(<argument><expr><name>lldb</name><operator>::</operator><name>RegisterKind</name> <name>reg_kind</name></expr></argument>, <argument><expr><name>uint32_t</name> <name>reg_num</name></expr></argument>,
<argument><expr><name>RegisterValue</name> <operator>&amp;</operator><name>reg_value</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>WriteRegister</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Context</name> <operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><name>lldb</name><operator>::</operator><name>RegisterKind</name> <name>reg_kind</name></expr></argument>,
<argument><expr><name>uint32_t</name> <name>reg_num</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>RegisterValue</name> <operator>&amp;</operator><name>reg_value</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint64_t</name></type> <name>ReadRegisterUnsigned</name><argument_list>(<argument><expr><name>lldb</name><operator>::</operator><name>RegisterKind</name> <name>reg_kind</name></expr></argument>, <argument><expr><name>uint32_t</name> <name>reg_num</name></expr></argument>,
<argument><expr><name>uint64_t</name> <name>fail_value</name></expr></argument>, <argument><expr><name>bool</name> <operator>*</operator><name>success_ptr</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>WriteRegisterUnsigned</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Context</name> <operator>&amp;</operator><name>context</name></expr></argument>,
<argument><expr><name>lldb</name><operator>::</operator><name>RegisterKind</name> <name>reg_kind</name></expr></argument>, <argument><expr><name>uint32_t</name> <name>reg_num</name></expr></argument>,
<argument><expr><name>uint64_t</name> <name>reg_value</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>ReadMemory</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Context</name> <operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><name>lldb</name><operator>::</operator><name>addr_t</name> <name>addr</name></expr></argument>, <argument><expr><name>void</name> <operator>*</operator><name>dst</name></expr></argument>,
<argument><expr><name>size_t</name> <name>dst_len</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint64_t</name></type> <name>ReadMemoryUnsigned</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Context</name> <operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><name>lldb</name><operator>::</operator><name>addr_t</name> <name>addr</name></expr></argument>,
<argument><expr><name>size_t</name> <name>byte_size</name></expr></argument>, <argument><expr><name>uint64_t</name> <name>fail_value</name></expr></argument>,
<argument><expr><name>bool</name> <operator>*</operator><name>success_ptr</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>WriteMemory</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Context</name> <operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><name>lldb</name><operator>::</operator><name>addr_t</name> <name>addr</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>void</name> <operator>*</operator><name>src</name></expr></argument>,
<argument><expr><name>size_t</name> <name>src_len</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>WriteMemoryUnsigned</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Context</name> <operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><name>lldb</name><operator>::</operator><name>addr_t</name> <name>addr</name></expr></argument>,
<argument><expr><name>uint64_t</name> <name>uval</name></expr></argument>, <argument><expr><name>size_t</name> <name>uval_byte_size</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<expr_stmt><expr><name>uint32_t</name> <macro><name>GetAddressByteSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>m_arch</name><operator>.</operator><name>GetAddressByteSize</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>lldb</name><operator>::</operator><name>ByteOrder</name> <macro><name>GetByteOrder</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>m_arch</name><operator>.</operator><name>GetByteOrder</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>Opcode</name> <operator>&amp;</operator><macro><name>GetOpcode</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>m_opcode</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>lldb</name><operator>::</operator><name>addr_t</name> <macro><name>GetAddress</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>m_addr</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>ArchSpec</name> <operator>&amp;</operator><macro><name>GetArchitecture</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>m_arch</name></expr>;</return> }</block></expr></expr_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>size_t</name></type> <name>ReadMemoryFrame</name><argument_list>(<argument><expr><name>EmulateInstruction</name> <operator>*</operator><name>instruction</name></expr></argument>, <argument><expr><name>void</name> <operator>*</operator><name>baton</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>Context</name> <operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><name>lldb</name><operator>::</operator><name>addr_t</name> <name>addr</name></expr></argument>,
<argument><expr><name>void</name> <operator>*</operator><name>dst</name></expr></argument>, <argument><expr><name>size_t</name> <name>length</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>size_t</name></type> <name>WriteMemoryFrame</name><argument_list>(<argument><expr><name>EmulateInstruction</name> <operator>*</operator><name>instruction</name></expr></argument>, <argument><expr><name>void</name> <operator>*</operator><name>baton</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>Context</name> <operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><name>lldb</name><operator>::</operator><name>addr_t</name> <name>addr</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>void</name> <operator>*</operator><name>dst</name></expr></argument>, <argument><expr><name>size_t</name> <name>length</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ReadRegisterFrame</name><parameter_list>(<parameter><decl><type><name>EmulateInstruction</name> <modifier>*</modifier></type><name>instruction</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>baton</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>RegisterInfo</name> <modifier>*</modifier></type><name>reg_info</name></decl></parameter>,
<parameter><decl><type><name>RegisterValue</name> <modifier>&amp;</modifier></type><name>reg_value</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>WriteRegisterFrame</name><parameter_list>(<parameter><decl><type><name>EmulateInstruction</name> <modifier>*</modifier></type><name>instruction</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>baton</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Context</name> <modifier>&amp;</modifier></type><name>context</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>RegisterInfo</name> <modifier>*</modifier></type><name>reg_info</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>RegisterValue</name> <modifier>&amp;</modifier></type><name>reg_value</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>size_t</name></type> <name>ReadMemoryDefault</name><argument_list>(<argument><expr><name>EmulateInstruction</name> <operator>*</operator><name>instruction</name></expr></argument>, <argument><expr><name>void</name> <operator>*</operator><name>baton</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>Context</name> <operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><name>lldb</name><operator>::</operator><name>addr_t</name> <name>addr</name></expr></argument>,
<argument><expr><name>void</name> <operator>*</operator><name>dst</name></expr></argument>, <argument><expr><name>size_t</name> <name>length</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>size_t</name></type> <name>WriteMemoryDefault</name><argument_list>(<argument><expr><name>EmulateInstruction</name> <operator>*</operator><name>instruction</name></expr></argument>, <argument><expr><name>void</name> <operator>*</operator><name>baton</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>Context</name> <operator>&amp;</operator><name>context</name></expr></argument>, <argument><expr><name>lldb</name><operator>::</operator><name>addr_t</name> <name>addr</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>void</name> <operator>*</operator><name>dst</name></expr></argument>, <argument><expr><name>size_t</name> <name>length</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ReadRegisterDefault</name><parameter_list>(<parameter><decl><type><name>EmulateInstruction</name> <modifier>*</modifier></type><name>instruction</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>baton</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>RegisterInfo</name> <modifier>*</modifier></type><name>reg_info</name></decl></parameter>,
<parameter><decl><type><name>RegisterValue</name> <modifier>&amp;</modifier></type><name>reg_value</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>WriteRegisterDefault</name><parameter_list>(<parameter><decl><type><name>EmulateInstruction</name> <modifier>*</modifier></type><name>instruction</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>baton</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Context</name> <modifier>&amp;</modifier></type><name>context</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>RegisterInfo</name> <modifier>*</modifier></type><name>reg_info</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>RegisterValue</name> <modifier>&amp;</modifier></type><name>reg_value</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>SetBaton</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>baton</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>SetCallbacks</name><parameter_list>(<parameter><decl><type><name>ReadMemoryCallback</name></type> <name>read_mem_callback</name></decl></parameter>,
<parameter><decl><type><name>WriteMemoryCallback</name></type> <name>write_mem_callback</name></decl></parameter>,
<parameter><decl><type><name>ReadRegisterCallback</name></type> <name>read_reg_callback</name></decl></parameter>,
<parameter><decl><type><name>WriteRegisterCallback</name></type> <name>write_reg_callback</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>SetReadMemCallback</name><parameter_list>(<parameter><decl><type><name>ReadMemoryCallback</name></type> <name>read_mem_callback</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>SetWriteMemCallback</name><parameter_list>(<parameter><decl><type><name>WriteMemoryCallback</name></type> <name>write_mem_callback</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>SetReadRegCallback</name><parameter_list>(<parameter><decl><type><name>ReadRegisterCallback</name></type> <name>read_reg_callback</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>SetWriteRegCallback</name><parameter_list>(<parameter><decl><type><name>WriteRegisterCallback</name></type> <name>write_reg_callback</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>GetBestRegisterKindAndNumber</name><argument_list>(<argument><expr><specifier>const</specifier> <name>RegisterInfo</name> <operator>*</operator><name>reg_info</name></expr></argument>,
<argument><expr><name>lldb</name><operator>::</operator><name>RegisterKind</name> <operator>&amp;</operator><name>reg_kind</name></expr></argument>,
<argument><expr><name>uint32_t</name> <operator>&amp;</operator><name>reg_num</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>uint32_t</name></type> <name>GetInternalRegisterNumber</name><parameter_list>(<parameter><decl><type><name>RegisterContext</name> <modifier>*</modifier></type><name>reg_ctx</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>RegisterInfo</name> <modifier>&amp;</modifier></type><name>reg_info</name></decl></parameter>)</parameter_list>;</function_decl>

<label><name>protected</name>:</label>
<decl_stmt><decl><type><name>ArchSpec</name></type> <name>m_arch</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>m_baton</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ReadMemoryCallback</name></type> <name>m_read_mem_callback</name> <init>= <expr><operator>&amp;</operator><name>ReadMemoryDefault</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WriteMemoryCallback</name></type> <name>m_write_mem_callback</name> <init>= <expr><operator>&amp;</operator><name>WriteMemoryDefault</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ReadRegisterCallback</name></type> <name>m_read_reg_callback</name> <init>= <expr><operator>&amp;</operator><name>ReadRegisterDefault</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WriteRegisterCallback</name></type> <name>m_write_reg_callback</name> <init>= <expr><operator>&amp;</operator><name>WriteRegisterDefault</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>lldb</name><operator>::</operator><name>addr_t</name> <name>m_addr</name> <operator>=</operator> <name>LLDB_INVALID_ADDRESS</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>Opcode</name></type> <name>m_opcode</name></decl>;</decl_stmt>

<label><name>private</name>:</label>

<expr_stmt><expr><call><name>EmulateInstruction</name><argument_list>(<argument><expr><specifier>const</specifier> <name>EmulateInstruction</name> <operator>&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name>delete</name></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>EmulateInstruction</name> <modifier>&amp;</modifier></type><name>operator</name><init>=<expr><operator>(</operator><specifier>const</specifier> <name>EmulateInstruction</name> <operator>&amp;</operator><operator>)</operator> <operator>=</operator> <name>delete</name></expr></init></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
