<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/lldb/include/lldb/Interpreter/CommandObject.h">







<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLDB_INTERPRETER_COMMANDOBJECT_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLDB_INTERPRETER_COMMANDOBJECT_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;map&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vector&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lldb/Utility/Flags.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lldb/Interpreter/CommandCompletions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lldb/Interpreter/Options.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lldb/Target/ExecutionContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lldb/Utility/Args.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lldb/Utility/CompletionRequest.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lldb/Utility/StringList.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lldb/lldb-private.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>lldb_private</name> <block>{<block_content>







<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>ValueType</name></expr></argument>&gt;</argument_list></name>
<name>int</name></type> <name>AddNamesMatchingPartialString</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name><name>map</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>, <argument><expr><name>ValueType</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>in_map</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>StringRef</name> <name>cmd_str</name></expr></argument>,
<argument><expr><name>StringList</name> <operator>&amp;</operator><name>matches</name></expr></argument>, <argument><expr><name>StringList</name> <operator>*</operator><name>descriptions</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>number_added</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>add_all</name> <init>= <expr><call><name><name>cmd_str</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><name>auto</name></type> <name>iter</name> <init>= <expr><call><name><name>in_map</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>end</name> <init>= <expr><call><name><name>in_map</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>iter</name> <operator>!=</operator> <name>end</name></expr>;</condition> <incr><expr><name>iter</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>add_all</name> <operator>||</operator> <operator>(</operator><call><name><name>iter</name><operator>-&gt;</operator><name>first</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name>string</name><argument_list>(<argument><expr><name>cmd_str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>number_added</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>matches</name><operator>.</operator><name>AppendString</name></name><argument_list>(<argument><expr><call><name><name>iter</name><operator>-&gt;</operator><name>first</name><operator>.</operator><name>c_str</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>descriptions</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>descriptions</name><operator>-&gt;</operator><name>AppendString</name></name><argument_list>(<argument><expr><call><name><name>iter</name><operator>-&gt;</operator><name>second</name><operator>-&gt;</operator><name>GetHelp</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<return>return <expr><name>number_added</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>ValueType</name></expr></argument>&gt;</argument_list></name>
<name>size_t</name></type> <name>FindLongestCommandWord</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name><name>map</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>, <argument><expr><name>ValueType</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>dict</name></expr></argument>)</argument_list> <block>{<block_content>
<decl_stmt><decl><type><name>auto</name></type> <name>end</name> <init>= <expr><call><name><name>dict</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>max_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><decl><type><name>auto</name></type> <name>pos</name> <init>= <expr><call><name><name>dict</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>pos</name> <operator>!=</operator> <name>end</name></expr>;</condition> <incr><expr><operator>++</operator><name>pos</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name><name>pos</name><operator>-&gt;</operator><name>first</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>max_len</name> <operator>&lt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>max_len</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>max_len</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>CommandObject</name> <block>{<block_content>
<label><name>public</name>:</label>
<typedef>typedef <expr_stmt><expr><name>llvm</name><operator>::</operator><call><call><name>StringRef</name><argument_list>(<argument><expr><name>ArgumentHelpCallbackFunction</name></expr></argument>)</argument_list></call><argument_list>()</argument_list></call></expr>;</expr_stmt></typedef>

<struct>struct <name>ArgumentHelpCallback</name> <block>{
<decl_stmt><decl><type><name>ArgumentHelpCallbackFunction</name> <modifier>*</modifier></type><name>help_callback</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>self_formatting</name></decl>;</decl_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>StringRef</name> <macro><name>operator</name><argument_list>()</argument_list></macro><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{ <return>return <expr><call>(<modifier>*</modifier><name>help_callback</name>)<argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>explicit</name> <name>operator</name> <macro><name>bool</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>(</operator><name>help_callback</name> <operator>!=</operator> <name>nullptr</name><operator>)</operator></expr>;</return> }</block></expr></expr_stmt>
}</block>;</struct>

<struct>struct <name>ArgumentTableEntry</name>
<block>{
<expr_stmt><expr><name>lldb</name><operator>::</operator><name>CommandArgumentType</name> <name>arg_type</name></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg_name</name></decl>;</decl_stmt>
<expr_stmt><expr><name>CommandCompletions</name><operator>::</operator><name>CommonCompletionTypes</name> <name>completion_type</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ArgumentHelpCallback</name></type> <name>help_function</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>help_text</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>CommandArgumentData</name>
<block>{
<expr_stmt><expr><name>lldb</name><operator>::</operator><name>CommandArgumentType</name> <name>arg_type</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ArgumentRepetitionType</name></type> <name>arg_repetition</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>uint32_t</name></type> <name>arg_opt_set_association</name></decl>;</decl_stmt>

<macro><name>CommandArgumentData</name><argument_list>(<argument>lldb::CommandArgumentType type = lldb::eArgTypeNone</argument>,
<argument>ArgumentRepetitionType repetition = eArgRepeatPlain</argument>,
<argument>uint32_t opt_set = LLDB_OPT_SET_ALL</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>arg_type</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>arg_repetition</name><argument_list>(<argument><expr><name>repetition</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>arg_opt_set_association</name><argument_list>(<argument>opt_set</argument>)</argument_list></macro> <expr><block>{}</block></expr></expr_stmt>
}</block>;</struct>

<typedef>typedef <expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CommandArgumentData</name></expr></argument>&gt;</argument_list></name>
<name>CommandArgumentEntry</name></expr>;</expr_stmt></typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>ArgumentTableEntry</name></type> <name><name>g_arguments_data</name>
<index>[<expr><name>lldb</name><operator>::</operator><name>eArgTypeLastArg</name></expr>]</index></name></decl>;</decl_stmt>

<typedef>typedef <expr_stmt><expr><name>std</name><operator>::</operator><name><name>map</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>, <argument><expr><name>lldb</name><operator>::</operator><name>CommandObjectSP</name></expr></argument>&gt;</argument_list></name> <name>CommandMap</name></expr>;</expr_stmt></typedef>

<macro><name>CommandObject</name><argument_list>(<argument>CommandInterpreter &amp;interpreter</argument>, <argument>llvm::StringRef name</argument>,
<argument>llvm::StringRef help = <literal type="string">""</literal></argument>, <argument>llvm::StringRef syntax = <literal type="string">""</literal></argument>,
<argument>uint32_t flags = <literal type="number">0</literal></argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<expr_stmt><expr><name>virtual</name> <operator>~</operator><call><name>CommandObject</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>GetArgumentTypeAsCString</name><argument_list>(<argument><expr><specifier>const</specifier> <name>lldb</name><operator>::</operator><name>CommandArgumentType</name> <name>arg_type</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>GetArgumentDescriptionAsCString</name><argument_list>(<argument><expr><specifier>const</specifier> <name>lldb</name><operator>::</operator><name>CommandArgumentType</name> <name>arg_type</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function><type><name>CommandInterpreter</name> <modifier>&amp;</modifier></type><name>GetCommandInterpreter</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>m_interpreter</name></expr>;</return> </block_content>}</block></function>
<function_decl><type><name>Debugger</name> <modifier>&amp;</modifier></type><name>GetDebugger</name><parameter_list>()</parameter_list>;</function_decl>

<expr_stmt><expr><name>virtual</name> <name>llvm</name><operator>::</operator><name>StringRef</name> <call><name>GetHelp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>virtual</name> <name>llvm</name><operator>::</operator><name>StringRef</name> <call><name>GetHelpLong</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>virtual</name> <name>llvm</name><operator>::</operator><name>StringRef</name> <call><name>GetSyntax</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>StringRef</name> <macro><name>GetCommandName</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>SetHelp</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>StringRef</name> <name>str</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>SetHelpLong</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>StringRef</name> <name>str</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>SetSyntax</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>StringRef</name> <name>str</name></expr></argument>)</argument_list></decl>;</decl_stmt>




<expr_stmt><expr><name>virtual</name> <name>bool</name> <macro><name>IsRemovable</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block></expr></expr_stmt>

<function><type><name>virtual</name> <name>bool</name></type> <name>IsMultiwordObject</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>false</name></expr>;</return> </block_content>}</block></function>

<function><type><name>virtual</name> <name>CommandObjectMultiword</name> <modifier>*</modifier></type><name>GetAsMultiwordCommand</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>nullptr</name></expr>;</return> </block_content>}</block></function>

<function><type><name>virtual</name> <name>bool</name></type> <name>IsAlias</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>false</name></expr>;</return> </block_content>}</block></function>




<function><type><name>virtual</name> <name>bool</name></type> <name>IsDashDashCommand</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>false</name></expr>;</return> </block_content>}</block></function>

<expr_stmt><expr><name>virtual</name> <name>lldb</name><operator>::</operator><name>CommandObjectSP</name> <macro><name>GetSubcommandSP</name><argument_list>(<argument>llvm::StringRef sub_cmd</argument>,
<argument>StringList *matches = nullptr</argument>)</argument_list></macro> <block>{
<return>return <expr><name>lldb</name><operator>::</operator><call><name>CommandObjectSP</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<decl_stmt><decl><type><name>virtual</name> <name>CommandObject</name> <modifier>*</modifier></type><name>GetSubcommandObject</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>StringRef</name> <name>sub_cmd</name></expr></argument>,
<argument><expr><name>StringList</name> <operator>*</operator><name>matches</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><name>nullptr</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>AproposAllSubCommands</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>StringRef</name> <name>prefix</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>StringRef</name> <name>search_word</name></expr></argument>,
<argument><expr><name>StringList</name> <operator>&amp;</operator><name>commands_found</name></expr></argument>,
<argument><expr><name>StringList</name> <operator>&amp;</operator><name>commands_help</name></expr></argument>)</argument_list> <block>{<block_content/>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>FormatLongHelpText</name><argument_list>(<argument><expr><name>Stream</name> <operator>&amp;</operator><name>output_strm</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>StringRef</name> <name>long_help</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function_decl><type><name>void</name></type> <name>GenerateHelpText</name><parameter_list>(<parameter><decl><type><name>CommandReturnObject</name> <modifier>&amp;</modifier></type><name>result</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>virtual</name> <name>void</name></type> <name>GenerateHelpText</name><parameter_list>(<parameter><decl><type><name>Stream</name> <modifier>&amp;</modifier></type><name>result</name></decl></parameter>)</parameter_list>;</function_decl>




<decl_stmt><decl><type><name>virtual</name> <name>bool</name></type> <name>LoadSubCommand</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>StringRef</name> <name>cmd_name</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>lldb</name><operator>::</operator><name>CommandObjectSP</name> <operator>&amp;</operator><name>command_obj</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<function_decl><type><name>virtual</name> <name>bool</name></type> <name>WantsRawCommandString</name><parameter_list>()</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>




<function><type><name>virtual</name> <name>bool</name></type> <name>WantsCompletion</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><operator>!</operator><call><name>WantsRawCommandString</name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>

<function_decl><type><name>virtual</name> <name>Options</name> <modifier>*</modifier></type><name>GetOptions</name><parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ArgumentTableEntry</name> <modifier>*</modifier></type><name>GetArgumentTable</name><parameter_list>()</parameter_list>;</function_decl>

<expr_stmt><expr><specifier>static</specifier> <name>lldb</name><operator>::</operator><name>CommandArgumentType</name> <macro><name>LookupArgumentName</name><argument_list>(<argument>llvm::StringRef arg_name</argument>)</argument_list></macro></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ArgumentTableEntry</name> <modifier>*</modifier></type>
<name>FindArgumentDataByType</name><argument_list>(<argument><expr><name>lldb</name><operator>::</operator><name>CommandArgumentType</name> <name>arg_type</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function_decl><type><name>int</name></type> <name>GetNumArgumentEntries</name><parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><name>CommandArgumentEntry</name> <modifier>*</modifier></type><name>GetArgumentEntryAtIndex</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type> <name>GetArgumentHelp</name><argument_list>(<argument><expr><name>Stream</name> <operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>lldb</name><operator>::</operator><name>CommandArgumentType</name> <name>arg_type</name></expr></argument>,
<argument><expr><name>CommandInterpreter</name> <operator>&amp;</operator><name>interpreter</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>GetArgumentName</name><argument_list>(<argument><expr><name>lldb</name><operator>::</operator><name>CommandArgumentType</name> <name>arg_type</name></expr></argument>)</argument_list></decl>;</decl_stmt>






<function_decl><type><name>void</name></type> <name>GetFormattedCommandArguments</name><parameter_list>(<parameter><decl><type><name>Stream</name> <modifier>&amp;</modifier></type><name>str</name></decl></parameter>,
<parameter><decl><type><name>uint32_t</name></type> <name>opt_set_mask</name> <init>= <expr><name>LLDB_OPT_SET_ALL</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>IsPairType</name><parameter_list>(<parameter><decl><type><name>ArgumentRepetitionType</name></type> <name>arg_repeat_type</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>ParseOptions</name><parameter_list>(<parameter><decl><type><name>Args</name> <modifier>&amp;</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>CommandReturnObject</name> <modifier>&amp;</modifier></type><name>result</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>void</name></type> <name>SetCommandName</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>StringRef</name> <name>name</name></expr></argument>)</argument_list></decl>;</decl_stmt>








<function_decl><type><name>virtual</name> <name>void</name></type> <name>HandleCompletion</name><parameter_list>(<parameter><decl><type><name>CompletionRequest</name> <modifier>&amp;</modifier></type><name>request</name></decl></parameter>)</parameter_list>;</function_decl>








<function><type><name>virtual</name> <name>void</name></type>
<name>HandleArgumentCompletion</name><parameter_list>(<parameter><decl><type><name>CompletionRequest</name> <modifier>&amp;</modifier></type><name>request</name></decl></parameter>,
<parameter><decl><type><name>OptionElementVector</name> <modifier>&amp;</modifier></type><name>opt_element_vector</name></decl></parameter>)</parameter_list> <block>{<block_content/>}</block></function>

<decl_stmt><decl><type><name>bool</name></type> <name>HelpTextContainsWord</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>StringRef</name> <name>search_word</name></expr></argument>,
<argument><expr><name>bool</name> <name>search_short_help</name> <operator>=</operator> <name>true</name></expr></argument>,
<argument><expr><name>bool</name> <name>search_long_help</name> <operator>=</operator> <name>true</name></expr></argument>,
<argument><expr><name>bool</name> <name>search_syntax</name> <operator>=</operator> <name>true</name></expr></argument>,
<argument><expr><name>bool</name> <name>search_options</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></decl>;</decl_stmt>





<function><type><name>Flags</name> <modifier>&amp;</modifier></type><name>GetFlags</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>m_flags</name></expr>;</return> </block_content>}</block></function>





<expr_stmt><expr><specifier>const</specifier> <name>Flags</name> <operator>&amp;</operator><macro><name>GetFlags</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>m_flags</name></expr>;</return> }</block></expr></expr_stmt>












<function><type><name>virtual</name> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>GetRepeatCommand</name><parameter_list>(<parameter><decl><type><name>Args</name> <modifier>&amp;</modifier></type><name>current_command_args</name></decl></parameter>,
<parameter><decl><type><name>uint32_t</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>nullptr</name></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><name>bool</name> <macro><name>HasOverrideCallback</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>m_command_override_callback</name> <operator>||</operator>
<name>m_deprecated_command_override_callback</name></expr>;</return>
}</block></expr></expr_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>SetOverrideCallback</name><argument_list>(<argument><expr><name>lldb</name><operator>::</operator><name>CommandOverrideCallback</name> <name>callback</name></expr></argument>,
<argument><expr><name>void</name> <operator>*</operator><name>baton</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><name>m_deprecated_command_override_callback</name> <operator>=</operator> <name>callback</name></expr>;</expr_stmt>
<expr_stmt><expr><name>m_command_override_baton</name> <operator>=</operator> <name>baton</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>SetOverrideCallback</name><argument_list>(<argument><expr><name>lldb</name><operator>::</operator><name>CommandOverrideCallbackWithResult</name> <name>callback</name></expr></argument>,
<argument><expr><name>void</name> <operator>*</operator><name>baton</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><name>m_command_override_callback</name> <operator>=</operator> <name>callback</name></expr>;</expr_stmt>
<expr_stmt><expr><name>m_command_override_baton</name> <operator>=</operator> <name>baton</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<function><type><name>bool</name></type> <name>InvokeOverrideCallback</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>CommandReturnObject</name> <modifier>&amp;</modifier></type><name>result</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>m_command_override_callback</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>m_command_override_callback</name><argument_list>(<argument><expr><name>m_command_override_baton</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>,
<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>m_deprecated_command_override_callback</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>m_deprecated_command_override_callback</name><argument_list>(<argument><expr><name>m_command_override_baton</name></expr></argument>,
<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function_decl><type><name>virtual</name> <name>bool</name></type> <name>Execute</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>args_string</name></decl></parameter>,
<parameter><decl><type><name>CommandReturnObject</name> <modifier>&amp;</modifier></type><name>result</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>

<label><name>protected</name>:</label>
<function_decl><type><name>bool</name></type> <name>ParseOptionsAndNotify</name><parameter_list>(<parameter><decl><type><name>Args</name> <modifier>&amp;</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>CommandReturnObject</name> <modifier>&amp;</modifier></type><name>result</name></decl></parameter>,
<parameter><decl><type><name>OptionGroupOptions</name> <modifier>&amp;</modifier></type><name>group_options</name></decl></parameter>,
<parameter><decl><type><name>ExecutionContext</name> <modifier>&amp;</modifier></type><name>exe_ctx</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>virtual</name> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>GetInvalidTargetDescription</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><literal type="string">"invalid target, create a target using the 'target create' command"</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>virtual</name> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>GetInvalidProcessDescription</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><literal type="string">"invalid process"</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>virtual</name> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>GetInvalidThreadDescription</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><literal type="string">"invalid thread"</literal></expr>;</return> </block_content>}</block></function>

<function><type><name>virtual</name> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>GetInvalidFrameDescription</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><literal type="string">"invalid frame"</literal></expr>;</return> </block_content>}</block></function>

<function><type><name>virtual</name> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>GetInvalidRegContextDescription</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><literal type="string">"invalid frame, no registers"</literal></expr>;</return>
</block_content>}</block></function>




<function_decl><type><name>Target</name> <modifier>&amp;</modifier></type><name>GetSelectedOrDummyTarget</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>prefer_dummy</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Target</name> <modifier>&amp;</modifier></type><name>GetSelectedTarget</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>Target</name> <modifier>&amp;</modifier></type><name>GetDummyTarget</name><parameter_list>()</parameter_list>;</function_decl>






<function_decl><type><name>Thread</name> <modifier>*</modifier></type><name>GetDefaultThread</name><parameter_list>()</parameter_list>;</function_decl>










<function_decl><type><name>bool</name></type> <name>CheckRequirements</name><parameter_list>(<parameter><decl><type><name>CommandReturnObject</name> <modifier>&amp;</modifier></type><name>result</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>Cleanup</name><parameter_list>()</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>CommandInterpreter</name> <modifier>&amp;</modifier></type><name>m_interpreter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExecutionContext</name></type> <name>m_exe_ctx</name></decl>;</decl_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_lock</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>recursive_mutex</name></expr></argument>&gt;</argument_list></name> <name>m_api_locker</name></expr>;</expr_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>m_cmd_name</name></expr>;</expr_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>m_cmd_help_short</name></expr>;</expr_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>m_cmd_help_long</name></expr>;</expr_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>m_cmd_syntax</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>Flags</name></type> <name>m_flags</name></decl>;</decl_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CommandArgumentEntry</name></expr></argument>&gt;</argument_list></name> <name>m_arguments</name></expr>;</expr_stmt>
<expr_stmt><expr><name>lldb</name><operator>::</operator><name>CommandOverrideCallback</name> <name>m_deprecated_command_override_callback</name></expr>;</expr_stmt>
<expr_stmt><expr><name>lldb</name><operator>::</operator><name>CommandOverrideCallbackWithResult</name> <name>m_command_override_callback</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>m_command_override_baton</name></decl>;</decl_stmt>



<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type> <name>AddIDsArgumentData</name><argument_list>(<argument><expr><name>CommandArgumentEntry</name> <operator>&amp;</operator><name>arg</name></expr></argument>,
<argument><expr><name>lldb</name><operator>::</operator><name>CommandArgumentType</name> <name>ID</name></expr></argument>,
<argument><expr><name>lldb</name><operator>::</operator><name>CommandArgumentType</name> <name>IDRange</name></expr></argument>)</argument_list></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>CommandObjectParsed</name> <range>: <expr><name>public</name> <name>CommandObject</name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>CommandObjectParsed</name><argument_list>(<argument>CommandInterpreter &amp;interpreter</argument>, <argument>const char *name</argument>,
<argument>const char *help = nullptr</argument>, <argument>const char *syntax = nullptr</argument>,
<argument>uint32_t flags = <literal type="number">0</literal></argument>)</argument_list></macro>
<operator>:</operator> <macro><name>CommandObject</name><argument_list>(<argument>interpreter</argument>, <argument>name</argument>, <argument>help</argument>, <argument>syntax</argument>, <argument>flags</argument>)</argument_list></macro> <block>{}</block>

<operator>~</operator><macro><name>CommandObjectParsed</name><argument_list>()</argument_list></macro> <name>override</name> <operator>=</operator> default</expr>;

<expr><name>bool</name> <macro><name>Execute</name><argument_list>(<argument>const char *args_string</argument>, <argument>CommandReturnObject &amp;result</argument>)</argument_list></macro> <name>override</name></expr>;

<expr><name>protected</name><operator>:</operator>
<name>virtual</name> <name>bool</name> <call><name>DoExecute</name><argument_list>(<argument><expr><name>Args</name> <operator>&amp;</operator><name>command</name></expr></argument>, <argument><expr><name>CommandReturnObject</name> <operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>bool</name> <macro><name>WantsRawCommandString</name><argument_list>()</argument_list></macro> <name>override</name> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block>
}</expr>;

<expr><name>class</name> <name>CommandObjectRaw</name> <operator>:</operator> <name>public</name> <name>CommandObject</name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>CommandObjectRaw</name><argument_list>(<argument>CommandInterpreter &amp;interpreter</argument>, <argument>llvm::StringRef name</argument>,
<argument>llvm::StringRef help = <literal type="string">""</literal></argument>, <argument>llvm::StringRef syntax = <literal type="string">""</literal></argument>,
<argument>uint32_t flags = <literal type="number">0</literal></argument>)</argument_list></macro>
<operator>:</operator> <macro><name>CommandObject</name><argument_list>(<argument>interpreter</argument>, <argument>name</argument>, <argument>help</argument>, <argument>syntax</argument>, <argument>flags</argument>)</argument_list></macro> <block>{}</block>

<operator>~</operator><macro><name>CommandObjectRaw</name><argument_list>()</argument_list></macro> <name>override</name> <operator>=</operator> default</expr>;

<expr><name>bool</name> <macro><name>Execute</name><argument_list>(<argument>const char *args_string</argument>, <argument>CommandReturnObject &amp;result</argument>)</argument_list></macro> <name>override</name></expr>;

<expr><name>protected</name><operator>:</operator>
<name>virtual</name> <name>bool</name> <macro><name>DoExecute</name><argument_list>(<argument>llvm::StringRef command</argument>,
<argument>CommandReturnObject &amp;result</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>bool</name> <macro><name>WantsRawCommandString</name><argument_list>()</argument_list></macro> <name>override</name> <block>{ <return>return <expr><name>true</name></expr>;</return> }</block>
}</expr>;

}</block></expr></block></expr></range></decl></decl_stmt></block_content></block></decl></decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
