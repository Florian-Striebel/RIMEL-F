<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/lldb/include/lldb/Core/ValueObject.h">







<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLDB_CORE_VALUEOBJECT_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLDB_CORE_VALUEOBJECT_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lldb/Core/Value.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lldb/Symbol/CompilerType.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lldb/Symbol/Type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lldb/Target/ExecutionContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lldb/Target/Process.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lldb/Utility/ConstString.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lldb/Utility/DataExtractor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lldb/Utility/SharedCluster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lldb/Utility/Status.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lldb/Utility/UserID.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lldb/lldb-defines.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lldb/lldb-enumerations.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lldb/lldb-forward.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lldb/lldb-private-enumerations.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lldb/lldb-types.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/ArrayRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/Optional.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/SmallVector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/StringRef.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;functional&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;initializer_list&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;map&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mutex&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utility&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstddef&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstdint&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>lldb_private</name> <block>{<block_content>
<decl_stmt><decl><type><name>class</name></type> <name>Declaration</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>DumpValueObjectOptions</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>EvaluateExpressionOptions</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ExecutionContextScope</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Log</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Scalar</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Stream</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>SymbolContextScope</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TypeFormatImpl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TypeSummaryImpl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TypeSummaryOptions</name></decl>;</decl_stmt>


















































<decl_stmt><decl><type><name>class</name></type> <name>ValueObject</name> <block>{<block_content>
<label><name>public</name>:</label>
<enum>enum <name>GetExpressionPathFormat</name> <block>{
<decl><name>eGetExpressionPathFormatDereferencePointers</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
<decl><name>eGetExpressionPathFormatHonorPointers</name></decl>
}</block>;</enum>

<enum>enum <name>ValueObjectRepresentationStyle</name> <block>{
<decl><name>eValueObjectRepresentationStyleValue</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
<decl><name>eValueObjectRepresentationStyleSummary</name></decl>,
<decl><name>eValueObjectRepresentationStyleLanguageSpecific</name></decl>,
<decl><name>eValueObjectRepresentationStyleLocation</name></decl>,
<decl><name>eValueObjectRepresentationStyleChildrenCount</name></decl>,
<decl><name>eValueObjectRepresentationStyleType</name></decl>,
<decl><name>eValueObjectRepresentationStyleName</name></decl>,
<decl><name>eValueObjectRepresentationStyleExpressionPath</name></decl>
}</block>;</enum>

<enum>enum <name>ExpressionPathScanEndReason</name> <block>{

<decl><name>eExpressionPathScanEndReasonEndOfString</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,

<decl><name>eExpressionPathScanEndReasonNoSuchChild</name></decl>,

<decl><name>eExpressionPathScanEndReasonNoSuchSyntheticChild</name></decl>,

<decl><name>eExpressionPathScanEndReasonEmptyRangeNotAllowed</name></decl>,

<decl><name>eExpressionPathScanEndReasonDotInsteadOfArrow</name></decl>,

<decl><name>eExpressionPathScanEndReasonArrowInsteadOfDot</name></decl>,

<decl><name>eExpressionPathScanEndReasonFragileIVarNotAllowed</name></decl>,

<decl><name>eExpressionPathScanEndReasonRangeOperatorNotAllowed</name></decl>,

<decl><name>eExpressionPathScanEndReasonRangeOperatorInvalid</name></decl>,

<decl><name>eExpressionPathScanEndReasonArrayRangeOperatorMet</name></decl>,

<decl><name>eExpressionPathScanEndReasonBitfieldRangeOperatorMet</name></decl>,

<decl><name>eExpressionPathScanEndReasonUnexpectedSymbol</name></decl>,

<decl><name>eExpressionPathScanEndReasonTakingAddressFailed</name></decl>,

<decl><name>eExpressionPathScanEndReasonDereferencingFailed</name></decl>,

<decl><name>eExpressionPathScanEndReasonRangeOperatorExpanded</name></decl>,

<decl><name>eExpressionPathScanEndReasonSyntheticValueMissing</name></decl>,
<decl><name>eExpressionPathScanEndReasonUnknown</name> <init>= <expr><literal type="number">0xFFFF</literal></expr></init></decl>
}</block>;</enum>

<enum>enum <name>ExpressionPathEndResultType</name> <block>{

<decl><name>eExpressionPathEndResultTypePlain</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,

<decl><name>eExpressionPathEndResultTypeBitfield</name></decl>,

<decl><name>eExpressionPathEndResultTypeBoundedRange</name></decl>,

<decl><name>eExpressionPathEndResultTypeUnboundedRange</name></decl>,

<decl><name>eExpressionPathEndResultTypeValueObjectList</name></decl>,
<decl><name>eExpressionPathEndResultTypeInvalid</name> <init>= <expr><literal type="number">0xFFFF</literal></expr></init></decl>
}</block>;</enum>

<enum>enum <name>ExpressionPathAftermath</name> <block>{

<decl><name>eExpressionPathAftermathNothing</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,

<decl><name>eExpressionPathAftermathDereference</name></decl>,

<decl><name>eExpressionPathAftermathTakeAddress</name></decl>
}</block>;</enum>

<enum>enum <name>ClearUserVisibleDataItems</name> <block>{
<decl><name>eClearUserVisibleDataItemsNothing</name> <init>= <expr><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <literal type="number">0</literal></expr></init></decl>,
<decl><name>eClearUserVisibleDataItemsValue</name> <init>= <expr><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr></init></decl>,
<decl><name>eClearUserVisibleDataItemsSummary</name> <init>= <expr><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <literal type="number">2</literal></expr></init></decl>,
<decl><name>eClearUserVisibleDataItemsLocation</name> <init>= <expr><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <literal type="number">3</literal></expr></init></decl>,
<decl><name>eClearUserVisibleDataItemsDescription</name> <init>= <expr><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <literal type="number">4</literal></expr></init></decl>,
<decl><name>eClearUserVisibleDataItemsSyntheticChildren</name> <init>= <expr><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <literal type="number">5</literal></expr></init></decl>,
<decl><name>eClearUserVisibleDataItemsAllStrings</name> <init>=
<expr><name>eClearUserVisibleDataItemsValue</name> <operator>|</operator> <name>eClearUserVisibleDataItemsSummary</name> <operator>|</operator>
<name>eClearUserVisibleDataItemsLocation</name> <operator>|</operator>
<name>eClearUserVisibleDataItemsDescription</name></expr></init></decl>,
<decl><name>eClearUserVisibleDataItemsAll</name> <init>= <expr><literal type="number">0xFFFF</literal></expr></init></decl>
}</block>;</enum>

<struct>struct <name>GetValueForExpressionPathOptions</name> <block>{
<decl_stmt><decl><type><name><name>enum</name> <name>class</name></name></type> <name>SyntheticChildrenTraversal</name> <block>{<block_content>
<expr_stmt><expr><name>None</name></expr><operator>,</operator>
<expr><name>ToSynthetic</name></expr><operator>,</operator>
<expr><name>FromSynthetic</name></expr><operator>,</operator>
<expr><name>Both</name></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>m_check_dot_vs_arrow_syntax</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>m_no_fragile_ivar</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>m_allow_bitfields_syntax</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SyntheticChildrenTraversal</name></type> <name>m_synthetic_children_traversal</name></decl>;</decl_stmt>

<macro><name>GetValueForExpressionPathOptions</name><argument_list>(
<argument>bool dot = false</argument>, <argument>bool no_ivar = false</argument>, <argument>bool bitfield = true</argument>,
<argument>SyntheticChildrenTraversal synth_traverse =
SyntheticChildrenTraversal::ToSynthetic</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>m_check_dot_vs_arrow_syntax</name><argument_list>(<argument><expr><name>dot</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>m_no_fragile_ivar</name><argument_list>(<argument><expr><name>no_ivar</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>m_allow_bitfields_syntax</name><argument_list>(<argument><expr><name>bitfield</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>m_synthetic_children_traversal</name><argument_list>(<argument>synth_traverse</argument>)</argument_list></macro> <expr><block>{}</block>

<name>GetValueForExpressionPathOptions</name> <operator>&amp;</operator><macro><name>DoCheckDotVsArrowSyntax</name><argument_list>()</argument_list></macro> <block>{
<expr><name>m_check_dot_vs_arrow_syntax</name> <operator>=</operator> <name>true</name></expr>;
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>GetValueForExpressionPathOptions</name> <modifier>&amp;</modifier></type><name>DontCheckDotVsArrowSyntax</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>m_check_dot_vs_arrow_syntax</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>GetValueForExpressionPathOptions</name> <modifier>&amp;</modifier></type><name>DoAllowFragileIVar</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>m_no_fragile_ivar</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>GetValueForExpressionPathOptions</name> <modifier>&amp;</modifier></type><name>DontAllowFragileIVar</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>m_no_fragile_ivar</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>GetValueForExpressionPathOptions</name> <modifier>&amp;</modifier></type><name>DoAllowBitfieldSyntax</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>m_allow_bitfields_syntax</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>GetValueForExpressionPathOptions</name> <modifier>&amp;</modifier></type><name>DontAllowBitfieldSyntax</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>m_allow_bitfields_syntax</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>GetValueForExpressionPathOptions</name> <modifier>&amp;</modifier></type>
<name>SetSyntheticChildrenTraversal</name><parameter_list>(<parameter><decl><type><name>SyntheticChildrenTraversal</name></type> <name>traverse</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>m_synthetic_children_traversal</name> <operator>=</operator> <name>traverse</name></expr>;</expr_stmt>
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>GetValueForExpressionPathOptions</name></type> <name>DefaultOptions</name><parameter_list>()</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>GetValueForExpressionPathOptions</name></type> <name>g_default_options</name></decl>;</decl_stmt>

<return>return <expr><name>g_default_options</name></expr>;</return>
</block_content>}</block></function>
}</block>;</struct>

<decl_stmt><decl><type><name>class</name></type> <name>EvaluationPoint</name> <block>{<block_content>
<label><name>public</name>:</label>
<expr_stmt><expr><call><name>EvaluationPoint</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<macro><name>EvaluationPoint</name><argument_list>(<argument>ExecutionContextScope *exe_scope</argument>,
<argument>bool use_selected = false</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<expr_stmt><expr><call><name>EvaluationPoint</name><argument_list>(<argument><expr><specifier>const</specifier> <name>EvaluationPoint</name> <operator>&amp;</operator><name>rhs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>~</operator><call><name>EvaluationPoint</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>ExecutionContextRef</name> <operator>&amp;</operator><macro><name>GetExecutionContextRef</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>m_exe_ctx_ref</name></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>SetIsConstant</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>SetUpdated</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>m_mod_id</name><operator>.</operator><name>SetInvalid</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name>bool</name> <macro><name>IsConstant</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>!</operator><call><name><name>m_mod_id</name><operator>.</operator><name>IsValid</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>ProcessModID</name> <macro><name>GetModID</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>m_mod_id</name></expr>;</return> }</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>SetUpdateID</name><parameter_list>(<parameter><decl><type><name>ProcessModID</name></type> <name>new_id</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>m_mod_id</name> <operator>=</operator> <name>new_id</name></expr>;</expr_stmt> </block_content>}</block></function>

<function><type><name>void</name></type> <name>SetNeedsUpdate</name><parameter_list>()</parameter_list> <block>{<block_content> <expr_stmt><expr><name>m_needs_update</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt> </block_content>}</block></function>

<function_decl><type><name>void</name></type> <name>SetUpdated</name><parameter_list>()</parameter_list>;</function_decl>

<function><type><name>bool</name></type> <name>NeedsUpdating</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>accept_invalid_exe_ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>SyncWithProcessState</name><argument_list>(<argument><expr><name>accept_invalid_exe_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>m_needs_update</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>IsValid</name><parameter_list>()</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>accept_invalid_exe_ctx</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>m_mod_id</name><operator>.</operator><name>IsValid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>SyncWithProcessState</name><argument_list>(<argument><expr><name>accept_invalid_exe_ctx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>m_mod_id</name><operator>.</operator><name>IsValid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>SetInvalid</name><parameter_list>()</parameter_list> <block>{<block_content>


<expr_stmt><expr><call><name><name>m_mod_id</name><operator>.</operator><name>SetInvalid</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>m_needs_update</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<label><name>private</name>:</label>
<function_decl><type><name>bool</name></type> <name>SyncWithProcessState</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>accept_invalid_exe_ctx</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>ProcessModID</name></type> <name>m_mod_id</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ExecutionContextRef</name></type> <name>m_exe_ctx_ref</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>m_needs_update</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<expr_stmt><expr><name>virtual</name> <operator>~</operator><call><name>ValueObject</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>EvaluationPoint</name> <operator>&amp;</operator><macro><name>GetUpdatePoint</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>m_update_point</name></expr>;</return> }</block></expr></expr_stmt>

<function><type><name>EvaluationPoint</name> <modifier>&amp;</modifier></type><name>GetUpdatePoint</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>m_update_point</name></expr>;</return> </block_content>}</block></function>

<expr_stmt><expr><specifier>const</specifier> <name>ExecutionContextRef</name> <operator>&amp;</operator><macro><name>GetExecutionContextRef</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>m_update_point</name><operator>.</operator><name>GetExecutionContextRef</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>lldb</name><operator>::</operator><name>TargetSP</name> <macro><name>GetTargetSP</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>m_update_point</name><operator>.</operator><name>GetExecutionContextRef</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>GetTargetSP</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>lldb</name><operator>::</operator><name>ProcessSP</name> <macro><name>GetProcessSP</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>m_update_point</name><operator>.</operator><name>GetExecutionContextRef</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>GetProcessSP</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>lldb</name><operator>::</operator><name>ThreadSP</name> <macro><name>GetThreadSP</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>m_update_point</name><operator>.</operator><name>GetExecutionContextRef</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>GetThreadSP</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>lldb</name><operator>::</operator><name>StackFrameSP</name> <macro><name>GetFrameSP</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>m_update_point</name><operator>.</operator><name>GetExecutionContextRef</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>GetFrameSP</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function_decl><type><name>void</name></type> <name>SetNeedsUpdate</name><parameter_list>()</parameter_list>;</function_decl>

<function><type><name>CompilerType</name></type> <name>GetCompilerType</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name>MaybeCalculateCompleteType</name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>


<function><type><name>virtual</name> <name>TypeImpl</name></type> <name>GetTypeImpl</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name>TypeImpl</name><argument_list>(<argument><expr><call><name>GetCompilerType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>

<function_decl><type><name>virtual</name> <name>bool</name></type> <name>CanProvideValue</name><parameter_list>()</parameter_list>;</function_decl>


<expr_stmt><expr><name>virtual</name> <name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>uint64_t</name></expr></argument>&gt;</argument_list></name> <call><name>GetByteSize</name><argument_list>()</argument_list></call> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>virtual</name> <name>lldb</name><operator>::</operator><name>ValueType</name> <macro><name>GetValueType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>


<function><type><name>virtual</name> <name>ConstString</name></type> <name>GetTypeName</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name>GetCompilerType</name><argument_list>()</argument_list></call><operator>.</operator><call><name>GetTypeName</name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>

<function><type><name>virtual</name> <name>ConstString</name></type> <name>GetDisplayTypeName</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name>GetTypeName</name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>

<function><type><name>virtual</name> <name>ConstString</name></type> <name>GetQualifiedTypeName</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name>GetCompilerType</name><argument_list>()</argument_list></call><operator>.</operator><call><name>GetTypeName</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><name>virtual</name> <name>lldb</name><operator>::</operator><name>LanguageType</name> <macro><name>GetObjectRuntimeLanguage</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>GetCompilerType</name><argument_list>()</argument_list></call><operator>.</operator><call><name>GetMinimumLanguage</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>virtual</name> <name>uint32_t</name></type>
<name>GetTypeInfo</name><parameter_list>(<parameter><decl><type><name>CompilerType</name> <modifier>*</modifier></type><name>pointee_or_element_compiler_type</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>GetCompilerType</name><argument_list>()</argument_list></call><operator>.</operator><call><name>GetTypeInfo</name><argument_list>(<argument><expr><name>pointee_or_element_compiler_type</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>virtual</name> <name>bool</name></type> <name>IsPointerType</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name>GetCompilerType</name><argument_list>()</argument_list></call><operator>.</operator><call><name>IsPointerType</name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>

<function><type><name>virtual</name> <name>bool</name></type> <name>IsArrayType</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name>GetCompilerType</name><argument_list>()</argument_list></call><operator>.</operator><call><name>IsArrayType</name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>

<function><type><name>virtual</name> <name>bool</name></type> <name>IsScalarType</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name>GetCompilerType</name><argument_list>()</argument_list></call><operator>.</operator><call><name>IsScalarType</name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>

<function><type><name>virtual</name> <name>bool</name></type> <name>IsPointerOrReferenceType</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name>GetCompilerType</name><argument_list>()</argument_list></call><operator>.</operator><call><name>IsPointerOrReferenceType</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function_decl><type><name>virtual</name> <name>bool</name></type> <name>IsPossibleDynamicType</name><parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>IsNilReference</name><parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>IsUninitializedReference</name><parameter_list>()</parameter_list>;</function_decl>

<function><type><name>virtual</name> <name>bool</name></type> <name>IsBaseClass</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>false</name></expr>;</return> </block_content>}</block></function>

<function_decl><type><name>bool</name></type> <name>IsBaseClass</name><parameter_list>(<parameter><decl><type><name>uint32_t</name> <modifier>&amp;</modifier></type><name>depth</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>virtual</name> <name>bool</name></type> <name>IsDereferenceOfParent</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>false</name></expr>;</return> </block_content>}</block></function>

<function><type><name>bool</name></type> <name>IsIntegerType</name><parameter_list>(<parameter><decl><type><name>bool</name> <modifier>&amp;</modifier></type><name>is_signed</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>GetCompilerType</name><argument_list>()</argument_list></call><operator>.</operator><call><name>IsIntegerType</name><argument_list>(<argument><expr><name>is_signed</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function_decl><type><name>virtual</name> <name>void</name></type> <name>GetExpressionPath</name><parameter_list>(
<parameter><decl><type><name>Stream</name> <modifier>&amp;</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><name>GetExpressionPathFormat</name></type> <init>= <expr><name>eGetExpressionPathFormatDereferencePointers</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><name>lldb</name><operator>::</operator><name>ValueObjectSP</name> <macro><name>GetValueForExpressionPath</name><argument_list>(
<argument>llvm::StringRef expression</argument>,
<argument>ExpressionPathScanEndReason *reason_to_stop = nullptr</argument>,
<argument>ExpressionPathEndResultType *final_value_type = nullptr</argument>,
<argument>const GetValueForExpressionPathOptions &amp;options =
GetValueForExpressionPathOptions::DefaultOptions()</argument>,
<argument>ExpressionPathAftermath *final_task_on_target = nullptr</argument>)</argument_list></macro></expr>;</expr_stmt>

<function><type><name>virtual</name> <name>bool</name></type> <name>IsInScope</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>true</name></expr>;</return> </block_content>}</block></function>

<expr_stmt><expr><name>virtual</name> <name>lldb</name><operator>::</operator><name>offset_t</name> <macro><name>GetByteOffset</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><literal type="number">0</literal></expr>;</return> }</block></expr></expr_stmt>

<function><type><name>virtual</name> <name>uint32_t</name></type> <name>GetBitfieldBitSize</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><literal type="number">0</literal></expr>;</return> </block_content>}</block></function>

<function><type><name>virtual</name> <name>uint32_t</name></type> <name>GetBitfieldBitOffset</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><literal type="number">0</literal></expr>;</return> </block_content>}</block></function>

<function><type><name>bool</name></type> <name>IsBitfield</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><operator>(</operator><call><name>GetBitfieldBitSize</name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><call><name>GetBitfieldBitOffset</name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>virtual</name> <name>bool</name></type> <name>IsArrayItemForPointer</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><name><name>m_flags</name><operator>.</operator><name>m_is_array_item_for_pointer</name></name></expr>;</return>
</block_content>}</block></function>

<function_decl><type><name>virtual</name> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>GetValueAsCString</name><parameter_list>()</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>virtual</name> <name>bool</name></type> <name>GetValueAsCString</name><argument_list>(<argument><expr><specifier>const</specifier> <name>lldb_private</name><operator>::</operator><name>TypeFormatImpl</name> <operator>&amp;</operator><name>format</name></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><name>string</name> <operator>&amp;</operator><name>destination</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>GetValueAsCString</name><argument_list>(<argument><expr><name>lldb</name><operator>::</operator><name>Format</name> <name>format</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name>string</name> <operator>&amp;</operator><name>destination</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function_decl><type><name>virtual</name> <name>uint64_t</name></type> <name>GetValueAsUnsigned</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>fail_value</name></decl></parameter>,
<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>success</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>virtual</name> <name>int64_t</name></type> <name>GetValueAsSigned</name><parameter_list>(<parameter><decl><type><name>int64_t</name></type> <name>fail_value</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>success</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>virtual</name> <name>bool</name></type> <name>SetValueFromCString</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value_str</name></decl></parameter>, <parameter><decl><type><name>Status</name> <modifier>&amp;</modifier></type><name>error</name></decl></parameter>)</parameter_list>;</function_decl>




<expr_stmt><expr><name>virtual</name> <name>lldb</name><operator>::</operator><name>ModuleSP</name> <call><name>GetModule</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<function_decl><type><name>ValueObject</name> <modifier>*</modifier></type><name>GetRoot</name><parameter_list>()</parameter_list>;</function_decl>




<decl_stmt><decl><type><name>ValueObject</name> <modifier>*</modifier></type><name>FollowParentChain</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name><name>function</name><argument_list type="generic">&lt;<argument><expr><name>bool</name><operator>(</operator><name>ValueObject</name> <operator>*</operator><operator>)</operator></expr></argument>&gt;</argument_list></name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function_decl><type><name>virtual</name> <name>bool</name></type> <name>GetDeclaration</name><parameter_list>(<parameter><decl><type><name>Declaration</name> <modifier>&amp;</modifier></type><name>decl</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><specifier>const</specifier> <name>Status</name> <modifier>&amp;</modifier></type><name>GetError</name><parameter_list>()</parameter_list>;</function_decl>

<expr_stmt><expr><name>ConstString</name> <macro><name>GetName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>m_name</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>lldb</name><operator>::</operator><name>user_id_t</name> <macro><name>GetID</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>m_id</name><operator>.</operator><name>GetID</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>virtual</name> <name>lldb</name><operator>::</operator><name>ValueObjectSP</name> <macro><name>GetChildAtIndex</name><argument_list>(<argument>size_t idx</argument>, <argument>bool can_create</argument>)</argument_list></macro></expr>;</expr_stmt>


<expr_stmt><expr><name>lldb</name><operator>::</operator><name>ValueObjectSP</name> <call><name>GetChildAtIndexPath</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>size_t</name></expr></argument>&gt;</argument_list></name> <name>idxs</name></expr></argument>,
<argument><expr><name>size_t</name> <operator>*</operator><name>index_of_error</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>lldb</name><operator>::</operator><name>ValueObjectSP</name>
<call><name>GetChildAtIndexPath</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>size_t</name></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <name>idxs</name></expr></argument>,
<argument><expr><name>size_t</name> <operator>*</operator><name>index_of_error</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>lldb</name><operator>::</operator><name>ValueObjectSP</name> <call><name>GetChildAtNamePath</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ConstString</name></expr></argument>&gt;</argument_list></name> <name>names</name></expr></argument>,
<argument><expr><name>ConstString</name> <operator>*</operator><name>name_of_error</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>lldb</name><operator>::</operator><name>ValueObjectSP</name>
<call><name>GetChildAtNamePath</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>ConstString</name></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <name>names</name></expr></argument>,
<argument><expr><name>ConstString</name> <operator>*</operator><name>name_of_error</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>virtual</name> <name>lldb</name><operator>::</operator><name>ValueObjectSP</name> <macro><name>GetChildMemberWithName</name><argument_list>(<argument>ConstString name</argument>,
<argument>bool can_create</argument>)</argument_list></macro></expr>;</expr_stmt>

<function_decl><type><name>virtual</name> <name>size_t</name></type> <name>GetIndexOfChildWithName</name><parameter_list>(<parameter><decl><type><name>ConstString</name></type> <name>name</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>size_t</name></type> <name>GetNumChildren</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>max</name> <init>= <expr><name>UINT32_MAX</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><specifier>const</specifier> <name>Value</name> <operator>&amp;</operator><macro><name>GetValue</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>m_value</name></expr>;</return> }</block></expr></expr_stmt>

<function><type><name>Value</name> <modifier>&amp;</modifier></type><name>GetValue</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>m_value</name></expr>;</return> </block_content>}</block></function>

<function_decl><type><name>virtual</name> <name>bool</name></type> <name>ResolveValue</name><parameter_list>(<parameter><decl><type><name>Scalar</name> <modifier>&amp;</modifier></type><name>scalar</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>virtual</name> <name>bool</name></type> <name>IsLogicalTrue</name><parameter_list>(<parameter><decl><type><name>Status</name> <modifier>&amp;</modifier></type><name>error</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>virtual</name> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>GetLocationAsCString</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name>GetLocationAsCStringImpl</name><argument_list>(<argument><expr><name>m_value</name></expr></argument>, <argument><expr><name>m_data</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>GetSummaryAsCString</name><argument_list>(<argument><expr><name>lldb</name><operator>::</operator><name>LanguageType</name> <name>lang</name> <operator>=</operator> <name>lldb</name><operator>::</operator><name>eLanguageTypeUnknown</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type>
<name>GetSummaryAsCString</name><argument_list>(<argument><expr><name>TypeSummaryImpl</name> <operator>*</operator><name>summary_ptr</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name>string</name> <operator>&amp;</operator><name>destination</name></expr></argument>,
<argument><expr><name>lldb</name><operator>::</operator><name>LanguageType</name> <name>lang</name> <operator>=</operator> <name>lldb</name><operator>::</operator><name>eLanguageTypeUnknown</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>GetSummaryAsCString</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name>string</name> <operator>&amp;</operator><name>destination</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>TypeSummaryOptions</name> <operator>&amp;</operator><name>options</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>GetSummaryAsCString</name><argument_list>(<argument><expr><name>TypeSummaryImpl</name> <operator>*</operator><name>summary_ptr</name></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><name>string</name> <operator>&amp;</operator><name>destination</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>TypeSummaryOptions</name> <operator>&amp;</operator><name>options</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function_decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>GetObjectDescription</name><parameter_list>()</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>bool</name></type> <name>HasSpecialPrintableRepresentation</name><argument_list>(
<argument><expr><name>ValueObjectRepresentationStyle</name> <name>val_obj_display</name></expr></argument>,
<argument><expr><name>lldb</name><operator>::</operator><name>Format</name> <name>custom_format</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>class</name></name></type> <name>PrintableRepresentationSpecialCases</name> <range>: <expr><name>bool</name> <block>{
<expr><name>eDisable</name> <operator>=</operator> <name>false</name></expr>,
<expr><name>eAllow</name> <operator>=</operator> <name>true</name></expr>
}</block></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type>
<name>DumpPrintableRepresentation</name><argument_list>(<argument><expr><name>Stream</name> <operator>&amp;</operator><name>s</name></expr></argument>,
<argument><expr><name>ValueObjectRepresentationStyle</name> <name>val_obj_display</name> <operator>=</operator>
<name>eValueObjectRepresentationStyleSummary</name></expr></argument>,
<argument><expr><name>lldb</name><operator>::</operator><name>Format</name> <name>custom_format</name> <operator>=</operator> <name>lldb</name><operator>::</operator><name>eFormatInvalid</name></expr></argument>,
<argument><expr><name>PrintableRepresentationSpecialCases</name> <name>special</name> <operator>=</operator>
<name>PrintableRepresentationSpecialCases</name><operator>::</operator><name>eAllow</name></expr></argument>,
<argument><expr><name>bool</name> <name>do_dump_error</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>GetValueIsValid</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>m_flags</name><operator>.</operator><name>m_value_is_valid</name></name></expr>;</return> }</block></expr></expr_stmt>



<function><type><name>bool</name></type> <name>GetValueDidChange</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name><name>m_flags</name><operator>.</operator><name>m_value_did_change</name></name></expr>;</return> </block_content>}</block></function>

<function_decl><type><name>bool</name></type> <name>UpdateValueIfNeeded</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>update_format</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>UpdateFormatsIfNeeded</name><parameter_list>()</parameter_list>;</function_decl>

<expr_stmt><expr><name>lldb</name><operator>::</operator><name>ValueObjectSP</name> <macro><name>GetSP</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>m_manager</name><operator>-&gt;</operator><name>GetSharedPointer</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>




<function><type><name>void</name></type> <name>SetName</name><parameter_list>(<parameter><decl><type><name>ConstString</name></type> <name>name</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>m_name</name> <operator>=</operator> <name>name</name></expr>;</expr_stmt> </block_content>}</block></function>

<expr_stmt><expr><name>virtual</name> <name>lldb</name><operator>::</operator><name>addr_t</name> <macro><name>GetAddressOf</name><argument_list>(<argument>bool scalar_is_load_address = true</argument>,
<argument>AddressType *address_type = nullptr</argument>)</argument_list></macro></expr>;</expr_stmt>

<expr_stmt><expr><name>lldb</name><operator>::</operator><name>addr_t</name> <call><name>GetPointerValue</name><argument_list>(<argument><expr><name>AddressType</name> <operator>*</operator><name>address_type</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>lldb</name><operator>::</operator><name>ValueObjectSP</name> <macro><name>GetSyntheticChild</name><argument_list>(<argument>ConstString key</argument>)</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<expr_stmt><expr><name>lldb</name><operator>::</operator><name>ValueObjectSP</name> <macro><name>GetSyntheticArrayMember</name><argument_list>(<argument>size_t index</argument>, <argument>bool can_create</argument>)</argument_list></macro></expr>;</expr_stmt>

<expr_stmt><expr><name>lldb</name><operator>::</operator><name>ValueObjectSP</name> <macro><name>GetSyntheticBitFieldChild</name><argument_list>(<argument>uint32_t from</argument>, <argument>uint32_t to</argument>,
<argument>bool can_create</argument>)</argument_list></macro></expr>;</expr_stmt>

<expr_stmt><expr><name>lldb</name><operator>::</operator><name>ValueObjectSP</name> <macro><name>GetSyntheticExpressionPathChild</name><argument_list>(<argument>const char *expression</argument>,
<argument>bool can_create</argument>)</argument_list></macro></expr>;</expr_stmt>

<expr_stmt><expr><name>virtual</name> <name>lldb</name><operator>::</operator><name>ValueObjectSP</name>
<macro><name>GetSyntheticChildAtOffset</name><argument_list>(<argument>uint32_t offset</argument>, <argument>const CompilerType &amp;type</argument>,
<argument>bool can_create</argument>,
<argument>ConstString name_const_str = ConstString()</argument>)</argument_list></macro></expr>;</expr_stmt>

<expr_stmt><expr><name>virtual</name> <name>lldb</name><operator>::</operator><name>ValueObjectSP</name>
<macro><name>GetSyntheticBase</name><argument_list>(<argument>uint32_t offset</argument>, <argument>const CompilerType &amp;type</argument>, <argument>bool can_create</argument>,
<argument>ConstString name_const_str = ConstString()</argument>)</argument_list></macro></expr>;</expr_stmt>

<expr_stmt><expr><name>virtual</name> <name>lldb</name><operator>::</operator><name>ValueObjectSP</name> <macro><name>GetDynamicValue</name><argument_list>(<argument>lldb::DynamicValueType valueType</argument>)</argument_list></macro></expr>;</expr_stmt>

<expr_stmt><expr><name>lldb</name><operator>::</operator><name>DynamicValueType</name> <call><name>GetDynamicValueType</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>virtual</name> <name>lldb</name><operator>::</operator><name>ValueObjectSP</name> <macro><name>GetStaticValue</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>GetSP</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>virtual</name> <name>lldb</name><operator>::</operator><name>ValueObjectSP</name> <macro><name>GetNonSyntheticValue</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>GetSP</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>lldb</name><operator>::</operator><name>ValueObjectSP</name> <call><name>GetSyntheticValue</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<function_decl><type><name>virtual</name> <name>bool</name></type> <name>HasSyntheticValue</name><parameter_list>()</parameter_list>;</function_decl>

<function><type><name>virtual</name> <name>bool</name></type> <name>IsSynthetic</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>false</name></expr>;</return> </block_content>}</block></function>

<expr_stmt><expr><name>lldb</name><operator>::</operator><name>ValueObjectSP</name>
<macro><name>GetQualifiedRepresentationIfAvailable</name><argument_list>(<argument>lldb::DynamicValueType dynValue</argument>,
<argument>bool synthValue</argument>)</argument_list></macro></expr>;</expr_stmt>

<expr_stmt><expr><name>virtual</name> <name>lldb</name><operator>::</operator><name>ValueObjectSP</name> <macro><name>CreateConstantValue</name><argument_list>(<argument>ConstString name</argument>)</argument_list></macro></expr>;</expr_stmt>

<expr_stmt><expr><name>virtual</name> <name>lldb</name><operator>::</operator><name>ValueObjectSP</name> <call><name>Dereference</name><argument_list>(<argument><expr><name>Status</name> <operator>&amp;</operator><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><name>virtual</name> <name>lldb</name><operator>::</operator><name>ValueObjectSP</name> <macro><name>Clone</name><argument_list>(<argument>ConstString new_name</argument>)</argument_list></macro></expr>;</expr_stmt>

<expr_stmt><expr><name>virtual</name> <name>lldb</name><operator>::</operator><name>ValueObjectSP</name> <call><name>AddressOf</name><argument_list>(<argument><expr><name>Status</name> <operator>&amp;</operator><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>virtual</name> <name>lldb</name><operator>::</operator><name>addr_t</name> <macro><name>GetLiveAddress</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>LLDB_INVALID_ADDRESS</name></expr>;</return> }</block></expr></expr_stmt>

<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>SetLiveAddress</name><argument_list>(<argument><expr><name>lldb</name><operator>::</operator><name>addr_t</name> <name>addr</name> <operator>=</operator> <name>LLDB_INVALID_ADDRESS</name></expr></argument>,
<argument><expr><name>AddressType</name> <name>address_type</name> <operator>=</operator> <name>eAddressTypeLoad</name></expr></argument>)</argument_list> <block>{<block_content/>}</block></decl></decl_stmt>

<expr_stmt><expr><name>virtual</name> <name>lldb</name><operator>::</operator><name>ValueObjectSP</name> <call><name>Cast</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CompilerType</name> <operator>&amp;</operator><name>compiler_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>virtual</name> <name>lldb</name><operator>::</operator><name>ValueObjectSP</name> <call><name>CastPointerType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>name</name></expr></argument>,
<argument><expr><name>CompilerType</name> <operator>&amp;</operator><name>ast_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>virtual</name> <name>lldb</name><operator>::</operator><name>ValueObjectSP</name> <call><name>CastPointerType</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>name</name></expr></argument>,
<argument><expr><name>lldb</name><operator>::</operator><name>TypeSP</name> <operator>&amp;</operator><name>type_sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<function><type><name>virtual</name> <name>void</name></type> <name>ValueUpdated</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>ClearUserVisibleData</name><argument_list>(<argument><expr><name>eClearUserVisibleDataItemsValue</name> <operator>|</operator>
<name>eClearUserVisibleDataItemsSummary</name> <operator>|</operator>
<name>eClearUserVisibleDataItemsDescription</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>virtual</name> <name>bool</name></type> <name>IsDynamic</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>false</name></expr>;</return> </block_content>}</block></function>

<function><type><name>virtual</name> <name>bool</name></type> <name>DoesProvideSyntheticValue</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>false</name></expr>;</return> </block_content>}</block></function>

<function><type><name>virtual</name> <name>bool</name></type> <name>IsSyntheticChildrenGenerated</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><name><name>m_flags</name><operator>.</operator><name>m_is_synthetic_children_generated</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>virtual</name> <name>void</name></type> <name>SetSyntheticChildrenGenerated</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>m_flags</name><operator>.</operator><name>m_is_synthetic_children_generated</name></name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function_decl><type><name>virtual</name> <name>SymbolContextScope</name> <modifier>*</modifier></type><name>GetSymbolContextScope</name><parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>Dump</name><parameter_list>(<parameter><decl><type><name>Stream</name> <modifier>&amp;</modifier></type><name>s</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>Dump</name><parameter_list>(<parameter><decl><type><name>Stream</name> <modifier>&amp;</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DumpValueObjectOptions</name> <modifier>&amp;</modifier></type><name>options</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><specifier>static</specifier> <name>lldb</name><operator>::</operator><name>ValueObjectSP</name>
<macro><name>CreateValueObjectFromExpression</name><argument_list>(<argument>llvm::StringRef name</argument>,
<argument>llvm::StringRef expression</argument>,
<argument>const ExecutionContext &amp;exe_ctx</argument>)</argument_list></macro></expr>;</expr_stmt>

<expr_stmt><expr><specifier>static</specifier> <name>lldb</name><operator>::</operator><name>ValueObjectSP</name>
<macro><name>CreateValueObjectFromExpression</name><argument_list>(<argument>llvm::StringRef name</argument>,
<argument>llvm::StringRef expression</argument>,
<argument>const ExecutionContext &amp;exe_ctx</argument>,
<argument>const EvaluateExpressionOptions &amp;options</argument>)</argument_list></macro></expr>;</expr_stmt>

<expr_stmt><expr><specifier>static</specifier> <name>lldb</name><operator>::</operator><name>ValueObjectSP</name>
<macro><name>CreateValueObjectFromAddress</name><argument_list>(<argument>llvm::StringRef name</argument>, <argument>uint64_t address</argument>,
<argument>const ExecutionContext &amp;exe_ctx</argument>,
<argument>CompilerType type</argument>)</argument_list></macro></expr>;</expr_stmt>

<expr_stmt><expr><specifier>static</specifier> <name>lldb</name><operator>::</operator><name>ValueObjectSP</name>
<macro><name>CreateValueObjectFromData</name><argument_list>(<argument>llvm::StringRef name</argument>, <argument>const DataExtractor &amp;data</argument>,
<argument>const ExecutionContext &amp;exe_ctx</argument>, <argument>CompilerType type</argument>)</argument_list></macro></expr>;</expr_stmt>

<expr_stmt><expr><name>lldb</name><operator>::</operator><name>ValueObjectSP</name> <call><name>Persist</name><argument_list>()</argument_list></call></expr>;</expr_stmt>



<function_decl><type><name>bool</name></type> <name>IsCStringContainer</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>check_pointer</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>size_t</name></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name>
<macro><name>ReadPointedString</name><argument_list>(<argument>lldb::DataBufferSP &amp;buffer_sp</argument>, <argument>Status &amp;error</argument>,
<argument>uint32_t max_length = <literal type="number">0</literal></argument>, <argument>bool honor_array = true</argument>,
<argument>lldb::Format item_format = lldb::eFormatCharArray</argument>)</argument_list></macro></expr>;</expr_stmt>

<function_decl><type><name>virtual</name> <name>size_t</name></type> <name>GetPointeeData</name><parameter_list>(<parameter><decl><type><name>DataExtractor</name> <modifier>&amp;</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>item_idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl></parameter>,
<parameter><decl><type><name>uint32_t</name></type> <name>item_count</name> <init>= <expr><literal type="number">1</literal></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>virtual</name> <name>uint64_t</name></type> <name>GetData</name><parameter_list>(<parameter><decl><type><name>DataExtractor</name> <modifier>&amp;</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>Status</name> <modifier>&amp;</modifier></type><name>error</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>virtual</name> <name>bool</name></type> <name>SetData</name><parameter_list>(<parameter><decl><type><name>DataExtractor</name> <modifier>&amp;</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>Status</name> <modifier>&amp;</modifier></type><name>error</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><name>virtual</name> <name>bool</name> <macro><name>GetIsConstant</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>m_update_point</name><operator>.</operator><name>IsConstant</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<function><type><name>bool</name></type> <name>NeedsUpdating</name><parameter_list>()</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>accept_invalid_exe_ctx</name> <init>=
<expr><operator>(</operator><call><name>CanUpdateWithInvalidExecutionContext</name><argument_list>()</argument_list></call> <operator>==</operator> <name>eLazyBoolYes</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name><name>m_update_point</name><operator>.</operator><name>NeedsUpdating</name></name><argument_list>(<argument><expr><name>accept_invalid_exe_ctx</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>SetIsConstant</name><parameter_list>()</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name><name>m_update_point</name><operator>.</operator><name>SetIsConstant</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>

<expr_stmt><expr><name>lldb</name><operator>::</operator><name>Format</name> <macro><name>GetFormat</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>SetFormat</name><argument_list>(<argument><expr><name>lldb</name><operator>::</operator><name>Format</name> <name>format</name></expr></argument>)</argument_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>format</name> <operator>!=</operator> <name>m_format</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ClearUserVisibleData</name><argument_list>(<argument><expr><name>eClearUserVisibleDataItemsValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>m_format</name> <operator>=</operator> <name>format</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name>virtual</name> <name>lldb</name><operator>::</operator><name>LanguageType</name> <call><name>GetPreferredDisplayLanguage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>SetPreferredDisplayLanguage</name><argument_list>(<argument><expr><name>lldb</name><operator>::</operator><name>LanguageType</name> <name>lt</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><name>m_preferred_display_language</name> <operator>=</operator> <name>lt</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name>lldb</name><operator>::</operator><name>TypeSummaryImplSP</name> <macro><name>GetSummaryFormat</name><argument_list>()</argument_list></macro> <block>{
<expr><call><name>UpdateFormatsIfNeeded</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><name>m_type_summary_sp</name></expr>;</return>
}</block></expr></expr_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>SetSummaryFormat</name><argument_list>(<argument><expr><name>lldb</name><operator>::</operator><name>TypeSummaryImplSP</name> <name>format</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><name>m_type_summary_sp</name> <operator>=</operator> <name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ClearUserVisibleData</name><argument_list>(<argument><expr><name>eClearUserVisibleDataItemsSummary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>SetValueFormat</name><argument_list>(<argument><expr><name>lldb</name><operator>::</operator><name>TypeFormatImplSP</name> <name>format</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><name>m_type_format_sp</name> <operator>=</operator> <name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ClearUserVisibleData</name><argument_list>(<argument><expr><name>eClearUserVisibleDataItemsValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name>lldb</name><operator>::</operator><name>TypeFormatImplSP</name> <macro><name>GetValueFormat</name><argument_list>()</argument_list></macro> <block>{
<expr><call><name>UpdateFormatsIfNeeded</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><name>m_type_format_sp</name></expr>;</return>
}</block></expr></expr_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>SetSyntheticChildren</name><argument_list>(<argument><expr><specifier>const</specifier> <name>lldb</name><operator>::</operator><name>SyntheticChildrenSP</name> <operator>&amp;</operator><name>synth_sp</name></expr></argument>)</argument_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>synth_sp</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>m_synthetic_children_sp</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>ClearUserVisibleData</name><argument_list>(<argument><expr><name>eClearUserVisibleDataItemsSyntheticChildren</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>m_synthetic_children_sp</name> <operator>=</operator> <name>synth_sp</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name>lldb</name><operator>::</operator><name>SyntheticChildrenSP</name> <macro><name>GetSyntheticChildren</name><argument_list>()</argument_list></macro> <block>{
<expr><call><name>UpdateFormatsIfNeeded</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><name>m_synthetic_children_sp</name></expr>;</return>
}</block></expr></expr_stmt>





<function><type><name>virtual</name> <name>ValueObject</name> <modifier>*</modifier></type><name>GetParent</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>m_parent</name></expr>;</return> </block_content>}</block></function>

<expr_stmt><expr><name>virtual</name> <specifier>const</specifier> <name>ValueObject</name> <operator>*</operator><macro><name>GetParent</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>m_parent</name></expr>;</return> }</block></expr></expr_stmt>

<function_decl><type><name>ValueObject</name> <modifier>*</modifier></type><name>GetNonBaseClassParent</name><parameter_list>()</parameter_list>;</function_decl>

<function><type><name>void</name></type> <name>SetAddressTypeOfChildren</name><parameter_list>(<parameter><decl><type><name>AddressType</name></type> <name>at</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>m_address_type_of_ptr_or_ref_children</name> <operator>=</operator> <name>at</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function_decl><type><name>AddressType</name></type> <name>GetAddressTypeOfChildren</name><parameter_list>()</parameter_list>;</function_decl>

<function><type><name>void</name></type> <name>SetHasCompleteType</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>m_flags</name><operator>.</operator><name>m_did_calculate_complete_objc_class_type</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>















<function_decl><type><name>virtual</name> <name>bool</name></type> <name>MightHaveChildren</name><parameter_list>()</parameter_list>;</function_decl>

<expr_stmt><expr><name>virtual</name> <name>lldb</name><operator>::</operator><name>VariableSP</name> <macro><name>GetVariable</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>nullptr</name></expr>;</return> }</block></expr></expr_stmt>

<function_decl><type><name>virtual</name> <name>bool</name></type> <name>IsRuntimeSupportValue</name><parameter_list>()</parameter_list>;</function_decl>

<function><type><name>virtual</name> <name>uint64_t</name></type> <name>GetLanguageFlags</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>m_language_flags</name></expr>;</return> </block_content>}</block></function>

<function><type><name>virtual</name> <name>void</name></type> <name>SetLanguageFlags</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>flags</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>m_language_flags</name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt> </block_content>}</block></function>

<label><name>protected</name>:</label>
<typedef>typedef <type><name><name>ClusterManager</name><argument_list type="generic">&lt;<argument><expr><name>ValueObject</name></expr></argument>&gt;</argument_list></name></type> <name>ValueObjectManager</name>;</typedef>

<decl_stmt><decl><type><name>class</name></type> <name>ChildrenManager</name> <block>{<block_content>
<label><name>public</name>:</label>
<expr_stmt><expr><call><name>ChildrenManager</name><argument_list>()</argument_list></call> <operator>:</operator> <call><name>m_mutex</name><argument_list>()</argument_list></call></expr><operator>,</operator> <macro><name>m_children</name><argument_list>()</argument_list></macro> <expr><block>{}</block>

<name>bool</name> <macro><name>HasChildAtIndex</name><argument_list>(<argument>size_t idx</argument>)</argument_list></macro> <block>{
<expr><name>std</name><operator>::</operator><name><name>lock_guard</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>recursive_mutex</name></expr></argument>&gt;</argument_list></name> <call><name>guard</name><argument_list>(<argument><expr><name>m_mutex</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>(</operator><call><name><name>m_children</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name><name>m_children</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>ValueObject</name> <modifier>*</modifier></type><name>GetChildAtIndex</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>idx</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>lock_guard</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>recursive_mutex</name></expr></argument>&gt;</argument_list></name> <call><name>guard</name><argument_list>(<argument><expr><name>m_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier></type> <name>iter</name> <init>= <expr><call><name><name>m_children</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>iter</name> <operator>==</operator> <call><name><name>m_children</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call><operator>)</operator></expr> ?</condition><then> <expr><name>nullptr</name></expr> </then><else>: <expr><name><name>iter</name><operator>-&gt;</operator><name>second</name></name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>SetChildAtIndex</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>idx</name></decl></parameter>, <parameter><decl><type><name>ValueObject</name> <modifier>*</modifier></type><name>valobj</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>ChildrenPair</name></type> <name>pair</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><name>valobj</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>lock_guard</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>recursive_mutex</name></expr></argument>&gt;</argument_list></name> <call><name>guard</name><argument_list>(<argument><expr><name>m_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>m_children</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>pair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>SetChildrenCount</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name>Clear</name><argument_list>(<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>

<function><type><name>size_t</name></type> <name>GetChildrenCount</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>m_children_count</name></expr>;</return> </block_content>}</block></function>

<function><type><name>void</name></type> <name>Clear</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>new_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>lock_guard</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>recursive_mutex</name></expr></argument>&gt;</argument_list></name> <call><name>guard</name><argument_list>(<argument><expr><name>m_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>m_children_count</name> <operator>=</operator> <name>new_count</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>m_children</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<label><name>private</name>:</label>
<typedef>typedef <expr_stmt><expr><name>std</name><operator>::</operator><name><name>map</name><argument_list type="generic">&lt;<argument><expr><name>size_t</name></expr></argument>, <argument><expr><name>ValueObject</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>ChildrenMap</name></expr>;</expr_stmt></typedef>
<typedef>typedef <expr_stmt><expr><name>ChildrenMap</name><operator>::</operator><name>iterator</name> <name>ChildrenIterator</name></expr>;</expr_stmt></typedef>
<typedef>typedef <expr_stmt><expr><name>ChildrenMap</name><operator>::</operator><name>value_type</name> <name>ChildrenPair</name></expr>;</expr_stmt></typedef>
<expr_stmt><expr><name>std</name><operator>::</operator><name>recursive_mutex</name> <name>m_mutex</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ChildrenMap</name></type> <name>m_children</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>m_children_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>




<decl_stmt><decl><type><name>ValueObject</name> <modifier>*</modifier></type><name>m_parent</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>ValueObject</name> <modifier>*</modifier></type><name>m_root</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>EvaluationPoint</name></type> <name>m_update_point</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ConstString</name></type> <name>m_name</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>DataExtractor</name></type> <name>m_data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value</name></type> <name>m_value</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>Status</name></type> <name>m_error</name></decl>;</decl_stmt>

<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>m_value_str</name></expr>;</expr_stmt>

<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>m_old_value_str</name></expr>;</expr_stmt>

<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>m_location_str</name></expr>;</expr_stmt>

<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>m_summary_str</name></expr>;</expr_stmt>


<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>m_object_desc_str</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>CompilerType</name></type> <name>m_override_type</name></decl>;</decl_stmt>







<decl_stmt><decl><type><name>ValueObjectManager</name> <modifier>*</modifier></type><name>m_manager</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ChildrenManager</name></type> <name>m_children</name></decl>;</decl_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>map</name><argument_list type="generic">&lt;<argument><expr><name>ConstString</name></expr></argument>, <argument><expr><name>ValueObject</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>m_synthetic_children</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ValueObject</name> <modifier>*</modifier></type><name>m_dynamic_value</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ValueObject</name> <modifier>*</modifier></type><name>m_synthetic_value</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ValueObject</name> <modifier>*</modifier></type><name>m_deref_valobj</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>



<expr_stmt><expr><name>lldb</name><operator>::</operator><name>ValueObjectSP</name> <name>m_addr_of_valobj_sp</name></expr>;</expr_stmt>

<expr_stmt><expr><name>lldb</name><operator>::</operator><name>Format</name> <name>m_format</name> <operator>=</operator> <name>lldb</name><operator>::</operator><name>eFormatDefault</name></expr>;</expr_stmt>
<expr_stmt><expr><name>lldb</name><operator>::</operator><name>Format</name> <name>m_last_format</name> <operator>=</operator> <name>lldb</name><operator>::</operator><name>eFormatDefault</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>m_last_format_mgr_revision</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>lldb</name><operator>::</operator><name>TypeSummaryImplSP</name> <name>m_type_summary_sp</name></expr>;</expr_stmt>
<expr_stmt><expr><name>lldb</name><operator>::</operator><name>TypeFormatImplSP</name> <name>m_type_format_sp</name></expr>;</expr_stmt>
<expr_stmt><expr><name>lldb</name><operator>::</operator><name>SyntheticChildrenSP</name> <name>m_synthetic_children_sp</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ProcessModID</name></type> <name>m_user_id_of_forced_summary</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AddressType</name></type> <name>m_address_type_of_ptr_or_ref_children</name> <init>= <expr><name>eAddressTypeInvalid</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>uint8_t</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name> <name>m_value_checksum</name></expr>;</expr_stmt>

<expr_stmt><expr><name>lldb</name><operator>::</operator><name>LanguageType</name> <name>m_preferred_display_language</name> <operator>=</operator> <name>lldb</name><operator>::</operator><name>eLanguageTypeUnknown</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>uint64_t</name></type> <name>m_language_flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>UserID</name></type> <name>m_id</name></decl>;</decl_stmt>



<struct>struct <name>Bitflags</name> <block>{
<decl_stmt><decl><type><name>bool</name></type> <name>m_value_is_valid</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>, <decl><type ref="prev"/><name>m_value_did_change</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>,
<decl><type ref="prev"/><name>m_children_count_valid</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>, <decl><type ref="prev"/><name>m_old_value_valid</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>,
<decl><type ref="prev"/><name>m_is_deref_of_parent</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>, <decl><type ref="prev"/><name>m_is_array_item_for_pointer</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>,
<decl><type ref="prev"/><name>m_is_bitfield_for_scalar</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>, <decl><type ref="prev"/><name>m_is_child_at_offset</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>,
<decl><type ref="prev"/><name>m_is_getting_summary</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>, <decl><type ref="prev"/><name>m_did_calculate_complete_objc_class_type</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>,
<decl><type ref="prev"/><name>m_is_synthetic_children_generated</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<macro><name>Bitflags</name><argument_list>()</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name>m_value_is_valid</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>m_value_did_change</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>m_children_count_valid</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>m_old_value_valid</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>m_is_deref_of_parent</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>m_is_array_item_for_pointer</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>m_is_bitfield_for_scalar</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>m_is_child_at_offset</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>m_is_getting_summary</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>m_did_calculate_complete_objc_class_type</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>m_is_synthetic_children_generated</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block>
}</block> <decl><name>m_flags</name></decl>;</struct>

<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ValueObjectChild</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ExpressionVariable</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>Target</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ValueObjectConstResultImpl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ValueObjectSynthetic</name></decl>;</decl_stmt>



<macro><name>ValueObject</name><argument_list>(<argument>ExecutionContextScope *exe_scope</argument>, <argument>ValueObjectManager &amp;manager</argument>,
<argument>AddressType child_ptr_or_ref_addr_type = eAddressTypeLoad</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>



<expr_stmt><expr><call><name>ValueObject</name><argument_list>(<argument><expr><name>ValueObject</name> <operator>&amp;</operator><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>ValueObjectManager</name> <modifier>*</modifier></type><name>GetManager</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>m_manager</name></expr>;</return> </block_content>}</block></function>

<function_decl><type><name>virtual</name> <name>bool</name></type> <name>UpdateValue</name><parameter_list>()</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>

<function><type><name>virtual</name> <name>LazyBool</name></type> <name>CanUpdateWithInvalidExecutionContext</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><name>eLazyBoolCalculate</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>CalculateDynamicValue</name><argument_list>(<argument><expr><name>lldb</name><operator>::</operator><name>DynamicValueType</name> <name>use_dynamic</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<expr_stmt><expr><name>virtual</name> <name>lldb</name><operator>::</operator><name>DynamicValueType</name> <macro><name>GetDynamicValueTypeImpl</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name>lldb</name><operator>::</operator><name>eNoDynamicValues</name></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>virtual</name> <name>bool</name></type> <name>HasDynamicValueTypeInfo</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>false</name></expr>;</return> </block_content>}</block></function>

<function_decl><type><name>virtual</name> <name>void</name></type> <name>CalculateSyntheticValue</name><parameter_list>()</parameter_list>;</function_decl>




<function_decl><type><name>virtual</name> <name>ValueObject</name> <modifier>*</modifier></type><name>CreateChildAtIndex</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>idx</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>synthetic_array_member</name></decl></parameter>,
<parameter><decl><type><name>int32_t</name></type> <name>synthetic_index</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>virtual</name> <name>size_t</name></type> <name>CalculateNumChildren</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>max</name> <init>= <expr><name>UINT32_MAX</name></expr></init></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>

<function_decl><type><name>void</name></type> <name>SetNumChildren</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>num_children</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>void</name></type> <name>SetValueDidChange</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>value_changed</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>m_flags</name><operator>.</operator><name>m_value_did_change</name></name> <operator>=</operator> <name>value_changed</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>SetValueIsValid</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>valid</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name><name>m_flags</name><operator>.</operator><name>m_value_is_valid</name></name> <operator>=</operator> <name>valid</name></expr>;</expr_stmt> </block_content>}</block></function>

<function_decl><type><name>void</name></type> <name>ClearUserVisibleData</name><parameter_list>(
<parameter><decl><type><name>uint32_t</name></type> <name>items</name> <init>= <expr><name>ValueObject</name><operator>::</operator><name>eClearUserVisibleDataItemsAllStrings</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>AddSyntheticChild</name><parameter_list>(<parameter><decl><type><name>ConstString</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>ValueObject</name> <modifier>*</modifier></type><name>valobj</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>DataExtractor</name> <modifier>&amp;</modifier></type><name>GetDataExtractor</name><parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>ClearDynamicTypeInformation</name><parameter_list>()</parameter_list>;</function_decl>



<function_decl><type><name>virtual</name> <name>CompilerType</name></type> <name>GetCompilerTypeImpl</name><parameter_list>()</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>

<function_decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>GetLocationAsCStringImpl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Value</name> <modifier>&amp;</modifier></type><name>value</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>DataExtractor</name> <modifier>&amp;</modifier></type><name>data</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>bool</name></type> <name>IsChecksumEmpty</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name><name>m_value_checksum</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>

<decl_stmt><decl><type><name>void</name></type> <name>SetPreferredDisplayLanguageIfNeeded</name><argument_list>(<argument><expr><name>lldb</name><operator>::</operator><name>LanguageType</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<label><name>protected</name>:</label>
<function><type><name>virtual</name> <name>void</name></type> <name>DoUpdateChildrenAddressType</name><parameter_list>(<parameter><decl><type><name>ValueObject</name> <modifier>&amp;</modifier></type><name>valobj</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return;</return> </block_content>}</block></function><empty_stmt>;</empty_stmt>

<label><name>private</name>:</label>
<function_decl><type><name>virtual</name> <name>CompilerType</name></type> <name>MaybeCalculateCompleteType</name><parameter_list>()</parameter_list>;</function_decl>
<function><type><name>void</name></type> <name>UpdateChildrenAddressType</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>GetRoot</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>DoUpdateChildrenAddressType</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name>lldb</name><operator>::</operator><name>ValueObjectSP</name> <macro><name>GetValueForExpressionPath_Impl</name><argument_list>(
<argument>llvm::StringRef expression_cstr</argument>,
<argument>ExpressionPathScanEndReason *reason_to_stop</argument>,
<argument>ExpressionPathEndResultType *final_value_type</argument>,
<argument>const GetValueForExpressionPathOptions &amp;options</argument>,
<argument>ExpressionPathAftermath *final_task_on_target</argument>)</argument_list></macro></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ValueObject</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ValueObject</name> <operator>&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name>delete</name></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ValueObject</name> <modifier>&amp;</modifier></type><name>operator</name><init>=<expr><operator>(</operator><specifier>const</specifier> <name>ValueObject</name> <operator>&amp;</operator><operator>)</operator> <operator>=</operator> <name>delete</name></expr></init></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

</block_content>}</block></decl></decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
