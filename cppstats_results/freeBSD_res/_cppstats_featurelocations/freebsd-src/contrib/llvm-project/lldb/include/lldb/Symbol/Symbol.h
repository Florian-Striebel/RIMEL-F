







#if !defined(LLDB_SYMBOL_SYMBOL_H)
#define LLDB_SYMBOL_SYMBOL_H

#include "lldb/Core/AddressRange.h"
#include "lldb/Core/Mangled.h"
#include "lldb/Symbol/SymbolContextScope.h"
#include "lldb/Utility/UserID.h"
#include "lldb/lldb-private.h"

namespace lldb_private {

class Symbol : public SymbolContextScope {
public:



Symbol();

Symbol(uint32_t symID, llvm::StringRef name, lldb::SymbolType type,
bool external, bool is_debug, bool is_trampoline, bool is_artificial,
const lldb::SectionSP &section_sp, lldb::addr_t value,
lldb::addr_t size, bool size_is_valid,
bool contains_linker_annotations, uint32_t flags);

Symbol(uint32_t symID, const Mangled &mangled, lldb::SymbolType type,
bool external, bool is_debug, bool is_trampoline, bool is_artificial,
const AddressRange &range, bool size_is_valid,
bool contains_linker_annotations, uint32_t flags);

Symbol(const Symbol &rhs);

const Symbol &operator=(const Symbol &rhs);

void Clear();

bool Compare(ConstString name, lldb::SymbolType type) const;

void Dump(Stream *s, Target *target, uint32_t index,
Mangled::NamePreference name_preference =
Mangled::ePreferDemangled) const;

bool ValueIsAddress() const;






Address &GetAddressRef() { return m_addr_range.GetBaseAddress(); }

const Address &GetAddressRef() const { return m_addr_range.GetBaseAddress(); }



lldb::addr_t GetFileAddress() const;




lldb::addr_t GetLoadAddress(Target *target) const;




Address GetAddress() const {








if (ValueIsAddress())
return m_addr_range.GetBaseAddress();
else
return Address();
}





uint64_t GetIntegerValue(uint64_t fail_value = 0) const {
if (ValueIsAddress()) {


return fail_value;
} else {

return m_addr_range.GetBaseAddress().GetOffset();
}
}

lldb::addr_t ResolveCallableAddress(Target &target) const;

ConstString GetName() const;

ConstString GetNameNoArguments() const;

ConstString GetDisplayName() const;

uint32_t GetID() const { return m_uid; }

lldb::LanguageType GetLanguage() const {


return GetMangled().GuessLanguage();
}

void SetID(uint32_t uid) { m_uid = uid; }

Mangled &GetMangled() {
SynthesizeNameIfNeeded();
return m_mangled;
}

const Mangled &GetMangled() const {
SynthesizeNameIfNeeded();
return m_mangled;
}

ConstString GetReExportedSymbolName() const;

FileSpec GetReExportedSymbolSharedLibrary() const;

void SetReExportedSymbolName(ConstString name);

bool SetReExportedSymbolSharedLibrary(const FileSpec &fspec);

Symbol *ResolveReExportedSymbol(Target &target) const;

uint32_t GetSiblingIndex() const;

lldb::SymbolType GetType() const { return (lldb::SymbolType)m_type; }

void SetType(lldb::SymbolType type) { m_type = (lldb::SymbolType)type; }

const char *GetTypeAsString() const;

uint32_t GetFlags() const { return m_flags; }

void SetFlags(uint32_t flags) { m_flags = flags; }

void GetDescription(Stream *s, lldb::DescriptionLevel level,
Target *target) const;

bool IsSynthetic() const { return m_is_synthetic; }

bool IsSyntheticWithAutoGeneratedName() const;

void SetIsSynthetic(bool b) { m_is_synthetic = b; }

bool GetSizeIsSynthesized() const { return m_size_is_synthesized; }

void SetSizeIsSynthesized(bool b) { m_size_is_synthesized = b; }

bool IsDebug() const { return m_is_debug; }

void SetDebug(bool b) { m_is_debug = b; }

bool IsExternal() const { return m_is_external; }

void SetExternal(bool b) { m_is_external = b; }

bool IsTrampoline() const;

bool IsIndirect() const;

bool IsWeak() const { return m_is_weak; }

void SetIsWeak (bool b) { m_is_weak = b; }

bool GetByteSizeIsValid() const { return m_size_is_valid; }

lldb::addr_t GetByteSize() const;

void SetByteSize(lldb::addr_t size) {
m_size_is_valid = size > 0;
m_addr_range.SetByteSize(size);
}

bool GetSizeIsSibling() const { return m_size_is_sibling; }

void SetSizeIsSibling(bool b) { m_size_is_sibling = b; }



uint32_t GetPrologueByteSize();

bool GetDemangledNameIsSynthesized() const {
return m_demangled_is_synthesized;
}

void SetDemangledNameIsSynthesized(bool b) { m_demangled_is_synthesized = b; }

bool ContainsLinkerAnnotations() const {
return m_contains_linker_annotations;
}
void SetContainsLinkerAnnotations(bool b) {
m_contains_linker_annotations = b;
}



void CalculateSymbolContext(SymbolContext *sc) override;

lldb::ModuleSP CalculateSymbolContextModule() override;

Symbol *CalculateSymbolContextSymbol() override;




void DumpSymbolContext(Stream *s) override;

lldb::DisassemblerSP GetInstructions(const ExecutionContext &exe_ctx,
const char *flavor,
bool prefer_file_cache);

bool GetDisassembly(const ExecutionContext &exe_ctx, const char *flavor,
bool prefer_file_cache, Stream &strm);

bool ContainsFileAddress(lldb::addr_t file_addr) const;

static llvm::StringRef GetSyntheticSymbolPrefix() {
return "___lldb_unnamed_symbol";
}

protected:




Symbol *ResolveReExportedSymbolInModuleSpec(
Target &target, ConstString &reexport_name,
lldb_private::ModuleSpec &module_spec,
lldb_private::ModuleList &seen_modules) const;

void SynthesizeNameIfNeeded() const;

uint32_t m_uid =
UINT32_MAX;
uint16_t m_type_data = 0;
uint16_t m_type_data_resolved : 1,

m_is_synthetic : 1,


m_is_debug : 1,

m_is_external : 1,
m_size_is_sibling : 1,

m_size_is_synthesized : 1,


m_size_is_valid : 1,
m_demangled_is_synthesized : 1,


m_contains_linker_annotations : 1,


m_is_weak : 1,
m_type : 6;
mutable Mangled m_mangled;
AddressRange m_addr_range;


uint32_t m_flags = 0;

};

}

#endif
