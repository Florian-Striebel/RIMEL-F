<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/lld/include/lld/ReaderWriter/MachOLinkingContext.h">







<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLD_READER_WRITER_MACHO_LINKING_CONTEXT_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLD_READER_WRITER_MACHO_LINKING_CONTEXT_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lld/Core/LinkingContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lld/Core/Reader.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lld/Core/Writer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/STLExtras.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/StringMap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/StringSet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/BinaryFormat/MachO.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/ErrorHandling.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;set&gt;</cpp:file></cpp:include>

<expr_stmt><expr><name>using</name> <name>llvm</name><operator>::</operator><name>MachO</name><operator>::</operator><name>HeaderFileType</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>lld</name> <block>{<block_content>

<decl_stmt><decl><type><name>namespace</name></type> <name>mach_o</name> <block>{<block_content>
<decl_stmt><decl><type><name>class</name></type> <name>ArchHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>MachODylibFile</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>MachOFile</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>SectCreateFile</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>MachOLinkingContext</name> <range>: <expr><name>public</name> <name>LinkingContext</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>MachOLinkingContext</name><argument_list>()</argument_list></call></expr>;
<expr><operator>~</operator><macro><name>MachOLinkingContext</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

enum <expr><name>Arch</name> <block>{
<expr><name>arch_unknown</name></expr>,
<expr><name>arch_ppc</name></expr>,
<expr><name>arch_x86</name></expr>,
<expr><name>arch_x86_64</name></expr>,
<expr><name>arch_armv6</name></expr>,
<expr><name>arch_armv7</name></expr>,
<expr><name>arch_armv7s</name></expr>,
<expr><name>arch_arm64</name></expr>,
}</block></expr>;

enum <expr><name>class</name> <name>OS</name> <block>{
<expr><name>unknown</name></expr>,
<expr><name>macOSX</name></expr>,
<expr><name>iOS</name></expr>,
<expr><name>iOS_simulator</name></expr>
}</block></expr>;

enum <expr><name>class</name> <name>ExportMode</name> <block>{
<expr><name>globals</name></expr>,
<expr><name>exported</name></expr>,
<expr><name>unexported</name></expr>
}</block></expr>;

enum <expr><name>class</name> <name>DebugInfoMode</name> <block>{
<expr><name>addDebugMap</name></expr>,
<expr><name>noDebugMap</name></expr>
}</block></expr>;

enum <expr><name>class</name> <name>UndefinedMode</name> <block>{
<expr><name>error</name></expr>,
<expr><name>warning</name></expr>,
<expr><name>suppress</name></expr>,
<expr><name>dynamicLookup</name></expr>
}</block></expr>;

enum <expr><name>ObjCConstraint</name> <block>{
<expr><name>objc_unknown</name> <operator>=</operator> <literal type="number">0</literal></expr>,
<expr><name>objc_supports_gc</name> <operator>=</operator> <literal type="number">2</literal></expr>,
<expr><name>objc_gc_only</name> <operator>=</operator> <literal type="number">4</literal></expr>,


<expr><name>objc_retainReleaseForSimulator</name> <operator>=</operator> <literal type="number">32</literal></expr>,
<expr><name>objc_retainRelease</name></expr>
}</block></expr>;




<expr><name>void</name> <macro><name>configure</name><argument_list>(<argument>HeaderFileType type</argument>, <argument>Arch arch</argument>, <argument>OS os</argument>, <argument>uint32_t minOSVersion</argument>,
<argument>bool exportDynamicSymbols</argument>)</argument_list></macro></expr>;

<expr><name>void</name> <macro><name>addPasses</name><argument_list>(<argument>PassManager &amp;pm</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>bool</name> <macro><name>validateImpl</name><argument_list>()</argument_list></macro> <name>override</name></expr>;
<expr><name>std</name><operator>::</operator><name>string</name> <macro><name>demangle</name><argument_list>(<argument>StringRef symbolName</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>void</name> <macro><name>createImplicitFiles</name><argument_list>(<argument>std::vector&lt;std::unique_ptr&lt;File&gt;&gt; &amp;</argument>)</argument_list></macro> <name>override</name></expr>;



<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>T</name></expr></argument>, <argument><expr><name>class</name><modifier>...</modifier> <name>Args</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>std</name><operator>::</operator><name><name>enable_if</name><argument_list type="generic">&lt;<argument><expr><operator>!</operator><name>std</name><operator>::</operator><name><name>is_array</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>, <argument><expr><name>T</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name>
<macro><name>make_file</name><argument_list>(<argument>Args &amp;&amp;... args</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>file</name> <operator>=</operator> <name>std</name><operator>::</operator><macro><name>unique_ptr</name></macro><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><name>new</name> <call><name>T</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name><name>forward</name><argument_list type="generic">&lt;<argument><expr><name>Args</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call><operator>...</operator></expr></argument>)</argument_list></call><operator>)</operator></expr>;
<expr><name>auto</name> <operator>*</operator><name>filePtr</name> <operator>=</operator> <call><name><name>file</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;
<expr><name>auto</name> <operator>*</operator><name>ctx</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>MachOLinkingContext</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>ctx</name><operator>-&gt;</operator><name>getNodes</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>push_back</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name><name>make_unique</name><argument_list type="generic">&lt;<argument><expr><name>FileNode</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>filePtr</name></expr>;</return>
}</block>

<name>uint32_t</name> <macro><name>getCPUType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>uint32_t</name> <macro><name>getCPUSubType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>bool</name> <macro><name>addEntryPointLoadCommand</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>addUnixThreadLoadCommand</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>outputTypeHasEntry</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>is64Bit</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>virtual</name> <name>uint64_t</name> <macro><name>pageZeroSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>_pageZeroSize</name></expr>;</return> }</block>
<name>virtual</name> <name>uint64_t</name> <macro><name>pageSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>_pageSize</name></expr>;</return> }</block>

<name>mach_o</name><operator>::</operator><name>ArchHandler</name> <operator>&amp;</operator><macro><name>archHandler</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>HeaderFileType</name> <macro><name>outputMachOType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>_outputMachOType</name></expr>;</return> }</block>

<name>Arch</name> <macro><name>arch</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>_arch</name></expr>;</return> }</block>
<name>StringRef</name> <macro><name>archName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>nameFromArch</name><argument_list>(<argument><expr><name>_arch</name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>OS</name> <macro><name>os</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>_os</name></expr>;</return> }</block>

<name>ExportMode</name> <macro><name>exportMode</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>_exportMode</name></expr>;</return> }</block>
<name>void</name> <macro><name>setExportMode</name><argument_list>(<argument>ExportMode mode</argument>)</argument_list></macro> <block>{ <expr><name>_exportMode</name> <operator>=</operator> <name>mode</name></expr>; }</block>
<name>void</name> <macro><name>addExportSymbol</name><argument_list>(<argument>StringRef sym</argument>)</argument_list></macro></expr>;
<expr><name>bool</name> <macro><name>exportRestrictMode</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>_exportMode</name> <operator>!=</operator> <name>ExportMode</name><operator>::</operator><name>globals</name></expr>;</return> }</block>
<name>bool</name> <macro><name>exportSymbolNamed</name><argument_list>(<argument>StringRef sym</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>DebugInfoMode</name> <macro><name>debugInfoMode</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>_debugInfoMode</name></expr>;</return> }</block>
<name>void</name> <macro><name>setDebugInfoMode</name><argument_list>(<argument>DebugInfoMode mode</argument>)</argument_list></macro> <block>{
<expr><name>_debugInfoMode</name> <operator>=</operator> <name>mode</name></expr>;
}</block>

<name>void</name> <macro><name>appendOrderedSymbol</name><argument_list>(<argument>StringRef symbol</argument>, <argument>StringRef filename</argument>)</argument_list></macro></expr>;

<expr><name>bool</name> <macro><name>keepPrivateExterns</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>_keepPrivateExterns</name></expr>;</return> }</block>
<name>void</name> <macro><name>setKeepPrivateExterns</name><argument_list>(<argument>bool v</argument>)</argument_list></macro> <block>{ <expr><name>_keepPrivateExterns</name> <operator>=</operator> <name>v</name></expr>; }</block>
<name>bool</name> <macro><name>demangleSymbols</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>_demangle</name></expr>;</return> }</block>
<name>void</name> <macro><name>setDemangleSymbols</name><argument_list>(<argument>bool d</argument>)</argument_list></macro> <block>{ <expr><name>_demangle</name> <operator>=</operator> <name>d</name></expr>; }</block>
<name>bool</name> <macro><name>mergeObjCCategories</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>_mergeObjCCategories</name></expr>;</return> }</block>
<name>void</name> <macro><name>setMergeObjCCategories</name><argument_list>(<argument>bool v</argument>)</argument_list></macro> <block>{ <expr><name>_mergeObjCCategories</name> <operator>=</operator> <name>v</name></expr>; }</block>


<name>std</name><operator>::</operator><name>error_code</name> <macro><name>createDependencyFile</name><argument_list>(<argument>StringRef path</argument>)</argument_list></macro></expr>;
<expr><name>void</name> <macro><name>addInputFileDependency</name><argument_list>(<argument>StringRef path</argument>)</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>void</name> <macro><name>addInputFileNotFound</name><argument_list>(<argument>StringRef path</argument>)</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>void</name> <macro><name>addOutputFileDependency</name><argument_list>(<argument>StringRef path</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>bool</name> <macro><name>minOS</name><argument_list>(<argument>StringRef mac</argument>, <argument>StringRef iOS</argument>)</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>void</name> <macro><name>setDoNothing</name><argument_list>(<argument>bool value</argument>)</argument_list></macro> <block>{ <expr><name>_doNothing</name> <operator>=</operator> <name>value</name></expr>; }</block>
<name>bool</name> <macro><name>doNothing</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>_doNothing</name></expr>;</return> }</block>
<name>bool</name> <macro><name>printAtoms</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>_printAtoms</name></expr>;</return> }</block>
<name>bool</name> <macro><name>testingFileUsage</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>_testingFileUsage</name></expr>;</return> }</block>
<specifier>const</specifier> <name>StringRefVector</name> <operator>&amp;</operator><macro><name>searchDirs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>_searchDirs</name></expr>;</return> }</block>
<specifier>const</specifier> <name>StringRefVector</name> <operator>&amp;</operator><macro><name>frameworkDirs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>_frameworkDirs</name></expr>;</return> }</block>
<name>void</name> <call><name>setSysLibRoots</name><argument_list>(<argument><expr><specifier>const</specifier> <name>StringRefVector</name> <operator>&amp;</operator><name>paths</name></expr></argument>)</argument_list></call></expr>;
<expr><specifier>const</specifier> <name>StringRefVector</name> <operator>&amp;</operator><macro><name>sysLibRoots</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>_syslibRoots</name></expr>;</return> }</block>
<name>bool</name> <macro><name>PIE</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>_pie</name></expr>;</return> }</block>
<name>void</name> <macro><name>setPIE</name><argument_list>(<argument>bool pie</argument>)</argument_list></macro> <block>{ <expr><name>_pie</name> <operator>=</operator> <name>pie</name></expr>; }</block>
<name>bool</name> <macro><name>generateVersionLoadCommand</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>_generateVersionLoadCommand</name></expr>;</return>
}</block>
<name>void</name> <macro><name>setGenerateVersionLoadCommand</name><argument_list>(<argument>bool v</argument>)</argument_list></macro> <block>{
<expr><name>_generateVersionLoadCommand</name> <operator>=</operator> <name>v</name></expr>;
}</block>

<name>bool</name> <macro><name>generateFunctionStartsLoadCommand</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>_generateFunctionStartsLoadCommand</name></expr>;</return>
}</block>
<name>void</name> <macro><name>setGenerateFunctionStartsLoadCommand</name><argument_list>(<argument>bool v</argument>)</argument_list></macro> <block>{
<expr><name>_generateFunctionStartsLoadCommand</name> <operator>=</operator> <name>v</name></expr>;
}</block>

<name>bool</name> <macro><name>generateDataInCodeLoadCommand</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>_generateDataInCodeLoadCommand</name></expr>;</return>
}</block>
<name>void</name> <macro><name>setGenerateDataInCodeLoadCommand</name><argument_list>(<argument>bool v</argument>)</argument_list></macro> <block>{
<expr><name>_generateDataInCodeLoadCommand</name> <operator>=</operator> <name>v</name></expr>;
}</block>

<name>uint64_t</name> <macro><name>stackSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>_stackSize</name></expr>;</return> }</block>
<name>void</name> <macro><name>setStackSize</name><argument_list>(<argument>uint64_t stackSize</argument>)</argument_list></macro> <block>{ <expr><name>_stackSize</name> <operator>=</operator> <name>stackSize</name></expr>; }</block>

<name>uint64_t</name> <macro><name>baseAddress</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>_baseAddress</name></expr>;</return> }</block>
<name>void</name> <macro><name>setBaseAddress</name><argument_list>(<argument>uint64_t baseAddress</argument>)</argument_list></macro> <block>{ <expr><name>_baseAddress</name> <operator>=</operator> <name>baseAddress</name></expr>; }</block>

<name>ObjCConstraint</name> <macro><name>objcConstraint</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>_objcConstraint</name></expr>;</return> }</block>

<name>uint32_t</name> <macro><name>osMinVersion</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>_osMinVersion</name></expr>;</return> }</block>

<name>uint32_t</name> <macro><name>sdkVersion</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>_sdkVersion</name></expr>;</return> }</block>
<name>void</name> <macro><name>setSdkVersion</name><argument_list>(<argument>uint64_t v</argument>)</argument_list></macro> <block>{ <expr><name>_sdkVersion</name> <operator>=</operator> <name>v</name></expr>; }</block>

<name>uint64_t</name> <macro><name>sourceVersion</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>_sourceVersion</name></expr>;</return> }</block>
<name>void</name> <macro><name>setSourceVersion</name><argument_list>(<argument>uint64_t v</argument>)</argument_list></macro> <block>{ <expr><name>_sourceVersion</name> <operator>=</operator> <name>v</name></expr>; }</block>

<name>uint32_t</name> <macro><name>swiftVersion</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>_swiftVersion</name></expr>;</return> }</block>






<name>bool</name> <macro><name>pathExists</name><argument_list>(<argument>StringRef path</argument>)</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>bool</name> <macro><name>fileExists</name><argument_list>(<argument>StringRef path</argument>)</argument_list></macro> <specifier>const</specifier></expr>;







<expr><name>void</name> <macro><name>addModifiedSearchDir</name><argument_list>(<argument>StringRef libPath</argument>, <argument>bool isSystemPath = false</argument>)</argument_list></macro></expr>;







<expr><name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>StringRef</name></expr></argument>&gt;</argument_list></name> <macro><name>searchDirForLibrary</name><argument_list>(<argument>StringRef path</argument>,
<argument>StringRef libName</argument>)</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>StringRef</name></expr></argument>&gt;</argument_list></name> <macro><name>searchLibrary</name><argument_list>(<argument>StringRef libName</argument>)</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>void</name> <macro><name>addFrameworkSearchDir</name><argument_list>(<argument>StringRef fwPath</argument>, <argument>bool isSystemPath = false</argument>)</argument_list></macro></expr>;



<expr><name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>StringRef</name></expr></argument>&gt;</argument_list></name> <macro><name>findPathForFramework</name><argument_list>(<argument>StringRef fwName</argument>)</argument_list></macro> <specifier>const</specifier></expr>;








<expr><name>uint32_t</name> <macro><name>compatibilityVersion</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>_compatibilityVersion</name></expr>;</return> }</block>






<name>uint32_t</name> <macro><name>currentVersion</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>_currentVersion</name></expr>;</return> }</block>






<name>StringRef</name> <macro><name>installName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>_installName</name></expr>;</return> }</block>






<name>bool</name> <macro><name>deadStrippableDylib</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>_deadStrippableDylib</name></expr>;</return> }</block>











<name>bool</name> <macro><name>useFlatNamespace</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>_flatNamespace</name></expr>;</return> }</block>











<name>UndefinedMode</name> <macro><name>undefinedMode</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>_undefinedMode</name></expr>;</return> }</block>







<name>StringRef</name> <macro><name>bundleLoader</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>_bundleLoader</name></expr>;</return> }</block>

<name>void</name> <macro><name>setCompatibilityVersion</name><argument_list>(<argument>uint32_t vers</argument>)</argument_list></macro> <block>{ <expr><name>_compatibilityVersion</name> <operator>=</operator> <name>vers</name></expr>; }</block>
<name>void</name> <macro><name>setCurrentVersion</name><argument_list>(<argument>uint32_t vers</argument>)</argument_list></macro> <block>{ <expr><name>_currentVersion</name> <operator>=</operator> <name>vers</name></expr>; }</block>
<name>void</name> <macro><name>setInstallName</name><argument_list>(<argument>StringRef name</argument>)</argument_list></macro> <block>{ <expr><name>_installName</name> <operator>=</operator> <name>name</name></expr>; }</block>
<name>void</name> <macro><name>setDeadStrippableDylib</name><argument_list>(<argument>bool deadStrippable</argument>)</argument_list></macro> <block>{
<expr><name>_deadStrippableDylib</name> <operator>=</operator> <name>deadStrippable</name></expr>;
}</block>
<name>void</name> <macro><name>setUseFlatNamespace</name><argument_list>(<argument>bool flatNamespace</argument>)</argument_list></macro> <block>{
<expr><name>_flatNamespace</name> <operator>=</operator> <name>flatNamespace</name></expr>;
}</block>

<name>void</name> <macro><name>setUndefinedMode</name><argument_list>(<argument>UndefinedMode undefinedMode</argument>)</argument_list></macro> <block>{
<expr><name>_undefinedMode</name> <operator>=</operator> <name>undefinedMode</name></expr>;
}</block>

<name>void</name> <macro><name>setBundleLoader</name><argument_list>(<argument>StringRef loader</argument>)</argument_list></macro> <block>{ <expr><name>_bundleLoader</name> <operator>=</operator> <name>loader</name></expr>; }</block>
<name>void</name> <macro><name>setPrintAtoms</name><argument_list>(<argument>bool value=true</argument>)</argument_list></macro> <block>{ <expr><name>_printAtoms</name> <operator>=</operator> <name>value</name></expr>; }</block>
<name>void</name> <macro><name>setTestingFileUsage</name><argument_list>(<argument>bool value = true</argument>)</argument_list></macro> <block>{
<expr><name>_testingFileUsage</name> <operator>=</operator> <name>value</name></expr>;
}</block>
<name>void</name> <macro><name>addExistingPathForDebug</name><argument_list>(<argument>StringRef path</argument>)</argument_list></macro> <block>{
<expr><call><name><name>_existingPaths</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>addRpath</name><argument_list>(<argument>StringRef rpath</argument>)</argument_list></macro></expr>;
<expr><specifier>const</specifier> <name>StringRefVector</name> <operator>&amp;</operator><macro><name>rpaths</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>_rpaths</name></expr>;</return> }</block>


<name>void</name> <macro><name>addSectionAlignment</name><argument_list>(<argument>StringRef seg</argument>, <argument>StringRef sect</argument>, <argument>uint16_t align</argument>)</argument_list></macro></expr>;


<expr><name>void</name> <macro><name>addSectCreateSection</name><argument_list>(<argument>StringRef seg</argument>, <argument>StringRef sect</argument>,
<argument>std::unique_ptr&lt;MemoryBuffer&gt; content</argument>)</argument_list></macro></expr>;


<expr><name>bool</name> <macro><name>sectionAligned</name><argument_list>(<argument>StringRef seg</argument>, <argument>StringRef sect</argument>, <argument>uint16_t &amp;align</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>StringRef</name> <macro><name>dyldPath</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><literal type="string">"/usr/lib/dyld"</literal></expr>;</return> }</block>


<name>bool</name> <macro><name>needsStubsPass</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>bool</name> <macro><name>needsGOTPass</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>bool</name> <macro><name>needsTLVPass</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>bool</name> <macro><name>needsCompactUnwindPass</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>bool</name> <macro><name>needsShimPass</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>bool</name> <macro><name>needsObjCPass</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>StringRef</name> <macro><name>binderSymbolName</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>void</name> <macro><name>registerDylib</name><argument_list>(<argument>mach_o::MachODylibFile *dylib</argument>, <argument>bool upward</argument>)</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name><name>ErrorOr</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>MemoryBuffer</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <macro><name>getMemoryBuffer</name><argument_list>(<argument>StringRef path</argument>)</argument_list></macro></expr>;




<expr><name>mach_o</name><operator>::</operator><name>MachODylibFile</name><operator>*</operator> <macro><name>findIndirectDylib</name><argument_list>(<argument>StringRef path</argument>)</argument_list></macro></expr>;

<expr><name>uint32_t</name> <macro><name>dylibCurrentVersion</name><argument_list>(<argument>StringRef installName</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>uint32_t</name> <macro><name>dylibCompatVersion</name><argument_list>(<argument>StringRef installName</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>mach_o</name><operator>::</operator><name>MachODylibFile</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>allDylibs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>_allDylibs</name></expr>;</return>
}</block>


<name>StringRef</name> <macro><name>copy</name><argument_list>(<argument>StringRef str</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>str</name><operator>.</operator><name>copy</name></name><argument_list>(<argument><expr><name>_allocator</name></expr></argument>)</argument_list></call></expr>;</return> }</block>



<name>bool</name> <macro><name>sliceFromFatFile</name><argument_list>(<argument>MemoryBufferRef mb</argument>, <argument>uint32_t &amp;offset</argument>, <argument>uint32_t &amp;size</argument>)</argument_list></macro></expr>;


<expr><name>bool</name> <macro><name>isUpwardDylib</name><argument_list>(<argument>StringRef installName</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>isThinObjectFile</name><argument_list>(<argument>StringRef path</argument>, <argument>Arch &amp;arch</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>Arch</name> <macro><name>archFromCpuType</name><argument_list>(<argument>uint32_t cputype</argument>, <argument>uint32_t cpusubtype</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>Arch</name> <macro><name>archFromName</name><argument_list>(<argument>StringRef archName</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>StringRef</name> <macro><name>nameFromArch</name><argument_list>(<argument>Arch arch</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>uint32_t</name> <macro><name>cpuTypeFromArch</name><argument_list>(<argument>Arch arch</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>uint32_t</name> <macro><name>cpuSubtypeFromArch</name><argument_list>(<argument>Arch arch</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>bool</name> <macro><name>is64Bit</name><argument_list>(<argument>Arch arch</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>bool</name> <macro><name>isHostEndian</name><argument_list>(<argument>Arch arch</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>bool</name> <macro><name>isBigEndian</name><argument_list>(<argument>Arch arch</argument>)</argument_list></macro></expr>;



<expr><specifier>static</specifier> <name>bool</name> <macro><name>parsePackedVersion</name><argument_list>(<argument>StringRef str</argument>, <argument>uint32_t &amp;result</argument>)</argument_list></macro></expr>;



<expr><specifier>static</specifier> <name>bool</name> <macro><name>parsePackedVersion</name><argument_list>(<argument>StringRef str</argument>, <argument>uint64_t &amp;result</argument>)</argument_list></macro></expr>;

<expr><name>void</name> <macro><name>finalizeInputFiles</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>llvm</name><operator>::</operator><name>Error</name> <macro><name>handleLoadedFile</name><argument_list>(<argument>File &amp;file</argument>)</argument_list></macro> <name>override</name></expr>;

<expr><name>bool</name> <macro><name>customAtomOrderer</name><argument_list>(<argument>const DefinedAtom *left</argument>, <argument>const DefinedAtom *right</argument>,
<argument>bool &amp;leftBeforeRight</argument>)</argument_list></macro> <specifier>const</specifier></expr>;




<expr><name>File</name><operator>*</operator> <macro><name>flatNamespaceFile</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>_flatNamespaceFile</name></expr>;</return> }</block>

<name>private</name><operator>:</operator>
<name>Writer</name> <operator>&amp;</operator><macro><name>writer</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;
<expr><name>mach_o</name><operator>::</operator><name>MachODylibFile</name><operator>*</operator> <macro><name>loadIndirectDylib</name><argument_list>(<argument>StringRef path</argument>)</argument_list></macro></expr>;
struct <expr><name>ArchInfo</name> <block>{
<expr><name>StringRef</name> <name>archName</name></expr>;
<expr><name>MachOLinkingContext</name><operator>::</operator><name>Arch</name> <name>arch</name></expr>;
<expr><name>bool</name> <name>littleEndian</name></expr>;
<expr><name>uint32_t</name> <name>cputype</name></expr>;
<expr><name>uint32_t</name> <name>cpusubtype</name></expr>;
}</block></expr>;

struct <expr><name>SectionAlign</name> <block>{
<expr><name>StringRef</name> <name>segmentName</name></expr>;
<expr><name>StringRef</name> <name>sectionName</name></expr>;
<expr><name>uint16_t</name> <name>align</name></expr>;
}</block></expr>;

struct <expr><name>OrderFileNode</name> <block>{
<expr><name>StringRef</name> <name>fileFilter</name></expr>;
<expr><name>unsigned</name> <name>order</name></expr>;
}</block></expr>;

<expr><specifier>static</specifier> <name>bool</name> <call><name>findOrderOrdinal</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>OrderFileNode</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>nodes</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>DefinedAtom</name> <operator>*</operator><name>atom</name></expr></argument>, <argument><expr><name>unsigned</name> <operator>&amp;</operator><name>ordinal</name></expr></argument>)</argument_list></call></expr>;

<expr><specifier>static</specifier> <name>ArchInfo</name> <name><name>_s_archInfos</name><index>[]</index></name></expr>;

<expr><name>std</name><operator>::</operator><name><name>set</name><argument_list type="generic">&lt;<argument><expr><name>StringRef</name></expr></argument>&gt;</argument_list></name> <name>_existingPaths</name></expr>;
<expr><name>StringRefVector</name> <name>_searchDirs</name></expr>;
<expr><name>StringRefVector</name> <name>_syslibRoots</name></expr>;
<expr><name>StringRefVector</name> <name>_frameworkDirs</name></expr>;
<expr><name>HeaderFileType</name> <name>_outputMachOType</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name>MachO</name><operator>::</operator><name>MH_EXECUTE</name></expr>;
<expr><name>bool</name> <name>_outputMachOTypeStatic</name> <operator>=</operator> <name>false</name></expr>;
<expr><name>bool</name> <name>_doNothing</name> <operator>=</operator> <name>false</name></expr>;
<expr><name>bool</name> <name>_pie</name> <operator>=</operator> <name>false</name></expr>;
<expr><name>Arch</name> <name>_arch</name> <operator>=</operator> <name>arch_unknown</name></expr>;
<expr><name>OS</name> <name>_os</name> <operator>=</operator> <name>OS</name><operator>::</operator><name>macOSX</name></expr>;
<expr><name>uint32_t</name> <name>_osMinVersion</name> <operator>=</operator> <literal type="number">0</literal></expr>;
<expr><name>uint32_t</name> <name>_sdkVersion</name> <operator>=</operator> <literal type="number">0</literal></expr>;
<expr><name>uint64_t</name> <name>_sourceVersion</name> <operator>=</operator> <literal type="number">0</literal></expr>;
<expr><name>uint64_t</name> <name>_pageZeroSize</name> <operator>=</operator> <literal type="number">0</literal></expr>;
<expr><name>uint64_t</name> <name>_pageSize</name> <operator>=</operator> <literal type="number">4096</literal></expr>;
<expr><name>uint64_t</name> <name>_baseAddress</name> <operator>=</operator> <literal type="number">0</literal></expr>;
<expr><name>uint64_t</name> <name>_stackSize</name> <operator>=</operator> <literal type="number">0</literal></expr>;
<expr><name>uint32_t</name> <name>_compatibilityVersion</name> <operator>=</operator> <literal type="number">0</literal></expr>;
<expr><name>uint32_t</name> <name>_currentVersion</name> <operator>=</operator> <literal type="number">0</literal></expr>;
<expr><name>ObjCConstraint</name> <name>_objcConstraint</name> <operator>=</operator> <name>objc_unknown</name></expr>;
<expr><name>uint32_t</name> <name>_swiftVersion</name> <operator>=</operator> <literal type="number">0</literal></expr>;
<expr><name>StringRef</name> <name>_installName</name></expr>;
<expr><name>StringRefVector</name> <name>_rpaths</name></expr>;
<expr><name>bool</name> <name>_flatNamespace</name> <operator>=</operator> <name>false</name></expr>;
<expr><name>UndefinedMode</name> <name>_undefinedMode</name> <operator>=</operator> <name>UndefinedMode</name><operator>::</operator><name>error</name></expr>;
<expr><name>bool</name> <name>_deadStrippableDylib</name> <operator>=</operator> <name>false</name></expr>;
<expr><name>bool</name> <name>_printAtoms</name> <operator>=</operator> <name>false</name></expr>;
<expr><name>bool</name> <name>_testingFileUsage</name> <operator>=</operator> <name>false</name></expr>;
<expr><name>bool</name> <name>_keepPrivateExterns</name> <operator>=</operator> <name>false</name></expr>;
<expr><name>bool</name> <name>_demangle</name> <operator>=</operator> <name>false</name></expr>;
<expr><name>bool</name> <name>_mergeObjCCategories</name> <operator>=</operator> <name>true</name></expr>;
<expr><name>bool</name> <name>_generateVersionLoadCommand</name> <operator>=</operator> <name>false</name></expr>;
<expr><name>bool</name> <name>_generateFunctionStartsLoadCommand</name> <operator>=</operator> <name>false</name></expr>;
<expr><name>bool</name> <name>_generateDataInCodeLoadCommand</name> <operator>=</operator> <name>false</name></expr>;
<expr><name>StringRef</name> <name>_bundleLoader</name></expr>;
<expr><name>mutable</name> <name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>mach_o</name><operator>::</operator><name>ArchHandler</name></expr></argument>&gt;</argument_list></name> <name>_archHandler</name></expr>;
<expr><name>mutable</name> <name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>Writer</name></expr></argument>&gt;</argument_list></name> <name>_writer</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>SectionAlign</name></expr></argument>&gt;</argument_list></name> <name>_sectAligns</name></expr>;
<expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>StringMap</name><argument_list type="generic">&lt;<argument><expr><name>mach_o</name><operator>::</operator><name>MachODylibFile</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <name>_pathToDylibMap</name></expr>;
<expr><name>mutable</name> <name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>mach_o</name><operator>::</operator><name>MachODylibFile</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <name>_allDylibs</name></expr>;
<expr><name>mutable</name> <name>std</name><operator>::</operator><name><name>set</name><argument_list type="generic">&lt;<argument><expr><name>mach_o</name><operator>::</operator><name>MachODylibFile</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <name>_upwardDylibs</name></expr>;
<expr><name>mutable</name> <name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>File</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <name>_indirectDylibs</name></expr>;
<expr><name>mutable</name> <name>std</name><operator>::</operator><name>mutex</name> <name>_dylibsMutex</name></expr>;
<expr><name>ExportMode</name> <name>_exportMode</name> <operator>=</operator> <name>ExportMode</name><operator>::</operator><name>globals</name></expr>;
<expr><name>llvm</name><operator>::</operator><name><name>StringSet</name><argument_list type="generic">&lt;&gt;</argument_list></name> <name>_exportedSymbols</name></expr>;
<expr><name>DebugInfoMode</name> <name>_debugInfoMode</name> <operator>=</operator> <name>DebugInfoMode</name><operator>::</operator><name>addDebugMap</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>raw_fd_ostream</name></expr></argument>&gt;</argument_list></name> <name>_dependencyInfo</name></expr>;
<expr><name>llvm</name><operator>::</operator><name><name>StringMap</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>OrderFileNode</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <name>_orderFiles</name></expr>;
<expr><name>unsigned</name> <name>_orderFileEntries</name> <operator>=</operator> <literal type="number">0</literal></expr>;
<expr><name>File</name> <operator>*</operator><name>_flatNamespaceFile</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>mach_o</name><operator>::</operator><name>SectCreateFile</name> <operator>*</operator><name>_sectCreateFile</name> <operator>=</operator> <name>nullptr</name></expr>;
}</block></expr></range></decl>;</decl_stmt>

</block_content>}</block></decl></decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
