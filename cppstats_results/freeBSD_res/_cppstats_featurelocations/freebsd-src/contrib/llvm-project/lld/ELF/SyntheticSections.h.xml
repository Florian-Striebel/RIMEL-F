<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/lld/ELF/SyntheticSections.h">


















<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLD_ELF_SYNTHETIC_SECTIONS_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLD_ELF_SYNTHETIC_SECTIONS_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"DWARF.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"EhFrame.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"InputSection.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/DenseSet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/MapVector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/MC/StringTableBuilder.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Endian.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;functional&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>lld</name> <block>{<block_content>
<decl_stmt><decl><type><name>namespace</name></type> <name>elf</name> <block>{<block_content>
<decl_stmt><decl><type><name>class</name></type> <name>Defined</name></decl>;</decl_stmt>
<struct_decl>struct <name>PhdrEntry</name>;</struct_decl>
<decl_stmt><decl><type><name>class</name></type> <name>SymbolTableBaseSection</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>VersionNeedBaseSection</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>SyntheticSection</name> <range>: <expr><name>public</name> <name>InputSection</name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>SyntheticSection</name><argument_list>(<argument>uint64_t flags</argument>, <argument>uint32_t type</argument>, <argument>uint32_t alignment</argument>,
<argument>StringRef name</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>InputSection</name><argument_list>(<argument>nullptr</argument>, <argument>flags</argument>, <argument>type</argument>, <argument>alignment</argument>, <argument>{}</argument>, <argument>name</argument>,
<argument>InputSectionBase::Synthetic</argument>)</argument_list></macro> <block>{
<expr><call><name>markLive</name><argument_list>()</argument_list></call></expr>;
}</block>

<name>virtual</name> <operator>~</operator><call><name>SyntheticSection</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;
<expr><name>virtual</name> <name>void</name> <call><name>writeTo</name><argument_list>(<argument><expr><name>uint8_t</name> <operator>*</operator><name>buf</name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">0</literal></expr>;
<expr><name>virtual</name> <name>size_t</name> <macro><name>getSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <operator>=</operator> <literal type="number">0</literal></expr>;
<expr><name>virtual</name> <name>void</name> <macro><name>finalizeContents</name><argument_list>()</argument_list></macro> <block>{}</block>


<name>virtual</name> <name>bool</name> <macro><name>updateAllocSize</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block>
<name>virtual</name> <name>bool</name> <macro><name>isNeeded</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>true</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const SectionBase *d</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>d</name><operator>-&gt;</operator><name>kind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>InputSectionBase</name><operator>::</operator><name>Synthetic</name></expr>;</return>
}</block>
}</expr>;

struct <expr><name>CieRecord</name> <block>{
<expr><name>EhSectionPiece</name> <operator>*</operator><name>cie</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>EhSectionPiece</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>fdes</name></expr>;
}</block></expr>;


<expr><name>class</name> <name>EhFrameSection</name> <name>final</name> <operator>:</operator> <name>public</name> <name>SyntheticSection</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>EhFrameSection</name><argument_list>()</argument_list></call></expr>;
<expr><name>void</name> <macro><name>writeTo</name><argument_list>(<argument>uint8_t *buf</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>void</name> <macro><name>finalizeContents</name><argument_list>()</argument_list></macro> <name>override</name></expr>;
<expr><name>bool</name> <macro><name>isNeeded</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><operator>!</operator><call><name><name>sections</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>size_t</name> <macro><name>getSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><name>size</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const SectionBase *d</argument>)</argument_list></macro> <block>{
<return>return <expr><name>SyntheticSection</name><operator>::</operator><call><name>classof</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>d</name><operator>-&gt;</operator><name>name</name></name> <operator>==</operator> <literal type="string">".eh_frame"</literal></expr>;</return>
}</block>

<name>void</name> <call><name>addSection</name><argument_list>(<argument><expr><name>EhInputSection</name> <operator>*</operator><name>sec</name></expr></argument>)</argument_list></call></expr>;

<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>EhInputSection</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>sections</name></expr>;
<expr><name>size_t</name> <name>numFdes</name> <operator>=</operator> <literal type="number">0</literal></expr>;

struct <expr><name>FdeData</name> <block>{
<expr><name>uint32_t</name> <name>pcRel</name></expr>;
<expr><name>uint32_t</name> <name>fdeVARel</name></expr>;
}</block></expr>;

<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>FdeData</name></expr></argument>&gt;</argument_list></name> <macro><name>getFdeData</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>CieRecord</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getCieRecords</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>cieRecords</name></expr>;</return> }</block>
<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>ELFT</name></expr></argument>&gt;</argument_list></name>
<name>void</name> <call><name>iterateFDEWithLSDA</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name><name>function_ref</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>(</operator><name>InputSection</name> <operator>&amp;</operator><operator>)</operator></expr></argument>&gt;</argument_list></name> <name>fn</name></expr></argument>)</argument_list></call></expr>;

<expr><name>private</name><operator>:</operator>


<name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>size_t</name></expr></argument>, <argument><expr><name>CieRecord</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>offsetToCie</name></expr>;

<expr><name>uint64_t</name> <name>size</name> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>ELFT</name></expr></argument>, <argument><expr><name>class</name> <name>RelTy</name></expr></argument>&gt;</argument_list></name>
<name>void</name> <call><name>addRecords</name><argument_list>(<argument><expr><name>EhInputSection</name> <operator>*</operator><name>s</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>RelTy</name></expr></argument>&gt;</argument_list></name> <name>rels</name></expr></argument>)</argument_list></call></expr>;
<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>ELFT</name></expr></argument>&gt;</argument_list></name> <name>void</name> <call><name>addSectionAux</name><argument_list>(<argument><expr><name>EhInputSection</name> <operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>;
<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>ELFT</name></expr></argument>, <argument><expr><name>class</name> <name>RelTy</name></expr></argument>&gt;</argument_list></name>
<name>void</name> <call><name>iterateFDEWithLSDAAux</name><argument_list>(<argument><expr><name>EhInputSection</name> <operator>&amp;</operator><name>sec</name></expr></argument>, <argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>RelTy</name></expr></argument>&gt;</argument_list></name> <name>rels</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name><name>DenseSet</name><argument_list type="generic">&lt;<argument><expr><name>size_t</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>ciesWithLSDA</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name><name>function_ref</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>(</operator><name>InputSection</name> <operator>&amp;</operator><operator>)</operator></expr></argument>&gt;</argument_list></name> <name>fn</name></expr></argument>)</argument_list></call></expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>ELFT</name></expr></argument>, <argument><expr><name>class</name> <name>RelTy</name></expr></argument>&gt;</argument_list></name>
<name>CieRecord</name> <operator>*</operator><call><name>addCie</name><argument_list>(<argument><expr><name>EhSectionPiece</name> <operator>&amp;</operator><name>piece</name></expr></argument>, <argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>RelTy</name></expr></argument>&gt;</argument_list></name> <name>rels</name></expr></argument>)</argument_list></call></expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>ELFT</name></expr></argument>, <argument><expr><name>class</name> <name>RelTy</name></expr></argument>&gt;</argument_list></name>
<name>Defined</name> <operator>*</operator><call><name>isFdeLive</name><argument_list>(<argument><expr><name>EhSectionPiece</name> <operator>&amp;</operator><name>piece</name></expr></argument>, <argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>RelTy</name></expr></argument>&gt;</argument_list></name> <name>rels</name></expr></argument>)</argument_list></call></expr>;

<expr><name>uint64_t</name> <macro><name>getFdePc</name><argument_list>(<argument>uint8_t *buf</argument>, <argument>size_t off</argument>, <argument>uint8_t enc</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CieRecord</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>cieRecords</name></expr>;


<expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>uint8_t</name></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><name>Symbol</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><name>CieRecord</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>cieMap</name></expr>;
}</block></expr>;

<expr><name>class</name> <name>GotSection</name> <operator>:</operator> <name>public</name> <name>SyntheticSection</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>GotSection</name><argument_list>()</argument_list></call></expr>;
<expr><name>size_t</name> <macro><name>getSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><name>size</name></expr>;</return> }</block>
<name>void</name> <macro><name>finalizeContents</name><argument_list>()</argument_list></macro> <name>override</name></expr>;
<expr><name>bool</name> <macro><name>isNeeded</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;
<expr><name>void</name> <macro><name>writeTo</name><argument_list>(<argument>uint8_t *buf</argument>)</argument_list></macro> <name>override</name></expr>;

<expr><name>void</name> <call><name>addEntry</name><argument_list>(<argument><expr><name>Symbol</name> <operator>&amp;</operator><name>sym</name></expr></argument>)</argument_list></call></expr>;
<expr><name>bool</name> <call><name>addDynTlsEntry</name><argument_list>(<argument><expr><name>Symbol</name> <operator>&amp;</operator><name>sym</name></expr></argument>)</argument_list></call></expr>;
<expr><name>bool</name> <call><name>addTlsIndex</name><argument_list>()</argument_list></call></expr>;
<expr><name>uint64_t</name> <macro><name>getGlobalDynAddr</name><argument_list>(<argument>const Symbol &amp;b</argument>)</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>uint64_t</name> <macro><name>getGlobalDynOffset</name><argument_list>(<argument>const Symbol &amp;b</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>uint64_t</name> <macro><name>getTlsIndexVA</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>getVA</name></name><argument_list>()</argument_list></call> <operator>+</operator> <name>tlsIndexOff</name></expr>;</return> }</block>
<name>uint32_t</name> <macro><name>getTlsIndexOff</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>tlsIndexOff</name></expr>;</return> }</block>



<name>bool</name> <name>hasGotOffRel</name> <operator>=</operator> <name>false</name></expr>;

<expr><name>protected</name><operator>:</operator>
<name>size_t</name> <name>numEntries</name> <operator>=</operator> <literal type="number">0</literal></expr>;
<expr><name>uint32_t</name> <name>tlsIndexOff</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;
<expr><name>uint64_t</name> <name>size</name> <operator>=</operator> <literal type="number">0</literal></expr>;
}</block></expr>;


<expr><name>class</name> <name>GnuStackSection</name> <operator>:</operator> <name>public</name> <name>SyntheticSection</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>GnuStackSection</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>SyntheticSection</name><argument_list>(<argument><literal type="number">0</literal></argument>, <argument>llvm::ELF::SHT_PROGBITS</argument>, <argument><literal type="number">1</literal></argument>, <argument><literal type="string">".note.GNU-stack"</literal></argument>)</argument_list></macro> <block>{}</block>
<name>void</name> <macro><name>writeTo</name><argument_list>(<argument>uint8_t *buf</argument>)</argument_list></macro> <name>override</name> <block>{}</block>
<name>size_t</name> <macro><name>getSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><literal type="number">0</literal></expr>;</return> }</block>
}</expr>;

<expr><name>class</name> <name>GnuPropertySection</name> <operator>:</operator> <name>public</name> <name>SyntheticSection</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>GnuPropertySection</name><argument_list>()</argument_list></call></expr>;
<expr><name>void</name> <macro><name>writeTo</name><argument_list>(<argument>uint8_t *buf</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>size_t</name> <macro><name>getSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;
}</block></expr>;


<expr><name>class</name> <name>BuildIdSection</name> <operator>:</operator> <name>public</name> <name>SyntheticSection</name> <block>{

<expr><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>headerSize</name> <operator>=</operator> <literal type="number">16</literal></expr>;

<expr><name>public</name><operator>:</operator>
<specifier>const</specifier> <name>size_t</name> <name>hashSize</name></expr>;
<expr><call><name>BuildIdSection</name><argument_list>()</argument_list></call></expr>;
<expr><name>void</name> <macro><name>writeTo</name><argument_list>(<argument>uint8_t *buf</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>size_t</name> <macro><name>getSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><name>headerSize</name> <operator>+</operator> <name>hashSize</name></expr>;</return> }</block>
<name>void</name> <call><name>writeBuildId</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>uint8_t</name></expr></argument>&gt;</argument_list></name> <name>buf</name></expr></argument>)</argument_list></call></expr>;

<expr><name>private</name><operator>:</operator>
<name>uint8_t</name> <operator>*</operator><name>hashBuf</name></expr>;
}</block></expr>;





<expr><name>class</name> <name>BssSection</name> <name>final</name> <operator>:</operator> <name>public</name> <name>SyntheticSection</name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>BssSection</name><argument_list>(<argument>StringRef name</argument>, <argument>uint64_t size</argument>, <argument>uint32_t alignment</argument>)</argument_list></macro></expr>;
<expr><name>void</name> <macro><name>writeTo</name><argument_list>(<argument>uint8_t *</argument>)</argument_list></macro> <name>override</name> <block>{
<expr><call><name>llvm_unreachable</name><argument_list>(<argument><expr><literal type="string">"unexpected writeTo() call for SHT_NOBITS section"</literal></expr></argument>)</argument_list></call></expr>;
}</block>
<name>bool</name> <macro><name>isNeeded</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><name>size</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</return> }</block>
<name>size_t</name> <macro><name>getSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><name>size</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const SectionBase *s</argument>)</argument_list></macro> <block>{ <return>return <expr><name><name>s</name><operator>-&gt;</operator><name>bss</name></name></expr>;</return> }</block>
<name>uint64_t</name> <name>size</name></expr>;
}</block></expr>;

<expr><name>class</name> <name>MipsGotSection</name> <name>final</name> <operator>:</operator> <name>public</name> <name>SyntheticSection</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>MipsGotSection</name><argument_list>()</argument_list></call></expr>;
<expr><name>void</name> <macro><name>writeTo</name><argument_list>(<argument>uint8_t *buf</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>size_t</name> <macro><name>getSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><name>size</name></expr>;</return> }</block>
<name>bool</name> <macro><name>updateAllocSize</name><argument_list>()</argument_list></macro> <name>override</name></expr>;
<expr><name>void</name> <macro><name>finalizeContents</name><argument_list>()</argument_list></macro> <name>override</name></expr>;
<expr><name>bool</name> <macro><name>isNeeded</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;



<expr><name>void</name> <call><name>build</name><argument_list>()</argument_list></call></expr>;

<expr><name>void</name> <macro><name>addEntry</name><argument_list>(<argument>InputFile &amp;file</argument>, <argument>Symbol &amp;sym</argument>, <argument>int64_t addend</argument>, <argument>RelExpr expr</argument>)</argument_list></macro></expr>;
<expr><name>void</name> <call><name>addDynTlsEntry</name><argument_list>(<argument><expr><name>InputFile</name> <operator>&amp;</operator><name>file</name></expr></argument>, <argument><expr><name>Symbol</name> <operator>&amp;</operator><name>sym</name></expr></argument>)</argument_list></call></expr>;
<expr><name>void</name> <call><name>addTlsIndex</name><argument_list>(<argument><expr><name>InputFile</name> <operator>&amp;</operator><name>file</name></expr></argument>)</argument_list></call></expr>;

<expr><name>uint64_t</name> <macro><name>getPageEntryOffset</name><argument_list>(<argument>const InputFile *f</argument>, <argument>const Symbol &amp;s</argument>,
<argument>int64_t addend</argument>)</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>uint64_t</name> <macro><name>getSymEntryOffset</name><argument_list>(<argument>const InputFile *f</argument>, <argument>const Symbol &amp;s</argument>,
<argument>int64_t addend</argument>)</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>uint64_t</name> <macro><name>getGlobalDynOffset</name><argument_list>(<argument>const InputFile *f</argument>, <argument>const Symbol &amp;s</argument>)</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>uint64_t</name> <macro><name>getTlsIndexOffset</name><argument_list>(<argument>const InputFile *f</argument>)</argument_list></macro> <specifier>const</specifier></expr>;





<expr><specifier>const</specifier> <name>Symbol</name> <operator>*</operator><macro><name>getFirstGlobalEntry</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>unsigned</name> <macro><name>getLocalEntriesNum</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>uint64_t</name> <macro><name>getGp</name><argument_list>(<argument>const InputFile *f = nullptr</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>private</name><operator>:</operator>























































































<specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>headerEntriesNum</name> <operator>=</operator> <literal type="number">2</literal></expr>;

<expr><name>uint64_t</name> <name>size</name> <operator>=</operator> <literal type="number">0</literal></expr>;


<expr><name>using</name> <name>GotEntry</name> <operator>=</operator> <name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>Symbol</name> <operator>*</operator></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>&gt;</argument_list></name></expr>;

struct <expr><name>FileGot</name> <block>{
<expr><name>InputFile</name> <operator>*</operator><name>file</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>size_t</name> <name>startIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;

struct <expr><name>PageBlock</name> <block>{
<expr><name>size_t</name> <name>firstIndex</name></expr>;
<expr><name>size_t</name> <name>count</name></expr>;
<expr><call><name>PageBlock</name><argument_list>()</argument_list></call> <operator>:</operator> <call><name>firstIndex</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>, <macro><name>count</name><argument_list>(<argument><literal type="number">0</literal></argument>)</argument_list></macro> <expr><block>{}</block></expr>
}</block></expr>;




<expr><name>llvm</name><operator>::</operator><name><name>SmallMapVector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>OutputSection</name> <operator>*</operator></expr></argument>, <argument><expr><name>PageBlock</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name> <name>pagesMap</name></expr>;

<expr><name>llvm</name><operator>::</operator><name><name>MapVector</name><argument_list type="generic">&lt;<argument><expr><name>GotEntry</name></expr></argument>, <argument><expr><name>size_t</name></expr></argument>&gt;</argument_list></name> <name>local16</name></expr>;
<expr><name>llvm</name><operator>::</operator><name><name>MapVector</name><argument_list type="generic">&lt;<argument><expr><name>GotEntry</name></expr></argument>, <argument><expr><name>size_t</name></expr></argument>&gt;</argument_list></name> <name>local32</name></expr>;
<expr><name>llvm</name><operator>::</operator><name><name>MapVector</name><argument_list type="generic">&lt;<argument><expr><name>Symbol</name> <operator>*</operator></expr></argument>, <argument><expr><name>size_t</name></expr></argument>&gt;</argument_list></name> <name>global</name></expr>;
<expr><name>llvm</name><operator>::</operator><name><name>MapVector</name><argument_list type="generic">&lt;<argument><expr><name>Symbol</name> <operator>*</operator></expr></argument>, <argument><expr><name>size_t</name></expr></argument>&gt;</argument_list></name> <name>relocs</name></expr>;
<expr><name>llvm</name><operator>::</operator><name><name>MapVector</name><argument_list type="generic">&lt;<argument><expr><name>Symbol</name> <operator>*</operator></expr></argument>, <argument><expr><name>size_t</name></expr></argument>&gt;</argument_list></name> <name>tls</name></expr>;

<expr><name>llvm</name><operator>::</operator><name><name>MapVector</name><argument_list type="generic">&lt;<argument><expr><name>Symbol</name> <operator>*</operator></expr></argument>, <argument><expr><name>size_t</name></expr></argument>&gt;</argument_list></name> <name>dynTlsSymbols</name></expr>;


<expr><name>size_t</name> <macro><name>getEntriesNum</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>size_t</name> <macro><name>getPageEntriesNum</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>size_t</name> <macro><name>getIndexedEntriesNum</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
}</block></expr>;




<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>FileGot</name></expr></argument>&gt;</argument_list></name> <name>gots</name></expr>;


<expr><name>FileGot</name> <operator>&amp;</operator><call><name>getGot</name><argument_list>(<argument><expr><name>InputFile</name> <operator>&amp;</operator><name>f</name></expr></argument>)</argument_list></call></expr>;




<expr><name>bool</name> <macro><name>tryMergeGots</name><argument_list>(<argument>FileGot &amp; dst</argument>, <argument>FileGot &amp; src</argument>, <argument>bool isPrimary</argument>)</argument_list></macro></expr>;
}</block></expr>;

<expr><name>class</name> <name>GotPltSection</name> <name>final</name> <operator>:</operator> <name>public</name> <name>SyntheticSection</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>GotPltSection</name><argument_list>()</argument_list></call></expr>;
<expr><name>void</name> <call><name>addEntry</name><argument_list>(<argument><expr><name>Symbol</name> <operator>&amp;</operator><name>sym</name></expr></argument>)</argument_list></call></expr>;
<expr><name>size_t</name> <macro><name>getSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;
<expr><name>void</name> <macro><name>writeTo</name><argument_list>(<argument>uint8_t *buf</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>bool</name> <macro><name>isNeeded</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;



<expr><name>bool</name> <name>hasGotPltOffRel</name> <operator>=</operator> <name>false</name></expr>;

<expr><name>private</name><operator>:</operator>
<name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Symbol</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>entries</name></expr>;
}</block></expr>;





<expr><name>class</name> <name>IgotPltSection</name> <name>final</name> <operator>:</operator> <name>public</name> <name>SyntheticSection</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>IgotPltSection</name><argument_list>()</argument_list></call></expr>;
<expr><name>void</name> <call><name>addEntry</name><argument_list>(<argument><expr><name>Symbol</name> <operator>&amp;</operator><name>sym</name></expr></argument>)</argument_list></call></expr>;
<expr><name>size_t</name> <macro><name>getSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;
<expr><name>void</name> <macro><name>writeTo</name><argument_list>(<argument>uint8_t *buf</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>bool</name> <macro><name>isNeeded</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><operator>!</operator><call><name><name>entries</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>private</name><operator>:</operator>
<name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Symbol</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>entries</name></expr>;
}</block></expr>;

<expr><name>class</name> <name>StringTableSection</name> <name>final</name> <operator>:</operator> <name>public</name> <name>SyntheticSection</name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>StringTableSection</name><argument_list>(<argument>StringRef name</argument>, <argument>bool dynamic</argument>)</argument_list></macro></expr>;
<expr><name>unsigned</name> <macro><name>addString</name><argument_list>(<argument>StringRef s</argument>, <argument>bool hashIt = true</argument>)</argument_list></macro></expr>;
<expr><name>void</name> <macro><name>writeTo</name><argument_list>(<argument>uint8_t *buf</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>size_t</name> <macro><name>getSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><name>size</name></expr>;</return> }</block>
<name>bool</name> <macro><name>isDynamic</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>dynamic</name></expr>;</return> }</block>

<name>private</name><operator>:</operator>
<specifier>const</specifier> <name>bool</name> <name>dynamic</name></expr>;

<expr><name>uint64_t</name> <name>size</name> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>StringRef</name></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name> <name>stringMap</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>StringRef</name></expr></argument>&gt;</argument_list></name> <name>strings</name></expr>;
}</block></expr>;

<expr><name>class</name> <name>DynamicReloc</name> <block>{
<expr><name>public</name><operator>:</operator>
enum <name>Kind</name> <block>{


<expr><name>AddendOnly</name></expr>,



<expr><name>AddendOnlyWithTargetVA</name></expr>,


<expr><name>AgainstSymbol</name></expr>,




<expr><name>AgainstSymbolWithTargetVA</name></expr>,


<expr><name>MipsMultiGotPage</name></expr>,
}</block></expr>;

<macro><name>DynamicReloc</name><argument_list>(<argument>RelType type</argument>, <argument>const InputSectionBase *inputSec</argument>,
<argument>uint64_t offsetInSec</argument>, <argument>Kind kind</argument>, <argument>Symbol &amp;sym</argument>, <argument>int64_t addend</argument>,
<argument>RelExpr expr</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>type</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>sym</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sym</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>inputSec</name><argument_list>(<argument><expr><name>inputSec</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>offsetInSec</name><argument_list>(<argument><expr><name>offsetInSec</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>kind</name><argument_list>(<argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>expr</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>, <macro><name>addend</name><argument_list>(<argument>addend</argument>)</argument_list></macro> <expr><block>{}</block>

<macro><name>DynamicReloc</name><argument_list>(<argument>RelType type</argument>, <argument>const InputSectionBase *inputSec</argument>,
<argument>uint64_t offsetInSec</argument>, <argument>int64_t addend = <literal type="number">0</literal></argument>)</argument_list></macro>
<operator>:</operator> <call><name>type</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>sym</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>inputSec</name><argument_list>(<argument><expr><name>inputSec</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>offsetInSec</name><argument_list>(<argument><expr><name>offsetInSec</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>kind</name><argument_list>(<argument><expr><name>AddendOnly</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>expr</name><argument_list>(<argument><expr><name>R_ADDEND</name></expr></argument>)</argument_list></call></expr>, <macro><name>addend</name><argument_list>(<argument>addend</argument>)</argument_list></macro> <expr><block>{}</block>


<macro><name>DynamicReloc</name><argument_list>(<argument>RelType type</argument>, <argument>const InputSectionBase *inputSec</argument>,
<argument>uint64_t offsetInSec</argument>, <argument>const OutputSection *outputSec</argument>,
<argument>int64_t addend</argument>)</argument_list></macro>
<operator>:</operator> <call><name>type</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>sym</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>inputSec</name><argument_list>(<argument><expr><name>inputSec</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>offsetInSec</name><argument_list>(<argument><expr><name>offsetInSec</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>kind</name><argument_list>(<argument><expr><name>MipsMultiGotPage</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>expr</name><argument_list>(<argument><expr><name>R_ADDEND</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>addend</name><argument_list>(<argument><expr><name>addend</name></expr></argument>)</argument_list></call></expr>,
<macro><name>outputSec</name><argument_list>(<argument>outputSec</argument>)</argument_list></macro> <expr><block>{}</block>

<name>uint64_t</name> <macro><name>getOffset</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>uint32_t</name> <macro><name>getSymIndex</name><argument_list>(<argument>SymbolTableBaseSection *symTab</argument>)</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>needsDynSymIndex</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>kind</name> <operator>==</operator> <name>AgainstSymbol</name> <operator>||</operator> <name>kind</name> <operator>==</operator> <name>AgainstSymbolWithTargetVA</name></expr>;</return>
}</block>




<name>int64_t</name> <macro><name>computeAddend</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>RelType</name> <name>type</name></expr>;
<expr><name>Symbol</name> <operator>*</operator><name>sym</name></expr>;
<expr><specifier>const</specifier> <name>InputSectionBase</name> <operator>*</operator><name>inputSec</name></expr>;
<expr><name>uint64_t</name> <name>offsetInSec</name></expr>;

<expr><name>private</name><operator>:</operator>
<name>Kind</name> <name>kind</name></expr>;


<expr><name>RelExpr</name> <name>expr</name></expr>;
<expr><name>int64_t</name> <name>addend</name></expr>;
<expr><specifier>const</specifier> <name>OutputSection</name> <operator>*</operator><name>outputSec</name> <operator>=</operator> <name>nullptr</name></expr>;
}</block></expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>ELFT</name></expr></argument>&gt;</argument_list></name> <name>class</name> <name>DynamicSection</name> <name>final</name> <operator>:</operator> <name>public</name> <name>SyntheticSection</name> <block>{
<macro><name>LLVM_ELF_IMPORT_TYPES_ELFT</name><argument_list>(<argument>ELFT</argument>)</argument_list></macro>


<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>int32_t</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name><name>function</name><argument_list type="generic">&lt;<argument><expr><name>uint64_t</name><operator>(</operator><operator>)</operator></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <name>entries</name></expr>;

<expr><name>public</name><operator>:</operator>
<call><name>DynamicSection</name><argument_list>()</argument_list></call></expr>;
<expr><name>void</name> <macro><name>finalizeContents</name><argument_list>()</argument_list></macro> <name>override</name></expr>;
<expr><name>void</name> <macro><name>writeTo</name><argument_list>(<argument>uint8_t *buf</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>size_t</name> <macro><name>getSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><name>size</name></expr>;</return> }</block>

<name>private</name><operator>:</operator>
<name>void</name> <macro><name>add</name><argument_list>(<argument>int32_t tag</argument>, <argument>std::function&lt;uint64_t()&gt; fn</argument>)</argument_list></macro></expr>;
<expr><name>void</name> <macro><name>addInt</name><argument_list>(<argument>int32_t tag</argument>, <argument>uint64_t val</argument>)</argument_list></macro></expr>;
<expr><name>void</name> <macro><name>addInSec</name><argument_list>(<argument>int32_t tag</argument>, <argument>InputSection *sec</argument>)</argument_list></macro></expr>;
<expr><name>void</name> <macro><name>addInSecRelative</name><argument_list>(<argument>int32_t tag</argument>, <argument>InputSection *sec</argument>)</argument_list></macro></expr>;
<expr><name>void</name> <macro><name>addOutSec</name><argument_list>(<argument>int32_t tag</argument>, <argument>OutputSection *sec</argument>)</argument_list></macro></expr>;
<expr><name>void</name> <macro><name>addSize</name><argument_list>(<argument>int32_t tag</argument>, <argument>OutputSection *sec</argument>)</argument_list></macro></expr>;
<expr><name>void</name> <macro><name>addSym</name><argument_list>(<argument>int32_t tag</argument>, <argument>Symbol *sym</argument>)</argument_list></macro></expr>;

<expr><name>uint64_t</name> <name>size</name> <operator>=</operator> <literal type="number">0</literal></expr>;
}</block></expr>;

<expr><name>class</name> <name>RelocationBaseSection</name> <operator>:</operator> <name>public</name> <name>SyntheticSection</name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>RelocationBaseSection</name><argument_list>(<argument>StringRef name</argument>, <argument>uint32_t type</argument>, <argument>int32_t dynamicTag</argument>,
<argument>int32_t sizeDynamicTag</argument>)</argument_list></macro></expr>;



<expr><name>void</name> <call><name>addReloc</name><argument_list>(<argument><expr><specifier>const</specifier> <name>DynamicReloc</name> <operator>&amp;</operator><name>reloc</name></expr></argument>)</argument_list></call></expr>;

<expr><name>void</name> <macro><name>addSymbolReloc</name><argument_list>(<argument>RelType dynType</argument>, <argument>InputSectionBase *isec</argument>,
<argument>uint64_t offsetInSec</argument>, <argument>Symbol &amp;sym</argument>, <argument>int64_t addend = <literal type="number">0</literal></argument>,
<argument>llvm::Optional&lt;RelType&gt; addendRelType = llvm::None</argument>)</argument_list></macro></expr>;


<expr><name>void</name> <macro><name>addRelativeReloc</name><argument_list>(<argument>RelType dynType</argument>, <argument>InputSectionBase *isec</argument>,
<argument>uint64_t offsetInSec</argument>, <argument>Symbol &amp;sym</argument>, <argument>int64_t addend</argument>,
<argument>RelType addendRelType</argument>, <argument>RelExpr expr</argument>)</argument_list></macro></expr>;


<expr><name>void</name> <macro><name>addAddendOnlyRelocIfNonPreemptible</name><argument_list>(<argument>RelType dynType</argument>,
<argument>InputSectionBase *isec</argument>,
<argument>uint64_t offsetInSec</argument>, <argument>Symbol &amp;sym</argument>,
<argument>RelType addendRelType</argument>)</argument_list></macro></expr>;
<expr><name>void</name> <macro><name>addReloc</name><argument_list>(<argument>DynamicReloc::Kind kind</argument>, <argument>RelType dynType</argument>,
<argument>InputSectionBase *inputSec</argument>, <argument>uint64_t offsetInSec</argument>, <argument>Symbol &amp;sym</argument>,
<argument>int64_t addend</argument>, <argument>RelExpr expr</argument>, <argument>RelType addendRelType</argument>)</argument_list></macro></expr>;
<expr><name>bool</name> <macro><name>isNeeded</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><operator>!</operator><call><name><name>relocs</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>size_t</name> <macro><name>getSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><call><name><name>relocs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>*</operator> <name><name>this</name><operator>-&gt;</operator><name>entsize</name></name></expr>;</return> }</block>
<name>size_t</name> <macro><name>getRelativeRelocCount</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>numRelativeRelocs</name></expr>;</return> }</block>
<name>void</name> <macro><name>finalizeContents</name><argument_list>()</argument_list></macro> <name>override</name></expr>;
<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const SectionBase *d</argument>)</argument_list></macro> <block>{
<return>return <expr><name>SyntheticSection</name><operator>::</operator><call><name>classof</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>d</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>llvm</name><operator>::</operator><name>ELF</name><operator>::</operator><name>SHT_RELA</name> <operator>||</operator> <name><name>d</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>llvm</name><operator>::</operator><name>ELF</name><operator>::</operator><name>SHT_REL</name> <operator>||</operator>
<name><name>d</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>llvm</name><operator>::</operator><name>ELF</name><operator>::</operator><name>SHT_RELR</name><operator>)</operator></expr>;</return>
}</block>
<name>int32_t</name> <name>dynamicTag</name></expr>, <expr><name>sizeDynamicTag</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>DynamicReloc</name></expr></argument>&gt;</argument_list></name> <name>relocs</name></expr>;

<expr><name>protected</name><operator>:</operator>
<name>size_t</name> <name>numRelativeRelocs</name> <operator>=</operator> <literal type="number">0</literal></expr>;
}</block></expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>ELFT</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>RelocationSection</name> <name>final</name> <operator>:</operator> <name>public</name> <name>RelocationBaseSection</name> <block>{
<expr><name>using</name> <name>Elf_Rel</name> <operator>=</operator> <name>typename</name> <name>ELFT</name><operator>::</operator><name>Rel</name></expr>;
<expr><name>using</name> <name>Elf_Rela</name> <operator>=</operator> <name>typename</name> <name>ELFT</name><operator>::</operator><name>Rela</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>RelocationSection</name><argument_list>(<argument>StringRef name</argument>, <argument>bool sort</argument>)</argument_list></macro></expr>;
<expr><name>void</name> <macro><name>writeTo</name><argument_list>(<argument>uint8_t *buf</argument>)</argument_list></macro> <name>override</name></expr>;

<expr><name>private</name><operator>:</operator>
<name>bool</name> <name>sort</name></expr>;
}</block></expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>ELFT</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>AndroidPackedRelocationSection</name> <name>final</name> <operator>:</operator> <name>public</name> <name>RelocationBaseSection</name> <block>{
<expr><name>using</name> <name>Elf_Rel</name> <operator>=</operator> <name>typename</name> <name>ELFT</name><operator>::</operator><name>Rel</name></expr>;
<expr><name>using</name> <name>Elf_Rela</name> <operator>=</operator> <name>typename</name> <name>ELFT</name><operator>::</operator><name>Rela</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>AndroidPackedRelocationSection</name><argument_list>(<argument>StringRef name</argument>)</argument_list></macro></expr>;

<expr><name>bool</name> <macro><name>updateAllocSize</name><argument_list>()</argument_list></macro> <name>override</name></expr>;
<expr><name>size_t</name> <macro><name>getSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><call><name><name>relocData</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>void</name> <macro><name>writeTo</name><argument_list>(<argument>uint8_t *buf</argument>)</argument_list></macro> <name>override</name> <block>{
<expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name><name>relocData</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>relocData</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<name>private</name><operator>:</operator>
<name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>char</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>&gt;</argument_list></name> <name>relocData</name></expr>;
}</block></expr>;

struct <expr><name>RelativeReloc</name> <block>{
<expr><name>uint64_t</name> <macro><name>getOffset</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>inputSec</name><operator>-&gt;</operator><name>getVA</name></name><argument_list>(<argument><expr><name>offsetInSec</name></expr></argument>)</argument_list></call></expr>;</return> }</block>

<specifier>const</specifier> <name>InputSectionBase</name> <operator>*</operator><name>inputSec</name></expr>;
<expr><name>uint64_t</name> <name>offsetInSec</name></expr>;
}</block></expr>;

<expr><name>class</name> <name>RelrBaseSection</name> <operator>:</operator> <name>public</name> <name>SyntheticSection</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>RelrBaseSection</name><argument_list>()</argument_list></call></expr>;
<expr><name>bool</name> <macro><name>isNeeded</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><operator>!</operator><call><name><name>relocs</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>RelativeReloc</name></expr></argument>&gt;</argument_list></name> <name>relocs</name></expr>;
}</block></expr>;





<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>ELFT</name></expr></argument>&gt;</argument_list></name> <name>class</name> <name>RelrSection</name> <name>final</name> <operator>:</operator> <name>public</name> <name>RelrBaseSection</name> <block>{
<expr><name>using</name> <name>Elf_Relr</name> <operator>=</operator> <name>typename</name> <name>ELFT</name><operator>::</operator><name>Relr</name></expr>;

<expr><name>public</name><operator>:</operator>
<call><name>RelrSection</name><argument_list>()</argument_list></call></expr>;

<expr><name>bool</name> <macro><name>updateAllocSize</name><argument_list>()</argument_list></macro> <name>override</name></expr>;
<expr><name>size_t</name> <macro><name>getSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><call><name><name>relrRelocs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>*</operator> <name><name>this</name><operator>-&gt;</operator><name>entsize</name></name></expr>;</return> }</block>
<name>void</name> <macro><name>writeTo</name><argument_list>(<argument>uint8_t *buf</argument>)</argument_list></macro> <name>override</name> <block>{
<expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name><name>relrRelocs</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getSize</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<name>private</name><operator>:</operator>
<name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>Elf_Relr</name></expr></argument>&gt;</argument_list></name> <name>relrRelocs</name></expr>;
}</block></expr>;

struct <expr><name>SymbolTableEntry</name> <block>{
<expr><name>Symbol</name> <operator>*</operator><name>sym</name></expr>;
<expr><name>size_t</name> <name>strTabOffset</name></expr>;
}</block></expr>;

<expr><name>class</name> <name>SymbolTableBaseSection</name> <operator>:</operator> <name>public</name> <name>SyntheticSection</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>SymbolTableBaseSection</name><argument_list>(<argument><expr><name>StringTableSection</name> <operator>&amp;</operator><name>strTabSec</name></expr></argument>)</argument_list></call></expr>;
<expr><name>void</name> <macro><name>finalizeContents</name><argument_list>()</argument_list></macro> <name>override</name></expr>;
<expr><name>size_t</name> <macro><name>getSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><call><name>getNumSymbols</name><argument_list>()</argument_list></call> <operator>*</operator> <name>entsize</name></expr>;</return> }</block>
<name>void</name> <call><name>addSymbol</name><argument_list>(<argument><expr><name>Symbol</name> <operator>*</operator><name>sym</name></expr></argument>)</argument_list></call></expr>;
<expr><name>unsigned</name> <macro><name>getNumSymbols</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>symbols</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</return> }</block>
<name>size_t</name> <call><name>getSymbolIndex</name><argument_list>(<argument><expr><name>Symbol</name> <operator>*</operator><name>sym</name></expr></argument>)</argument_list></call></expr>;
<expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>SymbolTableEntry</name></expr></argument>&gt;</argument_list></name> <macro><name>getSymbols</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>symbols</name></expr>;</return> }</block>

<name>protected</name><operator>:</operator>
<name>void</name> <call><name>sortSymTabSymbols</name><argument_list>()</argument_list></call></expr>;


<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>SymbolTableEntry</name></expr></argument>&gt;</argument_list></name> <name>symbols</name></expr>;

<expr><name>StringTableSection</name> <operator>&amp;</operator><name>strTabSec</name></expr>;

<expr><name>llvm</name><operator>::</operator><name>once_flag</name> <name>onceFlag</name></expr>;
<expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>Symbol</name> <operator>*</operator></expr></argument>, <argument><expr><name>size_t</name></expr></argument>&gt;</argument_list></name> <name>symbolIndexMap</name></expr>;
<expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>OutputSection</name> <operator>*</operator></expr></argument>, <argument><expr><name>size_t</name></expr></argument>&gt;</argument_list></name> <name>sectionIndexMap</name></expr>;
}</block></expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>ELFT</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>SymbolTableSection</name> <name>final</name> <operator>:</operator> <name>public</name> <name>SymbolTableBaseSection</name> <block>{
<expr><name>using</name> <name>Elf_Sym</name> <operator>=</operator> <name>typename</name> <name>ELFT</name><operator>::</operator><name>Sym</name></expr>;

<expr><name>public</name><operator>:</operator>
<call><name>SymbolTableSection</name><argument_list>(<argument><expr><name>StringTableSection</name> <operator>&amp;</operator><name>strTabSec</name></expr></argument>)</argument_list></call></expr>;
<expr><name>void</name> <macro><name>writeTo</name><argument_list>(<argument>uint8_t *buf</argument>)</argument_list></macro> <name>override</name></expr>;
}</block></expr>;

<expr><name>class</name> <name>SymtabShndxSection</name> <name>final</name> <operator>:</operator> <name>public</name> <name>SyntheticSection</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>SymtabShndxSection</name><argument_list>()</argument_list></call></expr>;

<expr><name>void</name> <macro><name>writeTo</name><argument_list>(<argument>uint8_t *buf</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>size_t</name> <macro><name>getSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;
<expr><name>bool</name> <macro><name>isNeeded</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;
<expr><name>void</name> <macro><name>finalizeContents</name><argument_list>()</argument_list></macro> <name>override</name></expr>;
}</block></expr>;



<expr><name>class</name> <name>GnuHashTableSection</name> <name>final</name> <operator>:</operator> <name>public</name> <name>SyntheticSection</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>GnuHashTableSection</name><argument_list>()</argument_list></call></expr>;
<expr><name>void</name> <macro><name>finalizeContents</name><argument_list>()</argument_list></macro> <name>override</name></expr>;
<expr><name>void</name> <macro><name>writeTo</name><argument_list>(<argument>uint8_t *buf</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>size_t</name> <macro><name>getSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><name>size</name></expr>;</return> }</block>



<name>void</name> <call><name>addSymbols</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>SymbolTableEntry</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>symbols</name></expr></argument>)</argument_list></call></expr>;

<expr><name>private</name><operator>:</operator>

enum <block>{ <expr><name>Shift2</name> <operator>=</operator> <literal type="number">26</literal></expr> }</block></expr>;

<expr><name>void</name> <call><name>writeBloomFilter</name><argument_list>(<argument><expr><name>uint8_t</name> <operator>*</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;
<expr><name>void</name> <call><name>writeHashTable</name><argument_list>(<argument><expr><name>uint8_t</name> <operator>*</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;

struct <expr><name>Entry</name> <block>{
<expr><name>Symbol</name> <operator>*</operator><name>sym</name></expr>;
<expr><name>size_t</name> <name>strTabOffset</name></expr>;
<expr><name>uint32_t</name> <name>hash</name></expr>;
<expr><name>uint32_t</name> <name>bucketIdx</name></expr>;
}</block></expr>;

<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>Entry</name></expr></argument>&gt;</argument_list></name> <name>symbols</name></expr>;
<expr><name>size_t</name> <name>maskWords</name></expr>;
<expr><name>size_t</name> <name>nBuckets</name> <operator>=</operator> <literal type="number">0</literal></expr>;
<expr><name>size_t</name> <name>size</name> <operator>=</operator> <literal type="number">0</literal></expr>;
}</block></expr>;

<expr><name>class</name> <name>HashTableSection</name> <name>final</name> <operator>:</operator> <name>public</name> <name>SyntheticSection</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>HashTableSection</name><argument_list>()</argument_list></call></expr>;
<expr><name>void</name> <macro><name>finalizeContents</name><argument_list>()</argument_list></macro> <name>override</name></expr>;
<expr><name>void</name> <macro><name>writeTo</name><argument_list>(<argument>uint8_t *buf</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>size_t</name> <macro><name>getSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><name>size</name></expr>;</return> }</block>

<name>private</name><operator>:</operator>
<name>size_t</name> <name>size</name> <operator>=</operator> <literal type="number">0</literal></expr>;
}</block></expr>;












<expr><name>class</name> <name>PltSection</name> <operator>:</operator> <name>public</name> <name>SyntheticSection</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>PltSection</name><argument_list>()</argument_list></call></expr>;
<expr><name>void</name> <macro><name>writeTo</name><argument_list>(<argument>uint8_t *buf</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>size_t</name> <macro><name>getSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;
<expr><name>bool</name> <macro><name>isNeeded</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;
<expr><name>void</name> <call><name>addSymbols</name><argument_list>()</argument_list></call></expr>;
<expr><name>void</name> <call><name>addEntry</name><argument_list>(<argument><expr><name>Symbol</name> <operator>&amp;</operator><name>sym</name></expr></argument>)</argument_list></call></expr>;
<expr><name>size_t</name> <macro><name>getNumEntries</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>entries</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>size_t</name> <name>headerSize</name></expr>;

<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Symbol</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>entries</name></expr>;
}</block></expr>;





<expr><name>class</name> <name>IpltSection</name> <name>final</name> <operator>:</operator> <name>public</name> <name>SyntheticSection</name> <block>{
<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Symbol</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>entries</name></expr>;

<expr><name>public</name><operator>:</operator>
<call><name>IpltSection</name><argument_list>()</argument_list></call></expr>;
<expr><name>void</name> <macro><name>writeTo</name><argument_list>(<argument>uint8_t *buf</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>size_t</name> <macro><name>getSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;
<expr><name>bool</name> <macro><name>isNeeded</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><operator>!</operator><call><name><name>entries</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>void</name> <call><name>addSymbols</name><argument_list>()</argument_list></call></expr>;
<expr><name>void</name> <call><name>addEntry</name><argument_list>(<argument><expr><name>Symbol</name> <operator>&amp;</operator><name>sym</name></expr></argument>)</argument_list></call></expr>;
}</block></expr>;

<expr><name>class</name> <name>PPC32GlinkSection</name> <operator>:</operator> <name>public</name> <name>PltSection</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>PPC32GlinkSection</name><argument_list>()</argument_list></call></expr>;
<expr><name>void</name> <macro><name>writeTo</name><argument_list>(<argument>uint8_t *buf</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>size_t</name> <macro><name>getSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Symbol</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>canonical_plts</name></expr>;
<expr><specifier>static</specifier> <name>constexpr</name> <name>size_t</name> <name>footerSize</name> <operator>=</operator> <literal type="number">64</literal></expr>;
}</block></expr>;


<expr><name>class</name> <name>IBTPltSection</name> <operator>:</operator> <name>public</name> <name>SyntheticSection</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>IBTPltSection</name><argument_list>()</argument_list></call></expr>;
<expr><name>void</name> <macro><name>writeTo</name><argument_list>(<argument>uint8_t *Buf</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>size_t</name> <macro><name>getSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;
}</block></expr>;

<expr><name>class</name> <name>GdbIndexSection</name> <name>final</name> <operator>:</operator> <name>public</name> <name>SyntheticSection</name> <block>{
<expr><name>public</name><operator>:</operator>
struct <name>AddressEntry</name> <block>{
<expr><name>InputSection</name> <operator>*</operator><name>section</name></expr>;
<expr><name>uint64_t</name> <name>lowAddress</name></expr>;
<expr><name>uint64_t</name> <name>highAddress</name></expr>;
<expr><name>uint32_t</name> <name>cuIndex</name></expr>;
}</block></expr>;

struct <expr><name>CuEntry</name> <block>{
<expr><name>uint64_t</name> <name>cuOffset</name></expr>;
<expr><name>uint64_t</name> <name>cuLength</name></expr>;
}</block></expr>;

struct <expr><name>NameAttrEntry</name> <block>{
<expr><name>llvm</name><operator>::</operator><name>CachedHashStringRef</name> <name>name</name></expr>;
<expr><name>uint32_t</name> <name>cuIndexAndAttrs</name></expr>;
}</block></expr>;

struct <expr><name>GdbChunk</name> <block>{
<expr><name>InputSection</name> <operator>*</operator><name>sec</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>AddressEntry</name></expr></argument>&gt;</argument_list></name> <name>addressAreas</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CuEntry</name></expr></argument>&gt;</argument_list></name> <name>compilationUnits</name></expr>;
}</block></expr>;

struct <expr><name>GdbSymbol</name> <block>{
<expr><name>llvm</name><operator>::</operator><name>CachedHashStringRef</name> <name>name</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>uint32_t</name></expr></argument>&gt;</argument_list></name> <name>cuVector</name></expr>;
<expr><name>uint32_t</name> <name>nameOff</name></expr>;
<expr><name>uint32_t</name> <name>cuVectorOff</name></expr>;
}</block></expr>;

<expr><call><name>GdbIndexSection</name><argument_list>()</argument_list></call></expr>;
<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>ELFT</name></expr></argument>&gt;</argument_list></name> <specifier>static</specifier> <name>GdbIndexSection</name> <operator>*</operator><call><name>create</name><argument_list>()</argument_list></call></expr>;
<expr><name>void</name> <macro><name>writeTo</name><argument_list>(<argument>uint8_t *buf</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>size_t</name> <macro><name>getSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><name>size</name></expr>;</return> }</block>
<name>bool</name> <macro><name>isNeeded</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>private</name><operator>:</operator>
struct <name>GdbIndexHeader</name> <block>{
<expr><name>llvm</name><operator>::</operator><name>support</name><operator>::</operator><name>ulittle32_t</name> <name>version</name></expr>;
<expr><name>llvm</name><operator>::</operator><name>support</name><operator>::</operator><name>ulittle32_t</name> <name>cuListOff</name></expr>;
<expr><name>llvm</name><operator>::</operator><name>support</name><operator>::</operator><name>ulittle32_t</name> <name>cuTypesOff</name></expr>;
<expr><name>llvm</name><operator>::</operator><name>support</name><operator>::</operator><name>ulittle32_t</name> <name>addressAreaOff</name></expr>;
<expr><name>llvm</name><operator>::</operator><name>support</name><operator>::</operator><name>ulittle32_t</name> <name>symtabOff</name></expr>;
<expr><name>llvm</name><operator>::</operator><name>support</name><operator>::</operator><name>ulittle32_t</name> <name>constantPoolOff</name></expr>;
}</block></expr>;

<expr><name>void</name> <call><name>initOutputSize</name><argument_list>()</argument_list></call></expr>;
<expr><name>size_t</name> <macro><name>computeSymtabSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>GdbChunk</name></expr></argument>&gt;</argument_list></name> <name>chunks</name></expr>;


<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>GdbSymbol</name></expr></argument>&gt;</argument_list></name> <name>symbols</name></expr>;

<expr><name>size_t</name> <name>size</name></expr>;
}</block></expr>;










<expr><name>class</name> <name>EhFrameHeader</name> <name>final</name> <operator>:</operator> <name>public</name> <name>SyntheticSection</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>EhFrameHeader</name><argument_list>()</argument_list></call></expr>;
<expr><name>void</name> <call><name>write</name><argument_list>()</argument_list></call></expr>;
<expr><name>void</name> <macro><name>writeTo</name><argument_list>(<argument>uint8_t *buf</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>size_t</name> <macro><name>getSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;
<expr><name>bool</name> <macro><name>isNeeded</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;
}</block></expr>;









<expr><name>class</name> <name>VersionDefinitionSection</name> <name>final</name> <operator>:</operator> <name>public</name> <name>SyntheticSection</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>VersionDefinitionSection</name><argument_list>()</argument_list></call></expr>;
<expr><name>void</name> <macro><name>finalizeContents</name><argument_list>()</argument_list></macro> <name>override</name></expr>;
<expr><name>size_t</name> <macro><name>getSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;
<expr><name>void</name> <macro><name>writeTo</name><argument_list>(<argument>uint8_t *buf</argument>)</argument_list></macro> <name>override</name></expr>;

<expr><name>private</name><operator>:</operator>
enum <block>{ <expr><name>EntrySize</name> <operator>=</operator> <literal type="number">28</literal></expr> }</block></expr>;
<expr><name>void</name> <macro><name>writeOne</name><argument_list>(<argument>uint8_t *buf</argument>, <argument>uint32_t index</argument>, <argument>StringRef name</argument>, <argument>size_t nameOff</argument>)</argument_list></macro></expr>;
<expr><name>StringRef</name> <call><name>getFileDefName</name><argument_list>()</argument_list></call></expr>;

<expr><name>unsigned</name> <name>fileDefNameOff</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name> <name>verDefNameOffs</name></expr>;
}</block></expr>;







<expr><name>class</name> <name>VersionTableSection</name> <name>final</name> <operator>:</operator> <name>public</name> <name>SyntheticSection</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>VersionTableSection</name><argument_list>()</argument_list></call></expr>;
<expr><name>void</name> <macro><name>finalizeContents</name><argument_list>()</argument_list></macro> <name>override</name></expr>;
<expr><name>size_t</name> <macro><name>getSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;
<expr><name>void</name> <macro><name>writeTo</name><argument_list>(<argument>uint8_t *buf</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>bool</name> <macro><name>isNeeded</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;
}</block></expr>;






<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>ELFT</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>VersionNeedSection</name> <name>final</name> <operator>:</operator> <name>public</name> <name>SyntheticSection</name> <block>{
<expr><name>using</name> <name>Elf_Verneed</name> <operator>=</operator> <name>typename</name> <name>ELFT</name><operator>::</operator><name>Verneed</name></expr>;
<expr><name>using</name> <name>Elf_Vernaux</name> <operator>=</operator> <name>typename</name> <name>ELFT</name><operator>::</operator><name>Vernaux</name></expr>;

struct <expr><name>Vernaux</name> <block>{
<expr><name>uint64_t</name> <name>hash</name></expr>;
<expr><name>uint32_t</name> <name>verneedIndex</name></expr>;
<expr><name>uint64_t</name> <name>nameStrTab</name></expr>;
}</block></expr>;

struct <expr><name>Verneed</name> <block>{
<expr><name>uint64_t</name> <name>nameStrTab</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>Vernaux</name></expr></argument>&gt;</argument_list></name> <name>vernauxs</name></expr>;
}</block></expr>;

<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>Verneed</name></expr></argument>&gt;</argument_list></name> <name>verneeds</name></expr>;

<expr><name>public</name><operator>:</operator>
<call><name>VersionNeedSection</name><argument_list>()</argument_list></call></expr>;
<expr><name>void</name> <macro><name>finalizeContents</name><argument_list>()</argument_list></macro> <name>override</name></expr>;
<expr><name>void</name> <macro><name>writeTo</name><argument_list>(<argument>uint8_t *buf</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>size_t</name> <macro><name>getSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;
<expr><name>bool</name> <macro><name>isNeeded</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;
}</block></expr>;





<expr><name>class</name> <name>MergeSyntheticSection</name> <operator>:</operator> <name>public</name> <name>SyntheticSection</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>void</name> <call><name>addSection</name><argument_list>(<argument><expr><name>MergeInputSection</name> <operator>*</operator><name>ms</name></expr></argument>)</argument_list></call></expr>;
<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>MergeInputSection</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>sections</name></expr>;

<expr><name>protected</name><operator>:</operator>
<macro><name>MergeSyntheticSection</name><argument_list>(<argument>StringRef name</argument>, <argument>uint32_t type</argument>, <argument>uint64_t flags</argument>,
<argument>uint32_t alignment</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>SyntheticSection</name><argument_list>(<argument>flags</argument>, <argument>type</argument>, <argument>alignment</argument>, <argument>name</argument>)</argument_list></macro> <block>{}</block></expr>
}</block></expr>;

<expr><name>class</name> <name>MergeTailSection</name> <name>final</name> <operator>:</operator> <name>public</name> <name>MergeSyntheticSection</name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>MergeTailSection</name><argument_list>(<argument>StringRef name</argument>, <argument>uint32_t type</argument>, <argument>uint64_t flags</argument>,
<argument>uint32_t alignment</argument>)</argument_list></macro></expr>;

<expr><name>size_t</name> <macro><name>getSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;
<expr><name>void</name> <macro><name>writeTo</name><argument_list>(<argument>uint8_t *buf</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>void</name> <macro><name>finalizeContents</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>private</name><operator>:</operator>
<name>llvm</name><operator>::</operator><name>StringTableBuilder</name> <name>builder</name></expr>;
}</block></expr>;

<expr><name>class</name> <name>MergeNoTailSection</name> <name>final</name> <operator>:</operator> <name>public</name> <name>MergeSyntheticSection</name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>MergeNoTailSection</name><argument_list>(<argument>StringRef name</argument>, <argument>uint32_t type</argument>, <argument>uint64_t flags</argument>,
<argument>uint32_t alignment</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>MergeSyntheticSection</name><argument_list>(<argument>name</argument>, <argument>type</argument>, <argument>flags</argument>, <argument>alignment</argument>)</argument_list></macro> <block>{}</block>

<name>size_t</name> <macro><name>getSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><name>size</name></expr>;</return> }</block>
<name>void</name> <macro><name>writeTo</name><argument_list>(<argument>uint8_t *buf</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>void</name> <macro><name>finalizeContents</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>private</name><operator>:</operator>





<name>size_t</name> <macro><name>getShardId</name><argument_list>(<argument>uint32_t hash</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>hash</name> <operator>&gt;&gt;</operator> <literal type="number">31</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>hash</name> <operator>&gt;&gt;</operator> <operator>(</operator><literal type="number">31</literal> <operator>-</operator> <name>llvm</name><operator>::</operator><call><name>countTrailingZeros</name><argument_list>(<argument><expr><name>numShards</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
}</block>


<name>size_t</name> <name>size</name></expr>;


<expr><name>constexpr</name> <specifier>static</specifier> <name>size_t</name> <name>numShards</name> <operator>=</operator> <literal type="number">32</literal></expr>;
<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>StringTableBuilder</name></expr></argument>&gt;</argument_list></name> <name>shards</name></expr>;
<expr><name>size_t</name> <name><name>shardOffsets</name><index>[<expr><name>numShards</name></expr>]</index></name></expr>;
}</block></expr>;


<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>ELFT</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>MipsAbiFlagsSection</name> <name>final</name> <operator>:</operator> <name>public</name> <name>SyntheticSection</name> <block>{
<expr><name>using</name> <name>Elf_Mips_ABIFlags</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name>object</name><operator>::</operator><name><name>Elf_Mips_ABIFlags</name><argument_list type="generic">&lt;<argument><expr><name>ELFT</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>public</name><operator>:</operator>
<specifier>static</specifier> <name>MipsAbiFlagsSection</name> <operator>*</operator><call><name>create</name><argument_list>()</argument_list></call></expr>;

<macro><name>MipsAbiFlagsSection</name><argument_list>(<argument>Elf_Mips_ABIFlags flags</argument>)</argument_list></macro>;
<expr><name>size_t</name> <macro><name>getSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><sizeof>sizeof<argument_list>(<argument><expr><name>Elf_Mips_ABIFlags</name></expr></argument>)</argument_list></sizeof></expr>;</return> }</block>
<name>void</name> <macro><name>writeTo</name><argument_list>(<argument>uint8_t *buf</argument>)</argument_list></macro> <name>override</name></expr>;

<expr><name>private</name><operator>:</operator>
<name>Elf_Mips_ABIFlags</name> <name>flags</name></expr>;
}</block></expr>;


<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>ELFT</name></expr></argument>&gt;</argument_list></name> <name>class</name> <name>MipsOptionsSection</name> <name>final</name> <operator>:</operator> <name>public</name> <name>SyntheticSection</name> <block>{
<expr><name>using</name> <name>Elf_Mips_Options</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name>object</name><operator>::</operator><name><name>Elf_Mips_Options</name><argument_list type="generic">&lt;<argument><expr><name>ELFT</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>Elf_Mips_RegInfo</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name>object</name><operator>::</operator><name><name>Elf_Mips_RegInfo</name><argument_list type="generic">&lt;<argument><expr><name>ELFT</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>public</name><operator>:</operator>
<specifier>static</specifier> <name>MipsOptionsSection</name> <operator>*</operator><call><name>create</name><argument_list>()</argument_list></call></expr>;

<macro><name>MipsOptionsSection</name><argument_list>(<argument>Elf_Mips_RegInfo reginfo</argument>)</argument_list></macro>;
<expr><name>void</name> <macro><name>writeTo</name><argument_list>(<argument>uint8_t *buf</argument>)</argument_list></macro> <name>override</name></expr>;

<expr><name>size_t</name> <macro><name>getSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><sizeof>sizeof<argument_list>(<argument><expr><name>Elf_Mips_Options</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Elf_Mips_RegInfo</name></expr></argument>)</argument_list></sizeof></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>Elf_Mips_RegInfo</name> <name>reginfo</name></expr>;
}</block></expr>;


<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>ELFT</name></expr></argument>&gt;</argument_list></name> <name>class</name> <name>MipsReginfoSection</name> <name>final</name> <operator>:</operator> <name>public</name> <name>SyntheticSection</name> <block>{
<expr><name>using</name> <name>Elf_Mips_RegInfo</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name>object</name><operator>::</operator><name><name>Elf_Mips_RegInfo</name><argument_list type="generic">&lt;<argument><expr><name>ELFT</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>public</name><operator>:</operator>
<specifier>static</specifier> <name>MipsReginfoSection</name> <operator>*</operator><call><name>create</name><argument_list>()</argument_list></call></expr>;

<macro><name>MipsReginfoSection</name><argument_list>(<argument>Elf_Mips_RegInfo reginfo</argument>)</argument_list></macro>;
<expr><name>size_t</name> <macro><name>getSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><sizeof>sizeof<argument_list>(<argument><expr><name>Elf_Mips_RegInfo</name></expr></argument>)</argument_list></sizeof></expr>;</return> }</block>
<name>void</name> <macro><name>writeTo</name><argument_list>(<argument>uint8_t *buf</argument>)</argument_list></macro> <name>override</name></expr>;

<expr><name>private</name><operator>:</operator>
<name>Elf_Mips_RegInfo</name> <name>reginfo</name></expr>;
}</block></expr>;





<expr><name>class</name> <name>MipsRldMapSection</name> <operator>:</operator> <name>public</name> <name>SyntheticSection</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>MipsRldMapSection</name><argument_list>()</argument_list></call></expr>;
<expr><name>size_t</name> <macro><name>getSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><name><name>config</name><operator>-&gt;</operator><name>wordsize</name></name></expr>;</return> }</block>
<name>void</name> <macro><name>writeTo</name><argument_list>(<argument>uint8_t *buf</argument>)</argument_list></macro> <name>override</name> <block>{}</block>
}</expr>;



































<expr><name>class</name> <name>ARMExidxSyntheticSection</name> <operator>:</operator> <name>public</name> <name>SyntheticSection</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>ARMExidxSyntheticSection</name><argument_list>()</argument_list></call></expr>;



<expr><name>bool</name> <call><name>addSection</name><argument_list>(<argument><expr><name>InputSection</name> <operator>*</operator><name>isec</name></expr></argument>)</argument_list></call></expr>;

<expr><name>size_t</name> <macro><name>getSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><name>size</name></expr>;</return> }</block>
<name>void</name> <macro><name>writeTo</name><argument_list>(<argument>uint8_t *buf</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>bool</name> <macro><name>isNeeded</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>void</name> <macro><name>finalizeContents</name><argument_list>()</argument_list></macro> <name>override</name></expr>;
<expr><name>InputSection</name> <operator>*</operator><macro><name>getLinkOrderDep</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><specifier>static</specifier> <name>bool</name> <call><name>classof</name><argument_list>(<argument><expr><specifier>const</specifier> <name>SectionBase</name> <operator>*</operator><name>d</name></expr></argument>)</argument_list></call></expr>;



<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>InputSection</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>exidxSections</name></expr>;

<expr><name>private</name><operator>:</operator>
<name>size_t</name> <name>size</name> <operator>=</operator> <literal type="number">0</literal></expr>;





<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>InputSection</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>executableSections</name></expr>;





<expr><name>InputSection</name> <operator>*</operator><name>sentinel</name> <operator>=</operator> <name>nullptr</name></expr>;
}</block></expr>;



<expr><name>class</name> <name>ThunkSection</name> <operator>:</operator> <name>public</name> <name>SyntheticSection</name> <block>{
<expr><name>public</name><operator>:</operator>

<macro><name>ThunkSection</name><argument_list>(<argument>OutputSection *os</argument>, <argument>uint64_t off</argument>)</argument_list></macro></expr>;





<expr><name>void</name> <call><name>addThunk</name><argument_list>(<argument><expr><name>Thunk</name> <operator>*</operator><name>t</name></expr></argument>)</argument_list></call></expr>;
<expr><name>size_t</name> <macro><name>getSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;
<expr><name>void</name> <macro><name>writeTo</name><argument_list>(<argument>uint8_t *buf</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>InputSection</name> <operator>*</operator><macro><name>getTargetInputSection</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <call><name>assignOffsets</name><argument_list>()</argument_list></call></expr>;



<expr><name>bool</name> <name>roundUpSizeForErrata</name> <operator>=</operator> <name>false</name></expr>;

<expr><name>private</name><operator>:</operator>
<name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>Thunk</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>thunks</name></expr>;
<expr><name>size_t</name> <name>size</name> <operator>=</operator> <literal type="number">0</literal></expr>;
}</block></expr>;



<expr><name>class</name> <name>PPC32Got2Section</name> <name>final</name> <operator>:</operator> <name>public</name> <name>SyntheticSection</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>PPC32Got2Section</name><argument_list>()</argument_list></call></expr>;
<expr><name>size_t</name> <macro><name>getSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><literal type="number">0</literal></expr>;</return> }</block>
<name>bool</name> <macro><name>isNeeded</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;
<expr><name>void</name> <macro><name>finalizeContents</name><argument_list>()</argument_list></macro> <name>override</name></expr>;
<expr><name>void</name> <macro><name>writeTo</name><argument_list>(<argument>uint8_t *buf</argument>)</argument_list></macro> <name>override</name> <block>{}</block></expr>
}</block></expr>;






<expr><name>class</name> <name>PPC64LongBranchTargetSection</name> <name>final</name> <operator>:</operator> <name>public</name> <name>SyntheticSection</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>PPC64LongBranchTargetSection</name><argument_list>()</argument_list></call></expr>;
<expr><name>uint64_t</name> <macro><name>getEntryVA</name><argument_list>(<argument>const Symbol *sym</argument>, <argument>int64_t addend</argument>)</argument_list></macro></expr>;
<expr><name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>uint32_t</name></expr></argument>&gt;</argument_list></name> <macro><name>addEntry</name><argument_list>(<argument>const Symbol *sym</argument>, <argument>int64_t addend</argument>)</argument_list></macro></expr>;
<expr><name>size_t</name> <macro><name>getSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;
<expr><name>void</name> <macro><name>writeTo</name><argument_list>(<argument>uint8_t *buf</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>bool</name> <macro><name>isNeeded</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;
<expr><name>void</name> <macro><name>finalizeContents</name><argument_list>()</argument_list></macro> <name>override</name> <block>{ <expr><name>finalized</name> <operator>=</operator> <name>true</name></expr>; }</block>

<name>private</name><operator>:</operator>
<name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Symbol</name> <operator>*</operator></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <name>entries</name></expr>;
<expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Symbol</name> <operator>*</operator></expr></argument>, <argument><expr><name>int64_t</name></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><name>uint32_t</name></expr></argument>&gt;</argument_list></name> <name>entry_index</name></expr>;
<expr><name>bool</name> <name>finalized</name> <operator>=</operator> <name>false</name></expr>;
}</block></expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>ELFT</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>PartitionElfHeaderSection</name> <operator>:</operator> <name>public</name> <name>SyntheticSection</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>PartitionElfHeaderSection</name><argument_list>()</argument_list></call></expr>;
<expr><name>size_t</name> <macro><name>getSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;
<expr><name>void</name> <macro><name>writeTo</name><argument_list>(<argument>uint8_t *buf</argument>)</argument_list></macro> <name>override</name></expr>;
}</block></expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>ELFT</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>PartitionProgramHeadersSection</name> <operator>:</operator> <name>public</name> <name>SyntheticSection</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>PartitionProgramHeadersSection</name><argument_list>()</argument_list></call></expr>;
<expr><name>size_t</name> <macro><name>getSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;
<expr><name>void</name> <macro><name>writeTo</name><argument_list>(<argument>uint8_t *buf</argument>)</argument_list></macro> <name>override</name></expr>;
}</block></expr>;

<expr><name>class</name> <name>PartitionIndexSection</name> <operator>:</operator> <name>public</name> <name>SyntheticSection</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>PartitionIndexSection</name><argument_list>()</argument_list></call></expr>;
<expr><name>size_t</name> <macro><name>getSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;
<expr><name>void</name> <macro><name>finalizeContents</name><argument_list>()</argument_list></macro> <name>override</name></expr>;
<expr><name>void</name> <macro><name>writeTo</name><argument_list>(<argument>uint8_t *buf</argument>)</argument_list></macro> <name>override</name></expr>;
}</block></expr>;

<expr><name>InputSection</name> <operator>*</operator><call><name>createInterpSection</name><argument_list>()</argument_list></call></expr>;
<expr><name>MergeInputSection</name> <operator>*</operator><call><name>createCommentSection</name><argument_list>()</argument_list></call></expr>;
<expr><name>MergeSyntheticSection</name> <operator>*</operator><macro><name>createMergeSynthetic</name><argument_list>(<argument>StringRef name</argument>, <argument>uint32_t type</argument>,
<argument>uint64_t flags</argument>, <argument>uint32_t alignment</argument>)</argument_list></macro></expr>;
<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>ELFT</name></expr></argument>&gt;</argument_list></name> <name>void</name> <call><name>splitSections</name><argument_list>()</argument_list></call></expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>ELFT</name></expr></argument>&gt;</argument_list></name> <name>void</name> <call><name>writeEhdr</name><argument_list>(<argument><expr><name>uint8_t</name> <operator>*</operator><name>buf</name></expr></argument>, <argument><expr><name>Partition</name> <operator>&amp;</operator><name>part</name></expr></argument>)</argument_list></call></expr>;
<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>ELFT</name></expr></argument>&gt;</argument_list></name> <name>void</name> <call><name>writePhdrs</name><argument_list>(<argument><expr><name>uint8_t</name> <operator>*</operator><name>buf</name></expr></argument>, <argument><expr><name>Partition</name> <operator>&amp;</operator><name>part</name></expr></argument>)</argument_list></call></expr>;

<expr><name>Defined</name> <operator>*</operator><macro><name>addSyntheticLocal</name><argument_list>(<argument>StringRef name</argument>, <argument>uint8_t type</argument>, <argument>uint64_t value</argument>,
<argument>uint64_t size</argument>, <argument>InputSectionBase &amp;section</argument>)</argument_list></macro></expr>;

<expr><name>void</name> <call><name>addVerneed</name><argument_list>(<argument><expr><name>Symbol</name> <operator>*</operator><name>ss</name></expr></argument>)</argument_list></call></expr>;


struct <expr><name>Partition</name> <block>{
<expr><name>StringRef</name> <name>name</name></expr>;
<expr><name>uint64_t</name> <name>nameStrTab</name></expr>;

<expr><name>SyntheticSection</name> <operator>*</operator><name>elfHeader</name></expr>;
<expr><name>SyntheticSection</name> <operator>*</operator><name>programHeaders</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>PhdrEntry</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>phdrs</name></expr>;

<expr><name>ARMExidxSyntheticSection</name> <operator>*</operator><name>armExidx</name></expr>;
<expr><name>BuildIdSection</name> <operator>*</operator><name>buildId</name></expr>;
<expr><name>SyntheticSection</name> <operator>*</operator><name>dynamic</name></expr>;
<expr><name>StringTableSection</name> <operator>*</operator><name>dynStrTab</name></expr>;
<expr><name>SymbolTableBaseSection</name> <operator>*</operator><name>dynSymTab</name></expr>;
<expr><name>EhFrameHeader</name> <operator>*</operator><name>ehFrameHdr</name></expr>;
<expr><name>EhFrameSection</name> <operator>*</operator><name>ehFrame</name></expr>;
<expr><name>GnuHashTableSection</name> <operator>*</operator><name>gnuHashTab</name></expr>;
<expr><name>HashTableSection</name> <operator>*</operator><name>hashTab</name></expr>;
<expr><name>RelocationBaseSection</name> <operator>*</operator><name>relaDyn</name></expr>;
<expr><name>RelrBaseSection</name> <operator>*</operator><name>relrDyn</name></expr>;
<expr><name>VersionDefinitionSection</name> <operator>*</operator><name>verDef</name></expr>;
<expr><name>SyntheticSection</name> <operator>*</operator><name>verNeed</name></expr>;
<expr><name>VersionTableSection</name> <operator>*</operator><name>verSym</name></expr>;

<expr><name>unsigned</name> <macro><name>getNumber</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>this</name> <operator>-</operator> <operator>&amp;</operator><name><name>partitions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr>;</return> }</block>
}</expr>;

<expr><specifier>extern</specifier> <name>Partition</name> <operator>*</operator><name>mainPart</name></expr>;

<expr><specifier>inline</specifier> <name>Partition</name> <operator>&amp;</operator><name>SectionBase</name><operator>::</operator><macro><name>getPartition</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isLive</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name><name>partitions</name><index>[<expr><name>partition</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</return>
}</block>



struct <name>InStruct</name> <block>{
<expr><name>InputSection</name> <operator>*</operator><name>attributes</name></expr>;
<expr><name>BssSection</name> <operator>*</operator><name>bss</name></expr>;
<expr><name>BssSection</name> <operator>*</operator><name>bssRelRo</name></expr>;
<expr><name>GotSection</name> <operator>*</operator><name>got</name></expr>;
<expr><name>GotPltSection</name> <operator>*</operator><name>gotPlt</name></expr>;
<expr><name>IgotPltSection</name> <operator>*</operator><name>igotPlt</name></expr>;
<expr><name>PPC64LongBranchTargetSection</name> <operator>*</operator><name>ppc64LongBranchTarget</name></expr>;
<expr><name>MipsGotSection</name> <operator>*</operator><name>mipsGot</name></expr>;
<expr><name>MipsRldMapSection</name> <operator>*</operator><name>mipsRldMap</name></expr>;
<expr><name>SyntheticSection</name> <operator>*</operator><name>partEnd</name></expr>;
<expr><name>SyntheticSection</name> <operator>*</operator><name>partIndex</name></expr>;
<expr><name>PltSection</name> <operator>*</operator><name>plt</name></expr>;
<expr><name>IpltSection</name> <operator>*</operator><name>iplt</name></expr>;
<expr><name>PPC32Got2Section</name> <operator>*</operator><name>ppc32Got2</name></expr>;
<expr><name>IBTPltSection</name> <operator>*</operator><name>ibtPlt</name></expr>;
<expr><name>RelocationBaseSection</name> <operator>*</operator><name>relaPlt</name></expr>;
<expr><name>RelocationBaseSection</name> <operator>*</operator><name>relaIplt</name></expr>;
<expr><name>StringTableSection</name> <operator>*</operator><name>shStrTab</name></expr>;
<expr><name>StringTableSection</name> <operator>*</operator><name>strTab</name></expr>;
<expr><name>SymbolTableBaseSection</name> <operator>*</operator><name>symTab</name></expr>;
<expr><name>SymtabShndxSection</name> <operator>*</operator><name>symTabShndx</name></expr>;
}</block></expr>;

<expr><specifier>extern</specifier> <name>InStruct</name> <name>in</name></expr>;

}</block></expr>
}</block></expr></block></expr></block></expr></range></decl></decl_stmt></block_content></block></decl></decl_stmt></block_content></block></decl></decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
