<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/compiler-rt/lib/sanitizer_common/sanitizer_common.h">













<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SANITIZER_COMMON_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SANITIZER_COMMON_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sanitizer_flags.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sanitizer_interface_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sanitizer_internal_defs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sanitizer_libc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sanitizer_list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sanitizer_mutex.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__clang__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<extern>extern <literal type="string">"C"</literal> <function_decl><type><name>void</name></type> <name>_ReadWriteBarrier</name><parameter_list>()</parameter_list>;</function_decl></extern>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>intrinsic</name><name>(</name><name>_ReadWriteBarrier</name><name>)</name></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>namespace</name></type> <name>__sanitizer</name> <block>{<block_content>

<struct_decl>struct <name>AddressInfo</name>;</struct_decl>
<struct_decl>struct <name>BufferedStackTrace</name>;</struct_decl>
<struct_decl>struct <name>SignalContext</name>;</struct_decl>
<struct_decl>struct <name>StackTrace</name>;</struct_decl>


<decl_stmt><decl><type><specifier>const</specifier> <name>uptr</name></type> <name>kWordSize</name> <init>= <expr><name>SANITIZER_WORDSIZE</name> <operator>/</operator> <literal type="number">8</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uptr</name></type> <name>kWordSizeInBits</name> <init>= <expr><literal type="number">8</literal> <operator>*</operator> <name>kWordSize</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>uptr</name></type> <name>kCacheLineSize</name> <init>= <expr><name>SANITIZER_CACHE_LINE_SIZE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>uptr</name></type> <name>kMaxPathLength</name> <init>= <expr><literal type="number">4096</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>uptr</name></type> <name>kMaxThreadStackSize</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">30</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>uptr</name></type> <name>kErrorMessageBufferSize</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">16</literal></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><specifier>const</specifier> <name>u64</name></type> <name>kExternalPCBit</name> <init>= <expr><literal type="number">1ULL</literal> <operator>&lt;&lt;</operator> <literal type="number">60</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>SanitizerToolName</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>extern</specifier> <name>atomic_uint32_t</name></type> <name>current_verbosity</name></decl>;</decl_stmt>
<function><type><specifier>inline</specifier> <name>void</name></type> <name>SetVerbosity</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>verbosity</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>atomic_store</name><argument_list>(<argument><expr><operator>&amp;</operator><name>current_verbosity</name></expr></argument>, <argument><expr><name>verbosity</name></expr></argument>, <argument><expr><name>memory_order_relaxed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>inline</specifier> <name>int</name></type> <name>Verbosity</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name>atomic_load</name><argument_list>(<argument><expr><operator>&amp;</operator><name>current_verbosity</name></expr></argument>, <argument><expr><name>memory_order_relaxed</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SANITIZER_ANDROID</name></expr></cpp:if>
<function><type><specifier>inline</specifier> <name>uptr</name></type> <name>GetPageSize</name><parameter_list>()</parameter_list> <block>{<block_content>

<return>return <expr><literal type="number">4096</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>inline</specifier> <name>uptr</name></type> <name>GetPageSizeCached</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><literal type="number">4096</literal></expr>;</return>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function_decl><type><name>uptr</name></type> <name>GetPageSize</name><parameter_list>()</parameter_list>;</function_decl>
<decl_stmt><decl><type><specifier>extern</specifier> <name>uptr</name></type> <name>PageSizeCached</name></decl>;</decl_stmt>
<function><type><specifier>inline</specifier> <name>uptr</name></type> <name>GetPageSizeCached</name><parameter_list>()</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>PageSizeCached</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>PageSizeCached</name> <operator>=</operator> <call><name>GetPageSize</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>PageSizeCached</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><name>uptr</name></type> <name>GetMmapGranularity</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>uptr</name></type> <name>GetMaxVirtualAddress</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>uptr</name></type> <name>GetMaxUserVirtualAddress</name><parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><name>tid_t</name></type> <name>GetTid</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>TgKill</name><parameter_list>(<parameter><decl><type><name>pid_t</name></type> <name>pid</name></decl></parameter>, <parameter><decl><type><name>tid_t</name></type> <name>tid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sig</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>uptr</name></type> <name>GetThreadSelf</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>GetThreadStackTopAndBottom</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>at_initialization</name></decl></parameter>, <parameter><decl><type><name>uptr</name> <modifier>*</modifier></type><name>stack_top</name></decl></parameter>,
<parameter><decl><type><name>uptr</name> <modifier>*</modifier></type><name>stack_bottom</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>void</name></type> <name>GetThreadStackAndTls</name><argument_list>(<argument><expr><name>bool</name> main</expr></argument>, <argument><expr><name>uptr</name> <operator>*</operator><name>stk_addr</name></expr></argument>, <argument><expr><name>uptr</name> <operator>*</operator><name>stk_size</name></expr></argument>,
<argument><expr><name>uptr</name> <operator>*</operator><name>tls_addr</name></expr></argument>, <argument><expr><name>uptr</name> <operator>*</operator><name>tls_size</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<function_decl><type><name>void</name> <modifier>*</modifier></type><name>MmapOrDie</name><parameter_list>(<parameter><decl><type><name>uptr</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mem_type</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>raw_report</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function><type><specifier>inline</specifier> <name>void</name> <modifier>*</modifier></type><name>MmapOrDieQuietly</name><parameter_list>(<parameter><decl><type><name>uptr</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mem_type</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>MmapOrDie</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name>mem_type</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function_decl><type><name>void</name></type> <name>UnmapOrDie</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><name>uptr</name></type> <name>size</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name> <modifier>*</modifier></type><name>MmapOrDieOnFatalError</name><parameter_list>(<parameter><decl><type><name>uptr</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mem_type</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>bool</name></type> <name>MmapFixedNoReserve</name><argument_list>(<argument><expr><name>uptr</name> <name>fixed_addr</name></expr></argument>, <argument><expr><name>uptr</name> <name>size</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>name</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list>
<name>WARN_UNUSED_RESULT</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>MmapFixedSuperNoReserve</name><argument_list>(<argument><expr><name>uptr</name> <name>fixed_addr</name></expr></argument>, <argument><expr><name>uptr</name> <name>size</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>name</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list> <name>WARN_UNUSED_RESULT</name></decl>;</decl_stmt>
<function_decl><type><name>void</name> <modifier>*</modifier></type><name>MmapNoReserveOrDie</name><parameter_list>(<parameter><decl><type><name>uptr</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mem_type</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name> <modifier>*</modifier></type><name>MmapFixedOrDie</name><parameter_list>(<parameter><decl><type><name>uptr</name></type> <name>fixed_addr</name></decl></parameter>, <parameter><decl><type><name>uptr</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name> <modifier>*</modifier></type><name>MmapFixedOrDieOnFatalError</name><parameter_list>(<parameter><decl><type><name>uptr</name></type> <name>fixed_addr</name></decl></parameter>, <parameter><decl><type><name>uptr</name></type> <name>size</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name> <modifier>*</modifier></type><name>MmapFixedNoAccess</name><parameter_list>(<parameter><decl><type><name>uptr</name></type> <name>fixed_addr</name></decl></parameter>, <parameter><decl><type><name>uptr</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name> <modifier>*</modifier></type><name>MmapNoAccess</name><parameter_list>(<parameter><decl><type><name>uptr</name></type> <name>size</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name> <modifier>*</modifier></type><name>MmapAlignedOrDieOnFatalError</name><parameter_list>(<parameter><decl><type><name>uptr</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>uptr</name></type> <name>alignment</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mem_type</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>bool</name></type> <name>MprotectNoAccess</name><parameter_list>(<parameter><decl><type><name>uptr</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>uptr</name></type> <name>size</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>MprotectReadOnly</name><parameter_list>(<parameter><decl><type><name>uptr</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>uptr</name></type> <name>size</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>MprotectMallocZones</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>prot</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SANITIZER_LINUX</name></expr></cpp:if>

<function_decl><type><name>void</name></type> <name>UnmapFromTo</name><parameter_list>(<parameter><decl><type><name>uptr</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>uptr</name></type> <name>to</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>







<function_decl><type><name>uptr</name></type> <name>MapDynamicShadow</name><parameter_list>(<parameter><decl><type><name>uptr</name></type> <name>shadow_size_bytes</name></decl></parameter>, <parameter><decl><type><name>uptr</name></type> <name>shadow_scale</name></decl></parameter>,
<parameter><decl><type><name>uptr</name></type> <name>min_shadow_base_alignment</name></decl></parameter>, <parameter><decl><type><name>uptr</name> <modifier>&amp;</modifier></type><name>high_mem_end</name></decl></parameter>)</parameter_list>;</function_decl>







<function_decl><type><name>uptr</name></type> <name>MapDynamicShadowAndAliases</name><parameter_list>(<parameter><decl><type><name>uptr</name></type> <name>shadow_size</name></decl></parameter>, <parameter><decl><type><name>uptr</name></type> <name>alias_size</name></decl></parameter>,
<parameter><decl><type><name>uptr</name></type> <name>num_aliases</name></decl></parameter>, <parameter><decl><type><name>uptr</name></type> <name>ring_buffer_size</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>ReserveShadowMemoryRange</name><parameter_list>(<parameter><decl><type><name>uptr</name></type> <name>beg</name></decl></parameter>, <parameter><decl><type><name>uptr</name></type> <name>end</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>madvise_shadow</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>void</name></type> <name>ProtectGap</name><parameter_list>(<parameter><decl><type><name>uptr</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>uptr</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>uptr</name></type> <name>zero_base_shadow_start</name></decl></parameter>,
<parameter><decl><type><name>uptr</name></type> <name>zero_base_max_shadow_start</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>uptr</name></type> <name>FindAvailableMemoryRange</name><parameter_list>(<parameter><decl><type><name>uptr</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>uptr</name></type> <name>alignment</name></decl></parameter>, <parameter><decl><type><name>uptr</name></type> <name>left_padding</name></decl></parameter>,
<parameter><decl><type><name>uptr</name> <modifier>*</modifier></type><name>largest_gap_found</name></decl></parameter>, <parameter><decl><type><name>uptr</name> <modifier>*</modifier></type><name>max_occupied_addr</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>bool</name></type> <name>MemoryRangeIsAvailable</name><parameter_list>(<parameter><decl><type><name>uptr</name></type> <name>range_start</name></decl></parameter>, <parameter><decl><type><name>uptr</name></type> <name>range_end</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>ReleaseMemoryPagesToOS</name><parameter_list>(<parameter><decl><type><name>uptr</name></type> <name>beg</name></decl></parameter>, <parameter><decl><type><name>uptr</name></type> <name>end</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>IncreaseTotalMmap</name><parameter_list>(<parameter><decl><type><name>uptr</name></type> <name>size</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>DecreaseTotalMmap</name><parameter_list>(<parameter><decl><type><name>uptr</name></type> <name>size</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>uptr</name></type> <name>GetRSS</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>SetShadowRegionHugePageMode</name><parameter_list>(<parameter><decl><type><name>uptr</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>uptr</name></type> <name>length</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>DontDumpShadowMemory</name><parameter_list>(<parameter><decl><type><name>uptr</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>uptr</name></type> <name>length</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>CheckVMASize</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>RunMallocHooks</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>uptr</name></type> <name>size</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>RunFreeHooks</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>class</name></type> <name>ReservedAddressRange</name> <block>{<block_content>
<label><name>public</name>:</label>
<function_decl><type><name>uptr</name></type> <name>Init</name><parameter_list>(<parameter><decl><type><name>uptr</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>, <parameter><decl><type><name>uptr</name></type> <name>fixed_addr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>uptr</name></type> <name>InitAligned</name><parameter_list>(<parameter><decl><type><name>uptr</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>uptr</name></type> <name>align</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>uptr</name></type> <name>Map</name><parameter_list>(<parameter><decl><type><name>uptr</name></type> <name>fixed_addr</name></decl></parameter>, <parameter><decl><type><name>uptr</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>uptr</name></type> <name>MapOrDie</name><parameter_list>(<parameter><decl><type><name>uptr</name></type> <name>fixed_addr</name></decl></parameter>, <parameter><decl><type><name>uptr</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>Unmap</name><parameter_list>(<parameter><decl><type><name>uptr</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>uptr</name></type> <name>size</name></decl></parameter>)</parameter_list>;</function_decl>
<expr_stmt><expr><name>void</name> <operator>*</operator><macro><name>base</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>base_</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>uptr</name> <macro><name>size</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>size_</name></expr>;</return> }</block></expr></expr_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>base_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uptr</name></type> <name>size_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>name_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uptr</name></type> <name>os_handle_</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>fill_profile_f</name>)<parameter_list>(<parameter><decl><type><name>uptr</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>uptr</name></type> <name>rss</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>file</name></decl></parameter>,
<parameter><decl><type><name>uptr</name> <modifier>*</modifier></type><name>stats</name></decl></parameter>, <parameter><decl><type><name>uptr</name></type> <name>stats_size</name></decl></parameter>)</parameter_list>;</function_decl></typedef>




<function_decl><type><name>void</name></type> <name>GetMemoryProfile</name><parameter_list>(<parameter><decl><type><name>fill_profile_f</name></type> <name>cb</name></decl></parameter>, <parameter><decl><type><name>uptr</name> <modifier>*</modifier></type><name>stats</name></decl></parameter>, <parameter><decl><type><name>uptr</name></type> <name>stats_size</name></decl></parameter>)</parameter_list>;</function_decl>




<decl_stmt><decl><type><name>class</name></type> <name>LowLevelAllocator</name> <block>{<block_content>
<label><name>public</name>:</label>

<function_decl><type><name>void</name> <modifier>*</modifier></type><name>Allocate</name><parameter_list>(<parameter><decl><type><name>uptr</name></type> <name>size</name></decl></parameter>)</parameter_list>;</function_decl>
<label><name>private</name>:</label>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>allocated_end_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>allocated_current_</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<function_decl><type><name>void</name></type> <name>SetLowLevelAllocateMinAlignment</name><parameter_list>(<parameter><decl><type><name>uptr</name></type> <name>alignment</name></decl></parameter>)</parameter_list>;</function_decl>
<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>LowLevelAllocateCallback</name>)<parameter_list>(<parameter><decl><type><name>uptr</name></type> <name>ptr</name></decl></parameter>, <parameter><decl><type><name>uptr</name></type> <name>size</name></decl></parameter>)</parameter_list>;</function_decl></typedef>


<function_decl><type><name>void</name></type> <name>SetLowLevelAllocateCallback</name><parameter_list>(<parameter><decl><type><name>LowLevelAllocateCallback</name></type> <name>callback</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>CatastrophicErrorWrite</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>uptr</name></type> <name>length</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>RawWrite</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>ColorizeReports</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>RemoveANSIEscapeSequencesFromString</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>Printf</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>Report</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>SetPrintfAndReportCallback</name><parameter_list>(<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>callback</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VReport</name><parameter_list>(<parameter><type><name>level</name></type></parameter>, <parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if ((uptr)Verbosity() &gt;= (level)) Report(__VA_ARGS__); } while (0)</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VPrintf</name><parameter_list>(<parameter><type><name>level</name></type></parameter>, <parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if ((uptr)Verbosity() &gt;= (level)) Printf(__VA_ARGS__); } while (0)</cpp:value></cpp:define>





<decl_stmt><decl><type><name>class</name></type> <name>ScopedErrorReportLock</name> <block>{<block_content>
<label><name>public</name>:</label>
<macro><name>ScopedErrorReportLock</name><argument_list>()</argument_list></macro> <macro><name>ACQUIRE</name><argument_list>(<argument>mutex_</argument>)</argument_list></macro> <block>{<block_content> <expr_stmt><expr><call><name>Lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt> </block_content>}</block>
<expr_stmt><expr><operator>~</operator><macro><name>ScopedErrorReportLock</name><argument_list>()</argument_list></macro> <macro><name>RELEASE</name><argument_list>(<argument>mutex_</argument>)</argument_list></macro> <block>{ <expr><call><name>Unlock</name><argument_list>()</argument_list></call></expr>; }</block>

<specifier>static</specifier> <name>void</name> <macro><name>Lock</name><argument_list>()</argument_list></macro> <call><name>ACQUIRE</name><argument_list>(<argument><expr><name>mutex_</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>Unlock</name><parameter_list>()</parameter_list> RELEASE<parameter_list>(<parameter><decl><type><name>mutex_</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CheckLocked</name><parameter_list>()</parameter_list> CHECK_LOCKED<parameter_list>(<parameter><decl><type><name>mutex_</name></type></decl></parameter>)</parameter_list>;</function_decl>

<label><name>private</name>:</label>
<decl_stmt><decl><type><specifier>static</specifier> <name>atomic_uintptr_t</name></type> <name>reporting_thread_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>StaticSpinMutex</name></type> <name>mutex_</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><specifier>extern</specifier> <name>uptr</name></type> <name>stoptheworld_tracer_pid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>uptr</name></type> <name>stoptheworld_tracer_ppid</name></decl>;</decl_stmt>

<function_decl><type><name>bool</name></type> <name>IsAccessibleMemoryRange</name><parameter_list>(<parameter><decl><type><name>uptr</name></type> <name>beg</name></decl></parameter>, <parameter><decl><type><name>uptr</name></type> <name>size</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>StripPathPrefix</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filepath</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>strip_file_prefix</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>StripModuleName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>module</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>uptr</name></type> <name>ReadBinaryName</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>uptr</name></type> <name>buf_len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>uptr</name></type> <name>ReadBinaryNameCached</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>uptr</name></type> <name>buf_len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>uptr</name></type> <name>ReadBinaryDir</name><parameter_list>( <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>uptr</name></type> <name>buf_len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>uptr</name></type> <name>ReadLongProcessName</name><parameter_list>( <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>uptr</name></type> <name>buf_len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>GetProcessName</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>UpdateProcessName</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CacheBinaryName</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>DisableCoreDumperIfNecessary</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>DumpProcessMap</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>GetEnv</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>SetEnv</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>u32</name></type> <name>GetUid</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ReExec</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CheckASLR</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CheckMPROTECT</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>GetArgv</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>GetEnviron</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>PrintCmdline</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>StackSizeIsUnlimited</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>SetStackSizeLimitInBytes</name><parameter_list>(<parameter><decl><type><name>uptr</name></type> <name>limit</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>AddressSpaceIsUnlimited</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>SetAddressSpaceUnlimited</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>AdjustStackSize</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>attr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>PlatformPrepareForSandboxing</name><parameter_list>(<parameter><decl><type><name>__sanitizer_sandbox_arguments</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>SetSandboxingCallback</name><parameter_list>(<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>f</name>)<parameter_list>()</parameter_list></function_decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>InitializeCoverage</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>enabled</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>coverage_dir</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>InitTlsSize</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>uptr</name></type> <name>GetTlsSize</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>SleepForSeconds</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>seconds</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>SleepForMillis</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>millis</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>u64</name></type> <name>NanoTime</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>u64</name></type> <name>MonotonicNanoTime</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>Atexit</name><parameter_list>(<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>function</name>)<parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>TemplateMatch</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>templ</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name> <name>NORETURN</name></type> <name>Abort</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name> <name>NORETURN</name></type> <name>Die</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name> <name>NORETURN</name></type>
<name>CheckFailed</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cond</name></decl></parameter>, <parameter><decl><type><name>u64</name></type> <name>v1</name></decl></parameter>, <parameter><decl><type><name>u64</name></type> <name>v2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name> <name>NORETURN</name></type> <name>ReportMmapFailureAndDie</name><parameter_list>(<parameter><decl><type><name>uptr</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mem_type</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mmap_type</name></decl></parameter>, <parameter><decl><type><name>error_t</name></type> <name>err</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>raw_report</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>



<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>DieCallbackType</name>)<parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl></typedef>





<function_decl><type><name>bool</name></type> <name>AddDieCallback</name><parameter_list>(<parameter><decl><type><name>DieCallbackType</name></type> <name>callback</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>RemoveDieCallback</name><parameter_list>(<parameter><decl><type><name>DieCallbackType</name></type> <name>callback</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>SetUserDieCallback</name><parameter_list>(<parameter><decl><type><name>DieCallbackType</name></type> <name>callback</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>SetCheckUnwindCallback</name><parameter_list>(<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>callback</name>)<parameter_list>()</parameter_list></function_decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>void</name></type> <name>SetSoftRssLimitExceededCallback</name><parameter_list>(<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>Callback</name>)<parameter_list>(<parameter><decl><type><name>bool</name></type> <name>exceeded</name></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>;</function_decl>


<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>SignalHandlerType</name>)<parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl></typedef>
<function_decl><type><name>HandleSignalMode</name></type> <name>GetHandleSignalMode</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>signum</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>InstallDeadlySignalHandlers</name><parameter_list>(<parameter><decl><type><name>SignalHandlerType</name></type> <name>handler</name></decl></parameter>)</parameter_list>;</function_decl>



<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>UnwindSignalStackCallbackType</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SignalContext</name> <modifier>&amp;</modifier></type><name>sig</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>callback_context</name></decl></parameter>,
<parameter><decl><type><name>BufferedStackTrace</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<function_decl><type><name>void</name></type> <name>HandleDeadlySignal</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>siginfo</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>tid</name></decl></parameter>,
<parameter><decl><type><name>UnwindSignalStackCallbackType</name></type> <name>unwind</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>unwind_context</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>StartReportDeadlySignal</name><parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>ReportDeadlySignal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SignalContext</name> <modifier>&amp;</modifier></type><name>sig</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>tid</name></decl></parameter>,
<parameter><decl><type><name>UnwindSignalStackCallbackType</name></type> <name>unwind</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>unwind_context</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>SetAlternateSignalStack</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>UnsetAlternateSignalStack</name><parameter_list>()</parameter_list>;</function_decl>





<function_decl><type><name>void</name></type> <name>ReportErrorSummary</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>error_message</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alt_tool_name</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>ReportErrorSummary</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>error_type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AddressInfo</name> <modifier>&amp;</modifier></type><name>info</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alt_tool_name</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>ReportErrorSummary</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>error_type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>StackTrace</name> <modifier>*</modifier></type><name>trace</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>alt_tool_name</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>ReportMmapWriteExec</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>prot</name></decl></parameter>)</parameter_list>;</function_decl>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SANITIZER_WINDOWS</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__clang__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<extern>extern <literal type="string">"C"</literal> <block>{<block_content>
<function_decl><type><name>unsigned</name> <name>char</name></type> <name>_BitScanForward</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>long</name> <modifier>*</modifier></type><name>index</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>mask</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>unsigned</name> <name>char</name></type> <name>_BitScanReverse</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>long</name> <modifier>*</modifier></type><name>index</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>mask</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN64</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>unsigned</name> <name>char</name></type> <name>_BitScanForward64</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>long</name> <modifier>*</modifier></type><name>index</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>__int64</name></type> <name>mask</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>unsigned</name> <name>char</name></type> <name>_BitScanReverse64</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>long</name> <modifier>*</modifier></type><name>index</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>__int64</name></type> <name>mask</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>inline</specifier> <name>uptr</name></type> <name>MostSignificantSetBitIndex</name><parameter_list>(<parameter><decl><type><name>uptr</name></type> <name>x</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>CHECK_NE</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><literal type="number">0U</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>up</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>SANITIZER_WINDOWS</name> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__clang__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN64</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>up</name> <operator>=</operator> <name>SANITIZER_WORDSIZE</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <call><name>__builtin_clzll</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>up</name> <operator>=</operator> <name>SANITIZER_WORDSIZE</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <call><name>__builtin_clzl</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN64</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<expr_stmt><expr><call><name>_BitScanReverse64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>up</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>_BitScanReverse</name><argument_list>(<argument><expr><operator>&amp;</operator><name>up</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>up</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>inline</specifier> <name>uptr</name></type> <name>LeastSignificantSetBitIndex</name><parameter_list>(<parameter><decl><type><name>uptr</name></type> <name>x</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>CHECK_NE</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><literal type="number">0U</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>up</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>SANITIZER_WINDOWS</name> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__clang__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN64</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>up</name> <operator>=</operator> <call><name>__builtin_ctzll</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>up</name> <operator>=</operator> <call><name>__builtin_ctzl</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN64</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<expr_stmt><expr><call><name>_BitScanForward64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>up</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>_BitScanForward</name><argument_list>(<argument><expr><operator>&amp;</operator><name>up</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>up</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>inline</specifier> <name>bool</name></type> <name>IsPowerOfTwo</name><parameter_list>(<parameter><decl><type><name>uptr</name></type> <name>x</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><operator>(</operator><name>x</name> <operator>&amp;</operator> <operator>(</operator><name>x</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>inline</specifier> <name>uptr</name></type> <name>RoundUpToPowerOfTwo</name><parameter_list>(<parameter><decl><type><name>uptr</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>IsPowerOfTwo</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>size</name></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>uptr</name></type> <name>up</name> <init>= <expr><call><name>MostSignificantSetBitIndex</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CHECK_LT</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><operator>(</operator><literal type="number">1ULL</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>up</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_GT</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><operator>(</operator><literal type="number">1ULL</literal> <operator>&lt;&lt;</operator> <name>up</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1ULL</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>up</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>inline</specifier> <name>uptr</name></type> <name>RoundUpTo</name><parameter_list>(<parameter><decl><type><name>uptr</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>uptr</name></type> <name>boundary</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>RAW_CHECK</name><argument_list>(<argument><expr><call><name>IsPowerOfTwo</name><argument_list>(<argument><expr><name>boundary</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>size</name> <operator>+</operator> <name>boundary</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>boundary</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>inline</specifier> <name>uptr</name></type> <name>RoundDownTo</name><parameter_list>(<parameter><decl><type><name>uptr</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>uptr</name></type> <name>boundary</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>x</name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>boundary</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>inline</specifier> <name>bool</name></type> <name>IsAligned</name><parameter_list>(<parameter><decl><type><name>uptr</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>uptr</name></type> <name>alignment</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><operator>(</operator><name>a</name> <operator>&amp;</operator> <operator>(</operator><name>alignment</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>inline</specifier> <name>uptr</name></type> <name>Log2</name><parameter_list>(<parameter><decl><type><name>uptr</name></type> <name>x</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><call><name>IsPowerOfTwo</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>LeastSignificantSetBitIndex</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>constexpr</name> <name>T</name></type> <name>Min</name><parameter_list>(<parameter><decl><type><name>T</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>T</name></type> <name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><ternary><condition><expr><name>a</name> <operator>&lt;</operator> <name>b</name></expr> ?</condition><then> <expr><name>a</name></expr> </then><else>: <expr><name>b</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>constexpr</name> <name>T</name></type> <name>Max</name><parameter_list>(<parameter><decl><type><name>T</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>T</name></type> <name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><ternary><condition><expr><name>a</name> <operator>&gt;</operator> <name>b</name></expr> ?</condition><then> <expr><name>a</name></expr> </then><else>: <expr><name>b</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
<function><type><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>class</name> <name>T</name></expr></argument>&gt;</argument_list></name> <name>void</name></type> <name>Swap</name><parameter_list>(<parameter><decl><type><name>T</name><modifier>&amp;</modifier></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>T</name><modifier>&amp;</modifier></type> <name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>T</name></type> <name>tmp</name> <init>= <expr><name>a</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>a</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>inline</specifier> <name>bool</name></type> <name>IsSpace</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><operator>(</operator><name>c</name> <operator>==</operator> <literal type="char">' '</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>c</name> <operator>==</operator> <literal type="char">'\n'</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>c</name> <operator>==</operator> <literal type="char">'\t'</literal><operator>)</operator> <operator>||</operator>
<operator>(</operator><name>c</name> <operator>==</operator> <literal type="char">'\f'</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>c</name> <operator>==</operator> <literal type="char">'\r'</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>c</name> <operator>==</operator> <literal type="char">'\v'</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>inline</specifier> <name>bool</name></type> <name>IsDigit</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><operator>(</operator><name>c</name> <operator>&gt;=</operator> <literal type="char">'0'</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>c</name> <operator>&lt;=</operator> <literal type="char">'9'</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>inline</specifier> <name>int</name></type> <name>ToLower</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><ternary><condition><expr><operator>(</operator><name>c</name> <operator>&gt;=</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="char">'Z'</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name>c</name> <operator>+</operator> <literal type="char">'a'</literal> <operator>-</operator> <literal type="char">'A'</literal><operator>)</operator></expr> </then><else>: <expr><name>c</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>




<decl_stmt><decl><type><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>InternalMmapVectorNoCtor</name> <block>{<block_content>
<label><name>public</name>:</label>
<decl_stmt><decl><type><name>using</name></type> <name>value_type</name> <init>= <expr><name>T</name></expr></init></decl>;</decl_stmt>
<function><type><name>void</name></type> <name>Initialize</name><parameter_list>(<parameter><decl><type><name>uptr</name></type> <name>initial_capacity</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>capacity_bytes_</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>size_</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>data_</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>reserve</name><argument_list>(<argument><expr><name>initial_capacity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>Destroy</name><parameter_list>()</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name>UnmapOrDie</name><argument_list>(<argument><expr><name>data_</name></expr></argument>, <argument><expr><name>capacity_bytes_</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>
<function><type><name>T</name> <modifier>&amp;</modifier></type><name>operator</name>[]<parameter_list>(<parameter><decl><type><name>uptr</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>CHECK_LT</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>size_</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>data_</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>
<decl_stmt><decl><type><specifier>const</specifier> <name>T</name> <modifier>&amp;</modifier></type><name><name>operator</name><index>[]</index></name><argument_list>(<argument><expr><name>uptr</name> <name>i</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><call><name>CHECK_LT</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>size_</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>data_</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<function><type><name>void</name></type> <name>push_back</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>T</name> <modifier>&amp;</modifier></type><name>element</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>CHECK_LE</name><argument_list>(<argument><expr><name>size_</name></expr></argument>, <argument><expr><call><name>capacity</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>size_</name> <operator>==</operator> <call><name>capacity</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uptr</name></type> <name>new_capacity</name> <init>= <expr><call><name>RoundUpToPowerOfTwo</name><argument_list>(<argument><expr><name>size_</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Realloc</name><argument_list>(<argument><expr><name>new_capacity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>internal_memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data_</name><index>[<expr><name>size_</name><operator>++</operator></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>element</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>T</name> <modifier>&amp;</modifier></type><name>back</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>CHECK_GT</name><argument_list>(<argument><expr><name>size_</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>data_</name><index>[<expr><name>size_</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>pop_back</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>CHECK_GT</name><argument_list>(<argument><expr><name>size_</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>size_</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></function>
<expr_stmt><expr><name>uptr</name> <macro><name>size</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>size_</name></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>T</name> <operator>*</operator><macro><name>data</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>data_</name></expr>;</return>
}</block></expr></expr_stmt>
<function><type><name>T</name> <modifier>*</modifier></type><name>data</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><name>data_</name></expr>;</return>
</block_content>}</block></function>
<expr_stmt><expr><name>uptr</name> <macro><name>capacity</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>capacity_bytes_</name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></sizeof></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>reserve</name><parameter_list>(<parameter><decl><type><name>uptr</name></type> <name>new_size</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>new_size</name> <operator>&gt;</operator> <call><name>capacity</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Realloc</name><argument_list>(<argument><expr><name>new_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>resize</name><parameter_list>(<parameter><decl><type><name>uptr</name></type> <name>new_size</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>new_size</name> <operator>&gt;</operator> <name>size_</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>reserve</name><argument_list>(<argument><expr><name>new_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>internal_memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data_</name><index>[<expr><name>size_</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>new_size</name> <operator>-</operator> <name>size_</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>size_</name> <operator>=</operator> <name>new_size</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>clear</name><parameter_list>()</parameter_list> <block>{<block_content> <expr_stmt><expr><name>size_</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> </block_content>}</block></function>
<expr_stmt><expr><name>bool</name> <macro><name>empty</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>size</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>T</name> <operator>*</operator><macro><name>begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>data</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<function><type><name>T</name> <modifier>*</modifier></type><name>begin</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name>data</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>
<expr_stmt><expr><specifier>const</specifier> <name>T</name> <operator>*</operator><macro><name>end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>data</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>size</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<function><type><name>T</name> <modifier>*</modifier></type><name>end</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name>data</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>size</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>swap</name><parameter_list>(<parameter><decl><type><name>InternalMmapVectorNoCtor</name> <modifier>&amp;</modifier></type><name>other</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>Swap</name><argument_list>(<argument><expr><name>data_</name></expr></argument>, <argument><expr><name><name>other</name><operator>.</operator><name>data_</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Swap</name><argument_list>(<argument><expr><name>capacity_bytes_</name></expr></argument>, <argument><expr><name><name>other</name><operator>.</operator><name>capacity_bytes_</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Swap</name><argument_list>(<argument><expr><name>size_</name></expr></argument>, <argument><expr><name><name>other</name><operator>.</operator><name>size_</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<label><name>private</name>:</label>
<function><type><name>void</name></type> <name>Realloc</name><parameter_list>(<parameter><decl><type><name>uptr</name></type> <name>new_capacity</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>CHECK_GT</name><argument_list>(<argument><expr><name>new_capacity</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECK_LE</name><argument_list>(<argument><expr><name>size_</name></expr></argument>, <argument><expr><name>new_capacity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>uptr</name></type> <name>new_capacity_bytes</name> <init>=
<expr><call><name>RoundUpTo</name><argument_list>(<argument><expr><name>new_capacity</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><call><name>GetPageSizeCached</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>T</name> <modifier>*</modifier></type><name>new_data</name> <init>= <expr><operator>(</operator><name>T</name> <operator>*</operator><operator>)</operator><call><name>MmapOrDie</name><argument_list>(<argument><expr><name>new_capacity_bytes</name></expr></argument>, <argument><expr><literal type="string">"InternalMmapVector"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>internal_memcpy</name><argument_list>(<argument><expr><name>new_data</name></expr></argument>, <argument><expr><name>data_</name></expr></argument>, <argument><expr><name>size_</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UnmapOrDie</name><argument_list>(<argument><expr><name>data_</name></expr></argument>, <argument><expr><name>capacity_bytes_</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>data_</name> <operator>=</operator> <name>new_data</name></expr>;</expr_stmt>
<expr_stmt><expr><name>capacity_bytes_</name> <operator>=</operator> <name>new_capacity_bytes</name></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><name>T</name> <modifier>*</modifier></type><name>data_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uptr</name></type> <name>capacity_bytes_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uptr</name></type> <name>size_</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name>operator</name><operator>==</operator><operator>(</operator><specifier>const</specifier> <name><name>InternalMmapVectorNoCtor</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>lhs</name><operator>,</operator>
<specifier>const</specifier> <name><name>InternalMmapVectorNoCtor</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>rhs</name><operator>)</operator> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>lhs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <call><name><name>rhs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name>internal_memcmp</name><argument_list>(<argument><expr><call><name><name>lhs</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>rhs</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>lhs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <name>operator</name><operator>!=</operator><operator>(</operator><specifier>const</specifier> <name><name>InternalMmapVectorNoCtor</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>lhs</name><operator>,</operator>
<specifier>const</specifier> <name><name>InternalMmapVectorNoCtor</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>rhs</name><operator>)</operator> <block>{
<return>return <expr><operator>!</operator><operator>(</operator><name>lhs</name> <operator>==</operator> <name>rhs</name><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>

<decl_stmt><decl><type><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>InternalMmapVector</name> <range>: <expr><name>public</name> <name><name>InternalMmapVectorNoCtor</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>InternalMmapVector</name><argument_list>()</argument_list></macro> <block>{ <expr><name><name>InternalMmapVectorNoCtor</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>Initialize</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>; }</block>
<name>explicit</name> <macro><name>InternalMmapVector</name><argument_list>(<argument>uptr cnt</argument>)</argument_list></macro> <block>{
<expr><name><name>InternalMmapVectorNoCtor</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>Initialize</name><argument_list>(<argument><expr><name>cnt</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>this</name><operator>-&gt;</operator><name>resize</name></name><argument_list>(<argument><expr><name>cnt</name></expr></argument>)</argument_list></call></expr>;
}</block>
<operator>~</operator><macro><name>InternalMmapVector</name><argument_list>()</argument_list></macro> <block>{ <expr><name><name>InternalMmapVectorNoCtor</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>Destroy</name><argument_list>()</argument_list></call></expr>; }</block>

<call><name>InternalMmapVector</name><argument_list>(<argument><expr><specifier>const</specifier> <name>InternalMmapVector</name> <operator>&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name>delete</name></expr>;
<expr><name>InternalMmapVector</name> <operator>&amp;</operator><name>operator</name><operator>=</operator><operator>(</operator><specifier>const</specifier> <name>InternalMmapVector</name> <operator>&amp;</operator><operator>)</operator> <operator>=</operator> <name>delete</name></expr>;
<expr><call><name>InternalMmapVector</name><argument_list>(<argument><expr><name>InternalMmapVector</name> <operator>&amp;&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name>delete</name></expr>;
<expr><name>InternalMmapVector</name> <operator>&amp;</operator><name>operator</name><operator>=</operator><operator>(</operator><name>InternalMmapVector</name> <operator>&amp;&amp;</operator><operator>)</operator> <operator>=</operator> <name>delete</name></expr>;
}</block></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>InternalScopedString</name> <block>{<block_content>
<label><name>public</name>:</label>
<expr_stmt><expr><call><name>InternalScopedString</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>buffer_</name><argument_list>(<argument><literal type="number">1</literal></argument>)</argument_list></macro> <block>{ <expr><name><name>buffer_</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>; }</block>

<name>uptr</name> <macro><name>length</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>buffer_</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>clear</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>buffer_</name><operator>.</operator><name>resize</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buffer_</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></function>
<function_decl><type><name>void</name></type> <name>append</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<expr_stmt><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><macro><name>data</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>buffer_</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>char</name> <modifier>*</modifier></type><name>data</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name><name>buffer_</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name><name>InternalMmapVector</name><argument_list type="generic">&lt;<argument><expr><name>char</name></expr></argument>&gt;</argument_list></name></type> <name>buffer_</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>class</name> <name>T</name><operator>&gt;</operator>
struct <name>CompareLess</name> <block>{
<expr><name>bool</name> <macro><name>operator</name><argument_list>()</argument_list></macro><operator>(</operator><specifier>const</specifier> <name>T</name> <operator>&amp;</operator><name>a</name><operator>,</operator> <specifier>const</specifier> <name>T</name> <operator>&amp;</operator><name>b</name><operator>)</operator> <specifier>const</specifier> <block>{ <return>return <expr><name>a</name> <operator>&lt;</operator> <name>b</name></expr>;</return></block></expr> }</block></expr></expr_stmt>
};


<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>T</name></expr></argument>, <argument><expr><name>class</name> <name>Compare</name> <operator>=</operator> <name><name>CompareLess</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name>
<name>void</name></type> <name>Sort</name><argument_list>(<argument><expr><name>T</name> <operator>*</operator><name>v</name></expr></argument>, <argument><expr><name>uptr</name> <name>size</name></expr></argument>, <argument><expr><name>Compare</name> <name>comp</name> <operator>=</operator> <block>{}</block></expr></argument>)</argument_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><decl><type><name>uptr</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>uptr</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>p</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>i</name></expr>;</init> <condition><expr><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>j</name> <operator>=</operator> <name>p</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>j</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>comp</name><argument_list>(<argument><expr><name><name>v</name><index>[<expr><name>p</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>v</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Swap</name><argument_list>(<argument><expr><name><name>v</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>v</name><index>[<expr><name>p</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<break>break;</break></block_content></block></else></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>


<for>for <control>(<init><decl><type><name>uptr</name></type> <name>i</name> <init>= <expr><name>size</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>Swap</name><argument_list>(<argument><expr><name><name>v</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>v</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>uptr</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>max_ind</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>i</name></expr>;</condition> <incr><expr><name>j</name> <operator>=</operator> <name>max_ind</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>uptr</name></type> <name>left</name> <init>= <expr><literal type="number">2</literal> <operator>*</operator> <name>j</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uptr</name></type> <name>right</name> <init>= <expr><literal type="number">2</literal> <operator>*</operator> <name>j</name> <operator>+</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>max_ind</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>i</name> <operator>&amp;&amp;</operator> <call><name>comp</name><argument_list>(<argument><expr><name><name>v</name><index>[<expr><name>max_ind</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>v</name><index>[<expr><name>left</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>max_ind</name> <operator>=</operator> <name>left</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>right</name> <operator>&lt;</operator> <name>i</name> <operator>&amp;&amp;</operator> <call><name>comp</name><argument_list>(<argument><expr><name><name>v</name><index>[<expr><name>max_ind</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>v</name><index>[<expr><name>right</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>max_ind</name> <operator>=</operator> <name>right</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>max_ind</name> <operator>!=</operator> <name>j</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Swap</name><argument_list>(<argument><expr><name><name>v</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>v</name><index>[<expr><name>max_ind</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<break>break;</break></block_content></block></else></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></decl></decl_stmt>



<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>Container</name></expr></argument>,
<argument><expr><name>class</name> <name>Compare</name> <operator>=</operator> <name><name>CompareLess</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Container</name><operator>::</operator><name>value_type</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name>
<name>uptr</name></type> <name>InternalLowerBound</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Container</name> <operator>&amp;</operator><name>v</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>typename</name> <name>Container</name><operator>::</operator><name>value_type</name> <operator>&amp;</operator><name>val</name></expr></argument>,
<argument><expr><name>Compare</name> <name>comp</name> <operator>=</operator> <block>{}</block></expr></argument>)</argument_list> <block>{<block_content>
<decl_stmt><decl><type><name>uptr</name></type> <name>first</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uptr</name></type> <name>last</name> <init>= <expr><call><name><name>v</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>last</name> <operator>&gt;</operator> <name>first</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uptr</name></type> <name>mid</name> <init>= <expr><operator>(</operator><name>first</name> <operator>+</operator> <name>last</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>comp</name><argument_list>(<argument><expr><name><name>v</name><index>[<expr><name>mid</name></expr>]</index></name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>first</name> <operator>=</operator> <name>mid</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>last</name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></while>
<return>return <expr><name>first</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<enum>enum <name>ModuleArch</name> <block>{
<decl><name>kModuleArchUnknown</name></decl>,
<decl><name>kModuleArchI386</name></decl>,
<decl><name>kModuleArchX86_64</name></decl>,
<decl><name>kModuleArchX86_64H</name></decl>,
<decl><name>kModuleArchARMV6</name></decl>,
<decl><name>kModuleArchARMV7</name></decl>,
<decl><name>kModuleArchARMV7S</name></decl>,
<decl><name>kModuleArchARMV7K</name></decl>,
<decl><name>kModuleArchARM64</name></decl>,
<decl><name>kModuleArchRISCV64</name></decl>
}</block>;</enum>


<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>Container</name></expr></argument>,
<argument><expr><name>class</name> <name>Compare</name> <operator>=</operator> <name><name>CompareLess</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Container</name><operator>::</operator><name>value_type</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name>
<name>void</name></type> <name>SortAndDedup</name><argument_list>(<argument><expr><name>Container</name> <operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><name>Compare</name> <name>comp</name> <operator>=</operator> <block>{}</block></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name>Sort</name><argument_list>(<argument><expr><call><name><name>v</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>v</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>comp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>uptr</name></type> <name>size</name> <init>= <expr><call><name><name>v</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>uptr</name></type> <name>last</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>uptr</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>comp</name><argument_list>(<argument><expr><name><name>v</name><index>[<expr><name>last</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>v</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>last</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>last</name> <operator>!=</operator> <name>i</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>v</name><index>[<expr><name>last</name></expr>]</index></name> <operator>=</operator> <name><name>v</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><operator>!</operator><call><name>comp</name><argument_list>(<argument><expr><name><name>v</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>v</name><index>[<expr><name>last</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name><name>v</name><operator>.</operator><name>resize</name></name><argument_list>(<argument><expr><name>last</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>




<function_decl><type><name>bool</name></type> <name>ReadFileToVector</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file_name</name></decl></parameter>,
<parameter><decl><type><name><name>InternalMmapVectorNoCtor</name><argument_list type="generic">&lt;<argument><expr><name>char</name></expr></argument>&gt;</argument_list></name> <modifier>*</modifier></type><name>buff</name></decl></parameter>,
<parameter><decl><type><name>uptr</name></type> <name>max_len</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">26</literal></expr></init></decl></parameter>, <parameter><decl><type><name>error_t</name> <modifier>*</modifier></type><name>errno_p</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>









<function_decl><type><name>bool</name></type> <name>ReadFileToBuffer</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file_name</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>buff</name></decl></parameter>, <parameter><decl><type><name>uptr</name> <modifier>*</modifier></type><name>buff_size</name></decl></parameter>,
<parameter><decl><type><name>uptr</name> <modifier>*</modifier></type><name>read_len</name></decl></parameter>, <parameter><decl><type><name>uptr</name></type> <name>max_len</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">26</literal></expr></init></decl></parameter>,
<parameter><decl><type><name>error_t</name> <modifier>*</modifier></type><name>errno_p</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>



<function><type><specifier>inline</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ModuleArchToString</name><parameter_list>(<parameter><decl><type><name>ModuleArch</name></type> <name>arch</name></decl></parameter>)</parameter_list> <block>{<block_content>
<switch>switch <condition>(<expr><name>arch</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>kModuleArchUnknown</name></expr>:</case>
<return>return <expr><literal type="string">""</literal></expr>;</return>
<case>case <expr><name>kModuleArchI386</name></expr>:</case>
<return>return <expr><literal type="string">"i386"</literal></expr>;</return>
<case>case <expr><name>kModuleArchX86_64</name></expr>:</case>
<return>return <expr><literal type="string">"x86_64"</literal></expr>;</return>
<case>case <expr><name>kModuleArchX86_64H</name></expr>:</case>
<return>return <expr><literal type="string">"x86_64h"</literal></expr>;</return>
<case>case <expr><name>kModuleArchARMV6</name></expr>:</case>
<return>return <expr><literal type="string">"armv6"</literal></expr>;</return>
<case>case <expr><name>kModuleArchARMV7</name></expr>:</case>
<return>return <expr><literal type="string">"armv7"</literal></expr>;</return>
<case>case <expr><name>kModuleArchARMV7S</name></expr>:</case>
<return>return <expr><literal type="string">"armv7s"</literal></expr>;</return>
<case>case <expr><name>kModuleArchARMV7K</name></expr>:</case>
<return>return <expr><literal type="string">"armv7k"</literal></expr>;</return>
<case>case <expr><name>kModuleArchARM64</name></expr>:</case>
<return>return <expr><literal type="string">"arm64"</literal></expr>;</return>
<case>case <expr><name>kModuleArchRISCV64</name></expr>:</case>
<return>return <expr><literal type="string">"riscv64"</literal></expr>;</return>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>CHECK</name><argument_list>(<argument><expr><literal type="number">0</literal> <operator>&amp;&amp;</operator> <literal type="string">"Invalid module arch"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="string">""</literal></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>const</specifier> <name>uptr</name></type> <name>kModuleUUIDSize</name> <init>= <expr><literal type="number">16</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uptr</name></type> <name>kMaxSegName</name> <init>= <expr><literal type="number">16</literal></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>class</name></type> <name>LoadedModule</name> <block>{<block_content>
<label><name>public</name>:</label>
<expr_stmt><expr><call><name>LoadedModule</name><argument_list>()</argument_list></call>
<operator>:</operator> <call><name>full_name_</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>base_address_</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>max_executable_address_</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>arch_</name><argument_list>(<argument><expr><name>kModuleArchUnknown</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>instrumented_</name><argument_list>(<argument>false</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>internal_memset</name><argument_list>(<argument><expr><name>uuid_</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>kModuleUUIDSize</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>ranges_</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;
}</block>
<name>void</name> <macro><name>set</name><argument_list>(<argument>const char *module_name</argument>, <argument>uptr base_address</argument>)</argument_list></macro></expr>;</expr_stmt>
<function_decl><type><name>void</name></type> <name>set</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>module_name</name></decl></parameter>, <parameter><decl><type><name>uptr</name></type> <name>base_address</name></decl></parameter>, <parameter><decl><type><name>ModuleArch</name></type> <name>arch</name></decl></parameter>,
<parameter><decl><type><name>u8</name></type> <name><name>uuid</name><index>[<expr><name>kModuleUUIDSize</name></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>instrumented</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>clear</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>addAddressRange</name><parameter_list>(<parameter><decl><type><name>uptr</name></type> <name>beg</name></decl></parameter>, <parameter><decl><type><name>uptr</name></type> <name>end</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>executable</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>writable</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>bool</name></type> <name>containsAddress</name><argument_list>(<argument><expr><name>uptr</name> <name>address</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><macro><name>full_name</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>full_name_</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>uptr</name> <macro><name>base_address</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>base_address_</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>uptr</name> <macro><name>max_executable_address</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>max_executable_address_</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>ModuleArch</name> <macro><name>arch</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>arch_</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>u8</name> <operator>*</operator><macro><name>uuid</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>uuid_</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>instrumented</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>instrumented_</name></expr>;</return> }</block></expr></expr_stmt>

<struct>struct <name>AddressRange</name> <block>{
<decl_stmt><decl><type><name>AddressRange</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uptr</name></type> <name>beg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uptr</name></type> <name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>executable</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>writable</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>name</name><index>[<expr><name>kMaxSegName</name></expr>]</index></name></decl>;</decl_stmt>

<macro><name>AddressRange</name><argument_list>(<argument>uptr beg</argument>, <argument>uptr end</argument>, <argument>bool executable</argument>, <argument>bool writable</argument>,
<argument>const char *name</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>next</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>beg</name><argument_list>(<argument><expr><name>beg</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>end</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>executable</name><argument_list>(<argument><expr><name>executable</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>writable</name><argument_list>(<argument>writable</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>internal_strncpy</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><operator>(</operator><name>name</name> <operator>?</operator> <name>name</name> <operator>:</operator> <literal type="string">""</literal><operator>)</operator></expr></argument>, <argument><expr><call><name>ARRAY_SIZE</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block></expr></expr_stmt>
}</block>;</struct>

<expr_stmt><expr><specifier>const</specifier> <name><name>IntrusiveList</name><argument_list type="generic">&lt;<argument><expr><name>AddressRange</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><macro><name>ranges</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ranges_</name></expr>;</return> }</block></expr></expr_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>full_name_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uptr</name></type> <name>base_address_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uptr</name></type> <name>max_executable_address_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ModuleArch</name></type> <name>arch_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>u8</name></type> <name><name>uuid_</name><index>[<expr><name>kModuleUUIDSize</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>instrumented_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>IntrusiveList</name><argument_list type="generic">&lt;<argument><expr><name>AddressRange</name></expr></argument>&gt;</argument_list></name></type> <name>ranges_</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<decl_stmt><decl><type><name>class</name></type> <name>ListOfModules</name> <block>{<block_content>
<label><name>public</name>:</label>
<expr_stmt><expr><call><name>ListOfModules</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>initialized</name><argument_list>(<argument>false</argument>)</argument_list></macro> <block>{}</block>
<operator>~</operator><macro><name>ListOfModules</name><argument_list>()</argument_list></macro> <block>{ <expr><call><name>clear</name><argument_list>()</argument_list></call></expr>; }</block>
<name>void</name> <call><name>init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<function_decl><type><name>void</name></type> <name>fallbackInit</name><parameter_list>()</parameter_list>;</function_decl>
<expr_stmt><expr><specifier>const</specifier> <name>LoadedModule</name> <operator>*</operator><macro><name>begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>modules_</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>LoadedModule</name> <modifier>*</modifier></type><name>begin</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name><name>modules_</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>
<expr_stmt><expr><specifier>const</specifier> <name>LoadedModule</name> <operator>*</operator><macro><name>end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>modules_</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>LoadedModule</name> <modifier>*</modifier></type><name>end</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name><name>modules_</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>
<expr_stmt><expr><name>uptr</name> <macro><name>size</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>modules_</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>LoadedModule</name> <modifier>&amp;</modifier></type><name><name>operator</name><index>[]</index></name><argument_list>(<argument><expr><name>uptr</name> <name>i</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><call><name>CHECK_LT</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><call><name><name>modules_</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>modules_</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<label><name>private</name>:</label>
<function><type><name>void</name></type> <name>clear</name><parameter_list>()</parameter_list> <block>{<block_content>
<for>for <control>(<init><expr><name>auto</name> <operator>&amp;</operator><name>module</name> <operator>:</operator> <name>modules_</name></expr></init>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name><name>module</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name><name>modules_</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>clearOrInit</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><ternary><condition><expr><name>initialized</name></expr> ?</condition><then> <expr><call><name>clear</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><call><name><name>modules_</name><operator>.</operator><name>Initialize</name></name><argument_list>(<argument><expr><name>kInitialCapacity</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>initialized</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><name><name>InternalMmapVectorNoCtor</name><argument_list type="generic">&lt;<argument><expr><name>LoadedModule</name></expr></argument>&gt;</argument_list></name></type> <name>modules_</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uptr</name></type> <name>kInitialCapacity</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">14</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>initialized</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>RangeIteratorCallback</name>)<parameter_list>(<parameter><decl><type><name>uptr</name></type> <name>begin</name></decl></parameter>, <parameter><decl><type><name>uptr</name></type> <name>end</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<enum>enum <name>AndroidApiLevel</name> <block>{
<decl><name>ANDROID_NOT_ANDROID</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>ANDROID_KITKAT</name> <init>= <expr><literal type="number">19</literal></expr></init></decl>,
<decl><name>ANDROID_LOLLIPOP_MR1</name> <init>= <expr><literal type="number">22</literal></expr></init></decl>,
<decl><name>ANDROID_POST_LOLLIPOP</name> <init>= <expr><literal type="number">23</literal></expr></init></decl>
}</block>;</enum>

<function_decl><type><name>void</name></type> <name>WriteToSyslog</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SANITIZER_WINDOWS</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__clang__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SANITIZER_WIN_TRACE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SANITIZER_WIN_TRACE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SANITIZER_MAC</name> <operator>||</operator> <name>SANITIZER_WIN_TRACE</name></expr></cpp:if>
<function_decl><type><name>void</name></type> <name>LogFullErrorReport</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><specifier>inline</specifier> <name>void</name></type> <name>LogFullErrorReport</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list> <block>{<block_content/>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SANITIZER_LINUX</name> <operator>||</operator> <name>SANITIZER_MAC</name></expr></cpp:if>
<function_decl><type><name>void</name></type> <name>WriteOneLineToSyslog</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>LogMessageOnPrintf</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><specifier>inline</specifier> <name>void</name></type> <name>WriteOneLineToSyslog</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list> <block>{<block_content/>}</block></function>
<function><type><specifier>inline</specifier> <name>void</name></type> <name>LogMessageOnPrintf</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list> <block>{<block_content/>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SANITIZER_LINUX</name> <operator>||</operator> <name>SANITIZER_WIN_TRACE</name></expr></cpp:if>

<function_decl><type><name>void</name></type> <name>AndroidLogInit</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>SetAbortMessage</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><specifier>inline</specifier> <name>void</name></type> <name>AndroidLogInit</name><parameter_list>()</parameter_list> <block>{<block_content/>}</block></function>

<function><type><specifier>inline</specifier> <name>void</name></type> <name>SetAbortMessage</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content/>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SANITIZER_ANDROID</name></expr></cpp:if>
<function_decl><type><name>void</name></type> <name>SanitizerInitializeUnwinder</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>AndroidApiLevel</name></type> <name>AndroidGetApiLevel</name><parameter_list>()</parameter_list>;</function_decl>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><specifier>inline</specifier> <name>void</name></type> <name>AndroidLogWrite</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buffer_unused</name></decl></parameter>)</parameter_list> <block>{<block_content/>}</block></function>
<function><type><specifier>inline</specifier> <name>void</name></type> <name>SanitizerInitializeUnwinder</name><parameter_list>()</parameter_list> <block>{<block_content/>}</block></function>
<function><type><specifier>inline</specifier> <name>AndroidApiLevel</name></type> <name>AndroidGetApiLevel</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>ANDROID_NOT_ANDROID</name></expr>;</return> </block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>inline</specifier> <name>uptr</name></type> <name>GetPthreadDestructorIterations</name><parameter_list>()</parameter_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><ternary><condition><expr><name>SANITIZER_ANDROID</name></expr></condition></ternary></expr></cpp:if>
<return>return <expr><ternary><condition><expr><operator>(</operator><call><name>AndroidGetApiLevel</name><argument_list>()</argument_list></call> <operator>==</operator> <name>ANDROID_LOLLIPOP_MR1</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">8</literal></expr> </then><else>: <expr><literal type="number">4</literal></expr></else></ternary></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SANITIZER_POSIX</name></expr></cpp:elif>
<return>return <expr><literal type="number">4</literal></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function_decl><type><name>void</name> <modifier>*</modifier></type><name>internal_start_thread</name><parameter_list>(<parameter><function_decl><type><name>void</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>internal_join_thread</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>th</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>MaybeStartBackgroudThread</name><parameter_list>()</parameter_list>;</function_decl>





<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>SanitizerBreakOptimization</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__clang__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>_ReadWriteBarrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<asm>__asm__ <specifier>__volatile__</specifier>("" : : "r" (arg) : "memory");</asm>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<struct>struct <name>SignalContext</name> <block>{
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>siginfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uptr</name></type> <name>addr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uptr</name></type> <name>pc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uptr</name></type> <name>sp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uptr</name></type> <name>bp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>is_memory_access</name></decl>;</decl_stmt>
<enum>enum <name>WriteFlag</name> <block>{ <decl><name>UNKNOWN</name></decl>, <decl><name>READ</name></decl>, <decl><name>WRITE</name></decl> }</block> <decl><name>write_flag</name></decl>;</enum>




<decl_stmt><decl><type><name>bool</name></type> <name>is_true_faulting_addr</name></decl>;</decl_stmt>



<expr_stmt><expr><call><name>SignalContext</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;</expr_stmt>




<expr_stmt><expr><call><name>SignalContext</name><argument_list>(<argument><expr><name>void</name> <operator>*</operator><name>siginfo</name></expr></argument>, <argument><expr><name>void</name> <operator>*</operator><name>context</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>siginfo</name><argument_list>(<argument><expr><name>siginfo</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>context</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>addr</name><argument_list>(<argument><expr><call><name>GetAddress</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>is_memory_access</name><argument_list>(<argument><expr><call><name>IsMemoryAccess</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>write_flag</name><argument_list>(<argument><expr><call><name>GetWriteFlag</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>is_true_faulting_addr</name><argument_list>(<argument>IsTrueFaultingAddress()</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>InitPcSpBp</name><argument_list>()</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>void</name> <call><name>DumpAllRegisters</name><argument_list>(<argument><expr><name>void</name> <operator>*</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>int</name> <macro><name>GetType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><macro><name>Describe</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>IsStackOverflow</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<label><name>private</name>:</label>

<function_decl><type><name>void</name></type> <name>InitPcSpBp</name><parameter_list>()</parameter_list>;</function_decl>
<expr_stmt><expr><name>uptr</name> <macro><name>GetAddress</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<expr_stmt><expr><name>WriteFlag</name> <macro><name>GetWriteFlag</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>IsMemoryAccess</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>IsTrueFaultingAddress</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
}</block>;</struct>

<function_decl><type><name>void</name></type> <name>InitializePlatformEarly</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>MaybeReexec</name><parameter_list>()</parameter_list>;</function_decl>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Fn</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>RunOnDestruction</name> <block>{<block_content>
<label><name>public</name>:</label>
<macro><name>explicit</name></macro> <macro><name>RunOnDestruction</name><argument_list>(<argument>Fn fn</argument>)</argument_list></macro> : <macro><name>fn_</name><argument_list>(<argument>fn</argument>)</argument_list></macro> <block>{<block_content/>}</block>
<expr_stmt><expr><operator>~</operator><macro><name>RunOnDestruction</name><argument_list>()</argument_list></macro> <block>{ <expr><call><name>fn_</name><argument_list>()</argument_list></call></expr>; }</block>

<name>private</name><operator>:</operator>
<name>Fn</name> <name>fn_</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Fn</name></expr></argument>&gt;</argument_list></name>
<name><name>RunOnDestruction</name><argument_list type="generic">&lt;<argument><expr><name>Fn</name></expr></argument>&gt;</argument_list></name></type> <name>at_scope_exit</name><parameter_list>(<parameter><decl><type><name>Fn</name></type> <name>fn</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>RunOnDestruction</name><argument_list type="generic">&lt;<argument><expr><name>Fn</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SANITIZER_LINUX</name> <operator>&amp;&amp;</operator> <name>SANITIZER_S390_64</name></expr></cpp:if>
<function_decl><type><name>void</name></type> <name>AvoidCVE_2016_2143</name><parameter_list>()</parameter_list>;</function_decl>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><specifier>inline</specifier> <name>void</name></type> <name>AvoidCVE_2016_2143</name><parameter_list>()</parameter_list> <block>{<block_content/>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<struct>struct <name>StackDepotStats</name> <block>{
<decl_stmt><decl><type><name>uptr</name></type> <name>n_uniq_ids</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uptr</name></type> <name>allocated</name></decl>;</decl_stmt>
}</block>;</struct>



<decl_stmt><decl><type><specifier>const</specifier> <name>s32</name></type> <name>kReleaseToOSIntervalNever</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<function_decl><type><name>void</name></type> <name>CheckNoDeepBind</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flag</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>bool</name></type> <name>GetRandom</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>uptr</name></type> <name>length</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>blocking</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>u32</name></type> <name>GetNumberOfCPUs</name><parameter_list>()</parameter_list>;</function_decl>
<decl_stmt><decl><type><specifier>extern</specifier> <name>u32</name></type> <name>NumberOfCPUsCached</name></decl>;</decl_stmt>
<function><type><specifier>inline</specifier> <name>u32</name></type> <name>GetNumberOfCPUsCached</name><parameter_list>()</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>NumberOfCPUsCached</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>NumberOfCPUsCached</name> <operator>=</operator> <call><name>GetNumberOfCPUs</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>NumberOfCPUsCached</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>ArrayRef</name> <block>{<block_content>
<label><name>public</name>:</label>
<macro><name>ArrayRef</name><argument_list>()</argument_list></macro> <block>{<block_content/>}</block>
<expr_stmt><expr><call><name>ArrayRef</name><argument_list>(<argument><expr><name>T</name> <operator>*</operator><name>begin</name></expr></argument>, <argument><expr><name>T</name> <operator>*</operator><name>end</name></expr></argument>)</argument_list></call> <operator>:</operator> <call><name>begin_</name><argument_list>(<argument><expr><name>begin</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>end_</name><argument_list>(<argument>end</argument>)</argument_list></macro> <expr><block>{}</block>

<name>T</name> <operator>*</operator><macro><name>begin</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>begin_</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>T</name> <modifier>*</modifier></type><name>end</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>end_</name></expr>;</return> </block_content>}</block></function>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>T</name> <modifier>*</modifier></type><name>begin_</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>T</name> <modifier>*</modifier></type><name>end_</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRINTF_128</name><parameter_list>(<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(*((u8 *)&amp;v + 0)), (*((u8 *)&amp;v + 1)), (*((u8 *)&amp;v + 2)), (*((u8 *)&amp;v + 3)), (*((u8 *)&amp;v + 4)), (*((u8 *)&amp;v + 5)), (*((u8 *)&amp;v + 6)), (*((u8 *)&amp;v + 7)), (*((u8 *)&amp;v + 8)), (*((u8 *)&amp;v + 9)), (*((u8 *)&amp;v + 10)), (*((u8 *)&amp;v + 11)), (*((u8 *)&amp;v + 12)), (*((u8 *)&amp;v + 13)), (*((u8 *)&amp;v + 14)), (*((u8 *)&amp;v + 15))</cpp:value></cpp:define>






}

inline <decl_stmt><decl><type><name>void</name> <modifier>*</modifier><name>operator</name></type> <name>new</name><argument_list>(<argument><expr><name>__sanitizer</name><operator>::</operator><name>operator_new_size_type</name> <name>size</name></expr></argument>,
<argument><expr><name>__sanitizer</name><operator>::</operator><name>LowLevelAllocator</name> <operator>&amp;</operator><name>alloc</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name><name>alloc</name><operator>.</operator><name>Allocate</name></name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
