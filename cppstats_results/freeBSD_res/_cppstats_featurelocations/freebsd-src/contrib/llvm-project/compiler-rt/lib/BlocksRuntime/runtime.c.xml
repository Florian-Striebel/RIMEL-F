<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/compiler-rt/lib/BlocksRuntime/runtime.c">























<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Block_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_AVAILABILITY_MACROS_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;AvailabilityMacros.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_TARGET_CONDITIONALS_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;TargetConditionals.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_OSATOMIC_COMPARE_AND_SWAP_INT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_OSATOMIC_COMPARE_AND_SWAP_LONG</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LIBKERN_OSATOMIC_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;libkern/OSAtomic.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__WIN32__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_CRT_SECURE_NO_WARNINGS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>

<function><type><specifier>static</specifier> <name>__inline</name> <name>bool</name></type> <name>OSAtomicCompareAndSwapLong</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>oldl</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>newl</name></decl></parameter>, <parameter><decl><type><name>long</name> <specifier>volatile</specifier> <modifier>*</modifier></type><name>dst</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>original</name> <init>= <expr><call><name>InterlockedCompareExchange</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>newl</name></expr></argument>, <argument><expr><name>oldl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>(</operator><name>original</name> <operator>==</operator> <name>oldl</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>__inline</name> <name>bool</name></type> <name>OSAtomicCompareAndSwapInt</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>oldi</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>newi</name></decl></parameter>, <parameter><decl><type><name>int</name> <specifier>volatile</specifier> <modifier>*</modifier></type><name>dst</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>original</name> <init>= <expr><call><name>InterlockedCompareExchange</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>newi</name></expr></argument>, <argument><expr><name>oldi</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>(</operator><name>original</name> <operator>==</operator> <name>oldi</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>








<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYNC_BOOL_COMPARE_AND_SWAP_INT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYNC_BOOL_COMPARE_AND_SWAP_LONG</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<function><type><specifier>static</specifier> <name>__inline</name> <name>bool</name></type> <name>OSAtomicCompareAndSwapLong</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>oldl</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>newl</name></decl></parameter>, <parameter><decl><type><name>long</name> <specifier>volatile</specifier> <modifier>*</modifier></type><name>dst</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>__sync_bool_compare_and_swap</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>oldl</name></expr></argument>, <argument><expr><name>newl</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>__inline</name> <name>bool</name></type> <name>OSAtomicCompareAndSwapInt</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>oldi</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>newi</name></decl></parameter>, <parameter><decl><type><name>int</name> <specifier>volatile</specifier> <modifier>*</modifier></type><name>dst</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>__sync_bool_compare_and_swap</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>oldi</name></expr></argument>, <argument><expr><name>newi</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> unknown atomic compare-and-swap primitive</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>






<decl_stmt><decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>_Block_copy_class</name> <init>= <expr><name>_NSConcreteMallocBlock</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>_Block_copy_finalizing_class</name> <init>= <expr><name>_NSConcreteMallocBlock</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>_Block_copy_flag</name> <init>= <expr><name>BLOCK_NEEDS_FREE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>_Byref_flag_initial_value</name> <init>= <expr><name>BLOCK_NEEDS_FREE</name> <operator>|</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>WANTS_ONE</name> <init>= <expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>isGC</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>





<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
static unsigned long int latching_incr_long(unsigned long int *where) {
while (1) {
unsigned long int old_value = *(volatile unsigned long int *)where;
if ((old_value &amp; BLOCK_REFCOUNT_MASK) == BLOCK_REFCOUNT_MASK) {
return BLOCK_REFCOUNT_MASK;
}
if (OSAtomicCompareAndSwapLong(old_value, old_value+1, (volatile long int *)where)) {
return old_value+1;
}
}
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type> <name>latching_incr_int</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>where</name></decl></parameter>)</parameter_list> <block>{<block_content>
<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>old_value</name> <init>= <expr><operator>*</operator><operator>(</operator><specifier>volatile</specifier> <name>int</name> <operator>*</operator><operator>)</operator><name>where</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>old_value</name> <operator>&amp;</operator> <name>BLOCK_REFCOUNT_MASK</name><operator>)</operator> <operator>==</operator> <name>BLOCK_REFCOUNT_MASK</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>BLOCK_REFCOUNT_MASK</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>OSAtomicCompareAndSwapInt</name><argument_list>(<argument><expr><name>old_value</name></expr></argument>, <argument><expr><name>old_value</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><specifier>volatile</specifier> <name>int</name> <operator>*</operator><operator>)</operator><name>where</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>old_value</name><operator>+</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
static int latching_decr_long(unsigned long int *where) {
while (1) {
unsigned long int old_value = *(volatile int *)where;
if ((old_value &amp; BLOCK_REFCOUNT_MASK) == BLOCK_REFCOUNT_MASK) {
return BLOCK_REFCOUNT_MASK;
}
if ((old_value &amp; BLOCK_REFCOUNT_MASK) == 0) {
return 0;
}
if (OSAtomicCompareAndSwapLong(old_value, old_value-1, (volatile long int *)where)) {
return old_value-1;
}
}
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type> <name>latching_decr_int</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>where</name></decl></parameter>)</parameter_list> <block>{<block_content>
<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>old_value</name> <init>= <expr><operator>*</operator><operator>(</operator><specifier>volatile</specifier> <name>int</name> <operator>*</operator><operator>)</operator><name>where</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>old_value</name> <operator>&amp;</operator> <name>BLOCK_REFCOUNT_MASK</name><operator>)</operator> <operator>==</operator> <name>BLOCK_REFCOUNT_MASK</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>BLOCK_REFCOUNT_MASK</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>old_value</name> <operator>&amp;</operator> <name>BLOCK_REFCOUNT_MASK</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>OSAtomicCompareAndSwapInt</name><argument_list>(<argument><expr><name>old_value</name></expr></argument>, <argument><expr><name>old_value</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><specifier>volatile</specifier> <name>int</name> <operator>*</operator><operator>)</operator><name>where</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>old_value</name><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
</block_content>}</block></function>





<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>mark</name> <name>GC</name> <name>Support</name> <name>Routines</name></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>_Block_alloc_default</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>long</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>initialCountIsOne</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>isObject</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>malloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>_Block_assign_default</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>destptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>destptr</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>_Block_setHasRefcount_default</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>hasRefcount</name></decl></parameter>)</parameter_list> <block>{<block_content>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>_Block_do_nothing</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>aBlock</name></decl></parameter>)</parameter_list> <block>{<block_content> </block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>_Block_retain_object_default</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ptr</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>_Block_release_object_default</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ptr</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>_Block_assign_weak_default</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>dest</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>ptr</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>_Block_memmove_default</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>_Block_memmove_gc_broken</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>destp</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>dest</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>srcp</name> <init>= <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>src</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>size</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>_Block_assign_default</name><argument_list>(<argument><expr><operator>*</operator><name>srcp</name></expr></argument>, <argument><expr><name>destp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>destp</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>srcp</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>size</name> <operator>-=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>





<function_decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>_Block_allocator</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name></type> <name>long</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>isOne</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>isObject</name></decl></parameter>)</parameter_list> <init>= <expr><name>_Block_alloc_default</name></expr></init>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> (<modifier>*</modifier><name>_Block_deallocator</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list> <init>= <expr><operator>(</operator><call><call><name>void</name> <argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator></call><operator>)</operator><name>free</name></expr></init>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> (<modifier>*</modifier><name>_Block_assign</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>destptr</name></decl></parameter>)</parameter_list> <init>= <expr><name>_Block_assign_default</name></expr></init>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> (<modifier>*</modifier><name>_Block_setHasRefcount</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>hasRefcount</name></decl></parameter>)</parameter_list> <init>= <expr><name>_Block_setHasRefcount_default</name></expr></init>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> (<modifier>*</modifier><name>_Block_retain_object</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list> <init>= <expr><name>_Block_retain_object_default</name></expr></init>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> (<modifier>*</modifier><name>_Block_release_object</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list> <init>= <expr><name>_Block_release_object_default</name></expr></init>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> (<modifier>*</modifier><name>_Block_assign_weak</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list> <init>= <expr><name>_Block_assign_weak_default</name></expr></init>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> (<modifier>*</modifier><name>_Block_memmove</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>size</name></decl></parameter>)</parameter_list> <init>= <expr><name>_Block_memmove_default</name></expr></init>;</function_decl>










<function><type><name>void</name></type> <name>_Block_use_GC</name><parameter_list>( <parameter><function_decl><type><name>void</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>alloc</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name></type> <name>long</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>isOne</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>isObject</name></decl></parameter>)</parameter_list></function_decl></parameter>,
<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>setHasRefcount</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type></decl></parameter>)</parameter_list></function_decl></parameter>,
<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>gc_assign</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>gc_assign_weak</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>gc_memmove</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>long</name></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><name>isGC</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name>_Block_allocator</name> <operator>=</operator> <name>alloc</name></expr>;</expr_stmt>
<expr_stmt><expr><name>_Block_deallocator</name> <operator>=</operator> <name>_Block_do_nothing</name></expr>;</expr_stmt>
<expr_stmt><expr><name>_Block_assign</name> <operator>=</operator> <name>gc_assign</name></expr>;</expr_stmt>
<expr_stmt><expr><name>_Block_copy_flag</name> <operator>=</operator> <name>BLOCK_IS_GC</name></expr>;</expr_stmt>
<expr_stmt><expr><name>_Block_copy_class</name> <operator>=</operator> <name>_NSConcreteAutoBlock</name></expr>;</expr_stmt>

<expr_stmt><expr><name>_Block_copy_finalizing_class</name> <operator>=</operator> <name>_NSConcreteFinalizingBlock</name></expr>;</expr_stmt>
<expr_stmt><expr><name>_Block_setHasRefcount</name> <operator>=</operator> <name>setHasRefcount</name></expr>;</expr_stmt>
<expr_stmt><expr><name>_Byref_flag_initial_value</name> <operator>=</operator> <name>BLOCK_IS_GC</name></expr>;</expr_stmt>
<expr_stmt><expr><name>_Block_retain_object</name> <operator>=</operator> <name>_Block_do_nothing</name></expr>;</expr_stmt>
<expr_stmt><expr><name>_Block_release_object</name> <operator>=</operator> <name>_Block_do_nothing</name></expr>;</expr_stmt>
<expr_stmt><expr><name>_Block_assign_weak</name> <operator>=</operator> <name>gc_assign_weak</name></expr>;</expr_stmt>
<expr_stmt><expr><name>_Block_memmove</name> <operator>=</operator> <name>gc_memmove</name></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>_Block_use_GC5</name><parameter_list>( <parameter><function_decl><type><name>void</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>alloc</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name></type> <name>long</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>isOne</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>isObject</name></decl></parameter>)</parameter_list></function_decl></parameter>,
<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>setHasRefcount</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type></decl></parameter>)</parameter_list></function_decl></parameter>,
<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>gc_assign</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>gc_assign_weak</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>_Block_use_GC</name><argument_list>(<argument><expr><name>alloc</name></expr></argument>, <argument><expr><name>setHasRefcount</name></expr></argument>, <argument><expr><name>gc_assign</name></expr></argument>, <argument><expr><name>gc_assign_weak</name></expr></argument>, <argument><expr><name>_Block_memmove_gc_broken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>









<function><type><name>void</name></type> <name>_Block_use_RR</name><parameter_list>( <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>retain</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>release</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>_Block_retain_object</name> <operator>=</operator> <name>retain</name></expr>;</expr_stmt>
<expr_stmt><expr><name>_Block_release_object</name> <operator>=</operator> <name>release</name></expr>;</expr_stmt>
</block_content>}</block></function>





<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>mark</name> <name>Copy</name><name>/</name><name>Release</name> <name>support</name></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>_Block_copy_internal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>Block_layout</name></name> <modifier>*</modifier></type><name>aBlock</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>wantsOne</name> <init>= <expr><operator>(</operator><name>WANTS_ONE</name> <operator>&amp;</operator> <name>flags</name><operator>)</operator> <operator>==</operator> <name>WANTS_ONE</name></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name>arg</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>



<expr_stmt><expr><name>aBlock</name> <operator>=</operator> <operator>(</operator>struct <name>Block_layout</name> <operator>*</operator><operator>)</operator><name>arg</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>aBlock</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>BLOCK_NEEDS_FREE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>latching_incr_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aBlock</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>aBlock</name></expr>;</return>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>aBlock</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>BLOCK_IS_GC</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>wantsOne</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><call><name>latching_incr_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aBlock</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>BLOCK_REFCOUNT_MASK</name><operator>)</operator> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>_Block_setHasRefcount</name><argument_list>(<argument><expr><name>aBlock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>aBlock</name></expr>;</return>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>aBlock</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>BLOCK_IS_GLOBAL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>aBlock</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isGC</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>Block_layout</name></name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>malloc</name><argument_list>(<argument><expr><name><name>aBlock</name><operator>-&gt;</operator><name>descriptor</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>aBlock</name></expr></argument>, <argument><expr><name><name>aBlock</name><operator>-&gt;</operator><name>descriptor</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>BLOCK_REFCOUNT_MASK</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>BLOCK_NEEDS_FREE</name> <operator>|</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>isa</name></name> <operator>=</operator> <name>_NSConcreteMallocBlock</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>BLOCK_HAS_COPY_DISPOSE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call>(<modifier>*</modifier><name><name>aBlock</name><operator>-&gt;</operator><name>descriptor</name><operator>-&gt;</operator><name>copy</name></name>)<argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>aBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>


<decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>int</name></type> <name>flags</name> <init>= <expr><name><name>aBlock</name><operator>-&gt;</operator><name>flags</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>hasCTOR</name> <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>BLOCK_HAS_CTOR</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>Block_layout</name></name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>_Block_allocator</name><argument_list>(<argument><expr><name><name>aBlock</name><operator>-&gt;</operator><name>descriptor</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>wantsOne</name></expr></argument>, <argument><expr><name>hasCTOR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>aBlock</name></expr></argument>, <argument><expr><name><name>aBlock</name><operator>-&gt;</operator><name>descriptor</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>BLOCK_NEEDS_FREE</name><operator>|</operator><name>BLOCK_REFCOUNT_MASK</name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>wantsOne</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>BLOCK_IS_GC</name> <operator>|</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>BLOCK_IS_GC</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>BLOCK_HAS_COPY_DISPOSE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call>(<modifier>*</modifier><name><name>aBlock</name><operator>-&gt;</operator><name>descriptor</name><operator>-&gt;</operator><name>copy</name></name>)<argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>aBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>hasCTOR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>isa</name></name> <operator>=</operator> <name>_NSConcreteFinalizingBlock</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>isa</name></name> <operator>=</operator> <name>_NSConcreteAutoBlock</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>












<function><type><specifier>static</specifier> <name>void</name></type> <name>_Block_byref_assign_copy</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>Block_byref</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>destp</name> <init>= <expr><operator>(</operator>struct <name>Block_byref</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>dest</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>Block_byref</name></name> <modifier>*</modifier></type><name>src</name> <init>= <expr><operator>(</operator>struct <name>Block_byref</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>



<if_stmt><if>if <condition>(<expr><name><name>src</name><operator>-&gt;</operator><name>forwarding</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>BLOCK_IS_GC</name></expr>)</condition> <block>{<block_content>
<empty_stmt>;</empty_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>src</name><operator>-&gt;</operator><name>forwarding</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>BLOCK_REFCOUNT_MASK</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>


<decl_stmt><decl><type><name>bool</name></type> <name>isWeak</name> <init>= <expr><operator>(</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>BLOCK_FIELD_IS_BYREF</name><operator>|</operator><name>BLOCK_FIELD_IS_WEAK</name><operator>)</operator><operator>)</operator> <operator>==</operator> <operator>(</operator><name>BLOCK_FIELD_IS_BYREF</name><operator>|</operator><name>BLOCK_FIELD_IS_WEAK</name><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>Block_byref</name></name> <modifier>*</modifier></type><name>copy</name> <init>= <expr><operator>(</operator>struct <name>Block_byref</name> <operator>*</operator><operator>)</operator><call><name>_Block_allocator</name><argument_list>(<argument><expr><name><name>src</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>isWeak</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>copy</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>flags</name></name> <operator>|</operator> <name>_Byref_flag_initial_value</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>copy</name><operator>-&gt;</operator><name>forwarding</name></name> <operator>=</operator> <name>copy</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>src</name><operator>-&gt;</operator><name>forwarding</name></name> <operator>=</operator> <name>copy</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>copy</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>isWeak</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>copy</name><operator>-&gt;</operator><name>isa</name></name> <operator>=</operator> <operator>&amp;</operator><name>_NSConcreteWeakBlockVariable</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>src</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>BLOCK_HAS_COPY_DISPOSE</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name><name>copy</name><operator>-&gt;</operator><name>byref_keep</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>byref_keep</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>copy</name><operator>-&gt;</operator><name>byref_destroy</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>byref_destroy</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call>(<modifier>*</modifier><name><name>src</name><operator>-&gt;</operator><name>byref_keep</name></name>)<argument_list>(<argument><expr><name>copy</name></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>

<expr_stmt><expr><call><name>_Block_memmove</name><argument_list>(
<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>copy</name><operator>-&gt;</operator><name>byref_keep</name></name></expr></argument>,
<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>src</name><operator>-&gt;</operator><name>byref_keep</name></name></expr></argument>,
<argument><expr><name><name>src</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>Block_byref_header</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>src</name><operator>-&gt;</operator><name>forwarding</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>BLOCK_NEEDS_FREE</name><operator>)</operator> <operator>==</operator> <name>BLOCK_NEEDS_FREE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>latching_incr_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src</name><operator>-&gt;</operator><name>forwarding</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>_Block_assign</name><argument_list>(<argument><expr><name><name>src</name><operator>-&gt;</operator><name>forwarding</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>destp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>_Block_byref_release</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>Block_byref</name></name> <modifier>*</modifier></type><name>shared_struct</name> <init>= <expr><operator>(</operator>struct <name>Block_byref</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>refcount</name></decl>;</decl_stmt>


<expr_stmt><expr><name>shared_struct</name> <operator>=</operator> <name><name>shared_struct</name><operator>-&gt;</operator><name>forwarding</name></name></expr>;</expr_stmt>




<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>shared_struct</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>BLOCK_NEEDS_FREE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>refcount</name> <operator>=</operator> <name><name>shared_struct</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>BLOCK_REFCOUNT_MASK</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>refcount</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"_Block_byref_release: Block byref data structure at %p underflowed\n"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>(</operator><call><name>latching_decr_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared_struct</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>BLOCK_REFCOUNT_MASK</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>shared_struct</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>BLOCK_HAS_COPY_DISPOSE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call>(<modifier>*</modifier><name><name>shared_struct</name><operator>-&gt;</operator><name>byref_destroy</name></name>)<argument_list>(<argument><expr><name>shared_struct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>_Block_deallocator</name><argument_list>(<argument><expr><operator>(</operator>struct <name>Block_layout</name> <operator>*</operator><operator>)</operator><name>shared_struct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>









<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>mark</name> <name>SPI</name><name>/</name><name>API</name></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name> <modifier>*</modifier></type><name>_Block_copy</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>_Block_copy_internal</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>WANTS_ONE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<function><type><name>void</name></type> <name>_Block_release</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>Block_layout</name></name> <modifier>*</modifier></type><name>aBlock</name> <init>= <expr><operator>(</operator>struct <name>Block_layout</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name></type> <name>newCount</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>aBlock</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>newCount</name> <operator>=</operator> <call><name>latching_decr_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aBlock</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>BLOCK_REFCOUNT_MASK</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>newCount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>aBlock</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>BLOCK_IS_GC</name></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><call><name>_Block_setHasRefcount</name><argument_list>(<argument><expr><name>aBlock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>aBlock</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>BLOCK_NEEDS_FREE</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>aBlock</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>BLOCK_HAS_COPY_DISPOSE</name></expr>)</condition><block type="pseudo"><block_content><expr_stmt><expr><call>(<modifier>*</modifier><name><name>aBlock</name><operator>-&gt;</operator><name>descriptor</name><operator>-&gt;</operator><name>dispose</name></name>)<argument_list>(<argument><expr><name>aBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>_Block_deallocator</name><argument_list>(<argument><expr><name>aBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>aBlock</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>BLOCK_IS_GLOBAL</name></expr>)</condition> <block>{<block_content>
<empty_stmt>;</empty_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Block_release called upon a stack Block: %p, ignored\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>aBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type> <name>_Block_destroy</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>Block_layout</name></name> <modifier>*</modifier></type><name>aBlock</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>arg</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>aBlock</name> <operator>=</operator> <operator>(</operator>struct <name>Block_layout</name> <operator>*</operator><operator>)</operator><name>arg</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>aBlock</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>BLOCK_IS_GC</name></expr>)</condition> <block>{<block_content>

<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>_Block_release</name><argument_list>(<argument><expr><name>aBlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>










<function><type><name>void</name> <modifier>*</modifier></type><name>_Block_copy_collectable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>aBlock</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>_Block_copy_internal</name><argument_list>(<argument><expr><name>aBlock</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<function><type><name>unsigned</name> <name>long</name> <name>int</name></type> <name>Block_size</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><operator>(</operator><operator>(</operator>struct <name>Block_layout</name> <operator>*</operator><operator>)</operator><name>arg</name><operator>)</operator><operator>-&gt;</operator><name><name>descriptor</name><operator>-&gt;</operator><name>size</name></name></expr>;</return>
</block_content>}</block></function>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>mark</name> <name>Compiler</name> <name>SPI</name> <name>entry</name> <name>points</name></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>







































<function><type><name>void</name></type> <name>_Block_object_assign</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>destAddr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>object</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>BLOCK_BYREF_CALLER</name><operator>)</operator> <operator>==</operator> <name>BLOCK_BYREF_CALLER</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>BLOCK_FIELD_IS_WEAK</name><operator>)</operator> <operator>==</operator> <name>BLOCK_FIELD_IS_WEAK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>_Block_assign_weak</name><argument_list>(<argument><expr><name>object</name></expr></argument>, <argument><expr><name>destAddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>

<expr_stmt><expr><call><name>_Block_assign</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>object</name></expr></argument>, <argument><expr><name>destAddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>BLOCK_FIELD_IS_BYREF</name><operator>)</operator> <operator>==</operator> <name>BLOCK_FIELD_IS_BYREF</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><call><name>_Block_byref_assign_copy</name><argument_list>(<argument><expr><name>destAddr</name></expr></argument>, <argument><expr><name>object</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>BLOCK_FIELD_IS_BLOCK</name><operator>)</operator> <operator>==</operator> <name>BLOCK_FIELD_IS_BLOCK</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>_Block_assign</name><argument_list>(<argument><expr><call><name>_Block_copy_internal</name><argument_list>(<argument><expr><name>object</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>destAddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>BLOCK_FIELD_IS_OBJECT</name><operator>)</operator> <operator>==</operator> <name>BLOCK_FIELD_IS_OBJECT</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>_Block_retain_object</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>_Block_assign</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>object</name></expr></argument>, <argument><expr><name>destAddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>




<function><type><name>void</name></type> <name>_Block_object_dispose</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>object</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>BLOCK_FIELD_IS_BYREF</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>_Block_byref_release</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>BLOCK_FIELD_IS_BLOCK</name><operator>|</operator><name>BLOCK_BYREF_CALLER</name><operator>)</operator><operator>)</operator> <operator>==</operator> <name>BLOCK_FIELD_IS_BLOCK</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><call><name>_Block_destroy</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>BLOCK_FIELD_IS_WEAK</name><operator>|</operator><name>BLOCK_FIELD_IS_BLOCK</name><operator>|</operator><name>BLOCK_BYREF_CALLER</name><operator>)</operator><operator>)</operator> <operator>==</operator> <name>BLOCK_FIELD_IS_OBJECT</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><call><name>_Block_release_object</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>





<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>mark</name> <name>Debugging</name></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>_Block_dump</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>block</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>Block_layout</name></name> <modifier>*</modifier></type><name>closure</name> <init>= <expr><operator>(</operator>struct <name>Block_layout</name> <operator>*</operator><operator>)</operator><name>block</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>buffer</name><index>[<expr><literal type="number">512</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cp</name> <init>= <expr><name>buffer</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>closure</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"NULL passed to _Block_dump\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>buffer</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <operator>(</operator><name><name>closure</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>BLOCK_HAS_DESCRIPTOR</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Block compiled by obsolete compiler, please recompile source for this Block\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>cp</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"^%p (new layout) =\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>closure</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>closure</name><operator>-&gt;</operator><name>isa</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cp</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"isa: NULL\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>closure</name><operator>-&gt;</operator><name>isa</name></name> <operator>==</operator> <name>_NSConcreteStackBlock</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cp</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"isa: stack Block\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>closure</name><operator>-&gt;</operator><name>isa</name></name> <operator>==</operator> <name>_NSConcreteMallocBlock</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cp</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"isa: malloc heap Block\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>closure</name><operator>-&gt;</operator><name>isa</name></name> <operator>==</operator> <name>_NSConcreteAutoBlock</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cp</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"isa: GC heap Block\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>closure</name><operator>-&gt;</operator><name>isa</name></name> <operator>==</operator> <name>_NSConcreteGlobalBlock</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cp</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"isa: global Block\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>closure</name><operator>-&gt;</operator><name>isa</name></name> <operator>==</operator> <name>_NSConcreteFinalizingBlock</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cp</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"isa: finalizing Block\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>cp</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"isa?: %p\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>closure</name><operator>-&gt;</operator><name>isa</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>cp</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"flags:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>closure</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>BLOCK_HAS_DESCRIPTOR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cp</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">" HASDESCRIPTOR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>closure</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>BLOCK_NEEDS_FREE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cp</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">" FREEME"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>closure</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>BLOCK_IS_GC</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cp</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">" ISGC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>closure</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>BLOCK_HAS_COPY_DISPOSE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cp</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">" HASHELP"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>closure</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>BLOCK_HAS_CTOR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cp</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">" HASCTOR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>cp</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"\nrefcount: %u\n"</literal></expr></argument>, <argument><expr><name><name>closure</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>BLOCK_REFCOUNT_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cp</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"invoke: %p\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><name><name>closure</name><operator>-&gt;</operator><name>invoke</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>Block_descriptor</name></name> <modifier>*</modifier></type><name>dp</name> <init>= <expr><name><name>closure</name><operator>-&gt;</operator><name>descriptor</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>cp</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"descriptor: %p\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cp</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"descriptor-&gt;reserved: %lu\n"</literal></expr></argument>, <argument><expr><name><name>dp</name><operator>-&gt;</operator><name>reserved</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cp</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"descriptor-&gt;size: %lu\n"</literal></expr></argument>, <argument><expr><name><name>dp</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>closure</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>BLOCK_HAS_COPY_DISPOSE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cp</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"descriptor-&gt;copy helper: %p\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><name><name>dp</name><operator>-&gt;</operator><name>copy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cp</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"descriptor-&gt;dispose helper: %p\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><name><name>dp</name><operator>-&gt;</operator><name>dispose</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<return>return <expr><name>buffer</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>_Block_byref_dump</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Block_byref</name></name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>buffer</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cp</name> <init>= <expr><name>buffer</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>cp</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">"byref data block %p contents:\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cp</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">" forwarding: %p\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>src</name><operator>-&gt;</operator><name>forwarding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cp</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">" flags: 0x%x\n"</literal></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cp</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">" size: %d\n"</literal></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>src</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>BLOCK_HAS_COPY_DISPOSE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cp</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">" copy helper: %p\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><name><name>src</name><operator>-&gt;</operator><name>byref_keep</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cp</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="string">" dispose helper: %p\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><name><name>src</name><operator>-&gt;</operator><name>byref_destroy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>buffer</name></expr>;</return>
</block_content>}</block></function>

</unit>
