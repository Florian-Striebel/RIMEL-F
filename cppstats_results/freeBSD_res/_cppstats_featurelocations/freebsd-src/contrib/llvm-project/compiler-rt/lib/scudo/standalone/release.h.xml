<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/compiler-rt/lib/scudo/standalone/release.h">







<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SCUDO_RELEASE_H_</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCUDO_RELEASE_H_</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mutex.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>scudo</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>ReleaseRecorder</name> <block>{<block_content>
<label><name>public</name>:</label>
<macro><name>ReleaseRecorder</name><argument_list>(<argument>uptr Base</argument>, <argument>MapPlatformData *Data = nullptr</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>Base</name><argument_list>(<argument><expr><name>Base</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Data</name><argument_list>(<argument>Data</argument>)</argument_list></macro> <expr><block>{}</block>

<name>uptr</name> <macro><name>getReleasedRangesCount</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ReleasedRangesCount</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>uptr</name> <macro><name>getReleasedBytes</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ReleasedBytes</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>uptr</name> <macro><name>getBase</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Base</name></expr>;</return> }</block></expr></expr_stmt>


<function><type><name>void</name></type> <name>releasePageRangeToOS</name><parameter_list>(<parameter><decl><type><name>uptr</name></type> <name>From</name></decl></parameter>, <parameter><decl><type><name>uptr</name></type> <name>To</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>uptr</name></type> <name>Size</name> <init>= <expr><name>To</name> <operator>-</operator> <name>From</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>releasePagesToOS</name><argument_list>(<argument><expr><name>Base</name></expr></argument>, <argument><expr><name>From</name></expr></argument>, <argument><expr><name>Size</name></expr></argument>, <argument><expr><name>Data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ReleasedRangesCount</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>ReleasedBytes</name> <operator>+=</operator> <name>Size</name></expr>;</expr_stmt>
</block_content>}</block></function>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>uptr</name></type> <name>ReleasedRangesCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uptr</name></type> <name>ReleasedBytes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uptr</name></type> <name>Base</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MapPlatformData</name> <modifier>*</modifier></type><name>Data</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>









<decl_stmt><decl><type><name>class</name></type> <name>PackedCounterArray</name> <block>{<block_content>
<label><name>public</name>:</label>
<macro><name>PackedCounterArray</name><argument_list>(<argument>uptr NumberOfRegions</argument>, <argument>uptr CountersPerRegion</argument>,
<argument>uptr MaxValue</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>Regions</name><argument_list>(<argument><expr><name>NumberOfRegions</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>NumCounters</name><argument_list>(<argument>CountersPerRegion</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>DCHECK_GT</name><argument_list>(<argument><expr><name>Regions</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>DCHECK_GT</name><argument_list>(<argument><expr><name>NumCounters</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>DCHECK_GT</name><argument_list>(<argument><expr><name>MaxValue</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;
<expr><name>constexpr</name> <name>uptr</name> <name>MaxCounterBits</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>Buffer</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">8UL</literal></expr>;


<expr><specifier>const</specifier> <name>uptr</name> <name>CounterSizeBits</name> <operator>=</operator>
<call><name>roundUpToPowerOfTwo</name><argument_list>(<argument><expr><call><name>getMostSignificantSetBitIndex</name><argument_list>(<argument><expr><name>MaxValue</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>DCHECK_LE</name><argument_list>(<argument><expr><name>CounterSizeBits</name></expr></argument>, <argument><expr><name>MaxCounterBits</name></expr></argument>)</argument_list></call></expr>;
<expr><name>CounterSizeBitsLog</name> <operator>=</operator> <call><name>getLog2</name><argument_list>(<argument><expr><name>CounterSizeBits</name></expr></argument>)</argument_list></call></expr>;
<expr><name>CounterMask</name> <operator>=</operator> <operator>~</operator><operator>(</operator><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>uptr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;&gt;</operator> <operator>(</operator><name>MaxCounterBits</name> <operator>-</operator> <name>CounterSizeBits</name><operator>)</operator></expr>;

<expr><specifier>const</specifier> <name>uptr</name> <name>PackingRatio</name> <operator>=</operator> <name>MaxCounterBits</name> <operator>&gt;&gt;</operator> <name>CounterSizeBitsLog</name></expr>;
<expr><call><name>DCHECK_GT</name><argument_list>(<argument><expr><name>PackingRatio</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;
<expr><name>PackingRatioLog</name> <operator>=</operator> <call><name>getLog2</name><argument_list>(<argument><expr><name>PackingRatio</name></expr></argument>)</argument_list></call></expr>;
<expr><name>BitOffsetMask</name> <operator>=</operator> <name>PackingRatio</name> <operator>-</operator> <literal type="number">1</literal></expr>;

<expr><name>SizePerRegion</name> <operator>=</operator>
<call><name>roundUpTo</name><argument_list>(<argument><expr><name>NumCounters</name></expr></argument>, <argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>uptr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><literal type="number">1U</literal></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <name>PackingRatioLog</name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator>
<name>PackingRatioLog</name></expr>;
<expr><name>BufferSize</name> <operator>=</operator> <name>SizePerRegion</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>Buffer</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>Regions</name></expr>;
<if_stmt><if>if <condition>(<expr><name>BufferSize</name> <operator>&lt;=</operator> <operator>(</operator><name>StaticBufferCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>Buffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>&amp;&amp;</operator>
<call><name><name>Mutex</name><operator>.</operator><name>tryLock</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Buffer</name> <operator>=</operator> <operator>&amp;</operator><name><name>StaticBuffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>Buffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BufferSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content> else <block>{<block_content>
<expr_stmt><expr><name>Buffer</name> <operator>=</operator> <call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>uptr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name>map</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>, <argument><expr><call><name>roundUpTo</name><argument_list>(<argument><expr><name>BufferSize</name></expr></argument>, <argument><expr><call><name>getPageSizeCached</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><literal type="string">"scudo:counters"</literal></expr></argument>, <argument><expr><name>MAP_ALLOWNOMEM</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
}
~PackedCounterArray(</block></block></if></if_stmt>) <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isAllocated</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt></block></block></expr></expr_stmt>
<if_stmt><if>if <condition>(<expr><name>Buffer</name> <operator>==</operator> <operator>&amp;</operator><name><name>StaticBuffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>Mutex</name><operator>.</operator><name>unlock</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>unmap</name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>void</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Buffer</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>roundUpTo</name><argument_list>(<argument><expr><name>BufferSize</name></expr></argument>, <argument><expr><call><name>getPageSizeCached</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isAllocated</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>!</operator><operator>!</operator><name>Buffer</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>uptr</name> <macro><name>getCount</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NumCounters</name></expr>;</return> }</block></expr></expr_stmt>

<decl_stmt><decl><type><name>uptr</name></type> <name>get</name><argument_list>(<argument><expr><name>uptr</name> <name>Region</name></expr></argument>, <argument><expr><name>uptr</name> <name>I</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><call><name>DCHECK_LT</name><argument_list>(<argument><expr><name>Region</name></expr></argument>, <argument><expr><name>Regions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DCHECK_LT</name><argument_list>(<argument><expr><name>I</name></expr></argument>, <argument><expr><name>NumCounters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uptr</name></type> <name>Index</name> <init>= <expr><name>I</name> <operator>&gt;&gt;</operator> <name>PackingRatioLog</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uptr</name></type> <name>BitOffset</name> <init>= <expr><operator>(</operator><name>I</name> <operator>&amp;</operator> <name>BitOffsetMask</name><operator>)</operator> <operator>&lt;&lt;</operator> <name>CounterSizeBitsLog</name></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>(</operator><name><name>Buffer</name><index>[<expr><name>Region</name> <operator>*</operator> <name>SizePerRegion</name> <operator>+</operator> <name>Index</name></expr>]</index></name> <operator>&gt;&gt;</operator> <name>BitOffset</name><operator>)</operator> <operator>&amp;</operator> <name>CounterMask</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>inc</name><argument_list>(<argument><expr><name>uptr</name> <name>Region</name></expr></argument>, <argument><expr><name>uptr</name> <name>I</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><call><name>DCHECK_LT</name><argument_list>(<argument><expr><call><name>get</name><argument_list>(<argument><expr><name>Region</name></expr></argument>, <argument><expr><name>I</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>CounterMask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uptr</name></type> <name>Index</name> <init>= <expr><name>I</name> <operator>&gt;&gt;</operator> <name>PackingRatioLog</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uptr</name></type> <name>BitOffset</name> <init>= <expr><operator>(</operator><name>I</name> <operator>&amp;</operator> <name>BitOffsetMask</name><operator>)</operator> <operator>&lt;&lt;</operator> <name>CounterSizeBitsLog</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>DCHECK_LT</name><argument_list>(<argument><expr><name>BitOffset</name></expr></argument>, <argument><expr><name>SCUDO_WORDSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Buffer</name><index>[<expr><name>Region</name> <operator>*</operator> <name>SizePerRegion</name> <operator>+</operator> <name>Index</name></expr>]</index></name> <operator>+=</operator> <call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>uptr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><literal type="number">1U</literal></expr></argument>)</argument_list></call>
<operator>&lt;&lt;</operator> <name>BitOffset</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>incRange</name><argument_list>(<argument><expr><name>uptr</name> <name>Region</name></expr></argument>, <argument><expr><name>uptr</name> <name>From</name></expr></argument>, <argument><expr><name>uptr</name> <name>To</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><call><name>DCHECK_LE</name><argument_list>(<argument><expr><name>From</name></expr></argument>, <argument><expr><name>To</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uptr</name></type> <name>Top</name> <init>= <expr><call><name>Min</name><argument_list>(<argument><expr><name>To</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>NumCounters</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>uptr</name></type> <name>I</name> <init>= <expr><name>From</name></expr></init></decl>;</init> <condition><expr><name>I</name> <operator>&lt;</operator> <name>Top</name></expr>;</condition> <incr><expr><name>I</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>inc</name><argument_list>(<argument><expr><name>Region</name></expr></argument>, <argument><expr><name>I</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name>uptr</name> <macro><name>getBufferSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>BufferSize</name></expr>;</return> }</block></expr></expr_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uptr</name></type> <name>StaticBufferCount</name> <init>= <expr><literal type="number">2048U</literal></expr></init></decl>;</decl_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><specifier>const</specifier> <name>uptr</name></type> <name>Regions</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uptr</name></type> <name>NumCounters</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uptr</name></type> <name>CounterSizeBitsLog</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uptr</name></type> <name>CounterMask</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uptr</name></type> <name>PackingRatioLog</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uptr</name></type> <name>BitOffsetMask</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uptr</name></type> <name>SizePerRegion</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uptr</name></type> <name>BufferSize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uptr</name> <modifier>*</modifier></type><name>Buffer</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>HybridMutex</name></type> <name>Mutex</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uptr</name></type> <name><name>StaticBuffer</name><index>[<expr><name>StaticBufferCount</name></expr>]</index></name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>ReleaseRecorderT</name></expr></argument>&gt;</argument_list></name> <name>class</name></type> <name>FreePagesRangeTracker</name> <block>{<block_content>
<label><name>public</name>:</label>
<macro><name>explicit</name></macro> <expr_stmt><expr><call><name>FreePagesRangeTracker</name><argument_list>(<argument><expr><name>ReleaseRecorderT</name> <operator>*</operator><name>Recorder</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>Recorder</name><argument_list>(<argument><expr><name>Recorder</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>PageSizeLog</name><argument_list>(<argument>getLog2(getPageSizeCached())</argument>)</argument_list></macro> <expr><block>{}</block>

<name>void</name> <macro><name>processNextPage</name><argument_list>(<argument>bool Freed</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><name>Freed</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>InRange</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>CurrentRangeStatePage</name> <operator>=</operator> <name>CurrentPage</name></expr>;</expr_stmt>
<expr_stmt><expr><name>InRange</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
} else <block>{<block_content>
<expr_stmt><expr><call><name>closeOpenedRange</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
CurrentPage++</block></block><empty_stmt>;</empty_stmt></if></if_stmt>
<expr_stmt/>}</block_content>

void skipPages(uptr N</block></if></if_stmt>) <block>{
<expr><call><name>closeOpenedRange</name><argument_list>()</argument_list></call></expr>;
<expr><name>CurrentPage</name> <operator>+=</operator> <name>N</name></expr>;
}</block></block>

<name>void</name> <macro><name>finish</name><argument_list>()</argument_list></macro> <block>{ <expr><call><name>closeOpenedRange</name><argument_list>()</argument_list></call></expr>; }</block>

<name>private</name><operator>:</operator>
<name>void</name> <macro><name>closeOpenedRange</name><argument_list>()</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><name>InRange</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>Recorder</name><operator>-&gt;</operator><name>releasePageRangeToOS</name></name><argument_list>(<argument><expr><operator>(</operator><name>CurrentRangeStatePage</name> <operator>&lt;&lt;</operator> <name>PageSizeLog</name><operator>)</operator></expr></argument>,
<argument><expr><operator>(</operator><name>CurrentPage</name> <operator>&lt;&lt;</operator> <name>PageSizeLog</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>InRange</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
}

ReleaseRecorderT *const Recorder</block><empty_stmt>;</empty_stmt></if></if_stmt>
<specifier>const</specifier> <name>uptr</name> <name>PageSizeLog</name></block></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>InRange</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uptr</name></type> <name>CurrentPage</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uptr</name></type> <name>CurrentRangeStatePage</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>TransferBatchT</name></expr></argument>, <argument><expr><name>class</name> <name>ReleaseRecorderT</name></expr></argument>, <argument><expr><name>typename</name> <name>DecompactPtrT</name></expr></argument>,
<argument><expr><name>typename</name> <name>SkipRegionT</name></expr></argument>&gt;</argument_list></name>
<name>NOINLINE</name> <name>void</name></type>
<name>releaseFreeMemoryToOS</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>IntrusiveList</name><argument_list type="generic">&lt;<argument><expr><name>TransferBatchT</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>FreeList</name></decl></parameter>,
<parameter><decl><type><name>uptr</name></type> <name>RegionSize</name></decl></parameter>, <parameter><decl><type><name>uptr</name></type> <name>NumberOfRegions</name></decl></parameter>, <parameter><decl><type><name>uptr</name></type> <name>BlockSize</name></decl></parameter>,
<parameter><decl><type><name>ReleaseRecorderT</name> <modifier>*</modifier></type><name>Recorder</name></decl></parameter>, <parameter><decl><type><name>DecompactPtrT</name></type> <name>DecompactPtr</name></decl></parameter>,
<parameter><decl><type><name>SkipRegionT</name></type> <name>SkipRegion</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>uptr</name></type> <name>PageSize</name> <init>= <expr><call><name>getPageSizeCached</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>uptr</name></type> <name>FullPagesBlockCountMax</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>SameBlockCountPerPage</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>BlockSize</name> <operator>&lt;=</operator> <name>PageSize</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>PageSize</name> <operator>%</operator> <name>BlockSize</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>FullPagesBlockCountMax</name> <operator>=</operator> <name>PageSize</name> <operator>/</operator> <name>BlockSize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>SameBlockCountPerPage</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>BlockSize</name> <operator>%</operator> <operator>(</operator><name>PageSize</name> <operator>%</operator> <name>BlockSize</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><name>FullPagesBlockCountMax</name> <operator>=</operator> <name>PageSize</name> <operator>/</operator> <name>BlockSize</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>SameBlockCountPerPage</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>


<expr_stmt><expr><name>FullPagesBlockCountMax</name> <operator>=</operator> <name>PageSize</name> <operator>/</operator> <name>BlockSize</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>SameBlockCountPerPage</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>BlockSize</name> <operator>%</operator> <name>PageSize</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>FullPagesBlockCountMax</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>SameBlockCountPerPage</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>


<expr_stmt><expr><name>FullPagesBlockCountMax</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>SameBlockCountPerPage</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>uptr</name></type> <name>PagesCount</name> <init>= <expr><call><name>roundUpTo</name><argument_list>(<argument><expr><name>RegionSize</name></expr></argument>, <argument><expr><name>PageSize</name></expr></argument>)</argument_list></call> <operator>/</operator> <name>PageSize</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PackedCounterArray</name></type> <name>Counters</name><argument_list>(<argument><expr><name>NumberOfRegions</name></expr></argument>, <argument><expr><name>PagesCount</name></expr></argument>,
<argument><expr><name>FullPagesBlockCountMax</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>Counters</name><operator>.</operator><name>isAllocated</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>uptr</name></type> <name>PageSizeLog</name> <init>= <expr><call><name>getLog2</name><argument_list>(<argument><expr><name>PageSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uptr</name></type> <name>RoundedRegionSize</name> <init>= <expr><name>PagesCount</name> <operator>&lt;&lt;</operator> <name>PageSizeLog</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uptr</name></type> <name>RoundedSize</name> <init>= <expr><name>NumberOfRegions</name> <operator>*</operator> <name>RoundedRegionSize</name></expr></init></decl>;</decl_stmt>



<if_stmt><if>if <condition>(<expr><name>BlockSize</name> <operator>&lt;=</operator> <name>PageSize</name> <operator>&amp;&amp;</operator> <name>PageSize</name> <operator>%</operator> <name>BlockSize</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>&amp;</modifier></type><name>It</name> <range>: <expr><name>FreeList</name></expr></range></decl></init>)</control> <block>{<block_content>
<for>for <control>(<init><decl><type><name>u32</name></type> <name>I</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>I</name> <operator>&lt;</operator> <call><name><name>It</name><operator>.</operator><name>getCount</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>I</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>uptr</name></type> <name>P</name> <init>= <expr><call><name>DecompactPtr</name><argument_list>(<argument><expr><call><name><name>It</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>-</operator> <call><name><name>Recorder</name><operator>-&gt;</operator><name>getBase</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>P</name> <operator>&gt;=</operator> <name>RoundedSize</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uptr</name></type> <name>RegionIndex</name> <init>= <expr><ternary><condition><expr><name>NumberOfRegions</name> <operator>==</operator> <literal type="number">1U</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>P</name> <operator>/</operator> <name>RegionSize</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uptr</name></type> <name>PInRegion</name> <init>= <expr><name>P</name> <operator>-</operator> <name>RegionIndex</name> <operator>*</operator> <name>RegionSize</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>Counters</name><operator>.</operator><name>inc</name></name><argument_list>(<argument><expr><name>RegionIndex</name></expr></argument>, <argument><expr><name>PInRegion</name> <operator>&gt;&gt;</operator> <name>PageSizeLog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>DCHECK_GE</name><argument_list>(<argument><expr><name>RegionSize</name></expr></argument>, <argument><expr><name>BlockSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uptr</name></type> <name>LastBlockInRegion</name> <init>= <expr><operator>(</operator><operator>(</operator><name>RegionSize</name> <operator>/</operator> <name>BlockSize</name><operator>)</operator> <operator>-</operator> <literal type="number">1U</literal><operator>)</operator> <operator>*</operator> <name>BlockSize</name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>&amp;</modifier></type><name>It</name> <range>: <expr><name>FreeList</name></expr></range></decl></init>)</control> <block>{<block_content>
<for>for <control>(<init><decl><type><name>u32</name></type> <name>I</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>I</name> <operator>&lt;</operator> <call><name><name>It</name><operator>.</operator><name>getCount</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>I</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>uptr</name></type> <name>P</name> <init>= <expr><call><name>DecompactPtr</name><argument_list>(<argument><expr><call><name><name>It</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>-</operator> <call><name><name>Recorder</name><operator>-&gt;</operator><name>getBase</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>P</name> <operator>&gt;=</operator> <name>RoundedSize</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uptr</name></type> <name>RegionIndex</name> <init>= <expr><ternary><condition><expr><name>NumberOfRegions</name> <operator>==</operator> <literal type="number">1U</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>P</name> <operator>/</operator> <name>RegionSize</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uptr</name></type> <name>PInRegion</name> <init>= <expr><name>P</name> <operator>-</operator> <name>RegionIndex</name> <operator>*</operator> <name>RegionSize</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>Counters</name><operator>.</operator><name>incRange</name></name><argument_list>(<argument><expr><name>RegionIndex</name></expr></argument>, <argument><expr><name>PInRegion</name> <operator>&gt;&gt;</operator> <name>PageSizeLog</name></expr></argument>,
<argument><expr><operator>(</operator><name>PInRegion</name> <operator>+</operator> <name>BlockSize</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&gt;&gt;</operator> <name>PageSizeLog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>PInRegion</name> <operator>==</operator> <name>LastBlockInRegion</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>PInRegion</name> <operator>+=</operator> <name>BlockSize</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>PInRegion</name> <operator>&lt;</operator> <name>RoundedRegionSize</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>Counters</name><operator>.</operator><name>incRange</name></name><argument_list>(<argument><expr><name>RegionIndex</name></expr></argument>, <argument><expr><name>PInRegion</name> <operator>&gt;&gt;</operator> <name>PageSizeLog</name></expr></argument>,
<argument><expr><operator>(</operator><name>PInRegion</name> <operator>+</operator> <name>BlockSize</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&gt;&gt;</operator> <name>PageSizeLog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>PInRegion</name> <operator>+=</operator> <name>BlockSize</name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>



<decl_stmt><decl><type><name><name>FreePagesRangeTracker</name><argument_list type="generic">&lt;<argument><expr><name>ReleaseRecorderT</name></expr></argument>&gt;</argument_list></name></type> <name>RangeTracker</name><argument_list>(<argument><expr><name>Recorder</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>SameBlockCountPerPage</name></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><decl><type><name>uptr</name></type> <name>I</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>I</name> <operator>&lt;</operator> <name>NumberOfRegions</name></expr>;</condition> <incr><expr><name>I</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>SkipRegion</name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>RangeTracker</name><operator>.</operator><name>skipPages</name></name><argument_list>(<argument><expr><name>PagesCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><decl><type><name>uptr</name></type> <name>J</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>J</name> <operator>&lt;</operator> <name>PagesCount</name></expr>;</condition> <incr><expr><name>J</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>RangeTracker</name><operator>.</operator><name>processNextPage</name></name><argument_list>(<argument><expr><call><name><name>Counters</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>I</name></expr></argument>, <argument><expr><name>J</name></expr></argument>)</argument_list></call> <operator>==</operator>
<name>FullPagesBlockCountMax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></for>
</block_content>}</block></if> <else>else <block>{<block_content>


<decl_stmt><decl><type><specifier>const</specifier> <name>uptr</name></type> <name>Pn</name> <init>= <expr><ternary><condition><expr><name>BlockSize</name> <operator>&lt;</operator> <name>PageSize</name></expr> ?</condition><then> <expr><name>PageSize</name> <operator>/</operator> <name>BlockSize</name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uptr</name></type> <name>Pnc</name> <init>= <expr><name>Pn</name> <operator>*</operator> <name>BlockSize</name></expr></init></decl>;</decl_stmt>





<for>for <control>(<init><decl><type><name>uptr</name></type> <name>I</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>I</name> <operator>&lt;</operator> <name>NumberOfRegions</name></expr>;</condition> <incr><expr><name>I</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>SkipRegion</name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>RangeTracker</name><operator>.</operator><name>skipPages</name></name><argument_list>(<argument><expr><name>PagesCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>uptr</name></type> <name>PrevPageBoundary</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uptr</name></type> <name>CurrentBoundary</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>uptr</name></type> <name>J</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>J</name> <operator>&lt;</operator> <name>PagesCount</name></expr>;</condition> <incr><expr><name>J</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>uptr</name></type> <name>PageBoundary</name> <init>= <expr><name>PrevPageBoundary</name> <operator>+</operator> <name>PageSize</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uptr</name></type> <name>BlocksPerPage</name> <init>= <expr><name>Pn</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>CurrentBoundary</name> <operator>&lt;</operator> <name>PageBoundary</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>CurrentBoundary</name> <operator>&gt;</operator> <name>PrevPageBoundary</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>BlocksPerPage</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>CurrentBoundary</name> <operator>+=</operator> <name>Pnc</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>CurrentBoundary</name> <operator>&lt;</operator> <name>PageBoundary</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>BlocksPerPage</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>CurrentBoundary</name> <operator>+=</operator> <name>BlockSize</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>PrevPageBoundary</name> <operator>=</operator> <name>PageBoundary</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>RangeTracker</name><operator>.</operator><name>processNextPage</name></name><argument_list>(<argument><expr><call><name><name>Counters</name><operator>.</operator><name>get</name></name><argument_list>(<argument><expr><name>I</name></expr></argument>, <argument><expr><name>J</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BlocksPerPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name><name>RangeTracker</name><operator>.</operator><name>finish</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
