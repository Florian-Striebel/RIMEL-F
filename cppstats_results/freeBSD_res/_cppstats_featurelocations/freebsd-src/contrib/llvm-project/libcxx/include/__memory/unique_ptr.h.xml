<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/libcxx/include/__memory/unique_ptr.h">








<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_LIBCPP___MEMORY_UNIQUE_PTR_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_LIBCPP___MEMORY_UNIQUE_PTR_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;__config&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;__functional_base&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;__functional/hash.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;__functional/operations.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;__memory/allocator_traits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;__memory/compressed_pair.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;__utility/forward.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstddef&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;type_traits&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utility&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>_LIBCPP_STD_VER</name> <operator>&lt;=</operator> <literal type="number">14</literal> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;__memory/auto_ptr.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>GCC</name> <name>system_header</name></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>_LIBCPP_PUSH_MACROS</name>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;__undef_macros&gt;</cpp:file></cpp:include>

<name>_LIBCPP_BEGIN_NAMESPACE_STD</name>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>_Tp</name></expr></argument>&gt;</argument_list></name>
struct <name>_LIBCPP_TEMPLATE_VIS</name> <name>default_delete</name> <block>{
<expr><call><name>static_assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>is_function</name><argument_list type="generic">&lt;<argument><expr><name>_Tp</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>,
<argument><expr><literal type="string">"default_delete cannot be instantiated for function types"</literal></expr></argument>)</argument_list></call></expr>;
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_LIBCPP_CXX03_LANG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><name>_LIBCPP_INLINE_VISIBILITY</name> <name>constexpr</name> <macro><name>default_delete</name><argument_list>()</argument_list></macro> <name>_NOEXCEPT</name> <operator>=</operator> default</expr>;
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr><name>_LIBCPP_INLINE_VISIBILITY</name> <macro><name>default_delete</name><argument_list>()</argument_list></macro> <block>{}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>_Up</name></expr></argument>&gt;</argument_list></name>
<name>_LIBCPP_INLINE_VISIBILITY</name>
<macro><name>default_delete</name><argument_list>(<argument>const default_delete&lt;_Up&gt;&amp;</argument>,
<argument>typename enable_if&lt;is_convertible&lt;_Up*</argument>, <argument>_Tp*&gt;::value&gt;::type* =
<literal type="number">0</literal></argument>)</argument_list></macro> <name>_NOEXCEPT</name> <block>{}</block>

<name>_LIBCPP_INLINE_VISIBILITY</name> <name>void</name> <macro><name>operator</name><argument_list>()</argument_list></macro><operator>(</operator><name>_Tp</name><operator>*</operator> <name>__ptr</name><operator>)</operator> <specifier>const</specifier> <name>_NOEXCEPT</name> <block>{
<expr><call><name>static_assert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>_Tp</name></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>,
<argument><expr><literal type="string">"default_delete can not delete incomplete type"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>static_assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>is_void</name><argument_list type="generic">&lt;<argument><expr><name>_Tp</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>,
<argument><expr><literal type="string">"default_delete can not delete incomplete type"</literal></expr></argument>)</argument_list></call></expr>;
<expr><name>delete</name> <name>__ptr</name></expr>;
}</block></expr>
}</block></expr>;</expr_stmt>

<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>class</name> <name>_Tp</name><operator>&gt;</operator>
struct <name>_LIBCPP_TEMPLATE_VIS</name> <name><name>default_delete</name><argument_list type="generic">&lt;<argument><expr><name><name>_Tp</name><index>[]</index></name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>private</name><operator>:</operator>
<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>_Up</name></expr></argument>&gt;</argument_list></name>
struct <name>_EnableIfConvertible</name>
<operator>:</operator> <name>enable_if</name><operator>&lt;</operator><name>is_convertible</name><operator>&lt;</operator><call><name>_Up</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><index>[]</index></expr>, <expr><call><name>_Tp</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><index>[]</index><operator>&gt;</operator><operator>::</operator><name>value</name><operator>&gt;</operator> <block>{}</block></expr>;

<expr><name>public</name><operator>:</operator>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_LIBCPP_CXX03_LANG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<name>_LIBCPP_INLINE_VISIBILITY</name> <name>constexpr</name> <macro><name>default_delete</name><argument_list>()</argument_list></macro> <name>_NOEXCEPT</name> <operator>=</operator> default</expr>;
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr><name>_LIBCPP_INLINE_VISIBILITY</name> <macro><name>default_delete</name><argument_list>()</argument_list></macro> <block>{}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>_Up</name></expr></argument>&gt;</argument_list></name>
<name>_LIBCPP_INLINE_VISIBILITY</name>
<macro><name>default_delete</name><argument_list>(<argument>const default_delete&lt;_Up[]&gt;&amp;</argument>,
<argument>typename _EnableIfConvertible&lt;_Up&gt;::type* = <literal type="number">0</literal></argument>)</argument_list></macro> <name>_NOEXCEPT</name> <block>{}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>_Up</name></expr></argument>&gt;</argument_list></name>
<name>_LIBCPP_INLINE_VISIBILITY</name>
<name>typename</name> <name><name>_EnableIfConvertible</name><argument_list type="generic">&lt;<argument><expr><name>_Up</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name>
<macro><name>operator</name><argument_list>()</argument_list></macro><operator>(</operator><name>_Up</name><operator>*</operator> <name>__ptr</name><operator>)</operator> <specifier>const</specifier> <name>_NOEXCEPT</name> <block>{
<expr><call><name>static_assert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>_Tp</name></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>,
<argument><expr><literal type="string">"default_delete can not delete incomplete type"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>static_assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>is_void</name><argument_list type="generic">&lt;<argument><expr><name>_Tp</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>,
<argument><expr><literal type="string">"default_delete can not delete void type"</literal></expr></argument>)</argument_list></call></expr>;
<expr><name><name>delete</name><index>[]</index></name> <name>__ptr</name></expr>;
}</block></expr>
}</block></expr>;</expr_stmt>

<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>class</name> <name>_Deleter</name><operator>&gt;</operator>
struct <name>__unique_ptr_deleter_sfinae</name> <block>{
<expr><call><name>static_assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>is_reference</name><argument_list type="generic">&lt;<argument><expr><name>_Deleter</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>, <argument><expr><literal type="string">"incorrect specialization"</literal></expr></argument>)</argument_list></call></expr>;
<typedef>typedef <type><specifier>const</specifier> <name>_Deleter</name><modifier>&amp;</modifier></type> <name>__lval_ref_type</name>;</typedef></block></expr></expr_stmt>
<typedef>typedef <expr_stmt><expr><name>_Deleter</name><operator>&amp;&amp;</operator> <name>__good_rval_ref_type</name></expr>;</expr_stmt></typedef>
<typedef>typedef <type><name>true_type</name></type> <name>__enable_rval_overload</name>;</typedef>
};

<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>class</name> <name>_Deleter</name><operator>&gt;</operator>
struct <name><name>__unique_ptr_deleter_sfinae</name><argument_list type="generic">&lt;<argument><expr><name>_Deleter</name> <specifier>const</specifier><operator>&amp;</operator></expr></argument>&gt;</argument_list></name> <block>{
<typedef>typedef <type><specifier>const</specifier> <name>_Deleter</name><modifier>&amp;</modifier></type> <name>__lval_ref_type</name>;</typedef></block></expr></expr_stmt>
<typedef>typedef <expr_stmt><expr><specifier>const</specifier> <name>_Deleter</name><operator>&amp;&amp;</operator> <name>__bad_rval_ref_type</name></expr>;</expr_stmt></typedef>
<typedef>typedef <type><name>false_type</name></type> <name>__enable_rval_overload</name>;</typedef>
};

<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>class</name> <name>_Deleter</name><operator>&gt;</operator>
struct <name><name>__unique_ptr_deleter_sfinae</name><argument_list type="generic">&lt;<argument><expr><name>_Deleter</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name> <block>{
<typedef>typedef <type><name>_Deleter</name><modifier>&amp;</modifier></type> <name>__lval_ref_type</name>;</typedef></block></expr></expr_stmt>
<typedef>typedef <expr_stmt><expr><name>_Deleter</name><operator>&amp;&amp;</operator> <name>__bad_rval_ref_type</name></expr>;</expr_stmt></typedef>
<typedef>typedef <type><name>false_type</name></type> <name>__enable_rval_overload</name>;</typedef>
};

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_LIBCPP_ABI_ENABLE_UNIQUE_PTR_TRIVIAL_ABI</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_LIBCPP_UNIQUE_PTR_TRIVIAL_ABI</name></cpp:macro> <cpp:value>__attribute__((trivial_abi))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_LIBCPP_UNIQUE_PTR_TRIVIAL_ABI</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>_Tp</name></expr></argument>, <argument><expr><name>class</name> <name>_Dp</name> <operator>=</operator> <name><name>default_delete</name><argument_list type="generic">&lt;<argument><expr><name>_Tp</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name>
<name>class</name> <name>_LIBCPP_UNIQUE_PTR_TRIVIAL_ABI</name> <name>_LIBCPP_TEMPLATE_VIS</name></type> <name>unique_ptr</name> <block>{<block_content>
<label><name>public</name>:</label>
<typedef>typedef <type><name>_Tp</name></type> <name>element_type</name>;</typedef>
<typedef>typedef <type><name>_Dp</name></type> <name>deleter_type</name>;</typedef>
<typedef>typedef <expr_stmt><expr><name>_LIBCPP_NODEBUG_TYPE</name> <name>typename</name> <name><name>__pointer</name><argument_list type="generic">&lt;<argument><expr><name>_Tp</name></expr></argument>, <argument><expr><name>deleter_type</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name> <name>pointer</name></expr>;</expr_stmt></typedef>

<expr_stmt><expr><call><name>static_assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>is_rvalue_reference</name><argument_list type="generic">&lt;<argument><expr><name>deleter_type</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>,
<argument><expr><literal type="string">"the specified deleter type cannot be an rvalue reference"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name><name>__compressed_pair</name><argument_list type="generic">&lt;<argument><expr><name>pointer</name></expr></argument>, <argument><expr><name>deleter_type</name></expr></argument>&gt;</argument_list></name></type> <name>__ptr_</name></decl>;</decl_stmt>

<struct>struct <name>__nat</name> <block>{ <decl_stmt><decl><type><name>int</name></type> <name>__for_bool_</name></decl>;</decl_stmt> }</block>;</struct>

<typedef>typedef <type><name>_LIBCPP_NODEBUG_TYPE</name> <name><name>__unique_ptr_deleter_sfinae</name><argument_list type="generic">&lt;<argument><expr><name>_Dp</name></expr></argument>&gt;</argument_list></name></type> <name>_DeleterSFINAE</name>;</typedef>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>bool</name> <name>_Dummy</name></expr></argument>&gt;</argument_list></name>
<name>using</name> <name>_LValRefType</name></type> <name>_LIBCPP_NODEBUG_TYPE</name> <init>=
<expr><name>typename</name> <name><name>__dependent_type</name><argument_list type="generic">&lt;<argument><expr><name>_DeleterSFINAE</name></expr></argument>, <argument><expr><name>_Dummy</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>__lval_ref_type</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>bool</name> <name>_Dummy</name></expr></argument>&gt;</argument_list></name>
<name>using</name> <name>_GoodRValRefType</name></type> <name>_LIBCPP_NODEBUG_TYPE</name> <init>=
<expr><name>typename</name> <name><name>__dependent_type</name><argument_list type="generic">&lt;<argument><expr><name>_DeleterSFINAE</name></expr></argument>, <argument><expr><name>_Dummy</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>__good_rval_ref_type</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>bool</name> <name>_Dummy</name></expr></argument>&gt;</argument_list></name>
<name>using</name> <name>_BadRValRefType</name></type> <name>_LIBCPP_NODEBUG_TYPE</name> <init>=
<expr><name>typename</name> <name><name>__dependent_type</name><argument_list type="generic">&lt;<argument><expr><name>_DeleterSFINAE</name></expr></argument>, <argument><expr><name>_Dummy</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>__bad_rval_ref_type</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>bool</name> <name>_Dummy</name></expr></argument>, <argument><expr><name>class</name> <name>_Deleter</name> <operator>=</operator> <name>typename</name> <name><name>__dependent_type</name><argument_list type="generic">&lt;
<argument><expr><name><name>__identity</name><argument_list type="generic">&lt;<argument><expr><name>deleter_type</name></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><name>_Dummy</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name>
<name>using</name> <name>_EnableIfDeleterDefaultConstructible</name></type> <name>_LIBCPP_NODEBUG_TYPE</name> <init>=
<expr><name>typename</name> <name><name>enable_if</name><argument_list type="generic">&lt;<argument><expr><name><name>is_default_constructible</name><argument_list type="generic">&lt;<argument><expr><name>_Deleter</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>&amp;&amp;</operator>
<operator>!</operator><name><name>is_pointer</name><argument_list type="generic">&lt;<argument><expr><name>_Deleter</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>_ArgType</name></expr></argument>&gt;</argument_list></name>
<name>using</name> <name>_EnableIfDeleterConstructible</name></type> <name>_LIBCPP_NODEBUG_TYPE</name> <init>=
<expr><name>typename</name> <name><name>enable_if</name><argument_list type="generic">&lt;<argument><expr><name><name>is_constructible</name><argument_list type="generic">&lt;<argument><expr><name>deleter_type</name></expr></argument>, <argument><expr><name>_ArgType</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>_UPtr</name></expr></argument>, <argument><expr><name>class</name> <name>_Up</name></expr></argument>&gt;</argument_list></name>
<name>using</name> <name>_EnableIfMoveConvertible</name></type> <name>_LIBCPP_NODEBUG_TYPE</name> <init>= <expr><name>typename</name> <name><name>enable_if</name><argument_list type="generic">&lt;
<argument><expr><name><name>is_convertible</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>_UPtr</name><operator>::</operator><name>pointer</name></expr></argument>, <argument><expr><name>pointer</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>&amp;&amp;</operator>
<operator>!</operator><name><name>is_array</name><argument_list type="generic">&lt;<argument><expr><name>_Up</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>
&gt;</argument_list></name><operator>::</operator><name>type</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>_UDel</name></expr></argument>&gt;</argument_list></name>
<name>using</name> <name>_EnableIfDeleterConvertible</name></type> <name>_LIBCPP_NODEBUG_TYPE</name> <init>= <expr><name>typename</name> <name>enable_if</name><operator>&lt;</operator>
<operator>(</operator><name><name>is_reference</name><argument_list type="generic">&lt;<argument><expr><name>_Dp</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>&amp;&amp;</operator> <name><name>is_same</name><argument_list type="generic">&lt;<argument><expr><name>_Dp</name></expr></argument>, <argument><expr><name>_UDel</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name><operator>)</operator> <operator>||</operator>
<operator>(</operator><operator>!</operator><name><name>is_reference</name><argument_list type="generic">&lt;<argument><expr><name>_Dp</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>&amp;&amp;</operator> <name><name>is_convertible</name><argument_list type="generic">&lt;<argument><expr><name>_UDel</name></expr></argument>, <argument><expr><name>_Dp</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name><operator>)</operator>
<operator>&gt;</operator><operator>::</operator><name>type</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>_UDel</name></expr></argument>&gt;</argument_list></name>
<name>using</name></type> <name>_EnableIfDeleterAssignable</name> <init>= <expr><name>typename</name> <name><name>enable_if</name><argument_list type="generic">&lt;
<argument><expr><name><name>is_assignable</name><argument_list type="generic">&lt;<argument><expr><name>_Dp</name><operator>&amp;</operator></expr></argument>, <argument><expr><name>_UDel</name><operator>&amp;&amp;</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>
&gt;</argument_list></name><operator>::</operator><name>type</name></expr></init></decl>;</decl_stmt>

<label><name>public</name>:</label>
<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>bool</name> <name>_Dummy</name> <operator>=</operator> <name>true</name></expr></argument>,
<argument><expr><name>class</name> <operator>=</operator> <name><name>_EnableIfDeleterDefaultConstructible</name><argument_list type="generic">&lt;<argument><expr><name>_Dummy</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name>
<name>_LIBCPP_INLINE_VISIBILITY</name>
<name>_LIBCPP_CONSTEXPR</name> <macro><name>unique_ptr</name><argument_list>()</argument_list></macro> <name>_NOEXCEPT</name> <operator>:</operator> <macro><name>__ptr_</name><argument_list>(<argument>pointer()</argument>, <argument>__default_init_tag()</argument>)</argument_list></macro> <block>{}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>bool</name> <name>_Dummy</name> <operator>=</operator> <name>true</name></expr></argument>,
<argument><expr><name>class</name> <operator>=</operator> <name><name>_EnableIfDeleterDefaultConstructible</name><argument_list type="generic">&lt;<argument><expr><name>_Dummy</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name>
<name>_LIBCPP_INLINE_VISIBILITY</name>
<name>_LIBCPP_CONSTEXPR</name> <macro><name>unique_ptr</name><argument_list>(<argument>nullptr_t</argument>)</argument_list></macro> <name>_NOEXCEPT</name> <operator>:</operator> <macro><name>__ptr_</name><argument_list>(<argument>pointer()</argument>, <argument>__default_init_tag()</argument>)</argument_list></macro> <block>{}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>bool</name> <name>_Dummy</name> <operator>=</operator> <name>true</name></expr></argument>,
<argument><expr><name>class</name> <operator>=</operator> <name><name>_EnableIfDeleterDefaultConstructible</name><argument_list type="generic">&lt;<argument><expr><name>_Dummy</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name>
<name>_LIBCPP_INLINE_VISIBILITY</name>
<name>explicit</name> <macro><name>unique_ptr</name><argument_list>(<argument>pointer __p</argument>)</argument_list></macro> <name>_NOEXCEPT</name> <operator>:</operator> <macro><name>__ptr_</name><argument_list>(<argument>__p</argument>, <argument>__default_init_tag()</argument>)</argument_list></macro> <block>{}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>bool</name> <name>_Dummy</name> <operator>=</operator> <name>true</name></expr></argument>,
<argument><expr><name>class</name> <operator>=</operator> <name><name>_EnableIfDeleterConstructible</name><argument_list type="generic">&lt;<argument><expr><name><name>_LValRefType</name><argument_list type="generic">&lt;<argument><expr><name>_Dummy</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></expr></argument> &gt;</argument_list></name>
<name>_LIBCPP_INLINE_VISIBILITY</name>
<macro><name>unique_ptr</name><argument_list>(<argument>pointer __p</argument>, <argument>_LValRefType&lt;_Dummy&gt; __d</argument>)</argument_list></macro> <name>_NOEXCEPT</name>
<operator>:</operator> <macro><name>__ptr_</name><argument_list>(<argument>__p</argument>, <argument>__d</argument>)</argument_list></macro> <block>{}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>bool</name> <name>_Dummy</name> <operator>=</operator> <name>true</name></expr></argument>,
<argument><expr><name>class</name> <operator>=</operator> <name><name>_EnableIfDeleterConstructible</name><argument_list type="generic">&lt;<argument><expr><name><name>_GoodRValRefType</name><argument_list type="generic">&lt;<argument><expr><name>_Dummy</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></expr></argument> &gt;</argument_list></name>
<name>_LIBCPP_INLINE_VISIBILITY</name>
<macro><name>unique_ptr</name><argument_list>(<argument>pointer __p</argument>, <argument>_GoodRValRefType&lt;_Dummy&gt; __d</argument>)</argument_list></macro> <name>_NOEXCEPT</name>
<operator>:</operator> <macro><name>__ptr_</name><argument_list>(<argument>__p</argument>, <argument>_VSTD::move(__d)</argument>)</argument_list></macro> <block>{
<expr><call><name>static_assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>is_reference</name><argument_list type="generic">&lt;<argument><expr><name>deleter_type</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>,
<argument><expr><literal type="string">"rvalue deleter bound to reference"</literal></expr></argument>)</argument_list></call></expr>;
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>bool</name> <name>_Dummy</name> <operator>=</operator> <name>true</name></expr></argument>,
<argument><expr><name>class</name> <operator>=</operator> <name><name>_EnableIfDeleterConstructible</name><argument_list type="generic">&lt;<argument><expr><name><name>_BadRValRefType</name><argument_list type="generic">&lt;<argument><expr><name>_Dummy</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></expr></argument> &gt;</argument_list></name>
<name>_LIBCPP_INLINE_VISIBILITY</name>
<macro><name>unique_ptr</name><argument_list>(<argument>pointer __p</argument>, <argument>_BadRValRefType&lt;_Dummy&gt; __d</argument>)</argument_list></macro> <operator>=</operator> <name>delete</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>_LIBCPP_INLINE_VISIBILITY</name></type>
<name>unique_ptr</name><argument_list>(<argument><expr><name>unique_ptr</name><operator>&amp;&amp;</operator> <name>__u</name></expr></argument>)</argument_list> <name>_NOEXCEPT</name>
<range>: <macro><name>__ptr_</name><argument_list>(<argument>__u.release()</argument>, <argument>_VSTD::forward&lt;deleter_type&gt;(__u.get_deleter())</argument>)</argument_list></macro> <expr><block>{
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>_Up</name></expr></argument>, <argument><expr><name>class</name> <name>_Ep</name></expr></argument>,
<argument><expr><name>class</name> <operator>=</operator> <name><name>_EnableIfMoveConvertible</name><argument_list type="generic">&lt;<argument><expr><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>_Up</name></expr></argument>, <argument><expr><name>_Ep</name></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><name>_Up</name></expr></argument>&gt;</argument_list></name></expr></argument>,
<argument><expr><name>class</name> <operator>=</operator> <name><name>_EnableIfDeleterConvertible</name><argument_list type="generic">&lt;<argument><expr><name>_Ep</name></expr></argument>&gt;</argument_list></name></expr></argument>
&gt;</argument_list></name>
<name>_LIBCPP_INLINE_VISIBILITY</name>
<macro><name>unique_ptr</name><argument_list>(<argument>unique_ptr&lt;_Up</argument>, <argument>_Ep&gt;&amp;&amp; __u</argument>)</argument_list></macro> <name>_NOEXCEPT</name>
<operator>:</operator> <macro><name>__ptr_</name><argument_list>(<argument>__u.release()</argument>, <argument>_VSTD::forward&lt;_Ep&gt;(__u.get_deleter())</argument>)</argument_list></macro> <block>{}</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>_LIBCPP_STD_VER</name> <operator>&lt;=</operator> <literal type="number">14</literal> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>_Up</name></expr></argument>&gt;</argument_list></name>
<name>_LIBCPP_INLINE_VISIBILITY</name>
<macro><name>unique_ptr</name><argument_list>(<argument>auto_ptr&lt;_Up&gt;&amp;&amp; __p</argument>,
<argument>typename enable_if&lt;is_convertible&lt;_Up*</argument>, <argument>_Tp*&gt;::value &amp;&amp;
is_same&lt;_Dp</argument>, <argument>default_delete&lt;_Tp&gt; &gt;::value</argument>,
<argument>__nat&gt;::type = __nat()</argument>)</argument_list></macro> <name>_NOEXCEPT</name>
<operator>:</operator> <macro><name>__ptr_</name><argument_list>(<argument>__p.release()</argument>, <argument>__default_init_tag()</argument>)</argument_list></macro> <block>{}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<name>_LIBCPP_INLINE_VISIBILITY</name>
<name>unique_ptr</name><operator>&amp;</operator> <name>operator</name><operator>=</operator><operator>(</operator><name>unique_ptr</name><operator>&amp;&amp;</operator> <name>__u</name><operator>)</operator> <name>_NOEXCEPT</name> <block>{
<expr><call><name>reset</name><argument_list>(<argument><expr><call><name><name>__u</name><operator>.</operator><name>release</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>__ptr_</name><operator>.</operator><name>second</name></name><argument_list>()</argument_list></call> <operator>=</operator> <name>_VSTD</name><operator>::</operator><call><name><name>forward</name><argument_list type="generic">&lt;<argument><expr><name>deleter_type</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>__u</name><operator>.</operator><name>get_deleter</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
}</block></expr></range></decl></decl_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>_Up</name></expr></argument>, <argument><expr><name>class</name> <name>_Ep</name></expr></argument>,
<argument><expr><name>class</name> <operator>=</operator> <name><name>_EnableIfMoveConvertible</name><argument_list type="generic">&lt;<argument><expr><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>_Up</name></expr></argument>, <argument><expr><name>_Ep</name></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><name>_Up</name></expr></argument>&gt;</argument_list></name></expr></argument>,
<argument><expr><name>class</name> <operator>=</operator> <name><name>_EnableIfDeleterAssignable</name><argument_list type="generic">&lt;<argument><expr><name>_Ep</name></expr></argument>&gt;</argument_list></name></expr></argument>
&gt;</argument_list></name>
<name>_LIBCPP_INLINE_VISIBILITY</name>
<name>unique_ptr</name><modifier>&amp;</modifier></type> <name>operator</name><init>=<expr><operator>(</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>_Up</name></expr></argument>, <argument><expr><name>_Ep</name></expr></argument>&gt;</argument_list></name><operator>&amp;&amp;</operator> <name>__u</name><operator>)</operator> <name>_NOEXCEPT</name> <block>{
<expr><call><name>reset</name><argument_list>(<argument><expr><call><name><name>__u</name><operator>.</operator><name>release</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>__ptr_</name><operator>.</operator><name>second</name></name><argument_list>()</argument_list></call> <operator>=</operator> <name>_VSTD</name><operator>::</operator><call><name><name>forward</name><argument_list type="generic">&lt;<argument><expr><name>_Ep</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>__u</name><operator>.</operator><name>get_deleter</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
}</block></expr></init></decl></decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>_LIBCPP_STD_VER</name> <operator>&lt;=</operator> <literal type="number">14</literal> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_LIBCPP_ENABLE_CXX17_REMOVED_AUTO_PTR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>_Up</name></expr></argument>&gt;</argument_list></name>
<name>_LIBCPP_INLINE_VISIBILITY</name>
<name>typename</name> <name><name>enable_if</name><argument_list type="generic">&lt;<argument><expr><name><name>is_convertible</name><argument_list type="generic">&lt;<argument><expr><name>_Up</name><operator>*</operator></expr></argument>, <argument><expr><name>_Tp</name><operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>&amp;&amp;</operator>
<name><name>is_same</name><argument_list type="generic">&lt;<argument><expr><name>_Dp</name></expr></argument>, <argument><expr><name><name>default_delete</name><argument_list type="generic">&lt;<argument><expr><name>_Tp</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>,
<argument><expr><name>unique_ptr</name><operator>&amp;</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name>
<name>operator</name><operator>=</operator><operator>(</operator><name><name>auto_ptr</name><argument_list type="generic">&lt;<argument><expr><name>_Up</name></expr></argument>&gt;</argument_list></name> <name>__p</name><operator>)</operator> <block>{
<expr><call><name>reset</name><argument_list>(<argument><expr><call><name><name>__p</name><operator>.</operator><name>release</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
}</block></expr></expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_LIBCPP_CXX03_LANG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>unique_ptr</name><argument_list>(<argument><expr><name>unique_ptr</name> <specifier>const</specifier><operator>&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name>delete</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>unique_ptr</name><modifier>&amp;</modifier></type> <name>operator</name><init>=<expr><operator>(</operator><name>unique_ptr</name> <specifier>const</specifier><operator>&amp;</operator><operator>)</operator> <operator>=</operator> <name>delete</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<expr_stmt><expr><name>_LIBCPP_INLINE_VISIBILITY</name>
<operator>~</operator><macro><name>unique_ptr</name><argument_list>()</argument_list></macro> <block>{ <expr><call><name>reset</name><argument_list>()</argument_list></call></expr>; }</block>

<name>_LIBCPP_INLINE_VISIBILITY</name>
<name>unique_ptr</name><operator>&amp;</operator> <name>operator</name><operator>=</operator><operator>(</operator><name>nullptr_t</name><operator>)</operator> <name>_NOEXCEPT</name> <block>{
<expr><call><name>reset</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>_LIBCPP_INLINE_VISIBILITY</name>
<name>typename</name> <name><name>add_lvalue_reference</name><argument_list type="generic">&lt;<argument><expr><name>_Tp</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name>
<name>operator</name><operator>*</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><operator>*</operator><call><name><name>__ptr_</name><operator>.</operator><name>first</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>_LIBCPP_INLINE_VISIBILITY</name>
<name>pointer</name> <name><name>operator</name><operator>-&gt;</operator><name/></name>(</expr></expr_stmt>)</block_content> const _NOEXCEPT <block>{<block_content>
<return>return <expr><call><name><name>__ptr_</name><operator>.</operator><name>first</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block>
_LIBCPP_INLINE_VISIBILITY
pointer get(</block></decl>) const _NOEXCEPT <block>{<block_content>
<return>return <expr><call><name><name>__ptr_</name><operator>.</operator><name>first</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></decl_stmt>
<function><type><name>_LIBCPP_INLINE_VISIBILITY</name>
<name>deleter_type</name><modifier>&amp;</modifier></type> <name>get_deleter</name><parameter_list>()</parameter_list> _NOEXCEPT <block>{<block_content>
<return>return <expr><call><name><name>__ptr_</name><operator>.</operator><name>second</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>
<expr_stmt><expr><name>_LIBCPP_INLINE_VISIBILITY</name>
<specifier>const</specifier> <name>deleter_type</name><operator>&amp;</operator> <macro><name>get_deleter</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>_NOEXCEPT</name> <block>{
<return>return <expr><call><name><name>__ptr_</name><operator>.</operator><name>second</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>_LIBCPP_INLINE_VISIBILITY</name>
<name>explicit</name> <name>operator</name> <macro><name>bool</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>_NOEXCEPT</name> <block>{
<return>return <expr><call><name><name>__ptr_</name><operator>.</operator><name>first</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>nullptr</name></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>_LIBCPP_INLINE_VISIBILITY</name>
<name>pointer</name></type> <name>release</name><parameter_list>()</parameter_list> _NOEXCEPT <block>{<block_content>
<decl_stmt><decl><type><name>pointer</name></type> <name>__t</name> <init>= <expr><call><name><name>__ptr_</name><operator>.</operator><name>first</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>__ptr_</name><operator>.</operator><name>first</name></name><argument_list>()</argument_list></call> <operator>=</operator> <call><name>pointer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>__t</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>_LIBCPP_INLINE_VISIBILITY</name>
<name>void</name></type> <name>reset</name><parameter_list>(<parameter><decl><type><name>pointer</name></type> <name>__p</name> <init>= <expr><call><name>pointer</name><argument_list>()</argument_list></call></expr></init></decl></parameter>)</parameter_list> _NOEXCEPT <block>{<block_content>
<decl_stmt><decl><type><name>pointer</name></type> <name>__tmp</name> <init>= <expr><call><name><name>__ptr_</name><operator>.</operator><name>first</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>__ptr_</name><operator>.</operator><name>first</name></name><argument_list>()</argument_list></call> <operator>=</operator> <name>__p</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>__tmp</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><call><name><name>__ptr_</name><operator>.</operator><name>second</name></name><argument_list>()</argument_list></call><argument_list>(<argument><expr><name>__tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>_LIBCPP_INLINE_VISIBILITY</name>
<name>void</name></type> <name>swap</name><parameter_list>(<parameter><decl><type><name>unique_ptr</name><modifier>&amp;</modifier></type> <name>__u</name></decl></parameter>)</parameter_list> _NOEXCEPT <block>{<block_content>
<expr_stmt><expr><call><name><name>__ptr_</name><operator>.</operator><name>swap</name></name><argument_list>(<argument><expr><name><name>__u</name><operator>.</operator><name>__ptr_</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
};


<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>_Tp</name></expr></argument>, <argument><expr><name>class</name> <name>_Dp</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>_LIBCPP_UNIQUE_PTR_TRIVIAL_ABI</name> <name>_LIBCPP_TEMPLATE_VIS</name></type> <name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name><name>_Tp</name><index>[]</index></name></expr></argument>, <argument><expr><name>_Dp</name></expr></argument>&gt;</argument_list></name> <block>{<block_content>
<label><name>public</name>:</label>
<typedef>typedef <type><name>_Tp</name></type> <name>element_type</name>;</typedef>
<typedef>typedef <type><name>_Dp</name></type> <name>deleter_type</name>;</typedef>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name><name>__pointer</name><argument_list type="generic">&lt;<argument><expr><name>_Tp</name></expr></argument>, <argument><expr><name>deleter_type</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name> <name>pointer</name></expr>;</expr_stmt></typedef>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name><name>__compressed_pair</name><argument_list type="generic">&lt;<argument><expr><name>pointer</name></expr></argument>, <argument><expr><name>deleter_type</name></expr></argument>&gt;</argument_list></name></type> <name>__ptr_</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>_From</name></expr></argument>&gt;</argument_list></name>
struct</type> <name>_CheckArrayPointerConversion</name> <range>: <expr><name><name>is_same</name><argument_list type="generic">&lt;<argument><expr><name>_From</name></expr></argument>, <argument><expr><name>pointer</name></expr></argument>&gt;</argument_list></name> <block>{}</block></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>_FromElem</name></expr></argument>&gt;</argument_list></name>
struct</type> <name><name>_CheckArrayPointerConversion</name><argument_list type="generic">&lt;<argument><expr><name>_FromElem</name><modifier>*</modifier></expr></argument>&gt;</argument_list></name>
<range>: <expr><name>integral_constant</name><operator>&lt;</operator><name>bool</name></expr></range></decl>,
<decl><type ref="prev"/><name><name>is_same</name><argument_list type="generic">&lt;<argument><expr><name>_FromElem</name><modifier>*</modifier></expr></argument>, <argument><expr><name>pointer</name></expr></argument>&gt;</argument_list></name>::<name>value</name> ||
<argument_list>(<argument><expr><name><name>is_same</name><argument_list type="generic">&lt;<argument><expr><name>pointer</name></expr></argument>, <argument><expr><name>element_type</name><operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>&amp;&amp;</operator>
<name>is_convertible</name><operator>&lt;</operator><call><name>_FromElem</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><index>[]</index></expr></argument>, <argument><expr><call><name>element_type</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><index>[]</index><operator>&gt;</operator><operator>::</operator><name>value</name></expr></argument>)</argument_list>
&gt;
<block>{<block_content/>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<typedef>typedef <type><name><name>__unique_ptr_deleter_sfinae</name><argument_list type="generic">&lt;<argument><expr><name>_Dp</name></expr></argument>&gt;</argument_list></name></type> <name>_DeleterSFINAE</name>;</typedef>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>bool</name> <name>_Dummy</name></expr></argument>&gt;</argument_list></name>
<name>using</name> <name>_LValRefType</name></type> <name>_LIBCPP_NODEBUG_TYPE</name> <init>=
<expr><name>typename</name> <name><name>__dependent_type</name><argument_list type="generic">&lt;<argument><expr><name>_DeleterSFINAE</name></expr></argument>, <argument><expr><name>_Dummy</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>__lval_ref_type</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>bool</name> <name>_Dummy</name></expr></argument>&gt;</argument_list></name>
<name>using</name> <name>_GoodRValRefType</name></type> <name>_LIBCPP_NODEBUG_TYPE</name> <init>=
<expr><name>typename</name> <name><name>__dependent_type</name><argument_list type="generic">&lt;<argument><expr><name>_DeleterSFINAE</name></expr></argument>, <argument><expr><name>_Dummy</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>__good_rval_ref_type</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>bool</name> <name>_Dummy</name></expr></argument>&gt;</argument_list></name>
<name>using</name> <name>_BadRValRefType</name></type> <name>_LIBCPP_NODEBUG_TYPE</name> <init>=
<expr><name>typename</name> <name><name>__dependent_type</name><argument_list type="generic">&lt;<argument><expr><name>_DeleterSFINAE</name></expr></argument>, <argument><expr><name>_Dummy</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>__bad_rval_ref_type</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>bool</name> <name>_Dummy</name></expr></argument>, <argument><expr><name>class</name> <name>_Deleter</name> <operator>=</operator> <name>typename</name> <name><name>__dependent_type</name><argument_list type="generic">&lt;
<argument><expr><name><name>__identity</name><argument_list type="generic">&lt;<argument><expr><name>deleter_type</name></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><name>_Dummy</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name>
<name>using</name> <name>_EnableIfDeleterDefaultConstructible</name></type> <name>_LIBCPP_NODEBUG_TYPE</name> <init>=
<expr><name>typename</name> <name><name>enable_if</name><argument_list type="generic">&lt;<argument><expr><name><name>is_default_constructible</name><argument_list type="generic">&lt;<argument><expr><name>_Deleter</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>&amp;&amp;</operator>
<operator>!</operator><name><name>is_pointer</name><argument_list type="generic">&lt;<argument><expr><name>_Deleter</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>_ArgType</name></expr></argument>&gt;</argument_list></name>
<name>using</name> <name>_EnableIfDeleterConstructible</name></type> <name>_LIBCPP_NODEBUG_TYPE</name> <init>=
<expr><name>typename</name> <name><name>enable_if</name><argument_list type="generic">&lt;<argument><expr><name><name>is_constructible</name><argument_list type="generic">&lt;<argument><expr><name>deleter_type</name></expr></argument>, <argument><expr><name>_ArgType</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>_Pp</name></expr></argument>&gt;</argument_list></name>
<name>using</name> <name>_EnableIfPointerConvertible</name></type> <name>_LIBCPP_NODEBUG_TYPE</name> <init>= <expr><name>typename</name> <name><name>enable_if</name><argument_list type="generic">&lt;
<argument><expr><name><name>_CheckArrayPointerConversion</name><argument_list type="generic">&lt;<argument><expr><name>_Pp</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>
&gt;</argument_list></name><operator>::</operator><name>type</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>_UPtr</name></expr></argument>, <argument><expr><name>class</name> <name>_Up</name></expr></argument>,
<argument><expr><name>class</name> <name>_ElemT</name> <operator>=</operator> <name>typename</name> <name>_UPtr</name><operator>::</operator><name>element_type</name></expr></argument>&gt;</argument_list></name>
<name>using</name> <name>_EnableIfMoveConvertible</name></type> <name>_LIBCPP_NODEBUG_TYPE</name> <init>= <expr><name>typename</name> <name>enable_if</name><operator>&lt;</operator>
<name><name>is_array</name><argument_list type="generic">&lt;<argument><expr><name>_Up</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>&amp;&amp;</operator>
<name><name>is_same</name><argument_list type="generic">&lt;<argument><expr><name>pointer</name></expr></argument>, <argument><expr><name>element_type</name><operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>&amp;&amp;</operator>
<name><name>is_same</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>_UPtr</name><operator>::</operator><name>pointer</name></expr></argument>, <argument><expr><name>_ElemT</name><operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>&amp;&amp;</operator>
<name>is_convertible</name><operator>&lt;</operator><call><name>_ElemT</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><index>[]</index></expr></init></decl>, <decl><type ref="prev"/><name>element_type</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list>[]&gt;::<name>value</name>
&gt;::<name>type</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>_UDel</name></expr></argument>&gt;</argument_list></name>
<name>using</name> <name>_EnableIfDeleterConvertible</name></type> <name>_LIBCPP_NODEBUG_TYPE</name> <init>= <expr><name>typename</name> <name>enable_if</name><operator>&lt;</operator>
<operator>(</operator><name><name>is_reference</name><argument_list type="generic">&lt;<argument><expr><name>_Dp</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>&amp;&amp;</operator> <name><name>is_same</name><argument_list type="generic">&lt;<argument><expr><name>_Dp</name></expr></argument>, <argument><expr><name>_UDel</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name><operator>)</operator> <operator>||</operator>
<operator>(</operator><operator>!</operator><name><name>is_reference</name><argument_list type="generic">&lt;<argument><expr><name>_Dp</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>&amp;&amp;</operator> <name><name>is_convertible</name><argument_list type="generic">&lt;<argument><expr><name>_UDel</name></expr></argument>, <argument><expr><name>_Dp</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name><operator>)</operator>
<operator>&gt;</operator><operator>::</operator><name>type</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>_UDel</name></expr></argument>&gt;</argument_list></name>
<name>using</name> <name>_EnableIfDeleterAssignable</name></type> <name>_LIBCPP_NODEBUG_TYPE</name> <init>= <expr><name>typename</name> <name><name>enable_if</name><argument_list type="generic">&lt;
<argument><expr><name><name>is_assignable</name><argument_list type="generic">&lt;<argument><expr><name>_Dp</name><operator>&amp;</operator></expr></argument>, <argument><expr><name>_UDel</name><operator>&amp;&amp;</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>
&gt;</argument_list></name><operator>::</operator><name>type</name></expr></init></decl>;</decl_stmt>

<label><name>public</name>:</label>
<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>bool</name> <name>_Dummy</name> <operator>=</operator> <name>true</name></expr></argument>,
<argument><expr><name>class</name> <operator>=</operator> <name><name>_EnableIfDeleterDefaultConstructible</name><argument_list type="generic">&lt;<argument><expr><name>_Dummy</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name>
<name>_LIBCPP_INLINE_VISIBILITY</name>
<name>_LIBCPP_CONSTEXPR</name> <macro><name>unique_ptr</name><argument_list>()</argument_list></macro> <name>_NOEXCEPT</name> <operator>:</operator> <macro><name>__ptr_</name><argument_list>(<argument>pointer()</argument>, <argument>__default_init_tag()</argument>)</argument_list></macro> <block>{}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>bool</name> <name>_Dummy</name> <operator>=</operator> <name>true</name></expr></argument>,
<argument><expr><name>class</name> <operator>=</operator> <name><name>_EnableIfDeleterDefaultConstructible</name><argument_list type="generic">&lt;<argument><expr><name>_Dummy</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name>
<name>_LIBCPP_INLINE_VISIBILITY</name>
<name>_LIBCPP_CONSTEXPR</name> <macro><name>unique_ptr</name><argument_list>(<argument>nullptr_t</argument>)</argument_list></macro> <name>_NOEXCEPT</name> <operator>:</operator> <macro><name>__ptr_</name><argument_list>(<argument>pointer()</argument>, <argument>__default_init_tag()</argument>)</argument_list></macro> <block>{}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>_Pp</name></expr></argument>, <argument><expr><name>bool</name> <name>_Dummy</name> <operator>=</operator> <name>true</name></expr></argument>,
<argument><expr><name>class</name> <operator>=</operator> <name><name>_EnableIfDeleterDefaultConstructible</name><argument_list type="generic">&lt;<argument><expr><name>_Dummy</name></expr></argument>&gt;</argument_list></name></expr></argument>,
<argument><expr><name>class</name> <operator>=</operator> <name><name>_EnableIfPointerConvertible</name><argument_list type="generic">&lt;<argument><expr><name>_Pp</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name>
<name>_LIBCPP_INLINE_VISIBILITY</name>
<name>explicit</name> <macro><name>unique_ptr</name><argument_list>(<argument>_Pp __p</argument>)</argument_list></macro> <name>_NOEXCEPT</name>
<operator>:</operator> <macro><name>__ptr_</name><argument_list>(<argument>__p</argument>, <argument>__default_init_tag()</argument>)</argument_list></macro> <block>{}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>_Pp</name></expr></argument>, <argument><expr><name>bool</name> <name>_Dummy</name> <operator>=</operator> <name>true</name></expr></argument>,
<argument><expr><name>class</name> <operator>=</operator> <name><name>_EnableIfDeleterConstructible</name><argument_list type="generic">&lt;<argument><expr><name><name>_LValRefType</name><argument_list type="generic">&lt;<argument><expr><name>_Dummy</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></expr></argument>,
<argument><expr><name>class</name> <operator>=</operator> <name><name>_EnableIfPointerConvertible</name><argument_list type="generic">&lt;<argument><expr><name>_Pp</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name>
<name>_LIBCPP_INLINE_VISIBILITY</name>
<macro><name>unique_ptr</name><argument_list>(<argument>_Pp __p</argument>, <argument>_LValRefType&lt;_Dummy&gt; __d</argument>)</argument_list></macro> <name>_NOEXCEPT</name>
<operator>:</operator> <macro><name>__ptr_</name><argument_list>(<argument>__p</argument>, <argument>__d</argument>)</argument_list></macro> <block>{}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>bool</name> <name>_Dummy</name> <operator>=</operator> <name>true</name></expr></argument>,
<argument><expr><name>class</name> <operator>=</operator> <name><name>_EnableIfDeleterConstructible</name><argument_list type="generic">&lt;<argument><expr><name><name>_LValRefType</name><argument_list type="generic">&lt;<argument><expr><name>_Dummy</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></expr></argument> &gt;</argument_list></name>
<name>_LIBCPP_INLINE_VISIBILITY</name>
<macro><name>unique_ptr</name><argument_list>(<argument>nullptr_t</argument>, <argument>_LValRefType&lt;_Dummy&gt; __d</argument>)</argument_list></macro> <name>_NOEXCEPT</name>
<operator>:</operator> <macro><name>__ptr_</name><argument_list>(<argument>nullptr</argument>, <argument>__d</argument>)</argument_list></macro> <block>{}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>_Pp</name></expr></argument>, <argument><expr><name>bool</name> <name>_Dummy</name> <operator>=</operator> <name>true</name></expr></argument>,
<argument><expr><name>class</name> <operator>=</operator> <name><name>_EnableIfDeleterConstructible</name><argument_list type="generic">&lt;<argument><expr><name><name>_GoodRValRefType</name><argument_list type="generic">&lt;<argument><expr><name>_Dummy</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></expr></argument>,
<argument><expr><name>class</name> <operator>=</operator> <name><name>_EnableIfPointerConvertible</name><argument_list type="generic">&lt;<argument><expr><name>_Pp</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name>
<name>_LIBCPP_INLINE_VISIBILITY</name>
<macro><name>unique_ptr</name><argument_list>(<argument>_Pp __p</argument>, <argument>_GoodRValRefType&lt;_Dummy&gt; __d</argument>)</argument_list></macro> <name>_NOEXCEPT</name>
<operator>:</operator> <macro><name>__ptr_</name><argument_list>(<argument>__p</argument>, <argument>_VSTD::move(__d)</argument>)</argument_list></macro> <block>{
<expr><call><name>static_assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>is_reference</name><argument_list type="generic">&lt;<argument><expr><name>deleter_type</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>,
<argument><expr><literal type="string">"rvalue deleter bound to reference"</literal></expr></argument>)</argument_list></call></expr>;
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>bool</name> <name>_Dummy</name> <operator>=</operator> <name>true</name></expr></argument>,
<argument><expr><name>class</name> <operator>=</operator> <name><name>_EnableIfDeleterConstructible</name><argument_list type="generic">&lt;<argument><expr><name><name>_GoodRValRefType</name><argument_list type="generic">&lt;<argument><expr><name>_Dummy</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></expr></argument> &gt;</argument_list></name>
<name>_LIBCPP_INLINE_VISIBILITY</name>
<macro><name>unique_ptr</name><argument_list>(<argument>nullptr_t</argument>, <argument>_GoodRValRefType&lt;_Dummy&gt; __d</argument>)</argument_list></macro> <name>_NOEXCEPT</name>
<operator>:</operator> <macro><name>__ptr_</name><argument_list>(<argument>nullptr</argument>, <argument>_VSTD::move(__d)</argument>)</argument_list></macro> <block>{
<expr><call><name>static_assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>is_reference</name><argument_list type="generic">&lt;<argument><expr><name>deleter_type</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>,
<argument><expr><literal type="string">"rvalue deleter bound to reference"</literal></expr></argument>)</argument_list></call></expr>;
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>_Pp</name></expr></argument>, <argument><expr><name>bool</name> <name>_Dummy</name> <operator>=</operator> <name>true</name></expr></argument>,
<argument><expr><name>class</name> <operator>=</operator> <name><name>_EnableIfDeleterConstructible</name><argument_list type="generic">&lt;<argument><expr><name><name>_BadRValRefType</name><argument_list type="generic">&lt;<argument><expr><name>_Dummy</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name></expr></argument>,
<argument><expr><name>class</name> <operator>=</operator> <name><name>_EnableIfPointerConvertible</name><argument_list type="generic">&lt;<argument><expr><name>_Pp</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name>
<name>_LIBCPP_INLINE_VISIBILITY</name>
<macro><name>unique_ptr</name><argument_list>(<argument>_Pp __p</argument>, <argument>_BadRValRefType&lt;_Dummy&gt; __d</argument>)</argument_list></macro> <operator>=</operator> <name>delete</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>_LIBCPP_INLINE_VISIBILITY</name></type>
<name>unique_ptr</name><argument_list>(<argument><expr><name>unique_ptr</name><operator>&amp;&amp;</operator> <name>__u</name></expr></argument>)</argument_list> <name>_NOEXCEPT</name>
<range>: <macro><name>__ptr_</name><argument_list>(<argument>__u.release()</argument>, <argument>_VSTD::forward&lt;deleter_type&gt;(__u.get_deleter())</argument>)</argument_list></macro> <expr><block>{
}</block>

<name>_LIBCPP_INLINE_VISIBILITY</name>
<name>unique_ptr</name><operator>&amp;</operator> <name>operator</name><operator>=</operator><operator>(</operator><name>unique_ptr</name><operator>&amp;&amp;</operator> <name>__u</name><operator>)</operator> <name>_NOEXCEPT</name> <block>{
<expr><call><name>reset</name><argument_list>(<argument><expr><call><name><name>__u</name><operator>.</operator><name>release</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>__ptr_</name><operator>.</operator><name>second</name></name><argument_list>()</argument_list></call> <operator>=</operator> <name>_VSTD</name><operator>::</operator><call><name><name>forward</name><argument_list type="generic">&lt;<argument><expr><name>deleter_type</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>__u</name><operator>.</operator><name>get_deleter</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
}</block></expr></range></decl></decl_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>_Up</name></expr></argument>, <argument><expr><name>class</name> <name>_Ep</name></expr></argument>,
<argument><expr><name>class</name> <operator>=</operator> <name><name>_EnableIfMoveConvertible</name><argument_list type="generic">&lt;<argument><expr><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>_Up</name></expr></argument>, <argument><expr><name>_Ep</name></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><name>_Up</name></expr></argument>&gt;</argument_list></name></expr></argument>,
<argument><expr><name>class</name> <operator>=</operator> <name><name>_EnableIfDeleterConvertible</name><argument_list type="generic">&lt;<argument><expr><name>_Ep</name></expr></argument>&gt;</argument_list></name></expr></argument>
&gt;</argument_list></name>
<name>_LIBCPP_INLINE_VISIBILITY</name></type>
<name>unique_ptr</name><argument_list>(<argument><expr><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>_Up</name></expr></argument>, <argument><expr><name>_Ep</name></expr></argument>&gt;</argument_list></name><operator>&amp;&amp;</operator> <name>__u</name></expr></argument>)</argument_list> <name>_NOEXCEPT</name>
<range>: <macro><name>__ptr_</name><argument_list>(<argument>__u.release()</argument>, <argument>_VSTD::forward&lt;_Ep&gt;(__u.get_deleter())</argument>)</argument_list></macro> <expr><block>{
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>_Up</name></expr></argument>, <argument><expr><name>class</name> <name>_Ep</name></expr></argument>,
<argument><expr><name>class</name> <operator>=</operator> <name><name>_EnableIfMoveConvertible</name><argument_list type="generic">&lt;<argument><expr><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>_Up</name></expr></argument>, <argument><expr><name>_Ep</name></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><name>_Up</name></expr></argument>&gt;</argument_list></name></expr></argument>,
<argument><expr><name>class</name> <operator>=</operator> <name><name>_EnableIfDeleterAssignable</name><argument_list type="generic">&lt;<argument><expr><name>_Ep</name></expr></argument>&gt;</argument_list></name></expr></argument>
&gt;</argument_list></name>
<name>_LIBCPP_INLINE_VISIBILITY</name>
<name>unique_ptr</name><operator>&amp;</operator>
<name>operator</name><operator>=</operator><operator>(</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>_Up</name></expr></argument>, <argument><expr><name>_Ep</name></expr></argument>&gt;</argument_list></name><operator>&amp;&amp;</operator> <name>__u</name><operator>)</operator> <name>_NOEXCEPT</name> <block>{
<expr><call><name>reset</name><argument_list>(<argument><expr><call><name><name>__u</name><operator>.</operator><name>release</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>__ptr_</name><operator>.</operator><name>second</name></name><argument_list>()</argument_list></call> <operator>=</operator> <name>_VSTD</name><operator>::</operator><call><name><name>forward</name><argument_list type="generic">&lt;<argument><expr><name>_Ep</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>__u</name><operator>.</operator><name>get_deleter</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
}</block></expr></range></decl></decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_LIBCPP_CXX03_LANG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>unique_ptr</name><argument_list>(<argument><expr><name>unique_ptr</name> <specifier>const</specifier><operator>&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name>delete</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>unique_ptr</name><modifier>&amp;</modifier></type> <name>operator</name><init>=<expr><operator>(</operator><name>unique_ptr</name> <specifier>const</specifier><operator>&amp;</operator><operator>)</operator> <operator>=</operator> <name>delete</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<label><name>public</name>:</label>
<expr_stmt><expr><name>_LIBCPP_INLINE_VISIBILITY</name>
<operator>~</operator><macro><name>unique_ptr</name><argument_list>()</argument_list></macro> <block>{ <expr><call><name>reset</name><argument_list>()</argument_list></call></expr>; }</block>

<name>_LIBCPP_INLINE_VISIBILITY</name>
<name>unique_ptr</name><operator>&amp;</operator> <name>operator</name><operator>=</operator><operator>(</operator><name>nullptr_t</name><operator>)</operator> <name>_NOEXCEPT</name> <block>{
<expr><call><name>reset</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>_LIBCPP_INLINE_VISIBILITY</name>
<name>typename</name> <name><name>add_lvalue_reference</name><argument_list type="generic">&lt;<argument><expr><name>_Tp</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name>
<name><name>operator</name><index>[]</index></name><operator>(</operator><name>size_t</name> <name>__i</name><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>__ptr_</name><operator>.</operator><name>first</name></name><argument_list>()</argument_list></call><index>[<expr><name>__i</name></expr>]</index></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>_LIBCPP_INLINE_VISIBILITY</name>
<name>pointer</name> <macro><name>get</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>_NOEXCEPT</name> <block>{
<return>return <expr><call><name><name>__ptr_</name><operator>.</operator><name>first</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>_LIBCPP_INLINE_VISIBILITY</name>
<name>deleter_type</name><modifier>&amp;</modifier></type> <name>get_deleter</name><parameter_list>()</parameter_list> _NOEXCEPT <block>{<block_content>
<return>return <expr><call><name><name>__ptr_</name><operator>.</operator><name>second</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><name>_LIBCPP_INLINE_VISIBILITY</name>
<specifier>const</specifier> <name>deleter_type</name><operator>&amp;</operator> <macro><name>get_deleter</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>_NOEXCEPT</name> <block>{
<return>return <expr><call><name><name>__ptr_</name><operator>.</operator><name>second</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>_LIBCPP_INLINE_VISIBILITY</name>
<name>explicit</name> <name>operator</name> <macro><name>bool</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>_NOEXCEPT</name> <block>{
<return>return <expr><call><name><name>__ptr_</name><operator>.</operator><name>first</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>nullptr</name></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>_LIBCPP_INLINE_VISIBILITY</name>
<name>pointer</name></type> <name>release</name><parameter_list>()</parameter_list> _NOEXCEPT <block>{<block_content>
<decl_stmt><decl><type><name>pointer</name></type> <name>__t</name> <init>= <expr><call><name><name>__ptr_</name><operator>.</operator><name>first</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>__ptr_</name><operator>.</operator><name>first</name></name><argument_list>()</argument_list></call> <operator>=</operator> <call><name>pointer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>__t</name></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>_Pp</name></expr></argument>&gt;</argument_list></name>
<name>_LIBCPP_INLINE_VISIBILITY</name>
<name>typename</name> <name><name>enable_if</name><argument_list type="generic">&lt;
<argument><expr><name><name>_CheckArrayPointerConversion</name><argument_list type="generic">&lt;<argument><expr><name>_Pp</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>
&gt;</argument_list></name><operator>::</operator><name>type</name>
<macro><name>reset</name><argument_list>(<argument>_Pp __p</argument>)</argument_list></macro> <name>_NOEXCEPT</name> <block>{
<expr><name>pointer</name> <name>__tmp</name> <operator>=</operator> <call><name><name>__ptr_</name><operator>.</operator><name>first</name></name><argument_list>()</argument_list></call></expr>;
<expr><call><name><name>__ptr_</name><operator>.</operator><name>first</name></name><argument_list>()</argument_list></call> <operator>=</operator> <name>__p</name></expr>;
<if_stmt><if>if <condition>(<expr><name>__tmp</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><call><name><name>__ptr_</name><operator>.</operator><name>second</name></name><argument_list>()</argument_list></call><argument_list>(<argument><expr><name>__tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
}</block></expr></expr_stmt>

<function><type><name>_LIBCPP_INLINE_VISIBILITY</name>
<name>void</name></type> <name>reset</name><parameter_list>(<parameter><decl><type><name>nullptr_t</name></type> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list> _NOEXCEPT <block>{<block_content>
<decl_stmt><decl><type><name>pointer</name></type> <name>__tmp</name> <init>= <expr><call><name><name>__ptr_</name><operator>.</operator><name>first</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>__ptr_</name><operator>.</operator><name>first</name></name><argument_list>()</argument_list></call> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>__tmp</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><call><name><name>__ptr_</name><operator>.</operator><name>second</name></name><argument_list>()</argument_list></call><argument_list>(<argument><expr><name>__tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>_LIBCPP_INLINE_VISIBILITY</name>
<name>void</name></type> <name>swap</name><parameter_list>(<parameter><decl><type><name>unique_ptr</name><modifier>&amp;</modifier></type> <name>__u</name></decl></parameter>)</parameter_list> _NOEXCEPT <block>{<block_content>
<expr_stmt><expr><call><name><name>__ptr_</name><operator>.</operator><name>swap</name></name><argument_list>(<argument><expr><name><name>__u</name><operator>.</operator><name>__ptr_</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>_Tp</name></expr></argument>, <argument><expr><name>class</name> <name>_Dp</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>_LIBCPP_INLINE_VISIBILITY</name>
<name>typename</name> <name><name>enable_if</name><argument_list type="generic">&lt;
<argument><expr><name><name>__is_swappable</name><argument_list type="generic">&lt;<argument><expr><name>_Dp</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>,
<argument><expr><name>void</name></expr></argument>
&gt;</argument_list></name><operator>::</operator><name>type</name>
<macro><name>swap</name><argument_list>(<argument>unique_ptr&lt;_Tp</argument>, <argument>_Dp&gt;&amp; __x</argument>, <argument>unique_ptr&lt;_Tp</argument>, <argument>_Dp&gt;&amp; __y</argument>)</argument_list></macro> <name>_NOEXCEPT</name> <block>{<expr><call><name><name>__x</name><operator>.</operator><name>swap</name></name><argument_list>(<argument><expr><name>__y</name></expr></argument>)</argument_list></call></expr>;}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>_T1</name></expr></argument>, <argument><expr><name>class</name> <name>_D1</name></expr></argument>, <argument><expr><name>class</name> <name>_T2</name></expr></argument>, <argument><expr><name>class</name> <name>_D2</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>_LIBCPP_INLINE_VISIBILITY</name>
<name>bool</name>
<name>operator</name><operator>==</operator><operator>(</operator><specifier>const</specifier> <name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>_T1</name></expr></argument>, <argument><expr><name>_D1</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>__x</name><operator>,</operator> <specifier>const</specifier> <name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>_T2</name></expr></argument>, <argument><expr><name>_D2</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>__y</name><operator>)</operator> <block>{<return>return <expr><call><name><name>__x</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>__y</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</return>}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>_T1</name></expr></argument>, <argument><expr><name>class</name> <name>_D1</name></expr></argument>, <argument><expr><name>class</name> <name>_T2</name></expr></argument>, <argument><expr><name>class</name> <name>_D2</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>_LIBCPP_INLINE_VISIBILITY</name>
<name>bool</name>
<name>operator</name><operator>!=</operator><operator>(</operator><specifier>const</specifier> <name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>_T1</name></expr></argument>, <argument><expr><name>_D1</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>__x</name><operator>,</operator> <specifier>const</specifier> <name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>_T2</name></expr></argument>, <argument><expr><name>_D2</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>__y</name><operator>)</operator> <block>{<return>return <expr><operator>!</operator><operator>(</operator><name>__x</name> <operator>==</operator> <name>__y</name><operator>)</operator></expr>;</return>}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>_T1</name></expr></argument>, <argument><expr><name>class</name> <name>_D1</name></expr></argument>, <argument><expr><name>class</name> <name>_T2</name></expr></argument>, <argument><expr><name>class</name> <name>_D2</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>_LIBCPP_INLINE_VISIBILITY</name>
<name>bool</name>
<name>operator</name><operator>&lt;</operator> <operator>(</operator><specifier>const</specifier> <name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>_T1</name></expr></argument>, <argument><expr><name>_D1</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>__x</name><operator>,</operator> <specifier>const</specifier> <name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>_T2</name></expr></argument>, <argument><expr><name>_D2</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>__y</name><operator>)</operator>
<block>{
<typedef>typedef <expr_stmt><expr><name>typename</name> <name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>_T1</name></expr></argument>, <argument><expr><name>_D1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>pointer</name> <name>_P1</name></expr>;</expr_stmt></typedef></block></expr></expr_stmt>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>_T2</name></expr></argument>, <argument><expr><name>_D2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>pointer</name> <name>_P2</name></expr>;</expr_stmt></typedef>
<typedef>typedef <expr_stmt><expr><name>typename</name> <name><name>common_type</name><argument_list type="generic">&lt;<argument><expr><name>_P1</name></expr></argument>, <argument><expr><name>_P2</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name> <name>_Vp</name></expr>;</expr_stmt></typedef>
<return>return <expr><call><call><name><name>less</name><argument_list type="generic">&lt;<argument><expr><name>_Vp</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><argument_list>(<argument><expr><call><name><name>__x</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>__y</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>class</name> <name>_T1</name></expr><operator>,</operator> <expr><name>class</name> <name>_D1</name></expr><operator>,</operator> <expr><name>class</name> <name>_T2</name></expr><operator>,</operator> <expr><name>class</name> <name>_D2</name><operator>&gt;</operator>
<specifier>inline</specifier> <name>_LIBCPP_INLINE_VISIBILITY</name>
<name>bool</name>
<name>operator</name><operator>&gt;</operator> <operator>(</operator><specifier>const</specifier> <name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>_T1</name></expr></argument>, <argument><expr><name>_D1</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>__x</name><operator>,</operator> <specifier>const</specifier> <name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>_T2</name></expr></argument>, <argument><expr><name>_D2</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>__y</name><operator>)</operator> <block>{<return>return <expr><name>__y</name> <operator>&lt;</operator> <name>__x</name></expr>;</return>}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>_T1</name></expr></argument>, <argument><expr><name>class</name> <name>_D1</name></expr></argument>, <argument><expr><name>class</name> <name>_T2</name></expr></argument>, <argument><expr><name>class</name> <name>_D2</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>_LIBCPP_INLINE_VISIBILITY</name>
<name>bool</name>
<name>operator</name><operator>&lt;=</operator><operator>(</operator><specifier>const</specifier> <name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>_T1</name></expr></argument>, <argument><expr><name>_D1</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>__x</name><operator>,</operator> <specifier>const</specifier> <name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>_T2</name></expr></argument>, <argument><expr><name>_D2</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>__y</name><operator>)</operator> <block>{<return>return <expr><operator>!</operator><operator>(</operator><name>__y</name> <operator>&lt;</operator> <name>__x</name><operator>)</operator></expr>;</return>}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>_T1</name></expr></argument>, <argument><expr><name>class</name> <name>_D1</name></expr></argument>, <argument><expr><name>class</name> <name>_T2</name></expr></argument>, <argument><expr><name>class</name> <name>_D2</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>_LIBCPP_INLINE_VISIBILITY</name>
<name>bool</name>
<name>operator</name><operator>&gt;=</operator><operator>(</operator><specifier>const</specifier> <name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>_T1</name></expr></argument>, <argument><expr><name>_D1</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>__x</name><operator>,</operator> <specifier>const</specifier> <name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>_T2</name></expr></argument>, <argument><expr><name>_D2</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>__y</name><operator>)</operator> <block>{<return>return <expr><operator>!</operator><operator>(</operator><name>__x</name> <operator>&lt;</operator> <name>__y</name><operator>)</operator></expr>;</return>}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>_T1</name></expr></argument>, <argument><expr><name>class</name> <name>_D1</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>_LIBCPP_INLINE_VISIBILITY</name>
<name>bool</name>
<name>operator</name><operator>==</operator><operator>(</operator><specifier>const</specifier> <name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>_T1</name></expr></argument>, <argument><expr><name>_D1</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>__x</name><operator>,</operator> <name>nullptr_t</name><operator>)</operator> <name>_NOEXCEPT</name>
<block>{
<return>return <expr><operator>!</operator><name>__x</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>_T1</name></expr></argument>, <argument><expr><name>class</name> <name>_D1</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>_LIBCPP_INLINE_VISIBILITY</name>
<name>bool</name>
<name>operator</name><operator>==</operator><operator>(</operator><name>nullptr_t</name><operator>,</operator> <specifier>const</specifier> <name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>_T1</name></expr></argument>, <argument><expr><name>_D1</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>__x</name><operator>)</operator> <name>_NOEXCEPT</name>
<block>{
<return>return <expr><operator>!</operator><name>__x</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>_T1</name></expr></argument>, <argument><expr><name>class</name> <name>_D1</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>_LIBCPP_INLINE_VISIBILITY</name>
<name>bool</name>
<name>operator</name><operator>!=</operator><operator>(</operator><specifier>const</specifier> <name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>_T1</name></expr></argument>, <argument><expr><name>_D1</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>__x</name><operator>,</operator> <name>nullptr_t</name><operator>)</operator> <name>_NOEXCEPT</name>
<block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>__x</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>_T1</name></expr></argument>, <argument><expr><name>class</name> <name>_D1</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>_LIBCPP_INLINE_VISIBILITY</name>
<name>bool</name>
<name>operator</name><operator>!=</operator><operator>(</operator><name>nullptr_t</name><operator>,</operator> <specifier>const</specifier> <name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>_T1</name></expr></argument>, <argument><expr><name>_D1</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>__x</name><operator>)</operator> <name>_NOEXCEPT</name>
<block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>__x</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>_T1</name></expr></argument>, <argument><expr><name>class</name> <name>_D1</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>_LIBCPP_INLINE_VISIBILITY</name>
<name>bool</name>
<name>operator</name><operator>&lt;</operator><operator>(</operator><specifier>const</specifier> <name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>_T1</name></expr></argument>, <argument><expr><name>_D1</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>__x</name><operator>,</operator> <name>nullptr_t</name><operator>)</operator>
<block>{
<typedef>typedef <expr_stmt><expr><name>typename</name> <name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>_T1</name></expr></argument>, <argument><expr><name>_D1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>pointer</name> <name>_P1</name></expr>;</expr_stmt></typedef></block></expr></expr_stmt>
<return>return <expr><call><call><name><name>less</name><argument_list type="generic">&lt;<argument><expr><name>_P1</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><argument_list>(<argument><expr><call><name><name>__x</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>class</name> <name>_T1</name></expr><operator>,</operator> <expr><name>class</name> <name>_D1</name><operator>&gt;</operator>
<specifier>inline</specifier> <name>_LIBCPP_INLINE_VISIBILITY</name>
<name>bool</name>
<name>operator</name><operator>&lt;</operator><operator>(</operator><name>nullptr_t</name><operator>,</operator> <specifier>const</specifier> <name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>_T1</name></expr></argument>, <argument><expr><name>_D1</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>__x</name><operator>)</operator>
<block>{
<typedef>typedef <expr_stmt><expr><name>typename</name> <name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>_T1</name></expr></argument>, <argument><expr><name>_D1</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>pointer</name> <name>_P1</name></expr>;</expr_stmt></typedef></block></expr></expr_stmt>
<return>return <expr><call><call><name><name>less</name><argument_list type="generic">&lt;<argument><expr><name>_P1</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><argument_list>(<argument><expr><name>nullptr</name></expr></argument>, <argument><expr><call><name><name>__x</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}

template <expr_stmt><expr><operator>&lt;</operator><name>class</name> <name>_T1</name></expr><operator>,</operator> <expr><name>class</name> <name>_D1</name><operator>&gt;</operator>
<specifier>inline</specifier> <name>_LIBCPP_INLINE_VISIBILITY</name>
<name>bool</name>
<name>operator</name><operator>&gt;</operator><operator>(</operator><specifier>const</specifier> <name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>_T1</name></expr></argument>, <argument><expr><name>_D1</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>__x</name><operator>,</operator> <name>nullptr_t</name><operator>)</operator>
<block>{
<return>return <expr><name>nullptr</name> <operator>&lt;</operator> <name>__x</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>_T1</name></expr></argument>, <argument><expr><name>class</name> <name>_D1</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>_LIBCPP_INLINE_VISIBILITY</name>
<name>bool</name>
<name>operator</name><operator>&gt;</operator><operator>(</operator><name>nullptr_t</name><operator>,</operator> <specifier>const</specifier> <name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>_T1</name></expr></argument>, <argument><expr><name>_D1</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>__x</name><operator>)</operator>
<block>{
<return>return <expr><name>__x</name> <operator>&lt;</operator> <name>nullptr</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>_T1</name></expr></argument>, <argument><expr><name>class</name> <name>_D1</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>_LIBCPP_INLINE_VISIBILITY</name>
<name>bool</name>
<name>operator</name><operator>&lt;=</operator><operator>(</operator><specifier>const</specifier> <name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>_T1</name></expr></argument>, <argument><expr><name>_D1</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>__x</name><operator>,</operator> <name>nullptr_t</name><operator>)</operator>
<block>{
<return>return <expr><operator>!</operator><operator>(</operator><name>nullptr</name> <operator>&lt;</operator> <name>__x</name><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>_T1</name></expr></argument>, <argument><expr><name>class</name> <name>_D1</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>_LIBCPP_INLINE_VISIBILITY</name>
<name>bool</name>
<name>operator</name><operator>&lt;=</operator><operator>(</operator><name>nullptr_t</name><operator>,</operator> <specifier>const</specifier> <name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>_T1</name></expr></argument>, <argument><expr><name>_D1</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>__x</name><operator>)</operator>
<block>{
<return>return <expr><operator>!</operator><operator>(</operator><name>__x</name> <operator>&lt;</operator> <name>nullptr</name><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>_T1</name></expr></argument>, <argument><expr><name>class</name> <name>_D1</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>_LIBCPP_INLINE_VISIBILITY</name>
<name>bool</name>
<name>operator</name><operator>&gt;=</operator><operator>(</operator><specifier>const</specifier> <name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>_T1</name></expr></argument>, <argument><expr><name>_D1</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>__x</name><operator>,</operator> <name>nullptr_t</name><operator>)</operator>
<block>{
<return>return <expr><operator>!</operator><operator>(</operator><name>__x</name> <operator>&lt;</operator> <name>nullptr</name><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>_T1</name></expr></argument>, <argument><expr><name>class</name> <name>_D1</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>_LIBCPP_INLINE_VISIBILITY</name>
<name>bool</name>
<name>operator</name><operator>&gt;=</operator><operator>(</operator><name>nullptr_t</name><operator>,</operator> <specifier>const</specifier> <name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>_T1</name></expr></argument>, <argument><expr><name>_D1</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>__x</name><operator>)</operator>
<block>{
<return>return <expr><operator>!</operator><operator>(</operator><name>nullptr</name> <operator>&lt;</operator> <name>__x</name><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>_LIBCPP_STD_VER</name> <operator>&gt;</operator> <literal type="number">11</literal></expr></cpp:if>

<macro><name>template</name></macro><expr_stmt><expr><operator>&lt;</operator><name>class</name> <name>_Tp</name><operator>&gt;</operator>
struct <name>__unique_if</name>
<block>{
<typedef>typedef <type><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>_Tp</name></expr></argument>&gt;</argument_list></name></type> <name>__unique_single</name>;</typedef>
}</block></expr></expr_stmt><empty_stmt>;</empty_stmt>

<macro><name>template</name></macro><expr_stmt><expr><operator>&lt;</operator><name>class</name> <name>_Tp</name><operator>&gt;</operator>
struct <name><name>__unique_if</name><argument_list type="generic">&lt;<argument><expr><name><name>_Tp</name><index>[]</index></name></expr></argument>&gt;</argument_list></name>
<block>{
<typedef>typedef <type><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name><name>_Tp</name><index>[]</index></name></expr></argument>&gt;</argument_list></name></type> <name>__unique_array_unknown_bound</name>;</typedef>
}</block></expr></expr_stmt><empty_stmt>;</empty_stmt>

<macro><name>template</name></macro><expr_stmt><expr><operator>&lt;</operator><name>class</name> <name>_Tp</name></expr><operator>,</operator> <expr><name>size_t</name> <name>_Np</name><operator>&gt;</operator>
struct <name><name>__unique_if</name><argument_list type="generic">&lt;<argument><expr><name><name>_Tp</name><index>[<expr><name>_Np</name></expr>]</index></name></expr></argument>&gt;</argument_list></name>
<block>{
<typedef>typedef <type><name>void</name></type> <name>__unique_array_known_bound</name>;</typedef>
}</block></expr></expr_stmt><empty_stmt>;</empty_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>class</name> <name>_Tp</name></expr></argument>, <argument><expr><name>class</name><modifier>...</modifier> <name>_Args</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>_LIBCPP_INLINE_VISIBILITY</name>
<name>typename</name> <name><name>__unique_if</name><argument_list type="generic">&lt;<argument><expr><name>_Tp</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>__unique_single</name>
<macro><name>make_unique</name><argument_list>(<argument>_Args&amp;&amp;... __args</argument>)</argument_list></macro>
<block>{
<return>return <macro><name>unique_ptr</name></macro><expr><operator>&lt;</operator><name>_Tp</name><operator>&gt;</operator><operator>(</operator><name>new</name> <call><name>_Tp</name><argument_list>(<argument><expr><name>_VSTD</name><operator>::</operator><call><name><name>forward</name><argument_list type="generic">&lt;<argument><expr><name>_Args</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>__args</name></expr></argument>)</argument_list></call><operator>...</operator></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>class</name> <name>_Tp</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>_LIBCPP_INLINE_VISIBILITY</name>
<name>typename</name> <name><name>__unique_if</name><argument_list type="generic">&lt;<argument><expr><name>_Tp</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>__unique_array_unknown_bound</name>
<macro><name>make_unique</name><argument_list>(<argument>size_t __n</argument>)</argument_list></macro>
<block>{
<typedef>typedef <expr_stmt><expr><name>typename</name> <name><name>remove_extent</name><argument_list type="generic">&lt;<argument><expr><name>_Tp</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name> <name>_Up</name></expr>;</expr_stmt></typedef></block></expr></expr_stmt>
<return>return <macro><name>unique_ptr</name></macro><expr><operator>&lt;</operator><name>_Tp</name><operator>&gt;</operator><operator>(</operator><name>new</name> <name><name>_Up</name><index>[<expr><name>__n</name></expr>]</index></name><operator>(</operator><operator>)</operator><operator>)</operator></expr>;</return>
}

template<expr_stmt><expr><operator>&lt;</operator><name>class</name> <name>_Tp</name></expr><operator>,</operator> <expr><name>class</name><operator>...</operator> <name>_Args</name><operator>&gt;</operator>
<name>typename</name> <name><name>__unique_if</name><argument_list type="generic">&lt;<argument><expr><name>_Tp</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>__unique_array_known_bound</name>
<call><name>make_unique</name><argument_list>(<argument><expr><name>_Args</name><operator>&amp;&amp;</operator><operator>...</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name>delete</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>_Tp</name></expr></argument>&gt;</argument_list></name> struct <name>_LIBCPP_TEMPLATE_VIS</name></type> <name>hash</name></decl>;</decl_stmt>

<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>class</name> <name>_Tp</name></expr><operator>,</operator> <expr><name>class</name> <name>_Dp</name><operator>&gt;</operator>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_LIBCPP_CXX03_LANG</name></expr></argument>)</argument_list></call></expr></cpp:if>
struct <name>_LIBCPP_TEMPLATE_VIS</name> <name><name>hash</name><argument_list type="generic">&lt;<argument><expr><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>_Tp</name></expr></argument>, <argument><expr><name>_Dp</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
struct <name>_LIBCPP_TEMPLATE_VIS</name> <name><name>hash</name><argument_list type="generic">&lt;<argument><expr><name><name>__enable_hash_helper</name><argument_list type="generic">&lt;
<argument><expr><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>_Tp</name></expr></argument>, <argument><expr><name>_Dp</name></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><name>typename</name> <name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>_Tp</name></expr></argument>, <argument><expr><name>_Dp</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>pointer</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>_LIBCPP_STD_VER</name> <operator>&lt;=</operator> <literal type="number">17</literal> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_LIBCPP_ENABLE_CXX20_REMOVED_BINDER_TYPEDEFS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><name>_LIBCPP_DEPRECATED_IN_CXX17</name></expr> <typedef>typedef <type><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>_Tp</name></expr></argument>, <argument><expr><name>_Dp</name></expr></argument>&gt;</argument_list></name></type> <name>argument_type</name>;</typedef>
<name>_LIBCPP_DEPRECATED_IN_CXX17</name></block></expr></expr_stmt> <typedef>typedef <type><name>size_t</name></type> <name>result_type</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>_LIBCPP_INLINE_VISIBILITY</name>
<name>size_t</name> <macro><name>operator</name><argument_list>()</argument_list></macro><operator>(</operator><specifier>const</specifier> <name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>_Tp</name></expr></argument>, <argument><expr><name>_Dp</name></expr></argument>&gt;</argument_list></name><operator>&amp;</operator> <name>__ptr</name><operator>)</operator> <specifier>const</specifier>
<block>{
<typedef>typedef <expr_stmt><expr><name>typename</name> <name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>_Tp</name></expr></argument>, <argument><expr><name>_Dp</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>pointer</name> <name>pointer</name></expr>;</expr_stmt></typedef></block></expr></expr_stmt>
<return>return <expr><call><call><name><name>hash</name><argument_list type="generic">&lt;<argument><expr><name>pointer</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><argument_list>(<argument><expr><call><name><name>__ptr</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}
}<empty_stmt>;</empty_stmt>

<decl><type><name>_LIBCPP_END_NAMESPACE_STD</name></type>

<name>_LIBCPP_POP_MACROS</name></decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
