<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/libucl/src/ucl_util.c">























<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ucl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ucl_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ucl_chartable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"kvec.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;glob.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/param.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NBBY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NBBY</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LIBGEN_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;libgen.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <macro><name>kvec_t</name><argument_list>(<argument>ucl_object_t *</argument>)</argument_list></macro> <expr_stmt><expr><name>ucl_array_t</name></expr>;</expr_stmt></typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UCL_ARRAY_GET</name><parameter_list>(<parameter><type><name>ar</name></type></parameter>, <parameter><type><name>obj</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ucl_array_t *ar = (ucl_array_t *)((obj) != NULL ? (obj)-&gt;value.av : NULL)</cpp:value></cpp:define>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_OPENSSL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;openssl/err.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;openssl/sha.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;openssl/rsa.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;openssl/ssl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;openssl/evp.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CURL_FOUND</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CURL_DISABLE_TYPECHECK</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;curl/curl.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FETCH_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fetch.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;io.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;direct.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>PROT_READ</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROT_READ</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>PROT_WRITE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROT_WRITE</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>PROT_READWRITE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROT_READWRITE</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MAP_SHARED</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAP_SHARED</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MAP_PRIVATE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAP_PRIVATE</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MAP_FAILED</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAP_FAILED</name></cpp:macro> <cpp:value>((void *) -1)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>getcwd</name></cpp:macro> <cpp:value>_getcwd</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>open</name></cpp:macro> <cpp:value>_open</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>close</name></cpp:macro> <cpp:value>_close</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>ucl_mmap</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>length</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>prot</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>access</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>off_t</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>map</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HANDLE</name></type> <name>handle</name> <init>= <expr><name>INVALID_HANDLE_VALUE</name></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>prot</name></expr>)</condition> <block>{<block_content>
<default>default:</default>
<case>case <expr><name>PROT_READ</name></expr>:</case>
<block>{<block_content>
<expr_stmt><expr><name>handle</name> <operator>=</operator> <call><name>CreateFileMapping</name><argument_list>(<argument><expr><operator>(</operator><name>HANDLE</name><operator>)</operator> <call><name>_get_osfhandle</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>PAGE_READONLY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>handle</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>map</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <call><name>MapViewOfFile</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>FILE_MAP_READ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>PROT_WRITE</name></expr>:</case>
<block>{<block_content>
<expr_stmt><expr><name>handle</name> <operator>=</operator> <call><name>CreateFileMapping</name><argument_list>(<argument><expr><operator>(</operator><name>HANDLE</name><operator>)</operator> <call><name>_get_osfhandle</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>PAGE_READWRITE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>handle</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>map</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <call><name>MapViewOfFile</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>FILE_MAP_WRITE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>PROT_READWRITE</name></expr>:</case>
<block>{<block_content>
<expr_stmt><expr><name>handle</name> <operator>=</operator> <call><name>CreateFileMapping</name><argument_list>(<argument><expr><operator>(</operator><name>HANDLE</name><operator>)</operator> <call><name>_get_osfhandle</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>PAGE_READWRITE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>handle</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>map</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <call><name>MapViewOfFile</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>FILE_MAP_ALL_ACCESS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
</block_content>}</block></switch>
<if_stmt><if>if <condition>(<expr><name>map</name> <operator>==</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>MAP_FAILED</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>map</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>ucl_munmap</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>map</name></decl></parameter>,<parameter><decl><type><name>size_t</name></type> <name>length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>UnmapViewOfFile</name><argument_list>(<argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return<expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return<expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name><modifier>*</modifier></type> <name>ucl_realpath</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>resolved_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>tmp</name><index>[<expr><name>MAX_PATH</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
<while>while<condition>(<expr><operator>*</operator><name>p</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><call><name>_fullpath</name><argument_list>(<argument><expr><name>resolved_path</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>MAX_PATH</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>char</name> <modifier>*</modifier></type><name>dirname</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>path_buffer</name><index>[<expr><name>_MAX_PATH</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>drive</name><index>[<expr><name>_MAX_DRIVE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>dir</name><index>[<expr><name>_MAX_DIR</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>fname</name><index>[<expr><name>_MAX_FNAME</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>ext</name><index>[<expr><name>_MAX_EXT</name></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>_splitpath</name> <argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>drive</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>ext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>_makepath</name><argument_list>(<argument><expr><name>path_buffer</name></expr></argument>, <argument><expr><name>drive</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>path_buffer</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type><name>basename</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>path_buffer</name><index>[<expr><name>_MAX_PATH</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>drive</name><index>[<expr><name>_MAX_DRIVE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>dir</name><index>[<expr><name>_MAX_DIR</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>fname</name><index>[<expr><name>_MAX_FNAME</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>ext</name><index>[<expr><name>_MAX_EXT</name></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>_splitpath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>drive</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>ext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>_makepath</name><argument_list>(<argument><expr><name>path_buffer</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>ext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>path_buffer</name></expr>;</return>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ucl_mmap</name></cpp:macro> <cpp:value>mmap</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ucl_munmap</name></cpp:macro> <cpp:value>munmap</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ucl_realpath</name></cpp:macro> <cpp:value>realpath</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>ucl_object_dtor</name>) <parameter_list>(<parameter><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>;</function_decl></typedef>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ucl_object_free_internal</name> <parameter_list>(<parameter><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>allow_rec</name></decl></parameter>,
<parameter><decl><type><name>ucl_object_dtor</name></type> <name>dtor</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ucl_object_dtor_unref</name> <parameter_list>(<parameter><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ucl_object_dtor_free</name> <parameter_list>(<parameter><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>trash_stack</name><index>[<expr><name>UCL_TRASH_KEY</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>UCL_FREE</name> <argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>hh</name><operator>.</operator><name>keylen</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>trash_stack</name><index>[<expr><name>UCL_TRASH_KEY</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>trash_stack</name><index>[<expr><name>UCL_TRASH_VALUE</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>UCL_FREE</name> <argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>trash_stack</name><index>[<expr><name>UCL_TRASH_VALUE</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>obj</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>UCL_OBJECT_EPHEMERAL</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>UCL_USERDATA</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>UCL_FREE</name> <argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>ucl_object_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>ucl_object_userdata</name></name> <modifier>*</modifier></type><name>ud</name> <init>= <expr><operator>(</operator>struct <name>ucl_object_userdata</name> <operator>*</operator><operator>)</operator><name>obj</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ud</name><operator>-&gt;</operator><name>dtor</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>ud</name><operator>-&gt;</operator><name>dtor</name></name> <argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>ud</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>UCL_FREE</name> <argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><operator>*</operator><name>ud</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>void</name></type>
<name>ucl_object_dtor_unref_single</name> <parameter_list>(<parameter><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>obj</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_ATOMIC_BUILTINS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>rc</name> <init>= <expr><call><name>__sync_sub_and_fetch</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>obj</name><operator>-&gt;</operator><name>ref</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if_stmt><if>if <condition>(<expr><operator>--</operator><name><name>obj</name><operator>-&gt;</operator><name>ref</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>ucl_object_free_internal</name> <argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>ucl_object_dtor_unref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ucl_object_dtor_unref</name> <parameter_list>(<parameter><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>ref</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_object_dtor_free</name> <argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>

<expr_stmt><expr><call><name>ucl_object_dtor_unref_single</name> <argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ucl_object_free_internal</name> <parameter_list>(<parameter><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>allow_rec</name></decl></parameter>, <parameter><decl><type><name>ucl_object_dtor</name></type> <name>dtor</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>tmp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sub</name></decl>;</decl_stmt>

<while>while <condition>(<expr><name>obj</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>UCL_ARRAY</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>UCL_ARRAY_GET</name> <argument_list>(<argument><expr><name>vec</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>vec</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>vec</name><operator>-&gt;</operator><name>n</name></name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>sub</name> <operator>=</operator> <call><name>kv_A</name> <argument_list>(<argument><expr><operator>*</operator><name>vec</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>sub</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <name>sub</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>sub</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <name><name>sub</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dtor</name> <argument_list>(<argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sub</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>kv_destroy</name> <argument_list>(<argument><expr><operator>*</operator><name>vec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UCL_FREE</name> <argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><operator>*</operator><name>vec</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>vec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>av</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>UCL_OBJECT</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>ov</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_hash_destroy</name> <argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>ov</name></name></expr></argument>, <argument><expr><operator>(</operator><name>ucl_hash_free_func</name><operator>)</operator><name>dtor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>ov</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dtor</name> <argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>obj</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>allow_rec</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ucl_object_free</name> <parameter_list>(<parameter><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>ucl_object_free_internal</name> <argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>ucl_object_dtor_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>size_t</name></type>
<name>ucl_unescape_json_string</name> <parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><name>str</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>h</name> <init>= <expr><name>str</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>uval</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<while>while <condition>(<expr><name>len</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>h</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>h</name> <operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>




<expr_stmt><expr><name>len</name> <operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>t</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><operator>*</operator><name>h</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'n'</literal></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>t</name><operator>++</operator> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'r'</literal></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>t</name><operator>++</operator> <operator>=</operator> <literal type="char">'\r'</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'b'</literal></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>t</name><operator>++</operator> <operator>=</operator> <literal type="char">'\b'</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'t'</literal></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>t</name><operator>++</operator> <operator>=</operator> <literal type="char">'\t'</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'f'</literal></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>t</name><operator>++</operator> <operator>=</operator> <literal type="char">'\f'</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'\\'</literal></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>t</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'"'</literal></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>t</name><operator>++</operator> <operator>=</operator> <literal type="char">'"'</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'u'</literal></expr>:</case>

<expr_stmt><expr><name>uval</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>--</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>uval</name> <operator>&lt;&lt;=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>isdigit</name> <argument_list>(<argument><expr><name><name>h</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>uval</name> <operator>+=</operator> <name><name>h</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>h</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <name><name>h</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">'f'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>uval</name> <operator>+=</operator> <name><name>h</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="char">'a'</literal> <operator>+</operator> <literal type="number">10</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>h</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name><name>h</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">'F'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>uval</name> <operator>+=</operator> <name><name>h</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="char">'A'</literal> <operator>+</operator> <literal type="number">10</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<break>break;</break>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>


<if_stmt><if>if<condition>(<expr><name>uval</name> <operator>&lt;</operator> <literal type="number">0x80</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name>uval</name></expr>;</expr_stmt>
<expr_stmt><expr><name>t</name> <operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if<condition>(<expr><name>uval</name> <operator>&lt;</operator> <literal type="number">0x800</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0xC0</literal> <operator>+</operator> <operator>(</operator><operator>(</operator><name>uval</name> <operator>&amp;</operator> <literal type="number">0x7C0</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">6</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x80</literal> <operator>+</operator> <operator>(</operator><operator>(</operator><name>uval</name> <operator>&amp;</operator> <literal type="number">0x03F</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>t</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if<condition>(<expr><name>uval</name> <operator>&lt;</operator> <literal type="number">0x10000</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0xE0</literal> <operator>+</operator> <operator>(</operator><operator>(</operator><name>uval</name> <operator>&amp;</operator> <literal type="number">0xF000</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">12</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x80</literal> <operator>+</operator> <operator>(</operator><operator>(</operator><name>uval</name> <operator>&amp;</operator> <literal type="number">0x0FC0</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">6</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x80</literal> <operator>+</operator> <operator>(</operator><operator>(</operator><name>uval</name> <operator>&amp;</operator> <literal type="number">0x003F</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>t</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

else if(uval &lt;= 0x10FFFF) {
t[0] = 0xF0 + ((uval &amp; 0x1C0000) &gt;&gt; 18);
t[1] = 0x80 + ((uval &amp; 0x03F000) &gt;&gt; 12);
t[2] = 0x80 + ((uval &amp; 0x000FC0) &gt;&gt; 6);
t[3] = 0x80 + ((uval &amp; 0x00003F));
t += 4;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<else>else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>t</name><operator>++</operator> <operator>=</operator> <literal type="char">'?'</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<expr_stmt><expr><name>h</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>-=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<continue>continue;</continue>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>t</name><operator>++</operator> <operator>=</operator> <literal type="char">'u'</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><operator>*</operator><name>t</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>h</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<expr_stmt><expr><name>h</name> <operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>t</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>h</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><operator>*</operator><name>t</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>t</name> <operator>-</operator> <name>str</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type>
<name>ucl_unescape_squoted_string</name> <parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><name>str</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>h</name> <init>= <expr><name>str</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></if></if_stmt>



<while>while <condition>(<expr><name>len</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>h</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>h</name> <operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>




<expr_stmt><expr><name>len</name> <operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>t</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><operator>*</operator><name>h</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'\''</literal></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>t</name><operator>++</operator> <operator>=</operator> <literal type="char">'\''</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'\n'</literal></expr>:</case>

<break>break;</break>
<case>case <expr><literal type="char">'\r'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>h</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>h</name> <operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<default>default:</default>

<expr_stmt><expr><operator>*</operator><name>t</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>t</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>h</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>

<expr_stmt><expr><name>h</name> <operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>t</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>h</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>

<expr_stmt><expr><operator>*</operator><name>t</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>t</name> <operator>-</operator> <name>str</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>ucl_copy_key_trash</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>deconst</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>obj</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>trash_stack</name><index>[<expr><name>UCL_TRASH_KEY</name></expr>]</index></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>obj</name><operator>-&gt;</operator><name>key</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>deconst</name> <operator>=</operator> <call><name>__DECONST</name> <argument_list>(<argument><expr><name>ucl_object_t</name> <operator>*</operator></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>deconst</name><operator>-&gt;</operator><name>trash_stack</name><index>[<expr><name>UCL_TRASH_KEY</name></expr>]</index></name> <operator>=</operator> <call><name>malloc</name> <argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>keylen</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>deconst</name><operator>-&gt;</operator><name>trash_stack</name><index>[<expr><name>UCL_TRASH_KEY</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name><name>deconst</name><operator>-&gt;</operator><name>trash_stack</name><index>[<expr><name>UCL_TRASH_KEY</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>keylen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>deconst</name><operator>-&gt;</operator><name>trash_stack</name><index>[<expr><name>UCL_TRASH_KEY</name></expr>]</index><index>[<expr><name><name>obj</name><operator>-&gt;</operator><name>keylen</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>deconst</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>trash_stack</name><index>[<expr><name>UCL_TRASH_KEY</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>deconst</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>UCL_OBJECT_ALLOCATED_KEY</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name><name>obj</name><operator>-&gt;</operator><name>trash_stack</name><index>[<expr><name>UCL_TRASH_KEY</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ucl_chunk_free</name> <parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ucl_chunk</name></name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>chunk</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>ucl_parser_special_handler_chain</name></name> <modifier>*</modifier></type><name>chain</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>

<macro><name>LL_FOREACH_SAFE</name> <argument_list>(<argument>chunk-&gt;special_handlers</argument>, <argument>chain</argument>, <argument>tmp</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>chain</name><operator>-&gt;</operator><name>special_handler</name><operator>-&gt;</operator><name>free_function</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>chain</name><operator>-&gt;</operator><name>special_handler</name><operator>-&gt;</operator><name>free_function</name></name> <argument_list>(
<argument><expr><name><name>chain</name><operator>-&gt;</operator><name>begin</name></name></expr></argument>,
<argument><expr><name><name>chain</name><operator>-&gt;</operator><name>len</name></name></expr></argument>,
<argument><expr><name><name>chain</name><operator>-&gt;</operator><name>special_handler</name><operator>-&gt;</operator><name>user_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>UCL_FREE</name> <argument_list>(<argument><expr><name><name>chain</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name><name>chain</name><operator>-&gt;</operator><name>begin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>UCL_FREE</name> <argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><operator>*</operator><name>chain</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>chain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>special_handlers</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>chunk</name><operator>-&gt;</operator><name>fname</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>fname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>UCL_FREE</name> <argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><operator>*</operator><name>chunk</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>ucl_copy_value_trash</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>deconst</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>obj</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>trash_stack</name><index>[<expr><name>UCL_TRASH_VALUE</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>deconst</name> <operator>=</operator> <call><name>__DECONST</name> <argument_list>(<argument><expr><name>ucl_object_t</name> <operator>*</operator></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>UCL_STRING</name></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>UCL_OBJECT_BINARY</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>deconst</name><operator>-&gt;</operator><name>trash_stack</name><index>[<expr><name>UCL_TRASH_VALUE</name></expr>]</index></name> <operator>=</operator> <call><name>malloc</name> <argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>deconst</name><operator>-&gt;</operator><name>trash_stack</name><index>[<expr><name>UCL_TRASH_VALUE</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name><name>deconst</name><operator>-&gt;</operator><name>trash_stack</name><index>[<expr><name>UCL_TRASH_VALUE</name></expr>]</index></name></expr></argument>,
<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>sv</name></name></expr></argument>,
<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>deconst</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>sv</name></name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>trash_stack</name><index>[<expr><name>UCL_TRASH_VALUE</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name><name>deconst</name><operator>-&gt;</operator><name>trash_stack</name><index>[<expr><name>UCL_TRASH_VALUE</name></expr>]</index></name> <operator>=</operator> <call><name>malloc</name> <argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>len</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>deconst</name><operator>-&gt;</operator><name>trash_stack</name><index>[<expr><name>UCL_TRASH_VALUE</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name><name>deconst</name><operator>-&gt;</operator><name>trash_stack</name><index>[<expr><name>UCL_TRASH_VALUE</name></expr>]</index></name></expr></argument>,
<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>sv</name></name></expr></argument>,
<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>deconst</name><operator>-&gt;</operator><name>trash_stack</name><index>[<expr><name>UCL_TRASH_VALUE</name></expr>]</index><index>[<expr><name><name>obj</name><operator>-&gt;</operator><name>len</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>deconst</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>sv</name></name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>trash_stack</name><index>[<expr><name>UCL_TRASH_VALUE</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>

<expr_stmt><expr><name><name>deconst</name><operator>-&gt;</operator><name>trash_stack</name><index>[<expr><name>UCL_TRASH_VALUE</name></expr>]</index></name> <operator>=</operator> <call><name>ucl_object_emit_single_json</name> <argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>deconst</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>trash_stack</name><index>[<expr><name>UCL_TRASH_VALUE</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>deconst</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>UCL_OBJECT_ALLOCATED_VALUE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name><name>obj</name><operator>-&gt;</operator><name>trash_stack</name><index>[<expr><name>UCL_TRASH_VALUE</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ucl_object_t</name><modifier>*</modifier></type>
<name>ucl_parser_get_object</name> <parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ucl_parser</name></name> <modifier>*</modifier></type><name>parser</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>UCL_STATE_ERROR</name> <operator>&amp;&amp;</operator> <name><name>parser</name><operator>-&gt;</operator><name>top_obj</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>ucl_object_ref</name> <argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>top_obj</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ucl_parser_free</name> <parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ucl_parser</name></name> <modifier>*</modifier></type><name>parser</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>ucl_stack</name></name> <modifier>*</modifier></type><name>stack</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>stmp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>ucl_macro</name></name> <modifier>*</modifier></type><name>macro</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>mtmp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>ucl_chunk</name></name> <modifier>*</modifier></type><name>chunk</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ctmp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>ucl_pubkey</name></name> <modifier>*</modifier></type><name>key</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ktmp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>ucl_variable</name></name> <modifier>*</modifier></type><name>var</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>vtmp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>tr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>trtmp</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>top_obj</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_object_unref</name> <argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>top_obj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>includepaths</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_object_unref</name> <argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>includepaths</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<macro><name>LL_FOREACH_SAFE</name> <argument_list>(<argument>parser-&gt;stack</argument>, <argument>stack</argument>, <argument>stmp</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<macro><name>HASH_ITER</name> <argument_list>(<argument>hh</argument>, <argument>parser-&gt;macroes</argument>, <argument>macro</argument>, <argument>mtmp</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>macro</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>HASH_DEL</name> <argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>macroes</name></name></expr></argument>, <argument><expr><name>macro</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UCL_FREE</name> <argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>ucl_macro</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>macro</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<macro><name>LL_FOREACH_SAFE</name> <argument_list>(<argument>parser-&gt;chunks</argument>, <argument>chunk</argument>, <argument>ctmp</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_chunk_free</name> <argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<macro><name>LL_FOREACH_SAFE</name> <argument_list>(<argument>parser-&gt;keys</argument>, <argument>key</argument>, <argument>ktmp</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>UCL_FREE</name> <argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>ucl_pubkey</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<macro><name>LL_FOREACH_SAFE</name> <argument_list>(<argument>parser-&gt;variables</argument>, <argument>var</argument>, <argument>vtmp</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>var</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UCL_FREE</name> <argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>ucl_variable</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<macro><name>LL_FOREACH_SAFE</name> <argument_list>(<argument>parser-&gt;trash_objs</argument>, <argument>tr</argument>, <argument>trtmp</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_object_free_internal</name> <argument_list>(<argument><expr><name>tr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>ucl_object_dtor_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>err</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>utstring_free</name> <argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>err</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>cur_file</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>cur_file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>comments</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_object_unref</name> <argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>comments</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>UCL_FREE</name> <argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>ucl_parser</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>ucl_parser_get_error</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ucl_parser</name></name> <modifier>*</modifier></type><name>parser</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>err</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>utstring_body</name> <argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>err</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>ucl_parser_get_error_code</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ucl_parser</name></name> <modifier>*</modifier></type><name>parser</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><name><name>parser</name><operator>-&gt;</operator><name>err_code</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>unsigned</name></type>
<name>ucl_parser_get_column</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ucl_parser</name></name> <modifier>*</modifier></type><name>parser</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>parser</name><operator>-&gt;</operator><name>chunks</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><name><name>parser</name><operator>-&gt;</operator><name>chunks</name><operator>-&gt;</operator><name>column</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>unsigned</name></type>
<name>ucl_parser_get_linenum</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ucl_parser</name></name> <modifier>*</modifier></type><name>parser</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>parser</name><operator>-&gt;</operator><name>chunks</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><name><name>parser</name><operator>-&gt;</operator><name>chunks</name><operator>-&gt;</operator><name>line</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ucl_parser_clear_error</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ucl_parser</name></name> <modifier>*</modifier></type><name>parser</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>parser</name><operator>-&gt;</operator><name>err</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>utstring_free</name><argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>err</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>err</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>err_code</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ucl_pubkey_add</name> <parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ucl_parser</name></name> <modifier>*</modifier></type><name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_OPENSSL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>ucl_create_err</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>err</name></name></expr></argument>, <argument><expr><literal type="string">"cannot check signatures without openssl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>OPENSSL_VERSION_NUMBER</name> <operator>&lt;</operator> <literal type="number">0x10000000L</literal><operator>)</operator></expr></cpp:if>
<expr_stmt><expr><call><name>ucl_create_err</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>err</name></name></expr></argument>, <argument><expr><literal type="string">"cannot check signatures, openssl version is unsupported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>EXIT_FAILURE</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name><name>struct</name> <name>ucl_pubkey</name></name> <modifier>*</modifier></type><name>nkey</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BIO</name> <modifier>*</modifier></type><name>mem</name></decl>;</decl_stmt>

<expr_stmt><expr><name>mem</name> <operator>=</operator> <call><name>BIO_new_mem_buf</name> <argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>key</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nkey</name> <operator>=</operator> <call><name>UCL_ALLOC</name> <argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>ucl_pubkey</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nkey</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_create_err</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>err</name></name></expr></argument>, <argument><expr><literal type="string">"cannot allocate memory for key"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>nkey</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <call><name>PEM_read_bio_PUBKEY</name> <argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nkey</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BIO_free</name> <argument_list>(<argument><expr><name>mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>nkey</name><operator>-&gt;</operator><name>key</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>UCL_FREE</name> <argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>ucl_pubkey</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>nkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ucl_create_err</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>err</name></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>,
<argument><expr><call><name>ERR_error_string</name> <argument_list>(<argument><expr><call><name>ERR_get_error</name> <argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>LL_PREPEND</name> <argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>keys</name></name></expr></argument>, <argument><expr><name>nkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>ucl_parser_add_special_handler</name> <parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ucl_parser</name></name> <modifier>*</modifier></type><name>parser</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>ucl_parser_special_handler</name></name> <modifier>*</modifier></type><name>handler</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>LL_APPEND</name> <argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>special_handlers</name></name></expr></argument>, <argument><expr><name>handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CURL_FOUND</name></expr></argument>)</argument_list></call></expr></cpp:if>
<struct>struct <name>ucl_curl_cbdata</name> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>buflen</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>ucl_curl_write_callback</name> <parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>contents</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nmemb</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>ud</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>ucl_curl_cbdata</name></name> <modifier>*</modifier></type><name>cbdata</name> <init>= <expr><name>ud</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>realsize</name> <init>= <expr><name>size</name> <operator>*</operator> <name>nmemb</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>cbdata</name><operator>-&gt;</operator><name>buf</name></name> <operator>=</operator> <call><name>realloc</name> <argument_list>(<argument><expr><name><name>cbdata</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>cbdata</name><operator>-&gt;</operator><name>buflen</name></name> <operator>+</operator> <name>realsize</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>cbdata</name><operator>-&gt;</operator><name>buf</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>cbdata</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name><name>cbdata</name><operator>-&gt;</operator><name>buflen</name></name></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><name>contents</name></expr></argument>, <argument><expr><name>realsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cbdata</name><operator>-&gt;</operator><name>buflen</name></name> <operator>+=</operator> <name>realsize</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cbdata</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name><name>cbdata</name><operator>-&gt;</operator><name>buflen</name></name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<return>return <expr><name>realsize</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>









<function><type><name>bool</name></type>
<name>ucl_fetch_url</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>url</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>buflen</name></decl></parameter>,
<parameter><decl><type><name>UT_string</name> <modifier>*</modifier><modifier>*</modifier></type><name>err</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>must_exist</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FETCH_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name><name>struct</name> <name>url</name></name> <modifier>*</modifier></type><name>fetch_url</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>url_stat</name></name></type> <name>us</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>in</name></decl>;</decl_stmt>

<expr_stmt><expr><name>fetch_url</name> <operator>=</operator> <call><name>fetchParseURL</name> <argument_list>(<argument><expr><name>url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fetch_url</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_create_err</name> <argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><literal type="string">"invalid URL %s: %s"</literal></expr></argument>,
<argument><expr><name>url</name></expr></argument>, <argument><expr><call><name>strerror</name> <argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>in</name> <operator>=</operator> <call><name>fetchXGet</name> <argument_list>(<argument><expr><name>fetch_url</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>us</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>must_exist</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_create_err</name> <argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><literal type="string">"cannot fetch URL %s: %s"</literal></expr></argument>,
<argument><expr><name>url</name></expr></argument>, <argument><expr><call><name>strerror</name> <argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>fetchFreeURL</name> <argument_list>(<argument><expr><name>fetch_url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>buflen</name> <operator>=</operator> <name><name>us</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>buf</name> <operator>=</operator> <call><name>malloc</name> <argument_list>(<argument><expr><operator>*</operator><name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>buf</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_create_err</name> <argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><literal type="string">"cannot allocate buffer for URL %s: %s"</literal></expr></argument>,
<argument><expr><name>url</name></expr></argument>, <argument><expr><call><name>strerror</name> <argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fclose</name> <argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fetchFreeURL</name> <argument_list>(<argument><expr><name>fetch_url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>fread</name> <argument_list>(<argument><expr><operator>*</operator><name>buf</name></expr></argument>, <argument><expr><operator>*</operator><name>buflen</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>in</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_create_err</name> <argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><literal type="string">"cannot read URL %s: %s"</literal></expr></argument>,
<argument><expr><name>url</name></expr></argument>, <argument><expr><call><name>strerror</name> <argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fclose</name> <argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fetchFreeURL</name> <argument_list>(<argument><expr><name>fetch_url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>fetchFreeURL</name> <argument_list>(<argument><expr><name>fetch_url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CURL_FOUND</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<decl_stmt><decl><type><name>CURL</name> <modifier>*</modifier></type><name>curl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>ucl_curl_cbdata</name></name></type> <name>cbdata</name></decl>;</decl_stmt>

<expr_stmt><expr><name>curl</name> <operator>=</operator> <call><name>curl_easy_init</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>curl</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_create_err</name> <argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><literal type="string">"CURL interface is broken"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>r</name> <operator>=</operator> <call><name>curl_easy_setopt</name> <argument_list>(<argument><expr><name>curl</name></expr></argument>, <argument><expr><name>CURLOPT_URL</name></expr></argument>, <argument><expr><name>url</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>CURLE_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_create_err</name> <argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><literal type="string">"invalid URL %s: %s"</literal></expr></argument>,
<argument><expr><name>url</name></expr></argument>, <argument><expr><call><name>curl_easy_strerror</name> <argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>curl_easy_cleanup</name> <argument_list>(<argument><expr><name>curl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>curl_easy_setopt</name> <argument_list>(<argument><expr><name>curl</name></expr></argument>, <argument><expr><name>CURLOPT_WRITEFUNCTION</name></expr></argument>, <argument><expr><name>ucl_curl_write_callback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cbdata</name><operator>.</operator><name>buf</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cbdata</name><operator>.</operator><name>buflen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>curl_easy_setopt</name> <argument_list>(<argument><expr><name>curl</name></expr></argument>, <argument><expr><name>CURLOPT_WRITEDATA</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cbdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>r</name> <operator>=</operator> <call><name>curl_easy_perform</name> <argument_list>(<argument><expr><name>curl</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>CURLE_OK</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>must_exist</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_create_err</name> <argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><literal type="string">"error fetching URL %s: %s"</literal></expr></argument>,
<argument><expr><name>url</name></expr></argument>, <argument><expr><call><name>curl_easy_strerror</name> <argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>curl_easy_cleanup</name> <argument_list>(<argument><expr><name>curl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>cbdata</name><operator>.</operator><name>buf</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>cbdata</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>buf</name> <operator>=</operator> <name><name>cbdata</name><operator>.</operator><name>buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>buflen</name> <operator>=</operator> <name><name>cbdata</name><operator>.</operator><name>buflen</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>curl_easy_cleanup</name> <argument_list>(<argument><expr><name>curl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>ucl_create_err</name> <argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><literal type="string">"URL support is disabled"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>









<function><type><name>bool</name></type>
<name>ucl_fetch_file</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>buflen</name></decl></parameter>,
<parameter><decl><type><name>UT_string</name> <modifier>*</modifier><modifier>*</modifier></type><name>err</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>must_exist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>stat</name> <argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>must_exist</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>EPERM</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_create_err</name> <argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><literal type="string">"cannot stat file %s: %s"</literal></expr></argument>,
<argument><expr><name>filename</name></expr></argument>, <argument><expr><call><name>strerror</name> <argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>S_ISREG</name> <argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>must_exist</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_create_err</name> <argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><literal type="string">"file %s is not a regular file"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>.</operator><name>st_size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>buf</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>buflen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fd</name> <operator>=</operator> <call><name>open</name> <argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_create_err</name> <argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><literal type="string">"cannot open file %s: %s"</literal></expr></argument>,
<argument><expr><name>filename</name></expr></argument>, <argument><expr><call><name>strerror</name> <argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>buf</name> <operator>=</operator> <call><name>ucl_mmap</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>st</name><operator>.</operator><name>st_size</name></name></expr></argument>, <argument><expr><name>PROT_READ</name></expr></argument>, <argument><expr><name>MAP_SHARED</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>MAP_FAILED</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>close</name> <argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ucl_create_err</name> <argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><literal type="string">"cannot mmap file %s: %s"</literal></expr></argument>,
<argument><expr><name>filename</name></expr></argument>, <argument><expr><call><name>strerror</name> <argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>buf</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>buflen</name> <operator>=</operator> <name><name>st</name><operator>.</operator><name>st_size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>close</name> <argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_OPENSSL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>OPENSSL_VERSION_NUMBER</name> <operator>&gt;=</operator> <literal type="number">0x10000000L</literal><operator>)</operator></expr></cpp:if>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>ucl_sig_check</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>datalen</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>sig</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>siglen</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ucl_parser</name></name> <modifier>*</modifier></type><name>parser</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>ucl_pubkey</name></name> <modifier>*</modifier></type><name>key</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>dig</name><index>[<expr><name>EVP_MAX_MD_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>diglen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>EVP_PKEY_CTX</name> <modifier>*</modifier></type><name>key_ctx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>EVP_MD_CTX</name> <modifier>*</modifier></type><name>sign_ctx</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>sign_ctx</name> <operator>=</operator> <call><name>EVP_MD_CTX_create</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<macro><name>LL_FOREACH</name> <argument_list>(<argument>parser-&gt;keys</argument>, <argument>key</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name>key_ctx</name> <operator>=</operator> <call><name>EVP_PKEY_CTX_new</name> <argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>key_ctx</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>EVP_PKEY_verify_init</name> <argument_list>(<argument><expr><name>key_ctx</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>EVP_PKEY_CTX_free</name> <argument_list>(<argument><expr><name>key_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>EVP_PKEY_CTX_set_rsa_padding</name> <argument_list>(<argument><expr><name>key_ctx</name></expr></argument>, <argument><expr><name>RSA_PKCS1_PADDING</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>EVP_PKEY_CTX_free</name> <argument_list>(<argument><expr><name>key_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>EVP_PKEY_CTX_set_signature_md</name> <argument_list>(<argument><expr><name>key_ctx</name></expr></argument>, <argument><expr><call><name>EVP_sha256</name> <argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>EVP_PKEY_CTX_free</name> <argument_list>(<argument><expr><name>key_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>EVP_DigestInit</name> <argument_list>(<argument><expr><name>sign_ctx</name></expr></argument>, <argument><expr><call><name>EVP_sha256</name> <argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>EVP_DigestUpdate</name> <argument_list>(<argument><expr><name>sign_ctx</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>datalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>EVP_DigestFinal</name> <argument_list>(<argument><expr><name>sign_ctx</name></expr></argument>, <argument><expr><name>dig</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>diglen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>EVP_PKEY_verify</name> <argument_list>(<argument><expr><name>key_ctx</name></expr></argument>, <argument><expr><name>sig</name></expr></argument>, <argument><expr><name>siglen</name></expr></argument>, <argument><expr><name>dig</name></expr></argument>, <argument><expr><name>diglen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>EVP_MD_CTX_destroy</name> <argument_list>(<argument><expr><name>sign_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>EVP_PKEY_CTX_free</name> <argument_list>(<argument><expr><name>key_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>EVP_PKEY_CTX_free</name> <argument_list>(<argument><expr><name>key_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>EVP_MD_CTX_destroy</name> <argument_list>(<argument><expr><name>sign_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<struct>struct <name>ucl_include_params</name> <block>{
<decl_stmt><decl><type><name>bool</name></type> <name>check_signature</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>must_exist</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>use_glob</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>use_prefix</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>soft_fail</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>allow_glob</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>priority</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>ucl_duplicate_strategy</name></name></type> <name>strat</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>ucl_parse_type</name></name></type> <name>parse_type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>target</name></decl>;</decl_stmt>
}</block>;</struct>









<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ucl_include_url</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>ucl_parser</name></name> <modifier>*</modifier></type><name>parser</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>ucl_include_params</name></name> <modifier>*</modifier></type><name>params</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<decl_stmt><decl><type><name>bool</name></type> <name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>buflen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>ucl_chunk</name></name> <modifier>*</modifier></type><name>chunk</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>urlbuf</name><index>[<expr><name>PATH_MAX</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>prev_state</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>urlbuf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>urlbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%.*s"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>len</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ucl_fetch_url</name> <argument_list>(<argument><expr><name>urlbuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buflen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>err</name></name></expr></argument>, <argument><expr><name><name>params</name><operator>-&gt;</operator><name>must_exist</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>!</operator><name><name>params</name><operator>-&gt;</operator><name>must_exist</name></name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>check_signature</name></name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_OPENSSL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>OPENSSL_VERSION_NUMBER</name> <operator>&gt;=</operator> <literal type="number">0x10000000L</literal><operator>)</operator></expr></cpp:if>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>sigbuf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>siglen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>urlbuf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>urlbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%.*s.sig"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>len</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ucl_fetch_url</name> <argument_list>(<argument><expr><name>urlbuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sigbuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>siglen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>err</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ucl_sig_check</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>, <argument><expr><name>sigbuf</name></expr></argument>, <argument><expr><name>siglen</name></expr></argument>, <argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_create_err</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>err</name></name></expr></argument>, <argument><expr><literal type="string">"cannot verify url %s: %s"</literal></expr></argument>,
<argument><expr><name>urlbuf</name></expr></argument>,
<argument><expr><call><name>ERR_error_string</name> <argument_list>(<argument><expr><call><name>ERR_get_error</name> <argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>siglen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_munmap</name> <argument_list>(<argument><expr><name>sigbuf</name></expr></argument>, <argument><expr><name>siglen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>siglen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_munmap</name> <argument_list>(<argument><expr><name>sigbuf</name></expr></argument>, <argument><expr><name>siglen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>prev_state</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>UCL_STATE_INIT</name></expr>;</expr_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ucl_parser_add_chunk_full</name> <argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>, <argument><expr><name><name>params</name><operator>-&gt;</operator><name>priority</name></name></expr></argument>,
<argument><expr><name><name>params</name><operator>-&gt;</operator><name>strat</name></name></expr></argument>, <argument><expr><name><name>params</name><operator>-&gt;</operator><name>parse_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>true</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>chunk</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>chunks</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>chunk</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>chunks</name></name> <operator>=</operator> <name><name>chunk</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ucl_chunk_free</name> <argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>prev_state</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>












<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ucl_include_file_single</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>ucl_parser</name></name> <modifier>*</modifier></type><name>parser</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ucl_include_params</name></name> <modifier>*</modifier></type><name>params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>ucl_chunk</name></name> <modifier>*</modifier></type><name>chunk</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>old_curfile</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>buflen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>filebuf</name><index>[<expr><name>PATH_MAX</name></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>realbuf</name><index>[<expr><name>PATH_MAX</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>prev_state</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>ucl_variable</name></name> <modifier>*</modifier></type><name>cur_var</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tmp_var</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>old_curdir</name> <init>= <expr><name>NULL</name></expr></init></decl>,
<decl><type ref="prev"><modifier>*</modifier></type><name>old_filename</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>nest_obj</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>old_obj</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>new_obj</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ucl_hash_t</name> <modifier>*</modifier></type><name>container</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>ucl_stack</name></name> <modifier>*</modifier></type><name>st</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>filebuf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>filebuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%.*s"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>len</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ucl_realpath</name> <argument_list>(<argument><expr><name>filebuf</name></expr></argument>, <argument><expr><name>realbuf</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>soft_fail</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>params</name><operator>-&gt;</operator><name>must_exist</name></name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>EPERM</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ucl_create_err</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>err</name></name></expr></argument>, <argument><expr><literal type="string">"cannot open file %s: %s"</literal></expr></argument>,
<argument><expr><name>filebuf</name></expr></argument>,
<argument><expr><call><name>strerror</name> <argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>cur_file</name></name> <operator>&amp;&amp;</operator> <call><name>strcmp</name> <argument_list>(<argument><expr><name>realbuf</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>cur_file</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>soft_fail</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ucl_create_err</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>err</name></name></expr></argument>, <argument><expr><literal type="string">"trying to include the file %s from itself"</literal></expr></argument>,
<argument><expr><name>realbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ucl_fetch_file</name> <argument_list>(<argument><expr><name>realbuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buflen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>err</name></name></expr></argument>, <argument><expr><name><name>params</name><operator>-&gt;</operator><name>must_exist</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>soft_fail</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>must_exist</name></name> <operator>||</operator> <name><name>parser</name><operator>-&gt;</operator><name>err</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>check_signature</name></name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_OPENSSL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>OPENSSL_VERSION_NUMBER</name> <operator>&gt;=</operator> <literal type="number">0x10000000L</literal><operator>)</operator></expr></cpp:if>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>sigbuf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>siglen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>filebuf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>filebuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s.sig"</literal></expr></argument>, <argument><expr><name>realbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ucl_fetch_file</name> <argument_list>(<argument><expr><name>filebuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sigbuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>siglen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>err</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ucl_sig_check</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>, <argument><expr><name>sigbuf</name></expr></argument>, <argument><expr><name>siglen</name></expr></argument>, <argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_create_err</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>err</name></name></expr></argument>, <argument><expr><literal type="string">"cannot verify file %s: %s"</literal></expr></argument>,
<argument><expr><name>filebuf</name></expr></argument>,
<argument><expr><call><name>ERR_error_string</name> <argument_list>(<argument><expr><call><name>ERR_get_error</name> <argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>sigbuf</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_munmap</name> <argument_list>(<argument><expr><name>sigbuf</name></expr></argument>, <argument><expr><name>siglen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>sigbuf</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_munmap</name> <argument_list>(<argument><expr><name>sigbuf</name></expr></argument>, <argument><expr><name>siglen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>old_curfile</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>cur_file</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>cur_file</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>


<macro><name>DL_FOREACH_SAFE</name> <argument_list>(<argument>parser-&gt;variables</argument>, <argument>cur_var</argument>, <argument>tmp_var</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>cur_var</name><operator>-&gt;</operator><name>var</name></name></expr></argument>, <argument><expr><literal type="string">"CURDIR"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>old_curdir</name> <operator>=</operator> <name>cur_var</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DL_DELETE</name> <argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>variables</name></name></expr></argument>, <argument><expr><name>cur_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>cur_var</name><operator>-&gt;</operator><name>var</name></name></expr></argument>, <argument><expr><literal type="string">"FILENAME"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>old_filename</name> <operator>=</operator> <name>cur_var</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DL_DELETE</name> <argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>variables</name></name></expr></argument>, <argument><expr><name>cur_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>ucl_parser_set_filevars</name> <argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>realbuf</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>prev_state</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>UCL_STATE_INIT</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>use_prefix</name></name> <operator>&amp;&amp;</operator> <name><name>params</name><operator>-&gt;</operator><name>prefix</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>prefix</name></name> <operator>=</operator> <call><name>basename</name> <argument_list>(<argument><expr><name>realbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ext</name> <operator>=</operator> <call><name>strrchr</name> <argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ext</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>ext</name></expr></argument>, <argument><expr><literal type="string">".conf"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name> <argument_list>(<argument><expr><name>ext</name></expr></argument>, <argument><expr><literal type="string">".ucl"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>ext</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>prefix</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>container</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>stack</name><operator>-&gt;</operator><name>obj</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>ov</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>old_obj</name> <operator>=</operator> <call><name>__DECONST</name> <argument_list>(<argument><expr><name>ucl_object_t</name> <operator>*</operator></expr></argument>, <argument><expr><call><name>ucl_hash_search</name> <argument_list>(<argument><expr><name>container</name></expr></argument>,
<argument><expr><name><name>params</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strcasecmp</name> <argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><literal type="string">"array"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>old_obj</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>old_obj</name> <operator>=</operator> <call><name>ucl_object_new_full</name> <argument_list>(<argument><expr><name>UCL_ARRAY</name></expr></argument>, <argument><expr><name><name>params</name><operator>-&gt;</operator><name>priority</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>old_obj</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <name><name>params</name><operator>-&gt;</operator><name>prefix</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>old_obj</name><operator>-&gt;</operator><name>keylen</name></name> <operator>=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ucl_copy_key_trash</name> <argument_list>(<argument><expr><name>old_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>old_obj</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>old_obj</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>old_obj</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name>container</name> <operator>=</operator> <call><name>ucl_hash_insert_object</name> <argument_list>(<argument><expr><name>container</name></expr></argument>, <argument><expr><name>old_obj</name></expr></argument>,
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>UCL_PARSER_KEY_LOWERCASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>stack</name><operator>-&gt;</operator><name>obj</name><operator>-&gt;</operator><name>len</name></name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>nest_obj</name> <operator>=</operator> <call><name>ucl_object_new_full</name> <argument_list>(<argument><expr><name>UCL_OBJECT</name></expr></argument>, <argument><expr><name><name>params</name><operator>-&gt;</operator><name>priority</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nest_obj</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>nest_obj</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nest_obj</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ucl_array_append</name> <argument_list>(<argument><expr><name>old_obj</name></expr></argument>, <argument><expr><name>nest_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ucl_object_type</name> <argument_list>(<argument><expr><name>old_obj</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>UCL_ARRAY</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>nest_obj</name> <operator>=</operator> <call><name>ucl_object_new_full</name> <argument_list>(<argument><expr><name>UCL_OBJECT</name></expr></argument>,
<argument><expr><name><name>params</name><operator>-&gt;</operator><name>priority</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nest_obj</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_create_err</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>err</name></name></expr></argument>,
<argument><expr><literal type="string">"cannot allocate memory for an object"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_munmap</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>nest_obj</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>nest_obj</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nest_obj</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ucl_array_append</name> <argument_list>(<argument><expr><name>old_obj</name></expr></argument>, <argument><expr><name>nest_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>

<expr_stmt><expr><name>new_obj</name> <operator>=</operator> <call><name>ucl_object_typed_new</name> <argument_list>(<argument><expr><name>UCL_ARRAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>new_obj</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_create_err</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>err</name></name></expr></argument>,
<argument><expr><literal type="string">"cannot allocate memory for an object"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_munmap</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>new_obj</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <name><name>old_obj</name><operator>-&gt;</operator><name>key</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_obj</name><operator>-&gt;</operator><name>keylen</name></name> <operator>=</operator> <name><name>old_obj</name><operator>-&gt;</operator><name>keylen</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_obj</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>UCL_OBJECT_MULTIVALUE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_obj</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>new_obj</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_obj</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name>nest_obj</name> <operator>=</operator> <call><name>ucl_object_new_full</name> <argument_list>(<argument><expr><name>UCL_OBJECT</name></expr></argument>,
<argument><expr><name><name>params</name><operator>-&gt;</operator><name>priority</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nest_obj</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_create_err</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>err</name></name></expr></argument>,
<argument><expr><literal type="string">"cannot allocate memory for an object"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_munmap</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>nest_obj</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>nest_obj</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nest_obj</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ucl_array_append</name> <argument_list>(<argument><expr><name>new_obj</name></expr></argument>, <argument><expr><name>old_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ucl_array_append</name> <argument_list>(<argument><expr><name>new_obj</name></expr></argument>, <argument><expr><name>nest_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ucl_hash_replace</name> <argument_list>(<argument><expr><name>container</name></expr></argument>, <argument><expr><name>old_obj</name></expr></argument>, <argument><expr><name>new_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>old_obj</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>nest_obj</name> <operator>=</operator> <call><name>ucl_object_new_full</name> <argument_list>(<argument><expr><name>UCL_OBJECT</name></expr></argument>, <argument><expr><name><name>params</name><operator>-&gt;</operator><name>priority</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>nest_obj</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_create_err</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>err</name></name></expr></argument>, <argument><expr><literal type="string">"cannot allocate memory for an object"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_munmap</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>nest_obj</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <name><name>params</name><operator>-&gt;</operator><name>prefix</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nest_obj</name><operator>-&gt;</operator><name>keylen</name></name> <operator>=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ucl_copy_key_trash</name><argument_list>(<argument><expr><name>nest_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nest_obj</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>nest_obj</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nest_obj</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name>container</name> <operator>=</operator> <call><name>ucl_hash_insert_object</name> <argument_list>(<argument><expr><name>container</name></expr></argument>, <argument><expr><name>nest_obj</name></expr></argument>,
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>UCL_PARSER_KEY_LOWERCASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>stack</name><operator>-&gt;</operator><name>obj</name><operator>-&gt;</operator><name>len</name></name> <operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ucl_object_type</name> <argument_list>(<argument><expr><name>old_obj</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>UCL_OBJECT</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>nest_obj</name> <operator>=</operator> <name>old_obj</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>

<expr_stmt><expr><call><name>ucl_create_err</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>err</name></name></expr></argument>,
<argument><expr><literal type="string">"Conflicting type for key: %s, asked %s, has %s"</literal></expr></argument>,
<argument><expr><name><name>params</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>, <argument><expr><name><name>params</name><operator>-&gt;</operator><name>target</name></name></expr></argument>,
<argument><expr><call><name>ucl_object_type_to_string</name> <argument_list>(<argument><expr><call><name>ucl_object_type</name> <argument_list>(<argument><expr><name>old_obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_munmap</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>



<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>stack</name><operator>-&gt;</operator><name>obj</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>ov</name></name> <operator>=</operator> <name>container</name></expr>;</expr_stmt>

<expr_stmt><expr><name>st</name> <operator>=</operator> <call><name>UCL_ALLOC</name> <argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>ucl_stack</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>st</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_create_err</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>err</name></name></expr></argument>, <argument><expr><literal type="string">"cannot allocate memory for an object"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ucl_object_unref</name> <argument_list>(<argument><expr><name>nest_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_munmap</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>obj</name></name> <operator>=</operator> <name>nest_obj</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>e</name><operator>.</operator><name>params</name><operator>.</operator><name>level</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>stack</name><operator>-&gt;</operator><name>e</name><operator>.</operator><name>params</name><operator>.</operator><name>level</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>e</name><operator>.</operator><name>params</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>stack</name><operator>-&gt;</operator><name>e</name><operator>.</operator><name>params</name><operator>.</operator><name>flags</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>e</name><operator>.</operator><name>params</name><operator>.</operator><name>line</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>stack</name><operator>-&gt;</operator><name>e</name><operator>.</operator><name>params</name><operator>.</operator><name>line</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>chunk</name></name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>chunks</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>LL_PREPEND</name> <argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>, <argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>cur_obj</name></name> <operator>=</operator> <name>nest_obj</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ucl_parser_add_chunk_full</name> <argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>, <argument><expr><name><name>params</name><operator>-&gt;</operator><name>priority</name></name></expr></argument>,
<argument><expr><name><name>params</name><operator>-&gt;</operator><name>strat</name></name></expr></argument>, <argument><expr><name><name>params</name><operator>-&gt;</operator><name>parse_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>prefix</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>nest_obj</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>stack</name></name> <operator>=</operator> <name><name>st</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UCL_FREE</name> <argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>ucl_stack</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>chunk</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>chunks</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>chunk</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>chunks</name></name> <operator>=</operator> <name><name>chunk</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ucl_chunk_free</name> <argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>recursion</name></name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>cur_file</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>cur_file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>cur_file</name></name> <operator>=</operator> <name>old_curfile</name></expr>;</expr_stmt>
<macro><name>DL_FOREACH_SAFE</name> <argument_list>(<argument>parser-&gt;variables</argument>, <argument>cur_var</argument>, <argument>tmp_var</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>cur_var</name><operator>-&gt;</operator><name>var</name></name></expr></argument>, <argument><expr><literal type="string">"CURDIR"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>old_curdir</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>DL_DELETE</name> <argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>variables</name></name></expr></argument>, <argument><expr><name>cur_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>cur_var</name><operator>-&gt;</operator><name>var</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>cur_var</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UCL_FREE</name> <argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>ucl_variable</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>cur_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>cur_var</name><operator>-&gt;</operator><name>var</name></name></expr></argument>, <argument><expr><literal type="string">"FILENAME"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>old_filename</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>DL_DELETE</name> <argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>variables</name></name></expr></argument>, <argument><expr><name>cur_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>cur_var</name><operator>-&gt;</operator><name>var</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>cur_var</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UCL_FREE</name> <argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>ucl_variable</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>cur_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<if_stmt><if>if <condition>(<expr><name>old_filename</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>DL_APPEND</name> <argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>variables</name></name></expr></argument>, <argument><expr><name>old_filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>old_curdir</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>DL_APPEND</name> <argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>variables</name></name></expr></argument>, <argument><expr><name>old_curdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>prev_state</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>buflen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_munmap</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>









<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ucl_include_file</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>ucl_parser</name></name> <modifier>*</modifier></type><name>parser</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>ucl_include_params</name></name> <modifier>*</modifier></type><name>params</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>data</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name> <init>= <expr><name>data</name> <operator>+</operator> <name>len</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>need_glob</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>glob_pattern</name><index>[<expr><name>PATH_MAX</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>params</name><operator>-&gt;</operator><name>allow_glob</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>ucl_include_file_single</name> <argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>parser</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>

<while>while <condition>(<expr><name>p</name> <operator>!=</operator> <name>end</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'*'</literal> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>need_glob</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>need_glob</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>glob_t</name></type> <name>globbuf</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memset</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>globbuf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>globbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ucl_strlcpy</name> <argument_list>(<argument><expr><name>glob_pattern</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>data</name></expr></argument>,
<argument><expr><operator>(</operator><ternary><condition><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>glob_pattern</name></expr></argument>)</argument_list></sizeof></expr> ?</condition><then> <expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><sizeof>sizeof <argument_list>(<argument><expr><name>glob_pattern</name></expr></argument>)</argument_list></sizeof></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>glob</name> <argument_list>(<argument><expr><name>glob_pattern</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>globbuf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><operator>!</operator><name><name>params</name><operator>-&gt;</operator><name>must_exist</name></name> <operator>||</operator> <name>false</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>globbuf</name><operator>.</operator><name>gl_pathc</name></name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>include_trace_func</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>parent</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>stack</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>parent</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>stack</name><operator>-&gt;</operator><name>obj</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name><name>parser</name><operator>-&gt;</operator><name>include_trace_func</name></name> <argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name><name>globbuf</name><operator>.</operator><name>gl_pathv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
<argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><name><name>globbuf</name><operator>.</operator><name>gl_pathv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>include_trace_ud</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ucl_include_file_single</name> <argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name><name>globbuf</name><operator>.</operator><name>gl_pathv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
<argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><name><name>globbuf</name><operator>.</operator><name>gl_pathv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>parser</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>soft_fail</name></name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>globfree</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>globbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>cnt</name> <operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>globfree</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>globbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cnt</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>params</name><operator>-&gt;</operator><name>must_exist</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_create_err</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>err</name></name></expr></argument>, <argument><expr><literal type="string">"cannot match any files for pattern %s"</literal></expr></argument>,
<argument><expr><name>glob_pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><call><name>ucl_include_file_single</name> <argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>parser</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>


<return>return <expr><call><name>ucl_include_file_single</name> <argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>parser</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ucl_include_common</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ucl_parser</name></name> <modifier>*</modifier></type><name>parser</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>default_try</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>default_sign</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>allow_url</name> <init>= <expr><name>false</name></expr></init></decl>, <decl><type ref="prev"/><name>search</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>duplicate</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>param</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ucl_object_iter_t</name></type> <name>it</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"/><name>ip</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>ipath</name><index>[<expr><name>PATH_MAX</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>ucl_include_params</name></name></type> <name>params</name></decl>;</decl_stmt>


<expr_stmt><expr><name><name>params</name><operator>.</operator><name>soft_fail</name></name> <operator>=</operator> <name>default_try</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>params</name><operator>.</operator><name>allow_glob</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>params</name><operator>.</operator><name>check_signature</name></name> <operator>=</operator> <name>default_sign</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>params</name><operator>.</operator><name>use_prefix</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>params</name><operator>.</operator><name>target</name></name> <operator>=</operator> <literal type="string">"object"</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>params</name><operator>.</operator><name>prefix</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>params</name><operator>.</operator><name>priority</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>params</name><operator>.</operator><name>parse_type</name></name> <operator>=</operator> <name>UCL_PARSE_UCL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>params</name><operator>.</operator><name>strat</name></name> <operator>=</operator> <name>UCL_DUPLICATE_APPEND</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>params</name><operator>.</operator><name>must_exist</name></name> <operator>=</operator> <operator>!</operator><name>default_try</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>include_trace_func</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>parent</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>stack</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>parent</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>stack</name><operator>-&gt;</operator><name>obj</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name><name>parser</name><operator>-&gt;</operator><name>include_trace_func</name></name> <argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>args</name></expr></argument>,
<argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>include_trace_ud</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>args</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>args</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>UCL_OBJECT</name></expr>)</condition> <block>{<block_content>
<while>while <condition>(<expr><operator>(</operator><name>param</name> <operator>=</operator> <call><name>ucl_object_iterate</name> <argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>UCL_BOOLEAN</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>strncmp</name> <argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><literal type="string">"try"</literal></expr></argument>, <argument><expr><name><name>param</name><operator>-&gt;</operator><name>keylen</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>params</name><operator>.</operator><name>must_exist</name></name> <operator>=</operator> <operator>!</operator><call><name>ucl_object_toboolean</name> <argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>strncmp</name> <argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><literal type="string">"sign"</literal></expr></argument>, <argument><expr><name><name>param</name><operator>-&gt;</operator><name>keylen</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>params</name><operator>.</operator><name>check_signature</name></name> <operator>=</operator> <call><name>ucl_object_toboolean</name> <argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>strncmp</name> <argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><literal type="string">"glob"</literal></expr></argument>, <argument><expr><name><name>param</name><operator>-&gt;</operator><name>keylen</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>params</name><operator>.</operator><name>allow_glob</name></name> <operator>=</operator> <call><name>ucl_object_toboolean</name> <argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>strncmp</name> <argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><literal type="string">"url"</literal></expr></argument>, <argument><expr><name><name>param</name><operator>-&gt;</operator><name>keylen</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>allow_url</name> <operator>=</operator> <call><name>ucl_object_toboolean</name> <argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>strncmp</name> <argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><literal type="string">"prefix"</literal></expr></argument>, <argument><expr><name><name>param</name><operator>-&gt;</operator><name>keylen</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>params</name><operator>.</operator><name>use_prefix</name></name> <operator>=</operator> <call><name>ucl_object_toboolean</name> <argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>UCL_STRING</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>strncmp</name> <argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><literal type="string">"key"</literal></expr></argument>, <argument><expr><name><name>param</name><operator>-&gt;</operator><name>keylen</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>params</name><operator>.</operator><name>prefix</name></name> <operator>=</operator> <call><name>ucl_object_tostring</name> <argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>strncmp</name> <argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><literal type="string">"target"</literal></expr></argument>, <argument><expr><name><name>param</name><operator>-&gt;</operator><name>keylen</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>params</name><operator>.</operator><name>target</name></name> <operator>=</operator> <call><name>ucl_object_tostring</name> <argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>strncmp</name> <argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><literal type="string">"duplicate"</literal></expr></argument>, <argument><expr><name><name>param</name><operator>-&gt;</operator><name>keylen</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>duplicate</name> <operator>=</operator> <call><name>ucl_object_tostring</name> <argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strcmp</name> <argument_list>(<argument><expr><name>duplicate</name></expr></argument>, <argument><expr><literal type="string">"append"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>params</name><operator>.</operator><name>strat</name></name> <operator>=</operator> <name>UCL_DUPLICATE_APPEND</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>strcmp</name> <argument_list>(<argument><expr><name>duplicate</name></expr></argument>, <argument><expr><literal type="string">"merge"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>params</name><operator>.</operator><name>strat</name></name> <operator>=</operator> <name>UCL_DUPLICATE_MERGE</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>strcmp</name> <argument_list>(<argument><expr><name>duplicate</name></expr></argument>, <argument><expr><literal type="string">"rewrite"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>params</name><operator>.</operator><name>strat</name></name> <operator>=</operator> <name>UCL_DUPLICATE_REWRITE</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>strcmp</name> <argument_list>(<argument><expr><name>duplicate</name></expr></argument>, <argument><expr><literal type="string">"error"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>params</name><operator>.</operator><name>strat</name></name> <operator>=</operator> <name>UCL_DUPLICATE_ERROR</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>UCL_ARRAY</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>strncmp</name> <argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><literal type="string">"path"</literal></expr></argument>, <argument><expr><name><name>param</name><operator>-&gt;</operator><name>keylen</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_set_include_path</name> <argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><call><name>__DECONST</name><argument_list>(<argument><expr><name>ucl_object_t</name> <operator>*</operator></expr></argument>, <argument><expr><name>param</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>UCL_INT</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>strncmp</name> <argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><literal type="string">"priority"</literal></expr></argument>, <argument><expr><name><name>param</name><operator>-&gt;</operator><name>keylen</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>params</name><operator>.</operator><name>priority</name></name> <operator>=</operator> <call><name>ucl_object_toint</name> <argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>params</name><operator>.</operator><name>priority</name></name> <operator>&gt;</operator> <name>UCL_PRIORITY_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_create_err</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>err</name></name></expr></argument>, <argument><expr><literal type="string">"Invalid priority value in macro: %d"</literal></expr></argument>,
<argument><expr><name><name>params</name><operator>.</operator><name>priority</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>includepaths</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>allow_url</name> <operator>&amp;&amp;</operator> <call><name>ucl_strnstr</name> <argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><literal type="string">"://"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>ucl_include_url</name> <argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>params</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>data</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>ucl_include_file</name> <argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>params</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>allow_url</name> <operator>&amp;&amp;</operator> <call><name>ucl_strnstr</name> <argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><literal type="string">"://"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>ucl_include_url</name> <argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>params</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ip</name> <operator>=</operator> <call><name>ucl_object_iterate_new</name> <argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>includepaths</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>(</operator><name>param</name> <operator>=</operator> <call><name>ucl_object_iterate_safe</name> <argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ucl_object_type</name><argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>UCL_STRING</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>ipath</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>ipath</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%.*s"</literal></expr></argument>, <argument><expr><call><name>ucl_object_tostring</name><argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>len</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>search</name> <operator>=</operator> <call><name>ucl_include_file</name> <argument_list>(<argument><expr><name>ipath</name></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><name>ipath</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>params</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>params</name><operator>.</operator><name>allow_glob</name></name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>ucl_object_iterate_free</name> <argument_list>(<argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>search</name> <operator>==</operator> <name>true</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>ucl_create_err</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>err</name></name></expr></argument>,
<argument><expr><literal type="string">"cannot find file: %.*s in search path"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>len</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>









<function><type><name>bool</name></type>
<name>ucl_include_handler</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>ud</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>ucl_parser</name></name> <modifier>*</modifier></type><name>parser</name> <init>= <expr><name>ud</name></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>ucl_include_common</name> <argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>parser</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>









<function><type><name>bool</name></type>
<name>ucl_includes_handler</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>ud</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>ucl_parser</name></name> <modifier>*</modifier></type><name>parser</name> <init>= <expr><name>ud</name></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>ucl_include_common</name> <argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>parser</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>









<function><type><name>bool</name></type>
<name>ucl_try_include_handler</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>ud</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>ucl_parser</name></name> <modifier>*</modifier></type><name>parser</name> <init>= <expr><name>ud</name></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>ucl_include_common</name> <argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>parser</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>









<function><type><name>bool</name></type>
<name>ucl_priority_handler</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>ud</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>ucl_parser</name></name> <modifier>*</modifier></type><name>parser</name> <init>= <expr><name>ud</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>priority</name> <init>= <expr><literal type="number">255</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>param</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>leftover</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ucl_object_iter_t</name></type> <name>it</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>args</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>args</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>UCL_OBJECT</name></expr>)</condition> <block>{<block_content>
<while>while <condition>(<expr><operator>(</operator><name>param</name> <operator>=</operator> <call><name>ucl_object_iterate</name> <argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>UCL_INT</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>strncmp</name> <argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><literal type="string">"priority"</literal></expr></argument>, <argument><expr><name><name>param</name><operator>-&gt;</operator><name>keylen</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>priority</name> <operator>=</operator> <call><name>ucl_object_toint</name> <argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ucl_strlcpy</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>data</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>priority</name> <operator>=</operator> <call><name>strtoul</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>leftover</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <operator>*</operator><name>leftover</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>||</operator> <name>priority</name> <operator>&gt;</operator> <name>UCL_PRIORITY_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_create_err</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>err</name></name></expr></argument>, <argument><expr><literal type="string">"Invalid priority value in macro: %s"</literal></expr></argument>,
<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>found</name> <operator>==</operator> <name>true</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>chunks</name><operator>-&gt;</operator><name>priority</name></name> <operator>=</operator> <name>priority</name></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ucl_create_err</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>err</name></name></expr></argument>, <argument><expr><literal type="string">"Unable to parse priority macro"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>









<function><type><name>bool</name></type>
<name>ucl_load_handler</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>ud</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>ucl_parser</name></name> <modifier>*</modifier></type><name>parser</name> <init>= <expr><name>ud</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>param</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>obj</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>old_obj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ucl_object_iter_t</name></type> <name>it</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>try_load</name></decl>, <decl><type ref="prev"/><name>multiline</name></decl>, <decl><type ref="prev"/><name>test</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>target</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>prefix</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>load_file</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>buflen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>priority</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>iv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>container</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>ucl_string_flags</name></name></type> <name>flags</name></decl>;</decl_stmt>


<expr_stmt><expr><name>try_load</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>multiline</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>test</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>target</name> <operator>=</operator> <literal type="string">"string"</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>prefix</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>load_file</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>buflen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>priority</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>obj</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>old_obj</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>args</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>args</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>UCL_OBJECT</name></expr>)</condition> <block>{<block_content>
<while>while <condition>(<expr><operator>(</operator><name>param</name> <operator>=</operator> <call><name>ucl_object_iterate</name> <argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>UCL_BOOLEAN</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>strncmp</name> <argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><literal type="string">"try"</literal></expr></argument>, <argument><expr><name><name>param</name><operator>-&gt;</operator><name>keylen</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>try_load</name> <operator>=</operator> <call><name>ucl_object_toboolean</name> <argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>strncmp</name> <argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><literal type="string">"multiline"</literal></expr></argument>, <argument><expr><name><name>param</name><operator>-&gt;</operator><name>keylen</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>multiline</name> <operator>=</operator> <call><name>ucl_object_toboolean</name> <argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>strncmp</name> <argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><literal type="string">"escape"</literal></expr></argument>, <argument><expr><name><name>param</name><operator>-&gt;</operator><name>keylen</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>test</name> <operator>=</operator> <call><name>ucl_object_toboolean</name> <argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>test</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>UCL_STRING_ESCAPE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>strncmp</name> <argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><literal type="string">"trim"</literal></expr></argument>, <argument><expr><name><name>param</name><operator>-&gt;</operator><name>keylen</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>test</name> <operator>=</operator> <call><name>ucl_object_toboolean</name> <argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>test</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>UCL_STRING_TRIM</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>UCL_STRING</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>strncmp</name> <argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><literal type="string">"key"</literal></expr></argument>, <argument><expr><name><name>param</name><operator>-&gt;</operator><name>keylen</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>ucl_object_tostring</name> <argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>strncmp</name> <argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><literal type="string">"target"</literal></expr></argument>, <argument><expr><name><name>param</name><operator>-&gt;</operator><name>keylen</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>target</name> <operator>=</operator> <call><name>ucl_object_tostring</name> <argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>UCL_INT</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>strncmp</name> <argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><literal type="string">"priority"</literal></expr></argument>, <argument><expr><name><name>param</name><operator>-&gt;</operator><name>keylen</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>priority</name> <operator>=</operator> <call><name>ucl_object_toint</name> <argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>prefix</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_create_err</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>err</name></name></expr></argument>, <argument><expr><literal type="string">"No Key specified in load macro"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>load_file</name> <operator>=</operator> <call><name>malloc</name> <argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>load_file</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_create_err</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>err</name></name></expr></argument>, <argument><expr><literal type="string">"cannot allocate memory for suffix"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>load_file</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"%.*s"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>len</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ucl_fetch_file</name> <argument_list>(<argument><expr><name>load_file</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buflen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>err</name></name></expr></argument>,
<argument><expr><operator>!</operator><name>try_load</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>load_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>try_load</name> <operator>||</operator> <name>false</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>load_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>container</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>stack</name><operator>-&gt;</operator><name>obj</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>old_obj</name> <operator>=</operator> <call><name>__DECONST</name> <argument_list>(<argument><expr><name>ucl_object_t</name> <operator>*</operator></expr></argument>, <argument><expr><call><name>ucl_object_lookup</name> <argument_list>(<argument><expr><name>container</name></expr></argument>,
<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>old_obj</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_create_err</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>err</name></name></expr></argument>, <argument><expr><literal type="string">"Key %s already exists"</literal></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_munmap</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strcasecmp</name> <argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><literal type="string">"string"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>obj</name> <operator>=</operator> <call><name>ucl_object_fromstring_common</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ucl_copy_value_trash</name> <argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>multiline</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>UCL_OBJECT_MULTILINE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>strcasecmp</name> <argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><literal type="string">"int"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>malloc</name> <argument_list>(<argument><expr><name>buflen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>tmp</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_create_err</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>err</name></name></expr></argument>, <argument><expr><literal type="string">"Memory allocation failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_munmap</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>buflen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"%.*s"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>buflen</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>iv</name> <operator>=</operator> <call><name>strtoll</name> <argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>obj</name> <operator>=</operator> <call><name>ucl_object_fromint</name> <argument_list>(<argument><expr><name>iv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_munmap</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>obj</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <name>prefix</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>keylen</name></name> <operator>=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ucl_copy_key_trash</name> <argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>obj</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ucl_object_set_priority</name> <argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>priority</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ucl_object_insert_key</name> <argument_list>(<argument><expr><name>container</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>keylen</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ucl_create_err</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>err</name></name></expr></argument>, <argument><expr><literal type="string">"Unable to parse load macro"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ucl_inherit_handler</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>ud</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>parent</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>cur</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>target</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>copy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ucl_object_iter_t</name></type> <name>it</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>replace</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>ucl_parser</name></name> <modifier>*</modifier></type><name>parser</name> <init>= <expr><name>ud</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>parent</name> <operator>=</operator> <call><name>ucl_object_lookup_len</name> <argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>parent</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>ucl_object_type</name> <argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>UCL_OBJECT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_create_err</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>err</name></name></expr></argument>, <argument><expr><literal type="string">"Unable to find inherited object %*.s"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>len</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>stack</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>parser</name><operator>-&gt;</operator><name>stack</name><operator>-&gt;</operator><name>obj</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
<call><name>ucl_object_type</name> <argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>stack</name><operator>-&gt;</operator><name>obj</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>UCL_OBJECT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_create_err</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>err</name></name></expr></argument>, <argument><expr><literal type="string">"Invalid inherit context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>target</name> <operator>=</operator> <name><name>parser</name><operator>-&gt;</operator><name>stack</name><operator>-&gt;</operator><name>obj</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>args</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>cur</name> <operator>=</operator> <call><name>ucl_object_lookup</name> <argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><literal type="string">"replace"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>replace</name> <operator>=</operator> <call><name>ucl_object_toboolean</name> <argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><operator>(</operator><name>cur</name> <operator>=</operator> <call><name>ucl_object_iterate</name> <argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>replace</name> <operator>&amp;&amp;</operator> <call><name>ucl_object_lookup_len</name> <argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name><name>cur</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name><name>cur</name><operator>-&gt;</operator><name>keylen</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>copy</name> <operator>=</operator> <call><name>ucl_object_copy</name> <argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>replace</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>copy</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>UCL_OBJECT_INHERITED</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ucl_object_insert_key</name> <argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>copy</name></expr></argument>, <argument><expr><name><name>copy</name><operator>-&gt;</operator><name>key</name></name></expr></argument>,
<argument><expr><name><name>copy</name><operator>-&gt;</operator><name>keylen</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>

<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ucl_parser_set_filevars</name> <parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ucl_parser</name></name> <modifier>*</modifier></type><name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>need_expand</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>realbuf</name><index>[<expr><name>PATH_MAX</name></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>curdir</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>filename</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>need_expand</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ucl_realpath</name> <argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>realbuf</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>ucl_strlcpy</name> <argument_list>(<argument><expr><name>realbuf</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>realbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>cur_file</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>cur_file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>cur_file</name></name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>realbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>ucl_parser_register_variable</name> <argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><literal type="string">"FILENAME"</literal></expr></argument>, <argument><expr><name>realbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>curdir</name> <operator>=</operator> <call><name>dirname</name> <argument_list>(<argument><expr><name>realbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ucl_parser_register_variable</name> <argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><literal type="string">"CURDIR"</literal></expr></argument>, <argument><expr><name>curdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>

<expr_stmt><expr><name>curdir</name> <operator>=</operator> <call><name>getcwd</name> <argument_list>(<argument><expr><name>realbuf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>realbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ucl_parser_register_variable</name> <argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><literal type="string">"FILENAME"</literal></expr></argument>, <argument><expr><literal type="string">"undef"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ucl_parser_register_variable</name> <argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><literal type="string">"CURDIR"</literal></expr></argument>, <argument><expr><name>curdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ucl_parser_add_file_full</name> <parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ucl_parser</name></name> <modifier>*</modifier></type><name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>priority</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>ucl_duplicate_strategy</name></name></type> <name>strat</name></decl></parameter>,
<parameter><decl><type><name><name>enum</name> <name>ucl_parse_type</name></name></type> <name>parse_type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>realbuf</name><index>[<expr><name>PATH_MAX</name></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ucl_realpath</name> <argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>realbuf</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_create_err</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>err</name></name></expr></argument>, <argument><expr><literal type="string">"cannot open file %s: %s"</literal></expr></argument>,
<argument><expr><name>filename</name></expr></argument>,
<argument><expr><call><name>strerror</name> <argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ucl_fetch_file</name> <argument_list>(<argument><expr><name>realbuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>err</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ucl_parser_set_filevars</name> <argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>realbuf</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ucl_parser_add_chunk_full</name> <argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>priority</name></expr></argument>, <argument><expr><name>strat</name></expr></argument>,
<argument><expr><name>parse_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_munmap</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ucl_parser_add_file_priority</name> <parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ucl_parser</name></name> <modifier>*</modifier></type><name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>priority</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>ucl_parser_add_file_full</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>priority</name></expr></argument>,
<argument><expr><name>UCL_DUPLICATE_APPEND</name></expr></argument>, <argument><expr><name>UCL_PARSE_UCL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ucl_parser_add_file</name> <parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ucl_parser</name></name> <modifier>*</modifier></type><name>parser</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>ucl_parser_add_file_full</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>,
<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>default_priority</name></name></expr></argument>, <argument><expr><name>UCL_DUPLICATE_APPEND</name></expr></argument>,
<argument><expr><name>UCL_PARSE_UCL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>bool</name></type>
<name>ucl_parser_add_fd_full</name> <parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ucl_parser</name></name> <modifier>*</modifier></type><name>parser</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>priority</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>ucl_duplicate_strategy</name></name></type> <name>strat</name></decl></parameter>,
<parameter><decl><type><name><name>enum</name> <name>ucl_parse_type</name></name></type> <name>parse_type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>fstat</name> <argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_create_err</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>err</name></name></expr></argument>, <argument><expr><literal type="string">"cannot stat fd %d: %s"</literal></expr></argument>,
<argument><expr><name>fd</name></expr></argument>, <argument><expr><call><name>strerror</name> <argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>.</operator><name>st_size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>buf</name> <operator>=</operator> <call><name>ucl_mmap</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>st</name><operator>.</operator><name>st_size</name></name></expr></argument>, <argument><expr><name>PROT_READ</name></expr></argument>, <argument><expr><name>MAP_SHARED</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>MAP_FAILED</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_create_err</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>parser</name><operator>-&gt;</operator><name>err</name></name></expr></argument>, <argument><expr><literal type="string">"cannot mmap fd %d: %s"</literal></expr></argument>,
<argument><expr><name>fd</name></expr></argument>, <argument><expr><call><name>strerror</name> <argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>parser</name><operator>-&gt;</operator><name>cur_file</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>parser</name><operator>-&gt;</operator><name>cur_file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>cur_file</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>st</name><operator>.</operator><name>st_size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ucl_parser_add_chunk_full</name> <argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>priority</name></expr></argument>, <argument><expr><name>strat</name></expr></argument>,
<argument><expr><name>parse_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_munmap</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ucl_parser_add_fd_priority</name> <parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ucl_parser</name></name> <modifier>*</modifier></type><name>parser</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>priority</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>ucl_parser_add_fd_full</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>default_priority</name></name></expr></argument>,
<argument><expr><name>UCL_DUPLICATE_APPEND</name></expr></argument>, <argument><expr><name>UCL_PARSE_UCL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ucl_parser_add_fd</name> <parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ucl_parser</name></name> <modifier>*</modifier></type><name>parser</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>ucl_parser_add_fd_priority</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>parser</name><operator>-&gt;</operator><name>default_priority</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type>
<name>ucl_strlcpy</name> <parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>siz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>d</name> <init>= <expr><name>dst</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name>src</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>n</name> <init>= <expr><name>siz</name></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name>n</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<while>while <condition>(<expr><operator>--</operator><name>n</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>s</name><operator>++</operator><operator>)</operator> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>siz</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>d</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><operator>(</operator><name>s</name> <operator>-</operator> <name>src</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type>
<name>ucl_strlcpy_unsafe</name> <parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>siz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>siz</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dst</name><index>[<expr><name>siz</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<return>return <expr><name>siz</name> <operator>-</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type>
<name>ucl_strlcpy_tolower</name> <parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>siz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>d</name> <init>= <expr><name>dst</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name>src</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>n</name> <init>= <expr><name>siz</name></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name>n</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<while>while <condition>(<expr><operator>--</operator><name>n</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <call><name>tolower</name> <argument_list>(<argument><expr><operator>*</operator><name>s</name><operator>++</operator></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>siz</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>d</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><operator>(</operator><name>s</name> <operator>-</operator> <name>src</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>




<function><type><name>char</name> <modifier>*</modifier></type>
<name>ucl_strnstr</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>find</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>sc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>mlen</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><name>find</name><operator>++</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>mlen</name> <operator>=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>find</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<do>do <block>{<block_content>
<do>do <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>sc</name> <operator>=</operator> <operator>*</operator><name>s</name><operator>++</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>len</name><operator>--</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block> while <condition>(<expr><name>sc</name> <operator>!=</operator> <name>c</name></expr>)</condition>;</do>
</block_content>}</block> while <condition>(<expr><call><name>strncmp</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>find</name></expr></argument>, <argument><expr><name>mlen</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>;</do>
<expr_stmt><expr><name>s</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>s</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>




<function><type><name>char</name> <modifier>*</modifier></type>
<name>ucl_strncasestr</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>find</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>sc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>mlen</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><name>find</name><operator>++</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>tolower</name> <argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>mlen</name> <operator>=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>find</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<do>do <block>{<block_content>
<do>do <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>sc</name> <operator>=</operator> <operator>*</operator><name>s</name><operator>++</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>len</name><operator>--</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block> while <condition>(<expr><call><name>tolower</name> <argument_list>(<argument><expr><name>sc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>c</name></expr>)</condition>;</do>
</block_content>}</block> while <condition>(<expr><call><name>strncasecmp</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>find</name></expr></argument>, <argument><expr><name>mlen</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>;</do>
<expr_stmt><expr><name>s</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>s</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>ucl_object_t</name> <modifier>*</modifier></type>
<name>ucl_object_fromstring_common</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>ucl_string_flags</name></name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>obj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>start</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>escaped_len</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>str</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>obj</name> <operator>=</operator> <call><name>ucl_object_new</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>obj</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>UCL_STRING_TRIM</name></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>start</name> <operator>=</operator> <name>str</name></expr>;</init> <condition><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>start</name> <operator>-</operator> <name>str</name><operator>)</operator> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>start</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ucl_test_character</name> <argument_list>(<argument><expr><operator>*</operator><name>start</name></expr></argument>, <argument><expr><name>UCL_CHARACTER_WHITESPACE_UNSAFE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<for>for <control>(<init><expr><name>end</name> <operator>=</operator> <name>str</name> <operator>+</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>end</name> <operator>&gt;</operator> <name>start</name></expr>;</condition> <incr><expr><name>end</name> <operator>--</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ucl_test_character</name> <argument_list>(<argument><expr><operator>*</operator><name>end</name></expr></argument>, <argument><expr><name>UCL_CHARACTER_WHITESPACE_UNSAFE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>end</name> <operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>start</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> <operator>=</operator> <name>str</name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>UCL_STRING</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>UCL_STRING_ESCAPE</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>start</name></expr><operator>,</operator> <expr><name>escaped_len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>end</name></expr>;</condition> <incr><expr><name>p</name> <operator>++</operator></expr><operator>,</operator> <expr><name>escaped_len</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ucl_test_character</name> <argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>, <argument><expr><name>UCL_CHARACTER_JSON_UNSAFE</name> <operator>|</operator> <name>UCL_CHARACTER_WHITESPACE_UNSAFE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><operator>*</operator><name>p</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'\v'</literal></expr>:</case>
<case>case <expr><literal type="char">'\0'</literal></expr>:</case>
<expr_stmt><expr><name>escaped_len</name> <operator>+=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">' '</literal></expr>:</case>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><name>escaped_len</name> <operator>++</operator></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>dst</name> <operator>=</operator> <call><name>malloc</name> <argument_list>(<argument><expr><name>escaped_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>dst</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>start</name></expr><operator>,</operator> <expr><name>d</name> <operator>=</operator> <name>dst</name></expr>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>end</name></expr>;</condition> <incr><expr><name>p</name> <operator>++</operator></expr><operator>,</operator> <expr><name>d</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ucl_test_character</name> <argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>, <argument><expr><name>UCL_CHARACTER_JSON_UNSAFE</name> <operator>|</operator> <name>UCL_CHARACTER_WHITESPACE_UNSAFE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><operator>*</operator><name>p</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'\n'</literal></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>d</name> <operator>=</operator> <literal type="char">'n'</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'\r'</literal></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>d</name> <operator>=</operator> <literal type="char">'r'</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'\b'</literal></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>d</name> <operator>=</operator> <literal type="char">'b'</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'\t'</literal></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>d</name> <operator>=</operator> <literal type="char">'t'</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'\f'</literal></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>d</name> <operator>=</operator> <literal type="char">'f'</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'\0'</literal></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <literal type="char">'u'</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>d</name> <operator>=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'\v'</literal></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <literal type="char">'u'</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>d</name> <operator>=</operator> <literal type="char">'B'</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'\\'</literal></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>d</name> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">' '</literal></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>d</name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'"'</literal></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>d</name> <operator>=</operator> <literal type="char">'"'</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>d</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><operator>*</operator><name>d</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>sv</name></name> <operator>=</operator> <name>dst</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>trash_stack</name><index>[<expr><name>UCL_TRASH_VALUE</name></expr>]</index></name> <operator>=</operator> <name>dst</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>escaped_len</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>dst</name> <operator>=</operator> <call><name>malloc</name> <argument_list>(<argument><expr><name>end</name> <operator>-</operator> <name>start</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>dst</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_strlcpy_unsafe</name> <argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name> <operator>-</operator> <name>start</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>sv</name></name> <operator>=</operator> <name>dst</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>trash_stack</name><index>[<expr><name>UCL_TRASH_VALUE</name></expr>]</index></name> <operator>=</operator> <name>dst</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>end</name> <operator>-</operator> <name>start</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>UCL_STRING_PARSE</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>dst</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>UCL_STRING_PARSE_BOOLEAN</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ucl_maybe_parse_boolean</name> <argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name><name>obj</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>UCL_STRING_PARSE_NUMBER</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_maybe_parse_number</name> <argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dst</name> <operator>+</operator> <name><name>obj</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pos</name></expr></argument>,
<argument><expr><name>flags</name> <operator>&amp;</operator> <name>UCL_STRING_PARSE_DOUBLE</name></expr></argument>,
<argument><expr><name>flags</name> <operator>&amp;</operator> <name>UCL_STRING_PARSE_BYTES</name></expr></argument>,
<argument><expr><name>flags</name> <operator>&amp;</operator> <name>UCL_STRING_PARSE_TIME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>ucl_maybe_parse_number</name> <argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>dst</name> <operator>+</operator> <name><name>obj</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pos</name></expr></argument>,
<argument><expr><name>flags</name> <operator>&amp;</operator> <name>UCL_STRING_PARSE_DOUBLE</name></expr></argument>,
<argument><expr><name>flags</name> <operator>&amp;</operator> <name>UCL_STRING_PARSE_BYTES</name></expr></argument>,
<argument><expr><name>flags</name> <operator>&amp;</operator> <name>UCL_STRING_PARSE_TIME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>obj</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ucl_object_insert_key_common</name> <parameter_list>(<parameter><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>top</name></decl></parameter>, <parameter><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>elt</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>keylen</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>copy_key</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>merge</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>replace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>found</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>cur</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ucl_object_iter_t</name></type> <name>it</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>elt</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>key</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>top</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>top</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>UCL_OBJECT</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>top</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>UCL_NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>top</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>UCL_OBJECT</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>top</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>ov</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>top</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>ov</name></name> <operator>=</operator> <call><name>ucl_hash_create</name> <argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>keylen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>keylen</name> <operator>=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>key</name></expr>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>key</name> <operator>+</operator> <name>keylen</name></expr>;</condition> <incr><expr><name>p</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ucl_test_character</name> <argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>, <argument><expr><name>UCL_CHARACTER_UCL_UNSAFE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>elt</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>UCL_OBJECT_NEED_KEY_ESCAPE</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>


<if_stmt><if>if <condition>(<expr><name><name>elt</name><operator>-&gt;</operator><name>trash_stack</name><index>[<expr><name>UCL_TRASH_KEY</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
<name>key</name> <operator>!=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name><name>elt</name><operator>-&gt;</operator><name>trash_stack</name><index>[<expr><name>UCL_TRASH_KEY</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>elt</name><operator>-&gt;</operator><name>trash_stack</name><index>[<expr><name>UCL_TRASH_KEY</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>elt</name><operator>-&gt;</operator><name>trash_stack</name><index>[<expr><name>UCL_TRASH_KEY</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>elt</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>UCL_OBJECT_ALLOCATED_KEY</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>elt</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>elt</name><operator>-&gt;</operator><name>keylen</name></name> <operator>=</operator> <name>keylen</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>copy_key</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_copy_key_trash</name> <argument_list>(<argument><expr><name>elt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>__DECONST</name> <argument_list>(<argument><expr><name>ucl_object_t</name> <operator>*</operator></expr></argument>, <argument><expr><call><name>ucl_hash_search_obj</name> <argument_list>(<argument><expr><name><name>top</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>ov</name></name></expr></argument>, <argument><expr><name>elt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>found</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>top</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>ov</name></name> <operator>=</operator> <call><name>ucl_hash_insert_object</name> <argument_list>(<argument><expr><name><name>top</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>ov</name></name></expr></argument>, <argument><expr><name>elt</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>top</name><operator>-&gt;</operator><name>len</name></name> <operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>replace</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>replace</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_hash_replace</name> <argument_list>(<argument><expr><name><name>top</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>ov</name></name></expr></argument>, <argument><expr><name>found</name></expr></argument>, <argument><expr><name>elt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ucl_object_unref</name> <argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>merge</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>found</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>UCL_OBJECT</name> <operator>&amp;&amp;</operator> <name><name>elt</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>UCL_OBJECT</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ucl_object_insert_key_common</name> <argument_list>(<argument><expr><name>elt</name></expr></argument>, <argument><expr><name>found</name></expr></argument>, <argument><expr><name><name>found</name><operator>-&gt;</operator><name>key</name></name></expr></argument>,
<argument><expr><name><name>found</name><operator>-&gt;</operator><name>keylen</name></name></expr></argument>, <argument><expr><name>copy_key</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ucl_hash_delete</name> <argument_list>(<argument><expr><name><name>top</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>ov</name></name></expr></argument>, <argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>top</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>ov</name></name> <operator>=</operator> <call><name>ucl_hash_insert_object</name> <argument_list>(<argument><expr><name><name>top</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>ov</name></name></expr></argument>, <argument><expr><name>elt</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>found</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>UCL_OBJECT</name> <operator>&amp;&amp;</operator> <name><name>elt</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>UCL_OBJECT</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ucl_object_insert_key_common</name> <argument_list>(<argument><expr><name>found</name></expr></argument>, <argument><expr><name>elt</name></expr></argument>, <argument><expr><name><name>elt</name><operator>-&gt;</operator><name>key</name></name></expr></argument>,
<argument><expr><name><name>elt</name><operator>-&gt;</operator><name>keylen</name></name></expr></argument>, <argument><expr><name>copy_key</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>found</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>UCL_OBJECT</name> <operator>&amp;&amp;</operator> <name><name>elt</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>UCL_OBJECT</name></expr>)</condition> <block>{<block_content>

<while>while <condition>(<expr><operator>(</operator><name>cur</name> <operator>=</operator> <call><name>ucl_object_iterate</name> <argument_list>(<argument><expr><name>elt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>ucl_object_ref</name> <argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ucl_object_insert_key_common</name> <argument_list>(<argument><expr><name>found</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name><name>cur</name><operator>-&gt;</operator><name>key</name></name></expr></argument>,
<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>keylen</name></name></expr></argument>, <argument><expr><name>copy_key</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>ucl_object_unref</name> <argument_list>(<argument><expr><name>elt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>

<expr_stmt><expr><call><name>DL_CONCAT</name> <argument_list>(<argument><expr><name>found</name></expr></argument>, <argument><expr><name>elt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>DL_CONCAT</name> <argument_list>(<argument><expr><name>found</name></expr></argument>, <argument><expr><name>elt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ucl_object_delete_keyl</name> <parameter_list>(<parameter><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>top</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>keylen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>found</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>top</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>key</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>__DECONST</name> <argument_list>(<argument><expr><name>ucl_object_t</name> <operator>*</operator></expr></argument>, <argument><expr><call><name>ucl_object_lookup_len</name> <argument_list>(<argument><expr><name>top</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>keylen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>found</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ucl_hash_delete</name> <argument_list>(<argument><expr><name><name>top</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>ov</name></name></expr></argument>, <argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ucl_object_unref</name> <argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>top</name><operator>-&gt;</operator><name>len</name></name> <operator>--</operator></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ucl_object_delete_key</name> <parameter_list>(<parameter><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>top</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>ucl_object_delete_keyl</name> <argument_list>(<argument><expr><name>top</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>ucl_object_t</name><modifier>*</modifier></type>
<name>ucl_object_pop_keyl</name> <parameter_list>(<parameter><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>top</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>keylen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>found</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>top</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>key</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>ucl_object_lookup_len</name> <argument_list>(<argument><expr><name>top</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>keylen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>found</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>ucl_hash_delete</name> <argument_list>(<argument><expr><name><name>top</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>ov</name></name></expr></argument>, <argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>top</name><operator>-&gt;</operator><name>len</name></name> <operator>--</operator></expr>;</expr_stmt>

<return>return <expr><call><name>__DECONST</name> <argument_list>(<argument><expr><name>ucl_object_t</name> <operator>*</operator></expr></argument>, <argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>ucl_object_t</name><modifier>*</modifier></type>
<name>ucl_object_pop_key</name> <parameter_list>(<parameter><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>top</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>ucl_object_pop_keyl</name> <argument_list>(<argument><expr><name>top</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ucl_object_insert_key</name> <parameter_list>(<parameter><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>top</name></decl></parameter>, <parameter><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>elt</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>keylen</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>copy_key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>ucl_object_insert_key_common</name> <argument_list>(<argument><expr><name>top</name></expr></argument>, <argument><expr><name>elt</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>keylen</name></expr></argument>, <argument><expr><name>copy_key</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ucl_object_insert_key_merged</name> <parameter_list>(<parameter><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>top</name></decl></parameter>, <parameter><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>elt</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>keylen</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>copy_key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>ucl_object_insert_key_common</name> <argument_list>(<argument><expr><name>top</name></expr></argument>, <argument><expr><name>elt</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>keylen</name></expr></argument>, <argument><expr><name>copy_key</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ucl_object_replace_key</name> <parameter_list>(<parameter><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>top</name></decl></parameter>, <parameter><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>elt</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>keylen</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>copy_key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>ucl_object_insert_key_common</name> <argument_list>(<argument><expr><name>top</name></expr></argument>, <argument><expr><name>elt</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>keylen</name></expr></argument>, <argument><expr><name>copy_key</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ucl_object_merge</name> <parameter_list>(<parameter><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>top</name></decl></parameter>, <parameter><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>elt</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>copy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>cur</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>cp</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>found</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ucl_object_iter_t</name></type> <name>iter</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>top</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>elt</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>top</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>UCL_ARRAY</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>elt</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>UCL_ARRAY</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>ucl_array_merge</name> <argument_list>(<argument><expr><name>top</name></expr></argument>, <argument><expr><name>elt</name></expr></argument>, <argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>copy</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_array_append</name> <argument_list>(<argument><expr><name>top</name></expr></argument>, <argument><expr><call><name>ucl_object_copy</name> <argument_list>(<argument><expr><name>elt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>ucl_array_append</name> <argument_list>(<argument><expr><name>top</name></expr></argument>, <argument><expr><call><name>ucl_object_ref</name> <argument_list>(<argument><expr><name>elt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>top</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>UCL_OBJECT</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>elt</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>UCL_OBJECT</name></expr>)</condition> <block>{<block_content>

<while>while <condition>(<expr><operator>(</operator><name>cur</name> <operator>=</operator> <operator>(</operator><name>ucl_object_t</name> <operator>*</operator><operator>)</operator> <call><name>ucl_hash_iterate</name> <argument_list>(<argument><expr><name><name>elt</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>ov</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>copy</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>ucl_object_copy</name> <argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>ucl_object_ref</name> <argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>__DECONST</name><argument_list>(<argument><expr><name>ucl_object_t</name> <operator>*</operator></expr></argument>,
<argument><expr><call><name>ucl_hash_search</name> <argument_list>(<argument><expr><name><name>top</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>ov</name></name></expr></argument>, <argument><expr><name><name>cp</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name><name>cp</name><operator>-&gt;</operator><name>keylen</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>found</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>top</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>ov</name></name> <operator>=</operator> <call><name>ucl_hash_insert_object</name> <argument_list>(<argument><expr><name><name>top</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>ov</name></name></expr></argument>, <argument><expr><name>cp</name></expr></argument>,
<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>top</name><operator>-&gt;</operator><name>len</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>found</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>UCL_OBJECT</name> <operator>||</operator> <name><name>found</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>UCL_ARRAY</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ucl_object_merge</name> <argument_list>(<argument><expr><name>found</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>, <argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>ucl_hash_replace</name> <argument_list>(<argument><expr><name><name>top</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>ov</name></name></expr></argument>, <argument><expr><name>found</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ucl_object_unref</name> <argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>copy</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>ucl_object_copy</name> <argument_list>(<argument><expr><name>elt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>ucl_object_ref</name> <argument_list>(<argument><expr><name>elt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>__DECONST</name><argument_list>(<argument><expr><name>ucl_object_t</name> <operator>*</operator></expr></argument>,
<argument><expr><call><name>ucl_hash_search</name> <argument_list>(<argument><expr><name><name>top</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>ov</name></name></expr></argument>, <argument><expr><name><name>cp</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name><name>cp</name><operator>-&gt;</operator><name>keylen</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>found</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>top</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>ov</name></name> <operator>=</operator> <call><name>ucl_hash_insert_object</name> <argument_list>(<argument><expr><name><name>top</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>ov</name></name></expr></argument>, <argument><expr><name>cp</name></expr></argument>,
<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>top</name><operator>-&gt;</operator><name>len</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>found</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>UCL_OBJECT</name> <operator>||</operator> <name><name>found</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>UCL_ARRAY</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ucl_object_merge</name> <argument_list>(<argument><expr><name>found</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>, <argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>ucl_hash_replace</name> <argument_list>(<argument><expr><name><name>top</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>ov</name></name></expr></argument>, <argument><expr><name>found</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ucl_object_unref</name> <argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type>
<name>ucl_object_lookup_len</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>klen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ucl_object_t</name></type> <name>srch</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>obj</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>obj</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>UCL_OBJECT</name> <operator>||</operator> <name>key</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>srch</name><operator>.</operator><name>key</name></name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>srch</name><operator>.</operator><name>keylen</name></name> <operator>=</operator> <name>klen</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ucl_hash_search_obj</name> <argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>ov</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>srch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type>
<name>ucl_object_lookup</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>key</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>ucl_object_lookup_len</name> <argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>ucl_object_t</name><modifier>*</modifier></type>
<name>ucl_object_lookup_any</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nk</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>obj</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>key</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ucl_object_lookup_len</name> <argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>va_start</name> <argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>ret</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>nk</name> <operator>=</operator> <call><name>va_arg</name> <argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>nk</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ucl_object_lookup_len</name> <argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>nk</name></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><name>nk</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>

<expr_stmt><expr><call><name>va_end</name> <argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>ucl_object_t</name><modifier>*</modifier></type>
<name>ucl_object_iterate_with_error</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><name>ucl_object_iter_t</name> <modifier>*</modifier></type><name>iter</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>expand_values</name></decl></parameter>,
<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ep</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>elt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>obj</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>iter</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>expand_values</name></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>UCL_OBJECT</name></expr>:</case>
<return>return <expr><operator>(</operator><specifier>const</specifier> <name>ucl_object_t</name><operator>*</operator><operator>)</operator><call><name>ucl_hash_iterate2</name> <argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>ov</name></name></expr></argument>, <argument><expr><name>iter</name></expr></argument>, <argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>;</return>
<break>break;</break>
<case>case <expr><name>UCL_ARRAY</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>idx</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>UCL_ARRAY_GET</name> <argument_list>(<argument><expr><name>vec</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>idx</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>(</operator><operator>*</operator><name>iter</name><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>vec</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<while>while <condition>(<expr><name>idx</name> <operator>&lt;</operator> <call><name>kv_size</name> <argument_list>(<argument><expr><operator>*</operator><name>vec</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>elt</name> <operator>=</operator> <call><name>kv_A</name> <argument_list>(<argument><expr><operator>*</operator><name>vec</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>idx</name> <operator>++</operator></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>idx</name> <operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><operator>*</operator><name>iter</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>idx</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>elt</name></expr>;</return>
<break>break;</break>
</block_content>}</block>
<default>default:</default>

<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>elt</name> <operator>=</operator> <operator>*</operator><name>iter</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>elt</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>elt</name> <operator>=</operator> <name>obj</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>elt</name> <operator>==</operator> <name>obj</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>iter</name> <operator>=</operator> <call><name>__DECONST</name> <argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>, <argument><expr><ternary><condition><expr><name><name>elt</name><operator>-&gt;</operator><name>next</name></name></expr> ?</condition><then> <expr><name><name>elt</name><operator>-&gt;</operator><name>next</name></name></expr> </then><else>: <expr><name>obj</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>elt</name></expr>;</return>


<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<enum>enum <name>ucl_safe_iter_flags</name> <block>{
<decl><name>UCL_ITERATE_FLAG_UNDEFINED</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>UCL_ITERATE_FLAG_INSIDE_ARRAY</name></decl>,
<decl><name>UCL_ITERATE_FLAG_INSIDE_OBJECT</name></decl>,
<decl><name>UCL_ITERATE_FLAG_IMPLICIT</name></decl>,
<decl><name>UCL_ITERATE_FLAG_EXCEPTION</name></decl>
}</block>;</enum>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>safe_iter_magic</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="char">'u'</literal></expr>, <expr><literal type="char">'i'</literal></expr>, <expr><literal type="char">'t'</literal></expr>, <expr><literal type="char">'e'</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<struct>struct <name>ucl_object_safe_iter</name> <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>magic</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>flags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>impl_it</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ucl_object_iter_t</name></type> <name>expl_it</name></decl>;</decl_stmt>
}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UCL_SAFE_ITER</name><parameter_list>(<parameter><type><name>ptr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(struct ucl_object_safe_iter *)(ptr)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UCL_SAFE_ITER_CHECK</name><parameter_list>(<parameter><type><name>it</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { assert (it != NULL); assert (memcmp (it-&gt;magic, safe_iter_magic, sizeof (it-&gt;magic)) == 0); } while (0)</cpp:value></cpp:define>




<function><type><name>ucl_object_iter_t</name></type>
<name>ucl_object_iterate_new</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>ucl_object_safe_iter</name></name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>

<expr_stmt><expr><name>it</name> <operator>=</operator> <call><name>UCL_ALLOC</name> <argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><operator>*</operator><name>it</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>it</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>magic</name></name></expr></argument>, <argument><expr><name>safe_iter_magic</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>magic</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>UCL_ITERATE_FLAG_UNDEFINED</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>expl_it</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>impl_it</name></name> <operator>=</operator> <name>obj</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><operator>(</operator><name>ucl_object_iter_t</name><operator>)</operator><name>it</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ucl_object_iter_chk_excpn</name><parameter_list>(<parameter><decl><type><name>ucl_object_iter_t</name> <modifier>*</modifier></type><name>it</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>ucl_object_safe_iter</name></name> <modifier>*</modifier></type><name>rit</name> <init>= <expr><call><name>UCL_SAFE_ITER</name> <argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>UCL_SAFE_ITER_CHECK</name> <argument_list>(<argument><expr><name>rit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name><name>rit</name><operator>-&gt;</operator><name>flags</name></name> <operator>==</operator> <name>UCL_ITERATE_FLAG_EXCEPTION</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>ucl_object_iter_t</name></type>
<name>ucl_object_iterate_reset</name> <parameter_list>(<parameter><decl><type><name>ucl_object_iter_t</name></type> <name>it</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>ucl_object_safe_iter</name></name> <modifier>*</modifier></type><name>rit</name> <init>= <expr><call><name>UCL_SAFE_ITER</name> <argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>UCL_SAFE_ITER_CHECK</name> <argument_list>(<argument><expr><name>rit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>rit</name><operator>-&gt;</operator><name>expl_it</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>rit</name><operator>-&gt;</operator><name>flags</name></name> <operator>==</operator> <name>UCL_ITERATE_FLAG_INSIDE_OBJECT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>UCL_FREE</name> <argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><operator>*</operator><name><name>rit</name><operator>-&gt;</operator><name>expl_it</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>rit</name><operator>-&gt;</operator><name>expl_it</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>rit</name><operator>-&gt;</operator><name>impl_it</name></name> <operator>=</operator> <name>obj</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rit</name><operator>-&gt;</operator><name>expl_it</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rit</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>UCL_ITERATE_FLAG_UNDEFINED</name></expr>;</expr_stmt>

<return>return <expr><name>it</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>ucl_object_t</name><modifier>*</modifier></type>
<name>ucl_object_iterate_safe</name> <parameter_list>(<parameter><decl><type><name>ucl_object_iter_t</name></type> <name>it</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>expand_values</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>ucl_object_iterate_full</name> <argument_list>(<argument><expr><name>it</name></expr></argument>, <argument><expr><ternary><condition><expr><name>expand_values</name></expr> ?</condition><then> <expr><name>UCL_ITERATE_BOTH</name></expr> </then><else>:
<expr><name>UCL_ITERATE_IMPLICIT</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>ucl_object_t</name><modifier>*</modifier></type>
<name>ucl_object_iterate_full</name> <parameter_list>(<parameter><decl><type><name>ucl_object_iter_t</name></type> <name>it</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>ucl_iterate_type</name></name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>ucl_object_safe_iter</name></name> <modifier>*</modifier></type><name>rit</name> <init>= <expr><call><name>UCL_SAFE_ITER</name> <argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ern</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>UCL_SAFE_ITER_CHECK</name> <argument_list>(<argument><expr><name>rit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>rit</name><operator>-&gt;</operator><name>impl_it</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>rit</name><operator>-&gt;</operator><name>impl_it</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>UCL_OBJECT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>rit</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>UCL_ITERATE_FLAG_INSIDE_OBJECT</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ucl_object_iterate_with_error</name> <argument_list>(<argument><expr><name><name>rit</name><operator>-&gt;</operator><name>impl_it</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rit</name><operator>-&gt;</operator><name>expl_it</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>ern</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>rit</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>UCL_ITERATE_FLAG_EXCEPTION</name></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>type</name> <operator>&amp;</operator> <name>UCL_ITERATE_IMPLICIT</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>rit</name><operator>-&gt;</operator><name>impl_it</name></name> <operator>=</operator> <name><name>rit</name><operator>-&gt;</operator><name>impl_it</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rit</name><operator>-&gt;</operator><name>expl_it</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<return>return <expr><call><name>ucl_object_iterate_safe</name> <argument_list>(<argument><expr><name>it</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>rit</name><operator>-&gt;</operator><name>impl_it</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>UCL_ARRAY</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>rit</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>UCL_ITERATE_FLAG_INSIDE_ARRAY</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ucl_object_iterate</name> <argument_list>(<argument><expr><name><name>rit</name><operator>-&gt;</operator><name>impl_it</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rit</name><operator>-&gt;</operator><name>expl_it</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>type</name> <operator>&amp;</operator> <name>UCL_ITERATE_IMPLICIT</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>rit</name><operator>-&gt;</operator><name>impl_it</name></name> <operator>=</operator> <name><name>rit</name><operator>-&gt;</operator><name>impl_it</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rit</name><operator>-&gt;</operator><name>expl_it</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<return>return <expr><call><name>ucl_object_iterate_safe</name> <argument_list>(<argument><expr><name>it</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>

<expr_stmt><expr><name><name>rit</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>UCL_ITERATE_FLAG_IMPLICIT</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name><name>rit</name><operator>-&gt;</operator><name>impl_it</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rit</name><operator>-&gt;</operator><name>impl_it</name></name> <operator>=</operator> <name><name>rit</name><operator>-&gt;</operator><name>impl_it</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&amp;</operator> <name>UCL_ITERATE_EXPLICIT</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>ret</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>UCL_OBJECT</name> <operator>||</operator> <name><name>ret</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>UCL_ARRAY</name></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>ucl_object_iterate_safe</name> <argument_list>(<argument><expr><name>it</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ucl_object_iterate_free</name> <parameter_list>(<parameter><decl><type><name>ucl_object_iter_t</name></type> <name>it</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>ucl_object_safe_iter</name></name> <modifier>*</modifier></type><name>rit</name> <init>= <expr><call><name>UCL_SAFE_ITER</name> <argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>UCL_SAFE_ITER_CHECK</name> <argument_list>(<argument><expr><name>rit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>rit</name><operator>-&gt;</operator><name>expl_it</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>rit</name><operator>-&gt;</operator><name>flags</name></name> <operator>==</operator> <name>UCL_ITERATE_FLAG_INSIDE_OBJECT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>UCL_FREE</name> <argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><operator>*</operator><name><name>rit</name><operator>-&gt;</operator><name>expl_it</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>rit</name><operator>-&gt;</operator><name>expl_it</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>UCL_FREE</name> <argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><operator>*</operator><name>rit</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type>
<name>ucl_object_lookup_path</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>top</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path_in</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>ucl_object_lookup_path_char</name> <argument_list>(<argument><expr><name>top</name></expr></argument>, <argument><expr><name>path_in</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type>
<name>ucl_object_lookup_path_char</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>top</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path_in</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name></type> <name>sep</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>found</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>err_str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>index</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>path_in</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>top</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>found</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>path_in</name></expr>;</expr_stmt>


<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <name>sep</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>

<expr_stmt><expr><name>c</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <name>sep</name> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;</operator> <name>c</name></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name><name>top</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>UCL_ARRAY</name></expr>:</case>

<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>strtoul</name> <argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>err_str</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>err_str</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>err_str</name> <operator>!=</operator> <name>sep</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>err_str</name> <operator>!=</operator> <literal type="char">'\0'</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>ucl_array_find_index</name> <argument_list>(<argument><expr><name>top</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>ucl_object_lookup_len</name> <argument_list>(<argument><expr><name>top</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>p</name> <operator>-</operator> <name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<if_stmt><if>if <condition>(<expr><name>o</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>top</name> <operator>=</operator> <name>o</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name>found</name> <operator>=</operator> <name>o</name></expr>;</expr_stmt>

<return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>ucl_object_t</name> <modifier>*</modifier></type>
<name>ucl_object_new</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>ucl_object_typed_new</name> <argument_list>(<argument><expr><name>UCL_NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>ucl_object_t</name> <modifier>*</modifier></type>
<name>ucl_object_typed_new</name> <parameter_list>(<parameter><decl><type><name>ucl_type_t</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>ucl_object_new_full</name> <argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>ucl_object_t</name> <modifier>*</modifier></type>
<name>ucl_object_new_full</name> <parameter_list>(<parameter><decl><type><name>ucl_type_t</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>priority</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>new</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>UCL_USERDATA</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>new</name> <operator>=</operator> <call><name>UCL_ALLOC</name> <argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>ucl_object_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>new</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memset</name> <argument_list>(<argument><expr><name>new</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>ucl_object_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>ref</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>type</name> <operator>&lt;=</operator> <name>UCL_NULL</name></expr> ?</condition><then> <expr><name>type</name></expr> </then><else>: <expr><name>UCL_NULL</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>new</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ucl_object_set_priority</name> <argument_list>(<argument><expr><name>new</name></expr></argument>, <argument><expr><name>priority</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>UCL_ARRAY</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>av</name></name> <operator>=</operator> <call><name>UCL_ALLOC</name> <argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>ucl_array_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>new</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>av</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memset</name> <argument_list>(<argument><expr><name><name>new</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>av</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>ucl_array_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UCL_ARRAY_GET</name> <argument_list>(<argument><expr><name>vec</name></expr></argument>, <argument><expr><name>new</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>kv_resize_safe</name> <argument_list>(<argument><expr><name>ucl_object_t</name> <operator>*</operator></expr></argument>, <argument><expr><operator>*</operator><name>vec</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>enomem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>new</name> <operator>=</operator> <call><name>ucl_object_new_userdata</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ucl_object_set_priority</name> <argument_list>(<argument><expr><name>new</name></expr></argument>, <argument><expr><name>priority</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<label><name>enomem</name>:</label>
<return>return <expr><name>new</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>ucl_object_reserve</name> <parameter_list>(<parameter><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>reserved</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>UCL_ARRAY</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>UCL_ARRAY_GET</name> <argument_list>(<argument><expr><name>vec</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>vec</name><operator>-&gt;</operator><name>m</name></name> <operator>&lt;</operator> <name>reserved</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>kv_resize_safe</name> <argument_list>(<argument><expr><name>ucl_object_t</name> <operator>*</operator></expr></argument>, <argument><expr><operator>*</operator><name>vec</name></expr></argument>, <argument><expr><name>reserved</name></expr></argument>, <argument><expr><name>e0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>UCL_OBJECT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_hash_reserve</name> <argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>ov</name></name></expr></argument>, <argument><expr><name>reserved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
<label><name>e0</name>:</label>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ucl_object_t</name><modifier>*</modifier></type>
<name>ucl_object_new_userdata</name> <parameter_list>(<parameter><decl><type><name>ucl_userdata_dtor</name></type> <name>dtor</name></decl></parameter>,
<parameter><decl><type><name>ucl_userdata_emitter</name></type> <name>emitter</name></decl></parameter>,
<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>ucl_object_userdata</name></name> <modifier>*</modifier></type><name>new</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>nsize</name> <init>= <expr><sizeof>sizeof <argument_list>(<argument><expr><operator>*</operator><name>new</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>new</name> <operator>=</operator> <call><name>UCL_ALLOC</name> <argument_list>(<argument><expr><name>nsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>new</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memset</name> <argument_list>(<argument><expr><name>new</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>obj</name><operator>.</operator><name>ref</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>obj</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>UCL_USERDATA</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>obj</name><operator>.</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>obj</name><operator>.</operator><name>prev</name></name> <operator>=</operator> <operator>(</operator><name>ucl_object_t</name> <operator>*</operator><operator>)</operator><name>new</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>dtor</name></name> <operator>=</operator> <name>dtor</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>emitter</name></name> <operator>=</operator> <name>emitter</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>obj</name><operator>.</operator><name>value</name><operator>.</operator><name>ud</name></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><operator>(</operator><name>ucl_object_t</name> <operator>*</operator><operator>)</operator><name>new</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ucl_type_t</name></type>
<name>ucl_object_type</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>obj</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>UCL_NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><name><name>obj</name><operator>-&gt;</operator><name>type</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ucl_object_t</name><modifier>*</modifier></type>
<name>ucl_object_fromstring</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>ucl_object_fromstring_common</name> <argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>UCL_STRING_ESCAPE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>ucl_object_t</name> <modifier>*</modifier></type>
<name>ucl_object_fromlstring</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>ucl_object_fromstring_common</name> <argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>UCL_STRING_ESCAPE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>ucl_object_t</name> <modifier>*</modifier></type>
<name>ucl_object_fromint</name> <parameter_list>(<parameter><decl><type><name>int64_t</name></type> <name>iv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>obj</name></decl>;</decl_stmt>

<expr_stmt><expr><name>obj</name> <operator>=</operator> <call><name>ucl_object_new</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>obj</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>UCL_INT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>iv</name></name> <operator>=</operator> <name>iv</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>obj</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ucl_object_t</name> <modifier>*</modifier></type>
<name>ucl_object_fromdouble</name> <parameter_list>(<parameter><decl><type><name>double</name></type> <name>dv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>obj</name></decl>;</decl_stmt>

<expr_stmt><expr><name>obj</name> <operator>=</operator> <call><name>ucl_object_new</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>obj</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>UCL_FLOAT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>dv</name></name> <operator>=</operator> <name>dv</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>obj</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ucl_object_t</name><modifier>*</modifier></type>
<name>ucl_object_frombool</name> <parameter_list>(<parameter><decl><type><name>bool</name></type> <name>bv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>obj</name></decl>;</decl_stmt>

<expr_stmt><expr><name>obj</name> <operator>=</operator> <call><name>ucl_object_new</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>obj</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>UCL_BOOLEAN</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>iv</name></name> <operator>=</operator> <name>bv</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>obj</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ucl_array_append</name> <parameter_list>(<parameter><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>top</name></decl></parameter>, <parameter><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>elt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>UCL_ARRAY_GET</name> <argument_list>(<argument><expr><name>vec</name></expr></argument>, <argument><expr><name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>elt</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>top</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>vec</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>vec</name> <operator>=</operator> <call><name>UCL_ALLOC</name> <argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><operator>*</operator><name>vec</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>vec</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>kv_init</name> <argument_list>(<argument><expr><operator>*</operator><name>vec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>top</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>av</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>vec</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>kv_push_safe</name> <argument_list>(<argument><expr><name>ucl_object_t</name> <operator>*</operator></expr></argument>, <argument><expr><operator>*</operator><name>vec</name></expr></argument>, <argument><expr><name>elt</name></expr></argument>, <argument><expr><name>e0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>top</name><operator>-&gt;</operator><name>len</name></name> <operator>++</operator></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>
<label><name>e0</name>:</label>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ucl_array_prepend</name> <parameter_list>(<parameter><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>top</name></decl></parameter>, <parameter><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>elt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>UCL_ARRAY_GET</name> <argument_list>(<argument><expr><name>vec</name></expr></argument>, <argument><expr><name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>elt</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>top</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>vec</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>vec</name> <operator>=</operator> <call><name>UCL_ALLOC</name> <argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><operator>*</operator><name>vec</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>kv_init</name> <argument_list>(<argument><expr><operator>*</operator><name>vec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>top</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>av</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>vec</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>kv_push_safe</name> <argument_list>(<argument><expr><name>ucl_object_t</name> <operator>*</operator></expr></argument>, <argument><expr><operator>*</operator><name>vec</name></expr></argument>, <argument><expr><name>elt</name></expr></argument>, <argument><expr><name>e0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>

<expr_stmt><expr><call><name>kv_prepend_safe</name> <argument_list>(<argument><expr><name>ucl_object_t</name> <operator>*</operator></expr></argument>, <argument><expr><operator>*</operator><name>vec</name></expr></argument>, <argument><expr><name>elt</name></expr></argument>, <argument><expr><name>e0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>top</name><operator>-&gt;</operator><name>len</name></name> <operator>++</operator></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>
<label><name>e0</name>:</label>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ucl_array_merge</name> <parameter_list>(<parameter><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>top</name></decl></parameter>, <parameter><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>elt</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>copy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>cp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ucl_object_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>obj</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>elt</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>top</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>top</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>UCL_ARRAY</name> <operator>||</operator> <name><name>elt</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>UCL_ARRAY</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>copy</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>ucl_object_copy</name> <argument_list>(<argument><expr><name>elt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>ucl_object_ref</name> <argument_list>(<argument><expr><name>elt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>UCL_ARRAY_GET</name> <argument_list>(<argument><expr><name>v1</name></expr></argument>, <argument><expr><name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UCL_ARRAY_GET</name> <argument_list>(<argument><expr><name>v2</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>v1</name> <operator>&amp;&amp;</operator> <name>v2</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>kv_concat_safe</name> <argument_list>(<argument><expr><name>ucl_object_t</name> <operator>*</operator></expr></argument>, <argument><expr><operator>*</operator><name>v1</name></expr></argument>, <argument><expr><operator>*</operator><name>v2</name></expr></argument>, <argument><expr><name>e0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>v2</name><operator>-&gt;</operator><name>n</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>v1</name><operator>-&gt;</operator><name>n</name></name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>obj</name> <operator>=</operator> <operator>&amp;</operator><call><name>kv_A</name> <argument_list>(<argument><expr><operator>*</operator><name>v1</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>obj</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>top</name><operator>-&gt;</operator><name>len</name></name> <operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>true</name></expr>;</return>
<label><name>e0</name>:</label>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ucl_object_t</name> <modifier>*</modifier></type>
<name>ucl_array_delete</name> <parameter_list>(<parameter><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>top</name></decl></parameter>, <parameter><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>elt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>UCL_ARRAY_GET</name> <argument_list>(<argument><expr><name>vec</name></expr></argument>, <argument><expr><name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>vec</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>vec</name><operator>-&gt;</operator><name>n</name></name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>kv_A</name> <argument_list>(<argument><expr><operator>*</operator><name>vec</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>elt</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>kv_del</name> <argument_list>(<argument><expr><name>ucl_object_t</name> <operator>*</operator></expr></argument>, <argument><expr><operator>*</operator><name>vec</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>elt</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>top</name><operator>-&gt;</operator><name>len</name></name> <operator>--</operator></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type>
<name>ucl_array_head</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>top</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>UCL_ARRAY_GET</name> <argument_list>(<argument><expr><name>vec</name></expr></argument>, <argument><expr><name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>vec</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>top</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>top</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>UCL_ARRAY</name> <operator>||</operator>
<name><name>top</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>av</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><operator>(</operator><ternary><condition><expr><name><name>vec</name><operator>-&gt;</operator><name>n</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>vec</name><operator>-&gt;</operator><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type>
<name>ucl_array_tail</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>top</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>UCL_ARRAY_GET</name> <argument_list>(<argument><expr><name>vec</name></expr></argument>, <argument><expr><name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>top</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>top</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>UCL_ARRAY</name> <operator>||</operator> <name><name>top</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>av</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><operator>(</operator><ternary><condition><expr><name><name>vec</name><operator>-&gt;</operator><name>n</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>vec</name><operator>-&gt;</operator><name>a</name><index>[<expr><name><name>vec</name><operator>-&gt;</operator><name>n</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>ucl_object_t</name> <modifier>*</modifier></type>
<name>ucl_array_pop_last</name> <parameter_list>(<parameter><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>top</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>UCL_ARRAY_GET</name> <argument_list>(<argument><expr><name>vec</name></expr></argument>, <argument><expr><name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ucl_object_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>obj</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>vec</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>vec</name><operator>-&gt;</operator><name>n</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>obj</name> <operator>=</operator> <operator>&amp;</operator><call><name>kv_A</name> <argument_list>(<argument><expr><operator>*</operator><name>vec</name></expr></argument>, <argument><expr><name><name>vec</name><operator>-&gt;</operator><name>n</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>*</operator><name>obj</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>kv_del</name> <argument_list>(<argument><expr><name>ucl_object_t</name> <operator>*</operator></expr></argument>, <argument><expr><operator>*</operator><name>vec</name></expr></argument>, <argument><expr><name><name>vec</name><operator>-&gt;</operator><name>n</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>top</name><operator>-&gt;</operator><name>len</name></name> <operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ucl_object_t</name> <modifier>*</modifier></type>
<name>ucl_array_pop_first</name> <parameter_list>(<parameter><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>top</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>UCL_ARRAY_GET</name> <argument_list>(<argument><expr><name>vec</name></expr></argument>, <argument><expr><name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ucl_object_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>obj</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>vec</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>vec</name><operator>-&gt;</operator><name>n</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>obj</name> <operator>=</operator> <operator>&amp;</operator><call><name>kv_A</name> <argument_list>(<argument><expr><operator>*</operator><name>vec</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>*</operator><name>obj</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>kv_del</name> <argument_list>(<argument><expr><name>ucl_object_t</name> <operator>*</operator></expr></argument>, <argument><expr><operator>*</operator><name>vec</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>top</name><operator>-&gt;</operator><name>len</name></name> <operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>unsigned</name> <name>int</name></type>
<name>ucl_array_size</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>top</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>top</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>top</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>UCL_ARRAY</name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>UCL_ARRAY_GET</name> <argument_list>(<argument><expr><name>vec</name></expr></argument>, <argument><expr><name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>vec</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>kv_size</name><argument_list>(<argument><expr><operator>*</operator><name>vec</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type>
<name>ucl_array_find_index</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>top</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>UCL_ARRAY_GET</name> <argument_list>(<argument><expr><name>vec</name></expr></argument>, <argument><expr><name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>vec</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>vec</name><operator>-&gt;</operator><name>n</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>index</name> <operator>&lt;</operator> <name><name>vec</name><operator>-&gt;</operator><name>n</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>kv_A</name> <argument_list>(<argument><expr><operator>*</operator><name>vec</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>unsigned</name> <name>int</name></type>
<name>ucl_array_index_of</name> <parameter_list>(<parameter><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>top</name></decl></parameter>, <parameter><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>elt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>UCL_ARRAY_GET</name> <argument_list>(<argument><expr><name>vec</name></expr></argument>, <argument><expr><name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>vec</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>vec</name><operator>-&gt;</operator><name>n</name></name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>kv_A</name> <argument_list>(<argument><expr><operator>*</operator><name>vec</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>elt</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<return>return <expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>ucl_object_t</name> <modifier>*</modifier></type>
<name>ucl_array_replace_index</name> <parameter_list>(<parameter><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>top</name></decl></parameter>, <parameter><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>elt</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>UCL_ARRAY_GET</name> <argument_list>(<argument><expr><name>vec</name></expr></argument>, <argument><expr><name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>vec</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>vec</name><operator>-&gt;</operator><name>n</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>index</name> <operator>&lt;</operator> <name><name>vec</name><operator>-&gt;</operator><name>n</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>kv_A</name> <argument_list>(<argument><expr><operator>*</operator><name>vec</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>kv_A</name> <argument_list>(<argument><expr><operator>*</operator><name>vec</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>elt</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ucl_object_t</name> <modifier>*</modifier></type>
<name>ucl_elt_append</name> <parameter_list>(<parameter><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>head</name></decl></parameter>, <parameter><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>elt</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>head</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>elt</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>elt</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>elt</name></expr>;</expr_stmt>
<expr_stmt><expr><name>head</name> <operator>=</operator> <name>elt</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name><name>elt</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>head</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>head</name><operator>-&gt;</operator><name>prev</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>elt</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>head</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>elt</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>elt</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>head</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ucl_object_todouble_safe</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>obj</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>target</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<switch>switch <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>UCL_INT</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>target</name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>iv</name></name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>UCL_FLOAT</name></expr>:</case>
<case>case <expr><name>UCL_TIME</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>target</name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>dv</name></name></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></switch>

<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>double</name></type>
<name>ucl_object_todouble</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>double</name></type> <name>result</name> <init>= <expr><literal type="number">0.</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ucl_object_todouble_safe</name> <argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ucl_object_toint_safe</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>obj</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>target</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<switch>switch <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>UCL_INT</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>target</name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>iv</name></name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>UCL_FLOAT</name></expr>:</case>
<case>case <expr><name>UCL_TIME</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>target</name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>dv</name></name></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></switch>

<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int64_t</name></type>
<name>ucl_object_toint</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name></type> <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ucl_object_toint_safe</name> <argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ucl_object_toboolean_safe</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>obj</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>target</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<switch>switch <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>UCL_BOOLEAN</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>target</name> <operator>=</operator> <operator>(</operator><name><name>obj</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>iv</name></name> <operator>==</operator> <name>true</name><operator>)</operator></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></switch>

<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ucl_object_toboolean</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ucl_object_toboolean_safe</name> <argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ucl_object_tostring_safe</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>obj</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>target</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>UCL_STRING</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>obj</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>UCL_OBJECT_BINARY</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>target</name> <operator>=</operator> <call><name>ucl_copy_value_trash</name> <argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<default>default:</default>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></switch>

<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>ucl_object_tostring</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ucl_object_tostring_safe</name> <argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>ucl_object_tostring_forced</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>obj</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>UCL_OBJECT_BINARY</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>ucl_copy_value_trash</name> <argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ucl_object_tolstring_safe</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>tlen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>obj</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>target</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<switch>switch <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>UCL_STRING</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>target</name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>sv</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tlen</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>tlen</name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<default>default:</default>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></switch>

<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>ucl_object_tolstring</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>tlen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ucl_object_tolstring_safe</name> <argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>tlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>ucl_object_key</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>ucl_copy_key_trash</name> <argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>ucl_object_keyl</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>obj</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>keylen</name></name></expr>;</expr_stmt>
<return>return <expr><name><name>obj</name><operator>-&gt;</operator><name>key</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ucl_object_t</name> <modifier>*</modifier></type>
<name>ucl_object_ref</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>obj</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>UCL_OBJECT_EPHEMERAL</name></expr>)</condition> <block>{<block_content>





<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ucl_object_copy</name> <argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>__DECONST</name> <argument_list>(<argument><expr><name>ucl_object_t</name> <operator>*</operator></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_ATOMIC_BUILTINS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>__sync_add_and_fetch</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>res</name><operator>-&gt;</operator><name>ref</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>ref</name></name> <operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type>
<name>ucl_object_copy_internal</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>other</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>allow_array</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<decl_stmt><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>new</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ucl_object_iter_t</name></type> <name>it</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>cur</name></decl>;</decl_stmt>

<expr_stmt><expr><name>new</name> <operator>=</operator> <call><name>malloc</name> <argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><operator>*</operator><name>new</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>new</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>new</name></expr></argument>, <argument><expr><name>other</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><operator>*</operator><name>new</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>other</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>UCL_OBJECT_EPHEMERAL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>UCL_OBJECT_EPHEMERAL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>ref</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>new</name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>other</name><operator>-&gt;</operator><name>trash_stack</name><index>[<expr><name>UCL_TRASH_KEY</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>trash_stack</name><index>[<expr><name>UCL_TRASH_KEY</name></expr>]</index></name> <operator>=</operator>
<call><name>strdup</name> <argument_list>(<argument><expr><name><name>other</name><operator>-&gt;</operator><name>trash_stack</name><index>[<expr><name>UCL_TRASH_KEY</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>other</name><operator>-&gt;</operator><name>key</name></name> <operator>==</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name><name>other</name><operator>-&gt;</operator><name>trash_stack</name><index>[<expr><name>UCL_TRASH_KEY</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <name><name>new</name><operator>-&gt;</operator><name>trash_stack</name><index>[<expr><name>UCL_TRASH_KEY</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>other</name><operator>-&gt;</operator><name>trash_stack</name><index>[<expr><name>UCL_TRASH_VALUE</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>trash_stack</name><index>[<expr><name>UCL_TRASH_VALUE</name></expr>]</index></name> <operator>=</operator>
<call><name>strdup</name> <argument_list>(<argument><expr><name><name>other</name><operator>-&gt;</operator><name>trash_stack</name><index>[<expr><name>UCL_TRASH_VALUE</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>new</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>UCL_STRING</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>sv</name></name> <operator>=</operator> <name><name>new</name><operator>-&gt;</operator><name>trash_stack</name><index>[<expr><name>UCL_TRASH_VALUE</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>other</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>UCL_ARRAY</name> <operator>||</operator> <name><name>other</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>UCL_OBJECT</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>memset</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>new</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name><name>new</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>(</operator><name>cur</name> <operator>=</operator> <call><name>ucl_object_iterate</name> <argument_list>(<argument><expr><name>other</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>other</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>UCL_ARRAY</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_array_append</name> <argument_list>(<argument><expr><name>new</name></expr></argument>, <argument><expr><call><name>ucl_object_copy_internal</name> <argument_list>(<argument><expr><name>cur</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>cp</name> <init>= <expr><call><name>ucl_object_copy_internal</name> <argument_list>(<argument><expr><name>cur</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>cp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_object_insert_key</name> <argument_list>(<argument><expr><name>new</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>, <argument><expr><name><name>cp</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name><name>cp</name><operator>-&gt;</operator><name>keylen</name></name></expr></argument>,
<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>allow_array</name> <operator>&amp;&amp;</operator> <name><name>other</name><operator>-&gt;</operator><name>next</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<macro><name>LL_FOREACH</name> <argument_list>(<argument>other-&gt;next</argument>, <argument>cur</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>cp</name> <init>= <expr><call><name>ucl_object_copy_internal</name> <argument_list>(<argument><expr><name>cur</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>cp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>DL_APPEND</name> <argument_list>(<argument><expr><name>new</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>new</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ucl_object_t</name> <modifier>*</modifier></type>
<name>ucl_object_copy</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>other</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>ucl_object_copy_internal</name> <argument_list>(<argument><expr><name>other</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ucl_object_unref</name> <parameter_list>(<parameter><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>obj</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_ATOMIC_BUILTINS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>rc</name> <init>= <expr><call><name>__sync_sub_and_fetch</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>obj</name><operator>-&gt;</operator><name>ref</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if_stmt><if>if <condition>(<expr><operator>--</operator><name><name>obj</name><operator>-&gt;</operator><name>ref</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>ucl_object_free_internal</name> <argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>ucl_object_dtor_unref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<function><type><name>int</name></type>
<name>ucl_object_compare</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>o1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>o2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>it1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>it2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ucl_object_iter_t</name></type> <name>iter</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><operator>(</operator><name>o1</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>o2</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition>
<block>{<block_content>

<return>return <expr><operator>(</operator><name>o1</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>o2</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>o1</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name><name>o2</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><name><name>o1</name><operator>-&gt;</operator><name>type</name></name><operator>)</operator> <operator>-</operator> <operator>(</operator><name><name>o2</name><operator>-&gt;</operator><name>type</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>o1</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>UCL_STRING</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>o1</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <name><name>o2</name><operator>-&gt;</operator><name>len</name></name> <operator>&amp;&amp;</operator> <name><name>o1</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>strcmp</name> <argument_list>(<argument><expr><call><name>ucl_object_tostring</name><argument_list>(<argument><expr><name>o1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ucl_object_tostring</name><argument_list>(<argument><expr><name>o2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name><name>o1</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <name><name>o2</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<case>case <expr><name>UCL_FLOAT</name></expr>:</case>
<case>case <expr><name>UCL_INT</name></expr>:</case>
<case>case <expr><name>UCL_TIME</name></expr>:</case>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ucl_object_todouble</name> <argument_list>(<argument><expr><name>o1</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>ucl_object_todouble</name> <argument_list>(<argument><expr><name>o2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>UCL_BOOLEAN</name></expr>:</case>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ucl_object_toboolean</name> <argument_list>(<argument><expr><name>o1</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>ucl_object_toboolean</name> <argument_list>(<argument><expr><name>o2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>UCL_ARRAY</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>o1</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <name><name>o2</name><operator>-&gt;</operator><name>len</name></name> <operator>&amp;&amp;</operator> <name><name>o1</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>UCL_ARRAY_GET</name> <argument_list>(<argument><expr><name>vec1</name></expr></argument>, <argument><expr><name>o1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UCL_ARRAY_GET</name> <argument_list>(<argument><expr><name>vec2</name></expr></argument>, <argument><expr><name>o2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>vec1</name><operator>-&gt;</operator><name>n</name></name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>it1</name> <operator>=</operator> <call><name>kv_A</name> <argument_list>(<argument><expr><operator>*</operator><name>vec1</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>it2</name> <operator>=</operator> <call><name>kv_A</name> <argument_list>(<argument><expr><operator>*</operator><name>vec2</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>it1</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>it2</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>it2</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>it1</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>it1</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>it2</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ucl_object_compare</name> <argument_list>(<argument><expr><name>it1</name></expr></argument>, <argument><expr><name>it2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name><name>o1</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <name><name>o2</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<case>case <expr><name>UCL_OBJECT</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>o1</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <name><name>o2</name><operator>-&gt;</operator><name>len</name></name> <operator>&amp;&amp;</operator> <name><name>o1</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<while>while <condition>(<expr><operator>(</operator><name>it1</name> <operator>=</operator> <call><name>ucl_object_iterate</name> <argument_list>(<argument><expr><name>o1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>it2</name> <operator>=</operator> <call><name>ucl_object_lookup</name> <argument_list>(<argument><expr><name>o2</name></expr></argument>, <argument><expr><call><name>ucl_object_key</name> <argument_list>(<argument><expr><name>it1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>it2</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ucl_object_compare</name> <argument_list>(<argument><expr><name>it1</name></expr></argument>, <argument><expr><name>it2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name><name>o1</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <name><name>o2</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>

<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>ucl_object_compare_qsort</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>o1</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>o2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>ucl_object_compare</name> <argument_list>(<argument><expr><operator>*</operator><name>o1</name></expr></argument>, <argument><expr><operator>*</operator><name>o2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ucl_object_array_sort</name> <parameter_list>(<parameter><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>ar</name></decl></parameter>,
<parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>cmp</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>o1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>o2</name></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>UCL_ARRAY_GET</name> <argument_list>(<argument><expr><name>vec</name></expr></argument>, <argument><expr><name>ar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>ar</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>ar</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>UCL_ARRAY</name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>qsort</name> <argument_list>(<argument><expr><name><name>vec</name><operator>-&gt;</operator><name>a</name></name></expr></argument>, <argument><expr><name><name>vec</name><operator>-&gt;</operator><name>n</name></name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>ucl_object_t</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><operator>(</operator><call><call><name>int</name> <argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><specifier>const</specifier> <name>void</name> <operator>*</operator></expr></argument>, <argument><expr><specifier>const</specifier> <name>void</name> <operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator><name>cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>ucl_object_sort_keys</name> <parameter_list>(<parameter><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>,
<parameter><decl><type><name><name>enum</name> <name>ucl_object_keys_sort_flags</name></name></type> <name>how</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>obj</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>obj</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>UCL_OBJECT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_hash_sort</name> <argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>ov</name></name></expr></argument>, <argument><expr><name>how</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRIOBITS</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>

<function><type><name>unsigned</name> <name>int</name></type>
<name>ucl_object_get_priority</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>obj</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><operator>(</operator><name><name>obj</name><operator>-&gt;</operator><name>flags</name></name> <operator>&gt;&gt;</operator> <operator>(</operator><operator>(</operator><sizeof>sizeof <argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>NBBY</name><operator>)</operator> <operator>-</operator> <name>PRIOBITS</name><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ucl_object_set_priority</name> <parameter_list>(<parameter><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>priority</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>obj</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>priority</name> <operator>&amp;=</operator> <operator>(</operator><literal type="number">0x1</literal> <operator>&lt;&lt;</operator> <name>PRIOBITS</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>priority</name> <operator>&lt;&lt;=</operator> <operator>(</operator><operator>(</operator><sizeof>sizeof <argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>NBBY</name><operator>)</operator> <operator>-</operator> <name>PRIOBITS</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>priority</name> <operator>|=</operator> <name><name>obj</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><operator>(</operator><sizeof>sizeof <argument_list>(<argument><expr><name><name>obj</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>NBBY</name><operator>)</operator> <operator>-</operator>
<name>PRIOBITS</name><operator>)</operator><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>obj</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>priority</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ucl_object_string_to_type</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><name>ucl_type_t</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>strcasecmp</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="string">"object"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>res</name> <operator>=</operator> <name>UCL_OBJECT</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>strcasecmp</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="string">"array"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>res</name> <operator>=</operator> <name>UCL_ARRAY</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>strcasecmp</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="string">"integer"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>res</name> <operator>=</operator> <name>UCL_INT</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>strcasecmp</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="string">"number"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>res</name> <operator>=</operator> <name>UCL_FLOAT</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>strcasecmp</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="string">"string"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>res</name> <operator>=</operator> <name>UCL_STRING</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>strcasecmp</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="string">"boolean"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>res</name> <operator>=</operator> <name>UCL_BOOLEAN</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>strcasecmp</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="string">"null"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>res</name> <operator>=</operator> <name>UCL_NULL</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>strcasecmp</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="string">"userdata"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>res</name> <operator>=</operator> <name>UCL_USERDATA</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>ucl_object_type_to_string</name> <parameter_list>(<parameter><decl><type><name>ucl_type_t</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><literal type="string">"unknown"</literal></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>UCL_OBJECT</name></expr>:</case>
<expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="string">"object"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>UCL_ARRAY</name></expr>:</case>
<expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="string">"array"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>UCL_INT</name></expr>:</case>
<expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="string">"integer"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>UCL_FLOAT</name></expr>:</case>
<case>case <expr><name>UCL_TIME</name></expr>:</case>
<expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="string">"number"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>UCL_STRING</name></expr>:</case>
<expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="string">"string"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>UCL_BOOLEAN</name></expr>:</case>
<expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="string">"boolean"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>UCL_USERDATA</name></expr>:</case>
<expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="string">"userdata"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>UCL_NULL</name></expr>:</case>
<expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="string">"null"</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>

<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type>
<name>ucl_parser_get_comments</name> <parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ucl_parser</name></name> <modifier>*</modifier></type><name>parser</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>parser</name> <operator>&amp;&amp;</operator> <name><name>parser</name><operator>-&gt;</operator><name>comments</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name><name>parser</name><operator>-&gt;</operator><name>comments</name></name></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type>
<name>ucl_comments_find</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>comments</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>srch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>comments</name> <operator>&amp;&amp;</operator> <name>srch</name></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>ucl_object_lookup_len</name> <argument_list>(<argument><expr><name>comments</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>srch</name></expr></argument>,
<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ucl_comments_move</name> <parameter_list>(<parameter><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>comments</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>to</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>found</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>obj</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>comments</name> <operator>&amp;&amp;</operator> <name>from</name> <operator>&amp;&amp;</operator> <name>to</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>ucl_object_lookup_len</name> <argument_list>(<argument><expr><name>comments</name></expr></argument>,
<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>from</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>obj</name> <operator>=</operator> <call><name>ucl_object_ref</name> <argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ucl_object_delete_keyl</name> <argument_list>(<argument><expr><name>comments</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>from</name></expr></argument>,
<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ucl_object_insert_key</name> <argument_list>(<argument><expr><name>comments</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>to</name></expr></argument>,
<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ucl_comments_add</name> <parameter_list>(<parameter><decl><type><name>ucl_object_t</name> <modifier>*</modifier></type><name>comments</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ucl_object_t</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>comment</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>comments</name> <operator>&amp;&amp;</operator> <name>obj</name> <operator>&amp;&amp;</operator> <name>comment</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ucl_object_insert_key</name> <argument_list>(<argument><expr><name>comments</name></expr></argument>, <argument><expr><call><name>ucl_object_fromstring</name> <argument_list>(<argument><expr><name>comment</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>obj</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ucl_parser_set_include_tracer</name> <parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ucl_parser</name></name> <modifier>*</modifier></type><name>parser</name></decl></parameter>,
<parameter><decl><type><name>ucl_include_trace_func_t</name></type> <name>func</name></decl></parameter>,
<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>user_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>include_trace_func</name></name> <operator>=</operator> <name>func</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name><operator>-&gt;</operator><name>include_trace_ud</name></name> <operator>=</operator> <name>user_data</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>ucl_parser_get_cur_file</name> <parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ucl_parser</name></name> <modifier>*</modifier></type><name>parser</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name><name>parser</name><operator>-&gt;</operator><name>cur_file</name></name></expr>;</return>
</block_content>}</block></function></block_content></block></function></block_content></block></function>
</unit>
