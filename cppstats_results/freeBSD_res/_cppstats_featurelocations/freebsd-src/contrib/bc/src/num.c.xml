<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/bc/src/num.c">


































<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdbool.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;setjmp.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;num.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;rand.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vm.h&gt;</cpp:file></cpp:include>




<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>bc_num_m</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>scale</name></decl></parameter>)</parameter_list>;</function_decl>







<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>size_t</name></type> <name>bc_num_mulOverflow</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>res</name> <init>= <expr><name>a</name> <operator>*</operator> <name>b</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><call><name>BC_VM_MUL_OVERFLOW</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_err</name><argument_list>(<argument><expr><name>BC_ERR_MATH_OVERFLOW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>ssize_t</name></type> <name>bc_num_neg</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>neg</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><operator>(</operator><operator>(</operator><operator>(</operator><name>ssize_t</name><operator>)</operator> <name>n</name><operator>)</operator> <operator>^</operator> <operator>-</operator><operator>(</operator><operator>(</operator><name>ssize_t</name><operator>)</operator> <name>neg</name><operator>)</operator><operator>)</operator> <operator>+</operator> <name>neg</name></expr>;</return>
</block_content>}</block></function>






<function><type><name>ssize_t</name></type> <name>bc_num_cmpZero</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BcNum</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>bc_num_neg</name><argument_list>(<argument><expr><operator>(</operator><name>n</name><operator>)</operator><operator>-&gt;</operator><name>len</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><call><name>BC_NUM_NEG</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>size_t</name></type> <name>bc_num_int</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BcNum</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><ternary><condition><expr><name><name>n</name><operator>-&gt;</operator><name>len</name></name></expr> ?</condition><then> <expr><name><name>n</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_num_expand</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>req</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>req</name> <operator>=</operator> <ternary><condition><expr><name>req</name> <operator>&gt;=</operator> <name>BC_NUM_DEF_SIZE</name></expr> ?</condition><then> <expr><name>req</name></expr> </then><else>: <expr><name>BC_NUM_DEF_SIZE</name></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>req</name> <operator>&gt;</operator> <name><name>n</name><operator>-&gt;</operator><name>cap</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>num</name></name> <operator>=</operator> <call><name>bc_vm_realloc</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><call><name>BC_NUM_SIZE</name><argument_list>(<argument><expr><name>req</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>cap</name></name> <operator>=</operator> <name>req</name></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_num_setToZero</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>scale</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>scale</name></name> <operator>=</operator> <name>scale</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>rdx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>bc_num_zero</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>bc_num_setToZero</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>bc_num_one</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>bc_num_zero</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>num</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_num_clean</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>


<while>while <condition>(<expr><call><name>BC_NUM_NONZERO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>n</name><operator>-&gt;</operator><name>num</name><index>[<expr><name><name>n</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>len</name></name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></while>


<if_stmt><if>if <condition>(<expr><call><name>BC_NUM_ZERO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>rdx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>


<decl_stmt><decl><type><name>size_t</name></type> <name>rdx</name> <init>= <expr><call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>len</name></name> <operator>&lt;</operator> <name>rdx</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>rdx</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>









<function><type><specifier>static</specifier> <name>size_t</name></type> <name>bc_num_log10</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name></expr>;</condition> <incr><expr><name>i</name> <operator>/=</operator> <name>BC_BASE</name></expr><operator>,</operator> <expr><operator>++</operator><name>len</name></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>len</name> <operator>-</operator> <literal type="number">1</literal> <operator>&lt;=</operator> <name>BC_BASE_DIGS</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>size_t</name></type> <name>bc_num_zeroDigits</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BcDig</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>*</operator><name>n</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator> <operator>*</operator><name>n</name><operator>)</operator> <operator>&lt;</operator> <name>BC_BASE_POW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>BC_BASE_DIGS</name> <operator>-</operator> <call><name>bc_num_log10</name><argument_list>(<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator> <operator>*</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>size_t</name></type> <name>bc_num_intDigits</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BcNum</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>digits</name> <init>= <expr><call><name>bc_num_int</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> <operator>*</operator> <name>BC_BASE_DIGS</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>digits</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>digits</name> <operator>-=</operator> <call><name>bc_num_zeroDigits</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>num</name></name> <operator>+</operator> <name><name>n</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>digits</name></expr>;</return>
</block_content>}</block></function>










<function><type><specifier>static</specifier> <name>size_t</name></type> <name>bc_num_nonZeroLen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name> <init>= <expr><name><name>n</name><operator>-&gt;</operator><name>len</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>len</name> <operator>==</operator> <call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>n</name><operator>-&gt;</operator><name>num</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><operator>--</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>









<function><type><specifier>static</specifier> <name>BcDig</name></type> <name>bc_num_addDigits</name><parameter_list>(<parameter><decl><type><name>BcDig</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>BcDig</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>carry</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>BcBigDig</name><operator>)</operator> <name>BC_BASE_POW</name><operator>)</operator> <operator>*</operator> <literal type="number">2</literal> <operator>==</operator> <operator>(</operator><operator>(</operator><name>BcDig</name><operator>)</operator> <name>BC_BASE_POW</name><operator>)</operator> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>a</name> <operator>&lt;</operator> <name>BC_BASE_POW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>b</name> <operator>&lt;</operator> <name>BC_BASE_POW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>a</name> <operator>+=</operator> <name>b</name> <operator>+</operator> <operator>*</operator><name>carry</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>carry</name> <operator>=</operator> <operator>(</operator><name>a</name> <operator>&gt;=</operator> <name>BC_BASE_POW</name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>carry</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>a</name> <operator>-=</operator> <name>BC_BASE_POW</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>a</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>a</name> <operator>&lt;</operator> <name>BC_BASE_POW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>a</name></expr>;</return>
</block_content>}</block></function>









<function><type><specifier>static</specifier> <name>BcDig</name></type> <name>bc_num_subDigits</name><parameter_list>(<parameter><decl><type><name>BcDig</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>BcDig</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>carry</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>a</name> <operator>&lt;</operator> <name>BC_BASE_POW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>b</name> <operator>&lt;</operator> <name>BC_BASE_POW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>b</name> <operator>+=</operator> <operator>*</operator><name>carry</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>carry</name> <operator>=</operator> <operator>(</operator><name>a</name> <operator>&lt;</operator> <name>b</name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>carry</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>a</name> <operator>+=</operator> <name>BC_BASE_POW</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>a</name> <operator>-</operator> <name>b</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>a</name> <operator>-</operator> <name>b</name> <operator>&lt;</operator> <name>BC_BASE_POW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>a</name> <operator>-</operator> <name>b</name></expr>;</return>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_num_addArrays</name><parameter_list>(<parameter><decl><type><name>BcDig</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BcDig</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>b</name></decl></parameter>,
<parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>carry</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>bc_num_addDigits</name><argument_list>(<argument><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>b</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>carry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>


<for>for <control>(<init>;</init> <condition><expr><name>carry</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>bc_num_addDigits</name><argument_list>(<argument><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>carry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_num_subArrays</name><parameter_list>(<parameter><decl><type><name>BcDig</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BcDig</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>b</name></decl></parameter>,
<parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>carry</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>bc_num_subDigits</name><argument_list>(<argument><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>b</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>carry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>


<for>for <control>(<init>;</init> <condition><expr><name>carry</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>bc_num_subDigits</name><argument_list>(<argument><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>carry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_num_mulArray</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>BcBigDig</name></type> <name>b</name></decl></parameter>,
<parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcBigDig</name></type> <name>carry</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>b</name> <operator>&lt;=</operator> <name>BC_BASE_POW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>len</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;</operator> <name><name>c</name><operator>-&gt;</operator><name>cap</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_num_expand</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>len</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>BC_NUM_SIZE</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>cap</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>a</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>BcBigDig</name></type> <name>in</name> <init>= <expr><operator>(</operator><operator>(</operator><name>BcBigDig</name><operator>)</operator> <name><name>a</name><operator>-&gt;</operator><name>num</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator> <operator>*</operator> <name>b</name> <operator>+</operator> <name>carry</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>num</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>in</name> <operator>%</operator> <name>BC_BASE_POW</name></expr>;</expr_stmt>
<expr_stmt><expr><name>carry</name> <operator>=</operator> <name>in</name> <operator>/</operator> <name>BC_BASE_POW</name></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>carry</name> <operator>&lt;</operator> <name>BC_BASE_POW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>num</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>BcDig</name><operator>)</operator> <name>carry</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>len</name></name> <operator>+=</operator> <operator>(</operator><name>carry</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_num_clean</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>BC_NUM_NEG</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>BC_NUM_NONZERO</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name><name>c</name><operator>-&gt;</operator><name>len</name></name> <operator>||</operator> <operator>!</operator><name><name>c</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>c</name><operator>-&gt;</operator><name>len</name></name> <operator>||</operator> <name><name>c</name><operator>-&gt;</operator><name>num</name><index>[<expr><name><name>c</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>||</operator> <call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>c</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>









<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_num_divArray</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>BcBigDig</name></type> <name>b</name></decl></parameter>,
<parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>BcBigDig</name> <modifier>*</modifier></type><name>rem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcBigDig</name></type> <name>carry</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>cap</name></name> <operator>&gt;=</operator> <name><name>a</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>a</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><operator>--</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>BcBigDig</name></type> <name>in</name> <init>= <expr><operator>(</operator><operator>(</operator><name>BcBigDig</name><operator>)</operator> <name><name>a</name><operator>-&gt;</operator><name>num</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator> <operator>+</operator> <name>carry</name> <operator>*</operator> <name>BC_BASE_POW</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>in</name> <operator>/</operator> <name>b</name> <operator>&lt;</operator> <name>BC_BASE_POW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>num</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>BcDig</name><operator>)</operator> <operator>(</operator><name>in</name> <operator>/</operator> <name>b</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>carry</name> <operator>=</operator> <name>in</name> <operator>%</operator> <name>b</name></expr>;</expr_stmt>
</block_content>}</block></for>


<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_clean</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>rem</name> <operator>=</operator> <name>carry</name></expr>;</expr_stmt>


<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>BC_NUM_NEG</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>BC_NUM_NONZERO</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name><name>c</name><operator>-&gt;</operator><name>len</name></name> <operator>||</operator> <operator>!</operator><name><name>c</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>c</name><operator>-&gt;</operator><name>len</name></name> <operator>||</operator> <name><name>c</name><operator>-&gt;</operator><name>num</name><index>[<expr><name><name>c</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>||</operator> <call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>c</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>ssize_t</name></type> <name>bc_num_compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BcDig</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BcDig</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>b</name></decl></parameter>,
<parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcDig</name></type> <name>c</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>c</name> <operator>=</operator> <name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <name><name>b</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>;</condition> <incr><expr><operator>--</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
<return>return <expr><call><name>bc_num_neg</name><argument_list>(<argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>c</name> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>ssize_t</name></type> <name>bc_num_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BcNum</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BcNum</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>min</name></decl>, <decl><type ref="prev"/><name>a_int</name></decl>, <decl><type ref="prev"/><name>b_int</name></decl>, <decl><type ref="prev"/><name>diff</name></decl>, <decl><type ref="prev"/><name>ardx</name></decl>, <decl><type ref="prev"/><name>brdx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcDig</name> <modifier>*</modifier></type><name>max_num</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>min_num</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>a_max</name></decl>, <decl><type ref="prev"/><name>neg</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>cmp</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>a</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>b</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name>b</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_NUM_ZERO</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>bc_num_neg</name><argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>len</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><operator>!</operator><call><name>BC_NUM_NEG</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>BC_NUM_ZERO</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>bc_num_cmpZero</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>BC_NUM_NEG</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>BC_NUM_NEG</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>neg</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>BC_NUM_NEG</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name>a_int</name> <operator>=</operator> <call><name>bc_num_int</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b_int</name> <operator>=</operator> <call><name>bc_num_int</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>a_int</name> <operator>-=</operator> <name>b_int</name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>a_int</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><ternary><condition><expr><name>neg</name></expr> ?</condition><then> <expr><operator>-</operator><operator>(</operator><operator>(</operator><name>ssize_t</name><operator>)</operator> <name>a_int</name><operator>)</operator></expr> </then><else>: <expr><operator>(</operator><name>ssize_t</name><operator>)</operator> <name>a_int</name></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name>ardx</name> <operator>=</operator> <call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>brdx</name> <operator>=</operator> <call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>a_max</name> <operator>=</operator> <operator>(</operator><name>ardx</name> <operator>&gt;</operator> <name>brdx</name><operator>)</operator></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>a_max</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>min</name> <operator>=</operator> <name>brdx</name></expr>;</expr_stmt>
<expr_stmt><expr><name>diff</name> <operator>=</operator> <name>ardx</name> <operator>-</operator> <name>brdx</name></expr>;</expr_stmt>
<expr_stmt><expr><name>max_num</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>num</name></name> <operator>+</operator> <name>diff</name></expr>;</expr_stmt>
<expr_stmt><expr><name>min_num</name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>num</name></name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>min</name> <operator>=</operator> <name>ardx</name></expr>;</expr_stmt>
<expr_stmt><expr><name>diff</name> <operator>=</operator> <name>brdx</name> <operator>-</operator> <name>ardx</name></expr>;</expr_stmt>
<expr_stmt><expr><name>max_num</name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>num</name></name> <operator>+</operator> <name>diff</name></expr>;</expr_stmt>
<expr_stmt><expr><name>min_num</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>num</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>bc_num_compare</name><argument_list>(<argument><expr><name>max_num</name></expr></argument>, <argument><expr><name>min_num</name></expr></argument>, <argument><expr><name>b_int</name> <operator>+</operator> <name>min</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>cmp</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>bc_num_neg</name><argument_list>(<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>cmp</name></expr></argument>, <argument><expr><operator>!</operator><name>a_max</name> <operator>==</operator> <operator>!</operator><name>neg</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>



<for>for <control>(<init><expr><name>max_num</name> <operator>-=</operator> <name>diff</name></expr><operator>,</operator> <expr><name>i</name> <operator>=</operator> <name>diff</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>diff</name></expr>;</condition> <incr><expr><operator>--</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>max_num</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>bc_num_neg</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>!</operator><name>a_max</name> <operator>==</operator> <operator>!</operator><name>neg</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>bc_num_truncate</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>places</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>nrdx</name></decl>, <decl><type ref="prev"/><name>places_rdx</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>places</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>



<expr_stmt><expr><name>nrdx</name> <operator>=</operator> <call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>places_rdx</name> <operator>=</operator> <ternary><condition><expr><name>nrdx</name></expr> ?</condition><then> <expr><name>nrdx</name> <operator>-</operator> <call><name>BC_NUM_RDX</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>scale</name></name> <operator>-</operator> <name>places</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>


<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>places</name> <operator>&lt;=</operator> <name><name>n</name><operator>-&gt;</operator><name>scale</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>BC_NUM_ZERO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>places_rdx</name> <operator>&lt;=</operator> <name><name>n</name><operator>-&gt;</operator><name>len</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>scale</name></name> <operator>-=</operator> <name>places</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BC_NUM_RDX_SET</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>nrdx</name> <operator>-</operator> <name>places_rdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_NUM_NONZERO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>pow</name></decl>;</decl_stmt>



<expr_stmt><expr><name>pow</name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>scale</name></name> <operator>%</operator> <name>BC_BASE_DIGS</name></expr>;</expr_stmt>
<expr_stmt><expr><name>pow</name> <operator>=</operator> <ternary><condition><expr><name>pow</name></expr> ?</condition><then> <expr><name>BC_BASE_DIGS</name> <operator>-</operator> <name>pow</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>pow</name> <operator>=</operator> <name><name>bc_num_pow10</name><index>[<expr><name>pow</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>len</name></name> <operator>-=</operator> <name>places_rdx</name></expr>;</expr_stmt>



<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>num</name></name> <operator>+</operator> <name>places_rdx</name></expr></argument>, <argument><expr><call><name>BC_NUM_SIZE</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_NUM_NONZERO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>num</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-=</operator> <name><name>n</name><operator>-&gt;</operator><name>num</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>%</operator> <operator>(</operator><name>BcDig</name><operator>)</operator> <name>pow</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>bc_num_clean</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>bc_num_extend</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>places</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>nrdx</name></decl>, <decl><type ref="prev"/><name>places_rdx</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>places</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_NUM_ZERO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>scale</name></name> <operator>+=</operator> <name>places</name></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>



<expr_stmt><expr><name>nrdx</name> <operator>=</operator> <call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>places_rdx</name> <operator>=</operator> <call><name>BC_NUM_RDX</name><argument_list>(<argument><expr><name>places</name> <operator>+</operator> <name><name>n</name><operator>-&gt;</operator><name>scale</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <name>nrdx</name></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name>places_rdx</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bc_num_expand</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><call><name>bc_vm_growSize</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name>places_rdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>num</name></name> <operator>+</operator> <name>places_rdx</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><call><name>BC_NUM_SIZE</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>BC_NUM_SIZE</name><argument_list>(<argument><expr><name>places_rdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>BC_NUM_RDX_SET</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>nrdx</name> <operator>+</operator> <name>places_rdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>scale</name></name> <operator>+=</operator> <name>places</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>len</name></name> <operator>+=</operator> <name>places_rdx</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>BC_NUM_RDX</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>scale</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_num_retireMul</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>scale</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>neg1</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>neg2</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>scale</name></name> <operator>&lt;</operator> <name>scale</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_num_extend</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>scale</name> <operator>-</operator> <name><name>n</name><operator>-&gt;</operator><name>scale</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_num_truncate</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>scale</name></name> <operator>-</operator> <name>scale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>bc_num_clean</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_NUM_NONZERO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>rdx</name></name> <operator>=</operator> <call><name>BC_NUM_NEG_VAL</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><operator>!</operator><name>neg1</name> <operator>!=</operator> <operator>!</operator><name>neg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_num_split</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>idx</name></decl></parameter>,
<parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_ZERO</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_ZERO</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&lt;</operator> <name><name>n</name><operator>-&gt;</operator><name>len</name></name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <name>idx</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>scale</name></name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>scale</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BC_NUM_RDX_SET</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BC_NUM_RDX_SET</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>cap</name></name> <operator>&gt;=</operator> <name><name>a</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>cap</name></name> <operator>&gt;=</operator> <name><name>b</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>num</name></name> <operator>+</operator> <name>idx</name></expr></argument>, <argument><expr><call><name>BC_NUM_SIZE</name><argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><call><name>BC_NUM_SIZE</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_num_clean</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>

<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_num_copy</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>bc_num_clean</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_num_shiftRdx</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>r</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>rdx</name> <init>= <expr><call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <name>rdx</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>cap</name></name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>cap</name></name> <operator>-</operator> <name>rdx</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>num</name></name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>num</name></name> <operator>+</operator> <name>rdx</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>BC_NUM_RDX_SET_NEG</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>BC_NUM_NEG</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>scale</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>size_t</name></type> <name>bc_num_shiftZero</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>



<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>BC_NUM_ZERO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>n</name><operator>-&gt;</operator><name>len</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>n</name><operator>-&gt;</operator><name>num</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>len</name></name> <operator>-=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>num</name></name> <operator>+=</operator> <name>i</name></expr>;</expr_stmt>

<return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_num_unshiftZero</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>places_rdx</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>len</name></name> <operator>+=</operator> <name>places_rdx</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>num</name></name> <operator>-=</operator> <name>places_rdx</name></expr>;</expr_stmt>
</block_content>}</block></function>









<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_num_shift</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>BcBigDig</name></type> <name>dig</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name> <init>= <expr><name><name>n</name><operator>-&gt;</operator><name>len</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcBigDig</name></type> <name>carry</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>pow</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcDig</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name><name>n</name><operator>-&gt;</operator><name>num</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dig</name> <operator>&lt;</operator> <name>BC_BASE_DIGS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>pow</name> <operator>=</operator> <name><name>bc_num_pow10</name><index>[<expr><name>dig</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>dig</name> <operator>=</operator> <name><name>bc_num_pow10</name><index>[<expr><name>BC_BASE_DIGS</name> <operator>-</operator> <name>dig</name></expr>]</index></name></expr>;</expr_stmt>



<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><operator>--</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>BcBigDig</name></type> <name>in</name></decl>, <decl><type ref="prev"/><name>temp</name></decl>;</decl_stmt>
<expr_stmt><expr><name>in</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>BcBigDig</name><operator>)</operator> <name><name>ptr</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>temp</name> <operator>=</operator> <name>carry</name> <operator>*</operator> <name>dig</name></expr>;</expr_stmt>
<expr_stmt><expr><name>carry</name> <operator>=</operator> <name>in</name> <operator>%</operator> <name>pow</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ptr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>BcDig</name><operator>)</operator> <operator>(</operator><name>in</name> <operator>/</operator> <name>pow</name><operator>)</operator><operator>)</operator> <operator>+</operator> <operator>(</operator><name>BcDig</name><operator>)</operator> <name>temp</name></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name>carry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_num_shiftLeft</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>places</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>BcBigDig</name></type> <name>dig</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>places_rdx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>shift</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>places</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>places</name> <operator>&gt;</operator> <name><name>n</name><operator>-&gt;</operator><name>scale</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><call><name>bc_vm_growSize</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX</name><argument_list>(<argument><expr><name>places</name> <operator>-</operator> <name><name>n</name><operator>-&gt;</operator><name>scale</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&gt;</operator> <name>SIZE_MAX</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_err</name><argument_list>(<argument><expr><name>BC_ERR_MATH_OVERFLOW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_NUM_ZERO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>scale</name></name> <operator>&gt;=</operator> <name>places</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>scale</name></name> <operator>-=</operator> <name>places</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>scale</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>






<expr_stmt><expr><name>dig</name> <operator>=</operator> <operator>(</operator><name>BcBigDig</name><operator>)</operator> <operator>(</operator><name>places</name> <operator>%</operator> <name>BC_BASE_DIGS</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>shift</name> <operator>=</operator> <operator>(</operator><name>dig</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>


<expr_stmt><expr><name>places_rdx</name> <operator>=</operator> <call><name>BC_NUM_RDX</name><argument_list>(<argument><expr><name>places</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>scale</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>nrdx</name> <init>= <expr><call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name>nrdx</name> <operator>&gt;=</operator> <name>places_rdx</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>mod</name> <init>= <expr><name><name>n</name><operator>-&gt;</operator><name>scale</name></name> <operator>%</operator> <name>BC_BASE_DIGS</name></expr></init></decl>, <decl><type ref="prev"/><name>revdig</name></decl>;</decl_stmt>



<expr_stmt><expr><name>mod</name> <operator>=</operator> <ternary><condition><expr><name>mod</name></expr> ?</condition><then> <expr><name>mod</name></expr> </then><else>: <expr><name>BC_BASE_DIGS</name></expr></else></ternary></expr>;</expr_stmt>


<expr_stmt><expr><name>revdig</name> <operator>=</operator> <ternary><condition><expr><name>dig</name></expr> ?</condition><then> <expr><name>BC_BASE_DIGS</name> <operator>-</operator> <name>dig</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>mod</name> <operator>+</operator> <name>revdig</name> <operator>&gt;</operator> <name>BC_BASE_DIGS</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>places_rdx</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>places_rdx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>places_rdx</name> <operator>-=</operator> <name>nrdx</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>places_rdx</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bc_num_expand</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><call><name>bc_vm_growSize</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name>places_rdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>num</name></name> <operator>+</operator> <name>places_rdx</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><call><name>BC_NUM_SIZE</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>BC_NUM_SIZE</name><argument_list>(<argument><expr><name>places_rdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>len</name></name> <operator>+=</operator> <name>places_rdx</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>places</name> <operator>&gt;</operator> <name><name>n</name><operator>-&gt;</operator><name>scale</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>scale</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BC_NUM_RDX_SET</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>scale</name></name> <operator>-=</operator> <name>places</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BC_NUM_RDX_SET</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><call><name>BC_NUM_RDX</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>scale</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><name>shift</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_num_shift</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>BC_BASE_DIGS</name> <operator>-</operator> <name>dig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>bc_num_clean</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>bc_num_shiftRight</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>places</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>BcBigDig</name></type> <name>dig</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>places_rdx</name></decl>, <decl><type ref="prev"/><name>scale</name></decl>, <decl><type ref="prev"/><name>scale_mod</name></decl>, <decl><type ref="prev"/><name>int_len</name></decl>, <decl><type ref="prev"/><name>expand</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>shift</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>places</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_NUM_ZERO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>scale</name></name> <operator>+=</operator> <name>places</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_expand</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><call><name>BC_NUM_RDX</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>scale</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>dig</name> <operator>=</operator> <operator>(</operator><name>BcBigDig</name><operator>)</operator> <operator>(</operator><name>places</name> <operator>%</operator> <name>BC_BASE_DIGS</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>shift</name> <operator>=</operator> <operator>(</operator><name>dig</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>scale</name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>scale</name></name></expr>;</expr_stmt>


<expr_stmt><expr><name>scale_mod</name> <operator>=</operator> <name>scale</name> <operator>%</operator> <name>BC_BASE_DIGS</name></expr>;</expr_stmt>
<expr_stmt><expr><name>scale_mod</name> <operator>=</operator> <ternary><condition><expr><name>scale_mod</name></expr> ?</condition><then> <expr><name>scale_mod</name></expr> </then><else>: <expr><name>BC_BASE_DIGS</name></expr></else></ternary></expr>;</expr_stmt>


<expr_stmt><expr><name>int_len</name> <operator>=</operator> <call><name>bc_num_int</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>places_rdx</name> <operator>=</operator> <call><name>BC_NUM_RDX</name><argument_list>(<argument><expr><name>places</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>scale_mod</name> <operator>+</operator> <name>dig</name> <operator>&gt;</operator> <name>BC_BASE_DIGS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>expand</name> <operator>=</operator> <name>places_rdx</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>places_rdx</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>expand</name> <operator>=</operator> <name>places_rdx</name></expr>;</expr_stmt>
<expr_stmt><expr><name>places_rdx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><name>expand</name> <operator>&gt;</operator> <name>int_len</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>expand</name> <operator>-=</operator> <name>int_len</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>expand</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>


<expr_stmt><expr><call><name>bc_num_extend</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>places_rdx</name> <operator>*</operator> <name>BC_BASE_DIGS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_expand</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><call><name>bc_vm_growSize</name><argument_list>(<argument><expr><name>expand</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>num</name></name> <operator>+</operator> <name><name>n</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>BC_NUM_SIZE</name><argument_list>(<argument><expr><name>expand</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>len</name></name> <operator>+=</operator> <name>expand</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>scale</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BC_NUM_RDX_SET</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>shift</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_num_shift</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>dig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>scale</name></name> <operator>=</operator> <name>scale</name> <operator>+</operator> <name>places</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BC_NUM_RDX_SET</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><call><name>BC_NUM_RDX</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>scale</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_num_clean</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name><name>n</name><operator>-&gt;</operator><name>len</name></name> <operator>&amp;&amp;</operator> <name><name>n</name><operator>-&gt;</operator><name>len</name></name> <operator>&lt;=</operator> <name><name>n</name><operator>-&gt;</operator><name>cap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>BC_NUM_RDX</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>scale</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>bc_num_inv</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>scale</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_NONZERO</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_div</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>one</name></name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>scale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>










<function><type><specifier>static</specifier> <name>bool</name></type> <name>bc_num_nonInt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>r</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>bool</name></type> <name>zero</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>rdx</name> <init>= <expr><call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rdx</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BcNum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>zero</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>zero</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name>rdx</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name>zero</name> <operator>=</operator> <operator>(</operator><name><name>n</name><operator>-&gt;</operator><name>num</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><operator>!</operator><name>zero</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>bc_num_shiftRdx</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLE_EXTRA_MATH</name></expr></cpp:if>









<function><type><specifier>static</specifier> <name>BcBigDig</name></type> <name>bc_num_intop</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BcNum</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BcNum</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>BcNum</name></type> <name>temp</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><call><name>bc_num_nonInt</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>temp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_err</name><argument_list>(<argument><expr><name>BC_ERR_MATH_NON_INTEGER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>bc_num_copy</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>bc_num_bigdig</name><argument_list>(<argument><expr><operator>&amp;</operator><name>temp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>











<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_num_as</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>sub</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>BcDig</name> <modifier>*</modifier></type><name>ptr_c</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ptr_l</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ptr_r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>min_rdx</name></decl>, <decl><type ref="prev"/><name>max_rdx</name></decl>, <decl><type ref="prev"/><name>diff</name></decl>, <decl><type ref="prev"/><name>a_int</name></decl>, <decl><type ref="prev"/><name>b_int</name></decl>, <decl><type ref="prev"/><name>min_len</name></decl>, <decl><type ref="prev"/><name>max_len</name></decl>, <decl><type ref="prev"/><name>max_int</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len_l</name></decl>, <decl><type ref="prev"/><name>len_r</name></decl>, <decl><type ref="prev"/><name>ardx</name></decl>, <decl><type ref="prev"/><name>brdx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>b_neg</name></decl>, <decl><type ref="prev"/><name>do_sub</name></decl>, <decl><type ref="prev"/><name>do_rev_sub</name></decl>, <decl><type ref="prev"/><name>carry</name></decl>, <decl><type ref="prev"/><name>c_neg</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BC_NUM_ZERO</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bc_num_copy</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BC_NUM_ZERO</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bc_num_copy</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>rdx</name></name> <operator>=</operator> <call><name>BC_NUM_NEG_VAL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>BC_NUM_NEG</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>sub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>



<expr_stmt><expr><name>b_neg</name> <operator>=</operator> <operator>(</operator><call><name>BC_NUM_NEG</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>sub</name><operator>)</operator></expr>;</expr_stmt>



<expr_stmt><expr><name>do_sub</name> <operator>=</operator> <operator>(</operator><call><name>BC_NUM_NEG</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>b_neg</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>a_int</name> <operator>=</operator> <call><name>bc_num_int</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b_int</name> <operator>=</operator> <call><name>bc_num_int</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>max_int</name> <operator>=</operator> <call><name>BC_MAX</name><argument_list>(<argument><expr><name>a_int</name></expr></argument>, <argument><expr><name>b_int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>ardx</name> <operator>=</operator> <call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>brdx</name> <operator>=</operator> <call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>min_rdx</name> <operator>=</operator> <call><name>BC_MIN</name><argument_list>(<argument><expr><name>ardx</name></expr></argument>, <argument><expr><name>brdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>max_rdx</name> <operator>=</operator> <call><name>BC_MAX</name><argument_list>(<argument><expr><name>ardx</name></expr></argument>, <argument><expr><name>brdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>diff</name> <operator>=</operator> <name>max_rdx</name> <operator>-</operator> <name>min_rdx</name></expr>;</expr_stmt>

<expr_stmt><expr><name>max_len</name> <operator>=</operator> <name>max_int</name> <operator>+</operator> <name>max_rdx</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>do_sub</name></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><name>a_int</name> <operator>!=</operator> <name>b_int</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>do_rev_sub</name> <operator>=</operator> <operator>(</operator><name>a_int</name> <operator>&lt;</operator> <name>b_int</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>ardx</name> <operator>&gt;</operator> <name>brdx</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>do_rev_sub</name> <operator>=</operator> <operator>(</operator><call><name>bc_num_compare</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>num</name></name> <operator>+</operator> <name>diff</name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>do_rev_sub</name> <operator>=</operator> <operator>(</operator><call><name>bc_num_compare</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>num</name></name> <operator>+</operator> <name>diff</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>



<expr_stmt><expr><name>max_len</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>do_rev_sub</name> <operator>=</operator> <operator>(</operator><name>a_int</name> <operator>&lt;</operator> <name>b_int</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>max_len</name> <operator>&lt;=</operator> <name><name>c</name><operator>-&gt;</operator><name>cap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>do_rev_sub</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ptr_l</name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>num</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>ptr_r</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>num</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>len_l</name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>len_r</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>ptr_l</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>num</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>ptr_r</name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>num</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>len_l</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>len_r</name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>ptr_c</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>num</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>carry</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name>diff</name></expr>)</condition> <block>{<block_content>




<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ardx</name> <operator>&gt;</operator> <name>brdx</name><operator>)</operator> <operator>!=</operator> <name>do_rev_sub</name></expr>)</condition> <block>{<block_content>




<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr_c</name></expr></argument>, <argument><expr><name>ptr_l</name></expr></argument>, <argument><expr><call><name>BC_NUM_SIZE</name><argument_list>(<argument><expr><name>diff</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ptr_l</name> <operator>+=</operator> <name>diff</name></expr>;</expr_stmt>
<expr_stmt><expr><name>len_l</name> <operator>-=</operator> <name>diff</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>



<if_stmt><if>if <condition>(<expr><name>do_sub</name></expr>)</condition> <block>{<block_content>



<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>diff</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ptr_c</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>bc_num_subDigits</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>ptr_r</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>carry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></if>
<else>else <block>{<block_content>


<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr_c</name></expr></argument>, <argument><expr><name>ptr_r</name></expr></argument>, <argument><expr><call><name>BC_NUM_SIZE</name><argument_list>(<argument><expr><name>diff</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<expr_stmt><expr><name>ptr_r</name> <operator>+=</operator> <name>diff</name></expr>;</expr_stmt>
<expr_stmt><expr><name>len_r</name> <operator>-=</operator> <name>diff</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<expr_stmt><expr><name>ptr_c</name> <operator>+=</operator> <name>diff</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>min_len</name> <operator>=</operator> <call><name>BC_MIN</name><argument_list>(<argument><expr><name>len_l</name></expr></argument>, <argument><expr><name>len_r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>








<if_stmt><if>if <condition>(<expr><name>do_sub</name></expr>)</condition> <block>{<block_content>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>min_len</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ptr_c</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>bc_num_subDigits</name><argument_list>(<argument><expr><name><name>ptr_l</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>ptr_r</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>carry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>


<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len_l</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>ptr_c</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>bc_num_subDigits</name><argument_list>(<argument><expr><name><name>ptr_l</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>carry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></if>
<else>else <block>{<block_content>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>min_len</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ptr_c</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>bc_num_addDigits</name><argument_list>(<argument><expr><name><name>ptr_l</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>ptr_r</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>carry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>


<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len_l</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>ptr_c</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>bc_num_addDigits</name><argument_list>(<argument><expr><name><name>ptr_l</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>carry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>


<expr_stmt><expr><name><name>ptr_c</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>bc_num_addDigits</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>carry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>carry</name> <operator>==</operator> <name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>c_neg</name> <operator>=</operator> <call><name>BC_NUM_NEG</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>(</operator><name>do_sub</name> <operator>&amp;&amp;</operator> <name>do_rev_sub</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BC_NUM_RDX_SET_NEG</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>max_rdx</name></expr></argument>, <argument><expr><name>c_neg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>max_len</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>scale</name></name> <operator>=</operator> <call><name>BC_MAX</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>scale</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>scale</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_num_clean</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>









<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_num_m_simp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BcNum</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BcNum</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>alen</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>len</name></name></expr></init></decl>, <decl><type ref="prev"/><name>blen</name> <init>= <expr><name><name>b</name><operator>-&gt;</operator><name>len</name></name></expr></init></decl>, <decl><type ref="prev"/><name>clen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcDig</name> <modifier>*</modifier></type><name>ptr_a</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>num</name></name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ptr_b</name> <init>= <expr><name><name>b</name><operator>-&gt;</operator><name>num</name></name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ptr_c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcBigDig</name></type> <name>sum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>carry</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sum</name></expr></argument>)</argument_list></sizeof> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BcDig</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>clen</name> <operator>=</operator> <call><name>bc_vm_growSize</name><argument_list>(<argument><expr><name>alen</name></expr></argument>, <argument><expr><name>blen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_expand</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>bc_vm_growSize</name><argument_list>(<argument><expr><name>clen</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>ptr_c</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>num</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>ptr_c</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>BC_NUM_SIZE</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>cap</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>clen</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>ssize_t</name></type> <name>sidx</name> <init>= <expr><operator>(</operator><name>ssize_t</name><operator>)</operator> <operator>(</operator><name>i</name> <operator>-</operator> <name>blen</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>


<expr_stmt><expr><name>j</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <call><name>BC_MAX</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>sidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>BC_MIN</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>blen</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<for>for <control>(<init>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>alen</name> <operator>&amp;&amp;</operator> <name>k</name> <operator>&lt;</operator> <name>blen</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr><operator>,</operator> <expr><operator>--</operator><name>k</name></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>sum</name> <operator>+=</operator> <operator>(</operator><operator>(</operator><name>BcBigDig</name><operator>)</operator> <name><name>ptr_a</name><index>[<expr><name>j</name></expr>]</index></name><operator>)</operator> <operator>*</operator> <operator>(</operator><operator>(</operator><name>BcBigDig</name><operator>)</operator> <name><name>ptr_b</name><index>[<expr><name>k</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>sum</name> <operator>&gt;=</operator> <operator>(</operator><operator>(</operator><name>BcBigDig</name><operator>)</operator> <name>BC_BASE_POW</name><operator>)</operator> <operator>*</operator> <name>BC_BASE_POW</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>carry</name> <operator>+=</operator> <name>sum</name> <operator>/</operator> <name>BC_BASE_POW</name></expr>;</expr_stmt>
<expr_stmt><expr><name>sum</name> <operator>%=</operator> <name>BC_BASE_POW</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>


<if_stmt><if>if <condition>(<expr><name>sum</name> <operator>&gt;=</operator> <name>BC_BASE_POW</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>carry</name> <operator>+=</operator> <name>sum</name> <operator>/</operator> <name>BC_BASE_POW</name></expr>;</expr_stmt>
<expr_stmt><expr><name>sum</name> <operator>%=</operator> <name>BC_BASE_POW</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name><name>ptr_c</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>BcDig</name><operator>)</operator> <name>sum</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ptr_c</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <name>BC_BASE_POW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sum</name> <operator>=</operator> <name>carry</name></expr>;</expr_stmt>
<expr_stmt><expr><name>carry</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></for>



<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name>sum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>clen</name></expr>;</expr_stmt>
</block_content>}</block></function>










<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_num_shiftAddSub</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>n</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>a</name></decl></parameter>,
<parameter><decl><type><name>size_t</name></type> <name>shift</name></decl></parameter>, <parameter><decl><type><name>BcNumShiftAddOp</name></type> <name>op</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;=</operator> <name>shift</name> <operator>+</operator> <name><name>a</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>op</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>num</name></name> <operator>+</operator> <name>shift</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_num_k</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BcNum</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BcNum</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>max</name></decl>, <decl><type ref="prev"/><name>max2</name></decl>, <decl><type ref="prev"/><name>total</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcNum</name></type> <name>l1</name></decl>, <decl><type ref="prev"/><name>h1</name></decl>, <decl><type ref="prev"/><name>l2</name></decl>, <decl><type ref="prev"/><name>h2</name></decl>, <decl><type ref="prev"/><name>m2</name></decl>, <decl><type ref="prev"/><name>m1</name></decl>, <decl><type ref="prev"/><name>z0</name></decl>, <decl><type ref="prev"/><name>z1</name></decl>, <decl><type ref="prev"/><name>z2</name></decl>, <decl><type ref="prev"/><name>temp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcDig</name> <modifier>*</modifier></type><name>digs</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>dig_ptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcNumShiftAddOp</name></type> <name>op</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>aone</name> <init>= <expr><call><name>BC_NUM_ONE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_ZERO</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BC_NUM_ZERO</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>BC_NUM_ZERO</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>aone</name> <operator>||</operator> <call><name>BC_NUM_ONE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bc_num_copy</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><ternary><condition><expr><name>aone</name></expr> ?</condition><then> <expr><name>b</name></expr> </then><else>: <expr><name>a</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>aone</name> <operator>&amp;&amp;</operator> <call><name>BC_NUM_NEG</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator> <call><name>BC_NUM_NEG</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>BC_NUM_NEG_TGL</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>len</name></name> <operator>&lt;</operator> <name>BC_NUM_KARATSUBA_LEN</name> <operator>||</operator> <name><name>b</name><operator>-&gt;</operator><name>len</name></name> <operator>&lt;</operator> <name>BC_NUM_KARATSUBA_LEN</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bc_num_m_simp</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>



<expr_stmt><expr><name>max</name> <operator>=</operator> <call><name>BC_MAX</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>max</name> <operator>=</operator> <call><name>BC_MAX</name><argument_list>(<argument><expr><name>max</name></expr></argument>, <argument><expr><name>BC_NUM_DEF_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>max2</name> <operator>=</operator> <operator>(</operator><name>max</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>



<expr_stmt><expr><name>total</name> <operator>=</operator> <call><name>bc_vm_arraySize</name><argument_list>(<argument><expr><name>BC_NUM_KARATSUBA_ALLOCS</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>


<expr_stmt><expr><name>digs</name> <operator>=</operator> <name>dig_ptr</name> <operator>=</operator> <call><name>bc_vm_malloc</name><argument_list>(<argument><expr><call><name>BC_NUM_SIZE</name><argument_list>(<argument><expr><name>total</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_num_setup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>l1</name></expr></argument>, <argument><expr><name>dig_ptr</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dig_ptr</name> <operator>+=</operator> <name>max</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_setup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>h1</name></expr></argument>, <argument><expr><name>dig_ptr</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dig_ptr</name> <operator>+=</operator> <name>max</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_setup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>l2</name></expr></argument>, <argument><expr><name>dig_ptr</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dig_ptr</name> <operator>+=</operator> <name>max</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_setup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>h2</name></expr></argument>, <argument><expr><name>dig_ptr</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dig_ptr</name> <operator>+=</operator> <name>max</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_setup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>m1</name></expr></argument>, <argument><expr><name>dig_ptr</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dig_ptr</name> <operator>+=</operator> <name>max</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_setup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>m2</name></expr></argument>, <argument><expr><name>dig_ptr</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>max</name> <operator>=</operator> <call><name>bc_vm_growSize</name><argument_list>(<argument><expr><name>max</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z0</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z1</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z2</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>max</name> <operator>=</operator> <call><name>bc_vm_growSize</name><argument_list>(<argument><expr><name>max</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>temp</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>BC_SETJMP_LOCKED</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_num_expand</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>max</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>BC_NUM_SIZE</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_num_split</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>max2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>l1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>h1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_split</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>max2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>l2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>h2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_num_sub</name><argument_list>(<argument><expr><operator>&amp;</operator><name>h1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>l1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>m1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_sub</name><argument_list>(<argument><expr><operator>&amp;</operator><name>l2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>h2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>m2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>






<if_stmt><if>if <condition>(<expr><call><name>BC_NUM_NONZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>h1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>BC_NUM_NONZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>h2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID_NP</name><argument_list>(<argument><expr><name>h1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID_NP</name><argument_list>(<argument><expr><name>h2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_num_m</name><argument_list>(<argument><expr><operator>&amp;</operator><name>h1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>h2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>z2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_clean</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_num_shiftAddSub</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>z2</name></expr></argument>, <argument><expr><name>max2</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>bc_num_addArrays</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_shiftAddSub</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>z2</name></expr></argument>, <argument><expr><name>max2</name></expr></argument>, <argument><expr><name>bc_num_addArrays</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BC_NUM_NONZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>l1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>BC_NUM_NONZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>l2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID_NP</name><argument_list>(<argument><expr><name>l1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID_NP</name><argument_list>(<argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_num_m</name><argument_list>(<argument><expr><operator>&amp;</operator><name>l1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>l2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>z0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_clean</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_num_shiftAddSub</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>z0</name></expr></argument>, <argument><expr><name>max2</name></expr></argument>, <argument><expr><name>bc_num_addArrays</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_shiftAddSub</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>z0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>bc_num_addArrays</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BC_NUM_NONZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>m1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>BC_NUM_NONZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>m2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID_NP</name><argument_list>(<argument><expr><name>m1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID_NP</name><argument_list>(<argument><expr><name>m1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_num_m</name><argument_list>(<argument><expr><operator>&amp;</operator><name>m1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>m2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>z1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_clean</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>op</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><call><name>BC_NUM_NEG_NP</name><argument_list>(<argument><expr><name>m1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>BC_NUM_NEG_NP</name><argument_list>(<argument><expr><name>m2</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then>
<expr><name>bc_num_subArrays</name></expr> </then><else>: <expr><name>bc_num_addArrays</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_shiftAddSub</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>z1</name></expr></argument>, <argument><expr><name>max2</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<label><name>err</name>:</label>
<expr_stmt><expr><name>BC_SIG_MAYLOCK</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>digs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>BC_LONGJMP_CONT</name></expr>;</expr_stmt>
</block_content>}</block></function>










<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_num_m</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>scale</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>BcNum</name></type> <name>cpa</name></decl>, <decl><type ref="prev"/><name>cpb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>ascale</name></decl>, <decl><type ref="prev"/><name>bscale</name></decl>, <decl><type ref="prev"/><name>ardx</name></decl>, <decl><type ref="prev"/><name>brdx</name></decl>, <decl><type ref="prev"/><name>azero</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>bzero</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>zero</name></decl>, <decl><type ref="prev"/><name>len</name></decl>, <decl><type ref="prev"/><name>rscale</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_num_zero</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ascale</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>scale</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>bscale</name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>scale</name></name></expr>;</expr_stmt>


<expr_stmt><expr><name>scale</name> <operator>=</operator> <call><name>BC_MAX</name><argument_list>(<argument><expr><name>scale</name></expr></argument>, <argument><expr><name>ascale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>scale</name> <operator>=</operator> <call><name>BC_MAX</name><argument_list>(<argument><expr><name>scale</name></expr></argument>, <argument><expr><name>bscale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rscale</name> <operator>=</operator> <name>ascale</name> <operator>+</operator> <name>bscale</name></expr>;</expr_stmt>
<expr_stmt><expr><name>scale</name> <operator>=</operator> <call><name>BC_MIN</name><argument_list>(<argument><expr><name>rscale</name></expr></argument>, <argument><expr><name>scale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>b</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>a</name><operator>-&gt;</operator><name>rdx</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>b</name><operator>-&gt;</operator><name>rdx</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>operand</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcBigDig</name></type> <name>dig</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>dig</name> <operator>=</operator> <operator>(</operator><name>BcBigDig</name><operator>)</operator> <name><name>a</name><operator>-&gt;</operator><name>num</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>operand</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>dig</name> <operator>=</operator> <operator>(</operator><name>BcBigDig</name><operator>)</operator> <name><name>b</name><operator>-&gt;</operator><name>num</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>operand</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>bc_num_mulArray</name><argument_list>(<argument><expr><name>operand</name></expr></argument>, <argument><expr><name>dig</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_NUM_NONZERO</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>rdx</name></name> <operator>=</operator> <call><name>BC_NUM_NEG_VAL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>BC_NUM_NEG</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>BC_NUM_NEG</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>



<expr_stmt><expr><call><name>bc_num_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cpa</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>len</name></name> <operator>+</operator> <call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cpb</name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>len</name></name> <operator>+</operator> <call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>BC_SETJMP_LOCKED</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_num_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cpa</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cpb</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID_NP</name><argument_list>(<argument><expr><name>cpa</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID_NP</name><argument_list>(<argument><expr><name>cpb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>BC_NUM_NEG_CLR_NP</name><argument_list>(<argument><expr><name>cpa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BC_NUM_NEG_CLR_NP</name><argument_list>(<argument><expr><name>cpb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID_NP</name><argument_list>(<argument><expr><name>cpa</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID_NP</name><argument_list>(<argument><expr><name>cpb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>ardx</name> <operator>=</operator> <call><name>BC_NUM_RDX_VAL_NP</name><argument_list>(<argument><expr><name>cpa</name></expr></argument>)</argument_list></call> <operator>*</operator> <name>BC_BASE_DIGS</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_shiftLeft</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cpa</name></expr></argument>, <argument><expr><name>ardx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>brdx</name> <operator>=</operator> <call><name>BC_NUM_RDX_VAL_NP</name><argument_list>(<argument><expr><name>cpb</name></expr></argument>)</argument_list></call> <operator>*</operator> <name>BC_BASE_DIGS</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_shiftLeft</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cpb</name></expr></argument>, <argument><expr><name>brdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_UNSETJMP</name></expr>;</expr_stmt>


<expr_stmt><expr><name>azero</name> <operator>=</operator> <call><name>bc_num_shiftZero</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cpa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bzero</name> <operator>=</operator> <call><name>bc_num_shiftZero</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cpb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>BC_SETJMP_LOCKED</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_num_clean</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cpa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_clean</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cpb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_num_k</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cpa</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cpb</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><name>zero</name> <operator>=</operator> <call><name>bc_vm_growSize</name><argument_list>(<argument><expr><name>azero</name></expr></argument>, <argument><expr><name>bzero</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>bc_vm_growSize</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name>zero</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_num_expand</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_num_shiftLeft</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><operator>(</operator><name>len</name> <operator>-</operator> <name><name>c</name><operator>-&gt;</operator><name>len</name></name><operator>)</operator> <operator>*</operator> <name>BC_BASE_DIGS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_shiftRight</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ardx</name> <operator>+</operator> <name>brdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_num_retireMul</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>scale</name></expr></argument>, <argument><expr><call><name>BC_NUM_NEG</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>BC_NUM_NEG</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>err</name>:</label>
<expr_stmt><expr><name>BC_SIG_MAYLOCK</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_unshiftZero</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cpb</name></expr></argument>, <argument><expr><name>bzero</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cpb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_unshiftZero</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cpa</name></expr></argument>, <argument><expr><name>azero</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cpa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>BC_LONGJMP_CONT</name></expr>;</expr_stmt>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>bool</name></type> <name>bc_num_nonZeroDig</name><parameter_list>(<parameter><decl><type><name>BcDig</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>nonzero</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><operator>!</operator><name>nonzero</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><operator>--</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name>nonzero</name> <operator>=</operator> <operator>(</operator><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></for>
<return>return <expr><name>nonzero</name></expr>;</return>
</block_content>}</block></function>










<function><type><specifier>static</specifier> <name>ssize_t</name></type> <name>bc_num_divCmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BcDig</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BcNum</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>ssize_t</name></type> <name>cmp</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <name>len</name> <operator>&amp;&amp;</operator> <name><name>a</name><index>[<expr><name>len</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>bc_num_compare</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>len</name></name> <operator>&lt;=</operator> <name>len</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>a</name><index>[<expr><name>len</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cmp</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>bc_num_compare</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>cmp</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return <expr><name>cmp</name></expr>;</return>
</block_content>}</block></function>









<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_num_divExtend</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>b</name></decl></parameter>,
<parameter><decl><type><name>BcBigDig</name></type> <name>divisor</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>pow</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>divisor</name> <operator>&lt;</operator> <name>BC_BASE_POW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>pow</name> <operator>=</operator> <name>BC_BASE_DIGS</name> <operator>-</operator> <call><name>bc_num_log10</name><argument_list>(<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>divisor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_num_shiftLeft</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>pow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_shiftLeft</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>pow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>









<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_num_d_long</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>b</name></decl></parameter>,
<parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>scale</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>BcBigDig</name></type> <name>divisor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>end</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>rdx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcNum</name></type> <name>cpb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>nonzero</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>len</name></name> <operator>&lt;</operator> <name><name>a</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>len</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><call><name>bc_num_expand</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>cap</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BcDig</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>BC_NUM_RDX_SET</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>scale</name></name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>scale</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>



<expr_stmt><expr><name>divisor</name> <operator>=</operator> <operator>(</operator><name>BcBigDig</name><operator>)</operator> <name><name>b</name><operator>-&gt;</operator><name>num</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>bc_num_nonZeroDig</name><argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>







<expr_stmt><expr><name>nonzero</name> <operator>=</operator> <operator>(</operator><name>divisor</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><operator>(</operator><literal type="number">10</literal> <operator>*</operator> <name>BC_BASE_DIGS</name><operator>)</operator> <operator>/</operator> <literal type="number">6</literal> <operator>+</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nonzero</name></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><call><name>bc_num_divExtend</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>divisor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>BC_MAX</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_expand</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>len</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;</operator> <name><name>a</name><operator>-&gt;</operator><name>len</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>len</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>



<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name>divisor</name> <operator>=</operator> <operator>(</operator><name>BcBigDig</name><operator>)</operator> <name><name>b</name><operator>-&gt;</operator><name>num</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>nonzero</name> <operator>=</operator> <call><name>bc_num_nonZeroDig</name><argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>



<expr_stmt><expr><name>divisor</name> <operator>+=</operator> <name>nonzero</name></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_num_expand</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>BC_NUM_SIZE</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>cap</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>scale</name></name> <operator>&gt;=</operator> <name>scale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rdx</name> <operator>=</operator> <call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>BC_NUM_RDX</name><argument_list>(<argument><expr><name>scale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_num_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cpb</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>BC_SETJMP_LOCKED</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>end</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>end</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&gt;=</operator> <name>rdx</name> <operator>&amp;&amp;</operator> <call><name>BC_NUM_NONZERO</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><operator>--</operator><name>i</name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>ssize_t</name></type> <name>cmp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcDig</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcBigDig</name></type> <name>result</name></decl>;</decl_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>num</name></name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> <operator>&gt;=</operator> <name><name>a</name><operator>-&gt;</operator><name>num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>bc_num_divCmp</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<while>while <condition>(<expr><name>cmp</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>BcBigDig</name></type> <name>n1</name></decl>, <decl><type ref="prev"/><name>dividend</name></decl>, <decl><type ref="prev"/><name>quotient</name></decl>;</decl_stmt>



<expr_stmt><expr><name>n1</name> <operator>=</operator> <operator>(</operator><name>BcBigDig</name><operator>)</operator> <name><name>n</name><index>[<expr><name>len</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>dividend</name> <operator>=</operator> <name>n1</name> <operator>*</operator> <name>BC_BASE_POW</name> <operator>+</operator> <operator>(</operator><name>BcBigDig</name><operator>)</operator> <name><name>n</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>quotient</name> <operator>=</operator> <operator>(</operator><name>dividend</name> <operator>/</operator> <name>divisor</name><operator>)</operator></expr>;</expr_stmt>




<if_stmt><if>if <condition>(<expr><name>quotient</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>quotient</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_subArrays</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>quotient</name> <operator>&lt;=</operator> <name>BC_BASE_POW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_num_mulArray</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><operator>(</operator><name>BcBigDig</name><operator>)</operator> <name>quotient</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cpb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_subArrays</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name><name>cpb</name><operator>.</operator><name>num</name></name></expr></argument>, <argument><expr><name><name>cpb</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>



<expr_stmt><expr><name>result</name> <operator>+=</operator> <name>quotient</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>result</name> <operator>&lt;=</operator> <name>BC_BASE_POW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<if_stmt><if>if <condition>(<expr><name>nonzero</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>bc_num_divCmp</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>cmp</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></while>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>result</name> <operator>&lt;</operator> <name>BC_BASE_POW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>num</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>BcDig</name><operator>)</operator> <name>result</name></expr>;</expr_stmt>
</block_content>}</block></for>

<label><name>err</name>:</label>
<expr_stmt><expr><name>BC_SIG_MAYLOCK</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cpb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>BC_LONGJMP_CONT</name></expr>;</expr_stmt>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_num_d</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>scale</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>cpardx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcNum</name></type> <name>cpa</name></decl>, <decl><type ref="prev"/><name>cpb</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BC_NUM_ZERO</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_err</name><argument_list>(<argument><expr><name>BC_ERR_MATH_DIVIDE_BY_ZERO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BC_NUM_ZERO</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bc_num_setToZero</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>scale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BC_NUM_ONE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bc_num_copy</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_retireMul</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>scale</name></expr></argument>, <argument><expr><call><name>BC_NUM_NEG</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>BC_NUM_NEG</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>b</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>scale</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>BcBigDig</name></type> <name>rem</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>bc_num_divArray</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><operator>(</operator><name>BcBigDig</name><operator>)</operator> <name><name>b</name><operator>-&gt;</operator><name>num</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_retireMul</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>scale</name></expr></argument>, <argument><expr><call><name>BC_NUM_NEG</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>BC_NUM_NEG</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>bc_num_divReq</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>scale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>




<expr_stmt><expr><call><name>bc_num_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cpa</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cpa</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_createCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cpb</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>BC_SETJMP_LOCKED</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name><name>cpa</name><operator>.</operator><name>len</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bc_num_expand</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cpa</name></expr></argument>, <argument><expr><call><name>bc_vm_growSize</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_extend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cpa</name></expr></argument>, <argument><expr><operator>(</operator><name>len</name> <operator>-</operator> <name><name>cpa</name><operator>.</operator><name>len</name></name><operator>)</operator> <operator>*</operator> <name>BC_BASE_DIGS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>cpardx</name> <operator>=</operator> <call><name>BC_NUM_RDX_VAL_NP</name><argument_list>(<argument><expr><name>cpa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cpa</name><operator>.</operator><name>scale</name></name> <operator>=</operator> <name>cpardx</name> <operator>*</operator> <name>BC_BASE_DIGS</name></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_num_extend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cpa</name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>scale</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cpardx</name> <operator>=</operator> <call><name>BC_NUM_RDX_VAL_NP</name><argument_list>(<argument><expr><name>cpa</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>BC_NUM_RDX</name><argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>scale</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BC_NUM_RDX_SET_NP</name><argument_list>(<argument><expr><name>cpa</name></expr></argument>, <argument><expr><name>cpardx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cpa</name><operator>.</operator><name>scale</name></name> <operator>=</operator> <name>cpardx</name> <operator>*</operator> <name>BC_BASE_DIGS</name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>scale</name> <operator>&gt;</operator> <name><name>cpa</name><operator>.</operator><name>scale</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bc_num_extend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cpa</name></expr></argument>, <argument><expr><name>scale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cpardx</name> <operator>=</operator> <call><name>BC_NUM_RDX_VAL_NP</name><argument_list>(<argument><expr><name>cpa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cpa</name><operator>.</operator><name>scale</name></name> <operator>=</operator> <name>cpardx</name> <operator>*</operator> <name>BC_BASE_DIGS</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>cpa</name><operator>.</operator><name>cap</name></name> <operator>==</operator> <name><name>cpa</name><operator>.</operator><name>len</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_num_expand</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cpa</name></expr></argument>, <argument><expr><call><name>bc_vm_growSize</name><argument_list>(<argument><expr><name><name>cpa</name><operator>.</operator><name>len</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><name><name>cpa</name><operator>.</operator><name>num</name><index>[<expr><name><name>cpa</name><operator>.</operator><name>len</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>






<if_stmt><if>if <condition>(<expr><name>cpardx</name> <operator>==</operator> <name><name>cpa</name><operator>.</operator><name>len</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>cpa</name><operator>.</operator><name>len</name></name> <operator>=</operator> <call><name>bc_num_nonZeroLen</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cpa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>BC_NUM_RDX_VAL_NP</name><argument_list>(<argument><expr><name>cpb</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>cpb</name><operator>.</operator><name>len</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>cpb</name><operator>.</operator><name>len</name></name> <operator>=</operator> <call><name>bc_num_nonZeroLen</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cpb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>cpb</name><operator>.</operator><name>scale</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BC_NUM_RDX_SET_NP</name><argument_list>(<argument><expr><name>cpb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_num_d_long</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cpa</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cpb</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>scale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_num_retireMul</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>scale</name></expr></argument>, <argument><expr><call><name>BC_NUM_NEG</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>BC_NUM_NEG</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>err</name>:</label>
<expr_stmt><expr><name>BC_SIG_MAYLOCK</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cpb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cpa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>BC_LONGJMP_CONT</name></expr>;</expr_stmt>
</block_content>}</block></function>













<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_num_r</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>c</name></decl></parameter>,
<parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>d</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>scale</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>ts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>BcNum</name></type> <name>temp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>neg</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BC_NUM_ZERO</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_err</name><argument_list>(<argument><expr><name>BC_ERR_MATH_DIVIDE_BY_ZERO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BC_NUM_ZERO</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bc_num_setToZero</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_setToZero</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_num_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>temp</name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>cap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>BC_SETJMP_LOCKED</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_num_d</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>scale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>scale</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>scale</name> <operator>=</operator> <name>ts</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_num_m</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>temp</name></expr></argument>, <argument><expr><name>scale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_sub</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>temp</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>scale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>ts</name> <operator>&gt;</operator> <name><name>d</name><operator>-&gt;</operator><name>scale</name></name> <operator>&amp;&amp;</operator> <call><name>BC_NUM_NONZERO</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_num_extend</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>ts</name> <operator>-</operator> <name><name>d</name><operator>-&gt;</operator><name>scale</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>neg</name> <operator>=</operator> <call><name>BC_NUM_NEG</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_retireMul</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>, <argument><expr><call><name>BC_NUM_NEG</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>BC_NUM_NEG</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>rdx</name></name> <operator>=</operator> <call><name>BC_NUM_NEG_VAL</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><ternary><condition><expr><call><name>BC_NUM_NONZERO</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>neg</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>err</name>:</label>
<expr_stmt><expr><name>BC_SIG_MAYLOCK</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>BC_LONGJMP_CONT</name></expr>;</expr_stmt>
</block_content>}</block></function>









<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_num_rem</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>scale</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>BcNum</name></type> <name>c1</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>ts</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ts</name> <operator>=</operator> <call><name>bc_vm_growSize</name><argument_list>(<argument><expr><name>scale</name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>scale</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ts</name> <operator>=</operator> <call><name>BC_MAX</name><argument_list>(<argument><expr><name>ts</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>scale</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_num_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c1</name></expr></argument>, <argument><expr><call><name>bc_num_mulReq</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>BC_SETJMP_LOCKED</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_num_r</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c1</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>scale</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>err</name>:</label>
<expr_stmt><expr><name>BC_SIG_MAYLOCK</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>BC_LONGJMP_CONT</name></expr>;</expr_stmt>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_num_p</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>scale</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>BcNum</name></type> <name>copy</name></decl>, <decl><type ref="prev"/><name>btemp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcBigDig</name></type> <name>exp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>powrdx</name></decl>, <decl><type ref="prev"/><name>resrdx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>neg</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><call><name>bc_num_nonInt</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>btemp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_err</name><argument_list>(<argument><expr><name>BC_ERR_MATH_NON_INTEGER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BC_NUM_ZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>btemp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bc_num_one</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BC_NUM_ZERO</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>BC_NUM_NEG_NP</name><argument_list>(<argument><expr><name>btemp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_err</name><argument_list>(<argument><expr><name>BC_ERR_MATH_DIVIDE_BY_ZERO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>bc_num_setToZero</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>scale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BC_NUM_ONE</name><argument_list>(<argument><expr><operator>&amp;</operator><name>btemp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BC_NUM_NEG_NP</name><argument_list>(<argument><expr><name>btemp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_num_copy</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_num_inv</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>scale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>neg</name> <operator>=</operator> <call><name>BC_NUM_NEG_NP</name><argument_list>(<argument><expr><name>btemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BC_NUM_NEG_CLR_NP</name><argument_list>(<argument><expr><name>btemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>exp</name> <operator>=</operator> <call><name>bc_num_bigdig</name><argument_list>(<argument><expr><operator>&amp;</operator><name>btemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_num_createCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>copy</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>BC_SETJMP_LOCKED</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><operator>!</operator><name>neg</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>max</name> <init>= <expr><call><name>BC_MAX</name><argument_list>(<argument><expr><name>scale</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>scale</name></name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>scalepow</name></decl>;</decl_stmt>
<expr_stmt><expr><name>scalepow</name> <operator>=</operator> <call><name>bc_num_mulOverflow</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>scale</name></name></expr></argument>, <argument><expr><name>exp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>scale</name> <operator>=</operator> <call><name>BC_MIN</name><argument_list>(<argument><expr><name>scalepow</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>



<for>for <control>(<init><expr><name>powrdx</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>scale</name></name></expr>;</init> <condition><expr><operator>!</operator><operator>(</operator><name>exp</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</condition> <incr><expr><name>exp</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>powrdx</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID_NP</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_mul</name><argument_list>(<argument><expr><operator>&amp;</operator><name>copy</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>copy</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>copy</name></expr></argument>, <argument><expr><name>powrdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>



<expr_stmt><expr><call><name>bc_num_copy</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>resrdx</name> <operator>=</operator> <name>powrdx</name></expr>;</expr_stmt>



<while>while <condition>(<expr><name>exp</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>powrdx</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID_NP</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_mul</name><argument_list>(<argument><expr><operator>&amp;</operator><name>copy</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>copy</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>copy</name></expr></argument>, <argument><expr><name>powrdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name>exp</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>resrdx</name> <operator>+=</operator> <name>powrdx</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID_NP</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_mul</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>copy</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>resrdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>


<if_stmt><if>if <condition>(<expr><name>neg</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_num_inv</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>scale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>scale</name></name> <operator>&gt;</operator> <name>scale</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_num_truncate</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>scale</name></name> <operator>-</operator> <name>scale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>bc_num_clean</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>err</name>:</label>
<expr_stmt><expr><name>BC_SIG_MAYLOCK</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>BC_LONGJMP_CONT</name></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLE_EXTRA_MATH</name></expr></cpp:if>







<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_num_place</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>scale</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>BcBigDig</name></type> <name>val</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>BC_UNUSED</name><argument_list>(<argument><expr><name>scale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>bc_num_intop</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>val</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>scale</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_num_truncate</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>scale</name></name> <operator>-</operator> <name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>val</name> <operator>&gt;</operator> <name><name>c</name><operator>-&gt;</operator><name>scale</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_num_extend</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>val</name> <operator>-</operator> <name><name>c</name><operator>-&gt;</operator><name>scale</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_num_left</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>scale</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>BcBigDig</name></type> <name>val</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>BC_UNUSED</name><argument_list>(<argument><expr><name>scale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>bc_num_intop</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_num_shiftLeft</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_num_right</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>scale</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>BcBigDig</name></type> <name>val</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>BC_UNUSED</name><argument_list>(<argument><expr><name>scale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>bc_num_intop</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BC_NUM_ZERO</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>bc_num_shiftRight</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



















<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_num_binary</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>scale</name></decl></parameter>,
<parameter><decl><type><name>BcNumBinOp</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>req</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>ptr_a</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ptr_b</name></decl>, <decl><type ref="prev"/><name>num2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>init</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>a</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>b</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>op</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>a</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ptr_a</name> <operator>=</operator> <operator>&amp;</operator><name>num2</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr_a</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BcNum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>init</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>ptr_a</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>b</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ptr_b</name> <operator>=</operator> <operator>&amp;</operator><name>num2</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <name>a</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr_b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BcNum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>init</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>ptr_b</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>



<if_stmt><if>if <condition>(<expr><name>init</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>bc_num_init</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>req</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><call><name>BC_SETJMP_LOCKED</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_expand</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>req</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>






<expr_stmt><expr><call><name>op</name><argument_list>(<argument><expr><name>ptr_a</name></expr></argument>, <argument><expr><name>ptr_b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>scale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>BC_NUM_NEG</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>BC_NUM_NONZERO</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name><name>c</name><operator>-&gt;</operator><name>len</name></name> <operator>||</operator> <operator>!</operator><name><name>c</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>c</name><operator>-&gt;</operator><name>len</name></name> <operator>||</operator> <name><name>c</name><operator>-&gt;</operator><name>num</name><index>[<expr><name><name>c</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>||</operator> <call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>c</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>err</name>:</label>

<if_stmt><if>if <condition>(<expr><name>init</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>BC_SIG_MAYLOCK</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>num2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>BC_LONGJMP_CONT</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>BC_ENABLE_LIBRARY</name></expr></cpp:if>










<function><type><name>bool</name></type> <name>bc_num_strValid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>val</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>bool</name></type> <name>radix</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>






<if_stmt><if>if <condition>(<expr><operator>!</operator><name>len</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>BcDig</name></type> <name>c</name> <init>= <expr><name><name>val</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><name>radix</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>radix</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>isdigit</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isupper</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>

<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>








<function><type><specifier>static</specifier> <name>BcBigDig</name></type> <name>bc_num_parseChar</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>base</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isupper</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isdigit</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>isupper</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>BC_NUM_NUM_LETTER</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>c</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator> <name>c</name><operator>)</operator> <operator>&gt;=</operator> <name>base</name></expr> ?</condition><then> <expr><operator>(</operator><name>char</name><operator>)</operator> <name>base</name> <operator>-</operator> <literal type="number">1</literal></expr> </then><else>: <expr><name>c</name></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></if>

<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>c</name> <operator>-=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return <expr><operator>(</operator><name>BcBigDig</name><operator>)</operator> <operator>(</operator><name>uchar</name><operator>)</operator> <name>c</name></expr>;</return>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_num_parseDecimal</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>n</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>val</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>temp</name></decl>, <decl><type ref="prev"/><name>mod</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>zero</name> <init>= <expr><name>true</name></expr></init></decl>, <decl><type ref="prev"/><name>rdx</name></decl>;</decl_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>val</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'0'</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>

<expr_stmt><expr><name>val</name> <operator>+=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>val</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator> <call><name>isalnum</name><argument_list>(<argument><expr><name><name>val</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>val</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>val</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>



<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rdx</name> <operator>=</operator> <operator>(</operator><name>ptr</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>




<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>zero</name> <operator>=</operator> <operator>(</operator><name><name>val</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'0'</literal> <operator>||</operator> <name><name>val</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal><operator>)</operator><operator>)</operator></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>




<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>scale</name></name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <operator>(</operator><name>rdx</name> <operator>*</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator> <operator>(</operator><name>val</name> <operator>+</operator> <name>len</name><operator>)</operator><operator>)</operator> <operator>-</operator>
<operator>(</operator><operator>(</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator> <name>ptr</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator><operator>)</operator></expr>;</expr_stmt>


<expr_stmt><expr><call><name>BC_NUM_RDX_SET</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><call><name>BC_NUM_RDX</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>scale</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>i</name> <operator>=</operator> <name>len</name> <operator>-</operator> <operator>(</operator><ternary><condition><expr><name>ptr</name> <operator>==</operator> <name>val</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>i</name></expr></else></ternary><operator>)</operator> <operator>-</operator> <name>rdx</name></expr>;</expr_stmt>
<expr_stmt><expr><name>temp</name> <operator>=</operator> <call><name>BC_NUM_ROUND_POW</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>mod</name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>scale</name></name> <operator>%</operator> <name>BC_BASE_DIGS</name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <ternary><condition><expr><name>mod</name></expr> ?</condition><then> <expr><name>BC_BASE_DIGS</name> <operator>-</operator> <name>mod</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>temp</name> <operator>+</operator> <name>i</name><operator>)</operator> <operator>/</operator> <name>BC_BASE_DIGS</name><operator>)</operator></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_num_expand</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>BC_NUM_SIZE</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>zero</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>rdx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>


<decl_stmt><decl><type><name>BcBigDig</name></type> <name>exp</name></decl>, <decl><type ref="prev"/><name>pow</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> <operator>&lt;=</operator> <name>BC_NUM_BIGDIG_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>exp</name> <operator>=</operator> <operator>(</operator><name>BcBigDig</name><operator>)</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name>pow</name> <operator>=</operator> <name><name>bc_num_pow10</name><index>[<expr><name>exp</name></expr>]</index></name></expr>;</expr_stmt>



<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><operator>--</operator><name>i</name></expr><operator>,</operator> <expr><operator>++</operator><name>exp</name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr><name><name>val</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>exp</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>


<decl_stmt><decl><type><name>size_t</name></type> <name>idx</name> <init>= <expr><name>exp</name> <operator>/</operator> <name>BC_BASE_DIGS</name></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><call><name>isupper</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'9'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>num</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>+=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>BcBigDig</name><operator>)</operator> <name>c</name><operator>)</operator> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator> <operator>*</operator> <name>pow</name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>(</operator><name>exp</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name>BC_BASE_DIGS</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pow</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>pow</name> <operator>*=</operator> <name>BC_BASE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_num_parseBase</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>n</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>val</name></decl></parameter>,
<parameter><decl><type><name>BcBigDig</name></type> <name>base</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>BcNum</name></type> <name>temp</name></decl>, <decl><type ref="prev"/><name>mult1</name></decl>, <decl><type ref="prev"/><name>mult2</name></decl>, <decl><type ref="prev"/><name>result1</name></decl>, <decl><type ref="prev"/><name>result2</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>m1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>m2</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>zero</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcBigDig</name></type> <name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>digs</name></decl>, <decl><type ref="prev"/><name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>zero</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name>zero</name> <operator>=</operator> <operator>(</operator><name><name>val</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal> <operator>||</operator> <name><name>val</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></for>
<if_stmt><if>if <condition>(<expr><name>zero</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_num_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>temp</name></expr></argument>, <argument><expr><name>BC_NUM_BIGDIG_LOG10</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mult1</name></expr></argument>, <argument><expr><name>BC_NUM_BIGDIG_LOG10</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>BC_SETJMP_LOCKED</name><argument_list>(<argument><expr><name>int_err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>






<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>c</name> <operator>=</operator> <name><name>val</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <literal type="char">'.'</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>


<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>bc_num_parseChar</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_num_mulArray</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mult1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_num_bigdig2num</name><argument_list>(<argument><expr><operator>&amp;</operator><name>temp</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mult1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>temp</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>



<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>len</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>val</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>int_err</name>;</goto></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>val</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>


<expr_stmt><expr><name>BC_UNSETJMP</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_num_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mult2</name></expr></argument>, <argument><expr><name>BC_NUM_BIGDIG_LOG10</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result1</name></expr></argument>, <argument><expr><name>BC_NUM_DEF_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result2</name></expr></argument>, <argument><expr><name>BC_NUM_DEF_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_one</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mult1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>BC_SETJMP_LOCKED</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>


<expr_stmt><expr><name>m1</name> <operator>=</operator> <operator>&amp;</operator><name>mult1</name></expr>;</expr_stmt>
<expr_stmt><expr><name>m2</name> <operator>=</operator> <operator>&amp;</operator><name>mult2</name></expr>;</expr_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>+=</operator> <literal type="number">1</literal></expr><operator>,</operator> <expr><name>digs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>c</name> <operator>=</operator> <name><name>val</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr><operator>,</operator> <expr><operator>++</operator><name>digs</name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>rdx</name></decl>;</decl_stmt>


<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>bc_num_parseChar</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><call><name>bc_num_mulArray</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result1</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_num_bigdig2num</name><argument_list>(<argument><expr><operator>&amp;</operator><name>temp</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_num_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>temp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_num_mulArray</name><argument_list>(<argument><expr><name>m1</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>m2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rdx</name> <operator>=</operator> <call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>m2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>m2</name><operator>-&gt;</operator><name>len</name></name> <operator>&lt;</operator> <name>rdx</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>m2</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>rdx</name></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>m1</name></expr>;</expr_stmt>
<expr_stmt><expr><name>m1</name> <operator>=</operator> <name>m2</name></expr>;</expr_stmt>
<expr_stmt><expr><name>m2</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
</block_content>}</block></for>





<expr_stmt><expr><call><name>bc_num_div</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result1</name></expr></argument>, <argument><expr><name>m1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result2</name></expr></argument>, <argument><expr><name>digs</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_num_truncate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result2</name></expr></argument>, <argument><expr><name>digs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_num_add</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result2</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>digs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_NUM_NONZERO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>scale</name></name> <operator>&lt;</operator> <name>digs</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_num_extend</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>digs</name> <operator>-</operator> <name><name>n</name><operator>-&gt;</operator><name>scale</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_num_zero</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<label><name>err</name>:</label>
<expr_stmt><expr><name>BC_SIG_MAYLOCK</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mult2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>int_err</name>:</label>
<expr_stmt><expr><name>BC_SIG_MAYLOCK</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mult1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>BC_LONGJMP_CONT</name></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>bc_num_printNewline</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>BC_ENABLE_LIBRARY</name></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>vm</name><operator>.</operator><name>nchars</name></name> <operator>&gt;=</operator> <name><name>vm</name><operator>.</operator><name>line_len</name></name> <operator>-</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>vm</name><operator>.</operator><name>line_len</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bc_vm_putchar</name><argument_list>(<argument><expr><literal type="char">'\\'</literal></expr></argument>, <argument><expr><name>bc_flush_none</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_vm_putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>bc_flush_err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_num_putchar</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>bslash</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <literal type="char">'\n'</literal> <operator>&amp;&amp;</operator> <name>bslash</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_num_printNewline</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>bc_vm_putchar</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>bc_flush_save</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>BC_ENABLE_LIBRARY</name></expr></cpp:if>












<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_num_printChar</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>rdx</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>bslash</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>BC_UNUSED</name><argument_list>(<argument><expr><name>rdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BC_UNUSED</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BC_UNUSED</name><argument_list>(<argument><expr><name>bslash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>len</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_vm_putchar</name><argument_list>(<argument><expr><operator>(</operator><name>uchar</name><operator>)</operator> <name>n</name></expr></argument>, <argument><expr><name>bc_flush_save</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>











<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_num_printDigits</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>rdx</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>bslash</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>exp</name></decl>, <decl><type ref="prev"/><name>pow</name></decl>;</decl_stmt>


<expr_stmt><expr><call><name>bc_num_putchar</name><argument_list>(<argument><expr><ternary><condition><expr><name>rdx</name></expr> ?</condition><then> <expr><literal type="char">'.'</literal></expr> </then><else>: <expr><literal type="char">' '</literal></expr></else></ternary></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<for>for <control>(<init><expr><name>exp</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>pow</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>exp</name> <operator>&lt;</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><operator>++</operator><name>exp</name></expr><operator>,</operator> <expr><name>pow</name> <operator>*=</operator> <name>BC_BASE</name></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>


<for>for <control>(<init><expr><name>exp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>exp</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>pow</name> <operator>/=</operator> <name>BC_BASE</name></expr><operator>,</operator> <expr><operator>++</operator><name>exp</name></expr></incr>)</control> <block>{<block_content>


<decl_stmt><decl><type><name>size_t</name></type> <name>dig</name> <init>= <expr><name>n</name> <operator>/</operator> <name>pow</name></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><name>n</name> <operator>-=</operator> <name>dig</name> <operator>*</operator> <name>pow</name></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_num_putchar</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>uchar</name><operator>)</operator> <name>dig</name><operator>)</operator> <operator>+</operator> <literal type="char">'0'</literal></expr></argument>, <argument><expr><name>bslash</name> <operator>||</operator> <name>exp</name> <operator>!=</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>












<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_num_printHex</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>rdx</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>bslash</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>BC_UNUSED</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BC_UNUSED</name><argument_list>(<argument><expr><name>bslash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>len</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>rdx</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_num_putchar</name><argument_list>(<argument><expr><literal type="char">'.'</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>bc_num_putchar</name><argument_list>(<argument><expr><name><name>bc_num_hex_digits</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>, <argument><expr><name>bslash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_num_printDecimal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>newline</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>rdx</name> <init>= <expr><call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>zero</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name><name>buffer</name><index>[<expr><name>BC_BASE_DIGS</name></expr>]</index></name></decl>;</decl_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>n</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><operator>--</operator><name>i</name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>BcDig</name></type> <name>n9</name> <init>= <expr><name><name>n</name><operator>-&gt;</operator><name>num</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>temp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>irdx</name> <init>= <expr><operator>(</operator><name>i</name> <operator>==</operator> <name>rdx</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><name>zero</name> <operator>=</operator> <operator>(</operator><name>zero</name> <operator>&amp;</operator> <operator>!</operator><name>irdx</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>temp</name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>scale</name></name> <operator>%</operator> <name>BC_BASE_DIGS</name></expr>;</expr_stmt>
<expr_stmt><expr><name>temp</name> <operator>=</operator> <ternary><condition><expr><name>i</name> <operator>||</operator> <operator>!</operator><name>temp</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>BC_BASE_DIGS</name> <operator>-</operator> <name>temp</name></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BC_BASE_DIGS</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n9</name> <operator>&amp;&amp;</operator> <name>j</name> <operator>&lt;</operator> <name>BC_BASE_DIGS</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>buffer</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator> <name>n9</name><operator>)</operator> <operator>%</operator> <name>BC_BASE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>n9</name> <operator>/=</operator> <name>BC_BASE</name></expr>;</expr_stmt>
</block_content>}</block></for>


<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>BC_BASE_DIGS</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>BC_BASE_DIGS</name> <operator>&amp;&amp;</operator> <name>j</name> <operator>&gt;=</operator> <name>temp</name></expr>;</condition> <incr><expr><operator>--</operator><name>j</name></expr></incr>)</control> <block>{<block_content>


<decl_stmt><decl><type><name>bool</name></type> <name>print_rdx</name> <init>= <expr><operator>(</operator><name>irdx</name> <operator>&amp;</operator> <operator>(</operator><name>j</name> <operator>==</operator> <name>BC_BASE_DIGS</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><name>zero</name> <operator>=</operator> <operator>(</operator><name>zero</name> <operator>&amp;&amp;</operator> <name><name>buffer</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>zero</name></expr>)</condition> <block>{<block_content>






<expr_stmt><expr><call><name>bc_num_printHex</name><argument_list>(<argument><expr><name><name>buffer</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>print_rdx</name></expr></argument>,
<argument><expr><operator>!</operator><name>newline</name> <operator>||</operator> <operator>(</operator><name>j</name> <operator>&gt;</operator> <name>temp</name> <operator>||</operator> <name>i</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLE_EXTRA_MATH</name></expr></cpp:if>








<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_num_printExponent</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>n</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>eng</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>newline</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>places</name></decl>, <decl><type ref="prev"/><name>mod</name></decl>, <decl><type ref="prev"/><name>nrdx</name> <init>= <expr><call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>neg</name> <init>= <expr><operator>(</operator><name><name>n</name><operator>-&gt;</operator><name>len</name></name> <operator>&lt;=</operator> <name>nrdx</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcNum</name></type> <name>temp</name></decl>, <decl><type ref="prev"/><name>exp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcDig</name></type> <name><name>digs</name><index>[<expr><name>BC_NUM_BIGDIG_LOG10</name></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_num_createCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>temp</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>BC_SETJMP_LOCKED</name><argument_list>(<argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name>neg</name></expr>)</condition> <block>{<block_content>


<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>idx</name> <init>= <expr><call><name>bc_num_nonZeroLen</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>places</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>BC_BASE_DIGS</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>BC_BASE_DIGS</name></expr>;</condition> <incr><expr><operator>--</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>bc_num_pow10</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <operator>(</operator><name>BcBigDig</name><operator>)</operator> <name><name>n</name><operator>-&gt;</operator><name>num</name><index>[<expr><name>idx</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>places</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <break>break;</break></block_content></block></else></if_stmt>
</block_content>}</block></for>



<expr_stmt><expr><name>places</name> <operator>+=</operator> <operator>(</operator><name>nrdx</name> <operator>-</operator> <operator>(</operator><name>idx</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>*</operator> <name>BC_BASE_DIGS</name></expr>;</expr_stmt>
<expr_stmt><expr><name>mod</name> <operator>=</operator> <name>places</name> <operator>%</operator> <literal type="number">3</literal></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>eng</name> <operator>&amp;&amp;</operator> <name>mod</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>places</name> <operator>+=</operator> <literal type="number">3</literal> <operator>-</operator> <name>mod</name></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>bc_num_shiftLeft</name><argument_list>(<argument><expr><operator>&amp;</operator><name>temp</name></expr></argument>, <argument><expr><name>places</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>



<expr_stmt><expr><name>places</name> <operator>=</operator> <call><name>bc_num_intDigits</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>



<expr_stmt><expr><name>mod</name> <operator>=</operator> <name>places</name> <operator>%</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>eng</name> <operator>&amp;&amp;</operator> <name>mod</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>places</name> <operator>-=</operator> <literal type="number">3</literal> <operator>-</operator> <operator>(</operator><literal type="number">3</literal> <operator>-</operator> <name>mod</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>bc_num_shiftRight</name><argument_list>(<argument><expr><operator>&amp;</operator><name>temp</name></expr></argument>, <argument><expr><name>places</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<expr_stmt><expr><call><name>bc_num_printDecimal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>temp</name></expr></argument>, <argument><expr><name>newline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_num_putchar</name><argument_list>(<argument><expr><literal type="char">'e'</literal></expr></argument>, <argument><expr><operator>!</operator><name>newline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name>places</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bc_num_printHex</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>!</operator><name>newline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>exit</name>;</goto>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>neg</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_num_putchar</name><argument_list>(<argument><expr><literal type="char">'-'</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>bc_num_setup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>exp</name></expr></argument>, <argument><expr><name>digs</name></expr></argument>, <argument><expr><name>BC_NUM_BIGDIG_LOG10</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_bigdig2num</name><argument_list>(<argument><expr><operator>&amp;</operator><name>exp</name></expr></argument>, <argument><expr><operator>(</operator><name>BcBigDig</name><operator>)</operator> <name>places</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_num_printDecimal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>exp</name></expr></argument>, <argument><expr><name>newline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>exit</name>:</label>
<expr_stmt><expr><name>BC_SIG_MAYLOCK</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>BC_LONGJMP_CONT</name></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>











<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_num_printFixup</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>BcBigDig</name></type> <name>rem</name></decl></parameter>,
<parameter><decl><type><name>BcBigDig</name></type> <name>pow</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>idx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name> <init>= <expr><name><name>n</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <name>idx</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcBigDig</name></type> <name>acc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcDig</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><name><name>n</name><operator>-&gt;</operator><name>num</name></name> <operator>+</operator> <name>idx</name></expr></init></decl>;</decl_stmt>



<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>



<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>i</name></expr></incr>)</control> <block>{<block_content>




<expr_stmt><expr><name>acc</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>BcBigDig</name><operator>)</operator> <name><name>a</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator> <operator>*</operator> <name>rem</name> <operator>+</operator> <operator>(</operator><operator>(</operator><name>BcBigDig</name><operator>)</operator> <name><name>a</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>


<expr_stmt><expr><name><name>a</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>BcDig</name><operator>)</operator> <operator>(</operator><name>acc</name> <operator>%</operator> <name>pow</name><operator>)</operator></expr>;</expr_stmt>


<expr_stmt><expr><name>acc</name> <operator>/=</operator> <name>pow</name></expr>;</expr_stmt>
<expr_stmt><expr><name>acc</name> <operator>+=</operator> <operator>(</operator><name>BcBigDig</name><operator>)</operator> <name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>acc</name> <operator>&gt;=</operator> <name>BC_BASE_POW</name></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>bc_vm_growSize</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_expand</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><call><name>bc_vm_growSize</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>a</name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>num</name></name> <operator>+</operator> <name>idx</name></expr>;</expr_stmt>


<expr_stmt><expr><name><name>a</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name><name>a</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>+=</operator> <name>acc</name> <operator>/</operator> <name>BC_BASE_POW</name></expr>;</expr_stmt>
<expr_stmt><expr><name>acc</name> <operator>%=</operator> <name>BC_BASE_POW</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>acc</name> <operator>&lt;</operator> <name>BC_BASE_POW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>BcDig</name><operator>)</operator> <name>acc</name></expr>;</expr_stmt>
</block_content>}</block></for>


<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>len</name> <operator>+</operator> <name>idx</name></expr>;</expr_stmt>
</block_content>}</block></function>









<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_num_printPrepare</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>BcBigDig</name></type> <name>rem</name></decl></parameter>, <parameter><decl><type><name>BcBigDig</name></type> <name>pow</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>



<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>n</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_num_printFixup</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>rem</name></expr></argument>, <argument><expr><name>pow</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>




<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>n</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pow</name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>BcBigDig</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>BcDig</name><operator>)</operator> <name>pow</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>num</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <operator>(</operator><name>BcDig</name><operator>)</operator> <name>pow</name></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal> <operator>==</operator> <name><name>n</name><operator>-&gt;</operator><name>len</name></name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <call><name>bc_vm_growSize</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_expand</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>num</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pow</name> <operator>&lt;</operator> <name>BC_BASE_POW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>num</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>+=</operator> <name><name>n</name><operator>-&gt;</operator><name>num</name><index>[<expr><name>i</name></expr>]</index></name> <operator>/</operator> <operator>(</operator><operator>(</operator><name>BcDig</name><operator>)</operator> <name>pow</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>num</name><index>[<expr><name>i</name></expr>]</index></name> <operator>%=</operator> <operator>(</operator><name>BcDig</name><operator>)</operator> <name>pow</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_num_printNum</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>BcBigDig</name></type> <name>base</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>,
<parameter><decl><type><name>BcNumDigitOp</name></type> <name>print</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>newline</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>BcVec</name></type> <name>stack</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcNum</name></type> <name>intp</name></decl>, <decl><type ref="prev"/><name>fracp1</name></decl>, <decl><type ref="prev"/><name>fracp2</name></decl>, <decl><type ref="prev"/><name>digit</name></decl>, <decl><type ref="prev"/><name>flen1</name></decl>, <decl><type ref="prev"/><name>flen2</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>n1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>n2</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>temp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcBigDig</name></type> <name>dig</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ptr</name></decl>, <decl><type ref="prev"/><name>acc</name></decl>, <decl><type ref="prev"/><name>exp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>nrdx</name></decl>, <decl><type ref="prev"/><name>idigits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>radix</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcDig</name></type> <name><name>digit_digs</name><index>[<expr><name>BC_NUM_BIGDIG_LOG10</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>base</name> <operator>&gt;</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_NUM_ZERO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>print</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>!</operator><name>newline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>







































<expr_stmt><expr><name>nrdx</name> <operator>=</operator> <call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_vec_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stack</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BcBigDig</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>BC_DTOR_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fracp1</name></expr></argument>, <argument><expr><name>nrdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_num_createCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>intp</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>BC_SETJMP_LOCKED</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_num_truncate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>intp</name></expr></argument>, <argument><expr><name><name>intp</name><operator>.</operator><name>scale</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_num_sub</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>intp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fracp1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>






<if_stmt><if>if <condition>(<expr><name>base</name> <operator>!=</operator> <name><name>vm</name><operator>.</operator><name>last_base</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>vm</name><operator>.</operator><name>last_pow</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vm</name><operator>.</operator><name>last_exp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>


<while>while <condition>(<expr><name><name>vm</name><operator>.</operator><name>last_pow</name></name> <operator>*</operator> <name>base</name> <operator>&lt;=</operator> <name>BC_BASE_POW</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>vm</name><operator>.</operator><name>last_pow</name></name> <operator>*=</operator> <name>base</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vm</name><operator>.</operator><name>last_exp</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></while>


<expr_stmt><expr><name><name>vm</name><operator>.</operator><name>last_rem</name></name> <operator>=</operator> <name>BC_BASE_POW</name> <operator>-</operator> <name><name>vm</name><operator>.</operator><name>last_pow</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vm</name><operator>.</operator><name>last_base</name></name> <operator>=</operator> <name>base</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>exp</name> <operator>=</operator> <name><name>vm</name><operator>.</operator><name>last_exp</name></name></expr>;</expr_stmt>





<if_stmt><if>if <condition>(<expr><name><name>vm</name><operator>.</operator><name>last_rem</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_num_printPrepare</name><argument_list>(<argument><expr><operator>&amp;</operator><name>intp</name></expr></argument>, <argument><expr><name><name>vm</name><operator>.</operator><name>last_rem</name></name></expr></argument>, <argument><expr><name><name>vm</name><operator>.</operator><name>last_pow</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>





<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>intp</name><operator>.</operator><name>len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>


<expr_stmt><expr><name>acc</name> <operator>=</operator> <operator>(</operator><name>BcBigDig</name><operator>)</operator> <name><name>intp</name><operator>.</operator><name>num</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>


<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>exp</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>i</name> <operator>&lt;</operator> <name><name>intp</name><operator>.</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal> <operator>||</operator> <name>acc</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>j</name> <operator>!=</operator> <name>exp</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>dig</name> <operator>=</operator> <name>acc</name> <operator>%</operator> <name>base</name></expr>;</expr_stmt>
<expr_stmt><expr><name>acc</name> <operator>/=</operator> <name>base</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>dig</name> <operator>=</operator> <name>acc</name></expr>;</expr_stmt>
<expr_stmt><expr><name>acc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dig</name> <operator>&lt;</operator> <name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_vec_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stack</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>acc</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>stack</name><operator>.</operator><name>len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>bc_vec_item_rev</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stack</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>






<expr_stmt><expr><call><name>print</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>!</operator><name>newline</name> <operator>||</operator>
<operator>(</operator><name><name>n</name><operator>-&gt;</operator><name>scale</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>i</name> <operator>==</operator> <name><name>stack</name><operator>.</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>n</name><operator>-&gt;</operator><name>scale</name></name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>


<expr_stmt><expr><name>BC_UNSETJMP</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_num_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fracp2</name></expr></argument>, <argument><expr><name>nrdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_setup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>digit</name></expr></argument>, <argument><expr><name>digit_digs</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>digit_digs</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BcDig</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>flen1</name></expr></argument>, <argument><expr><name>BC_NUM_BIGDIG_LOG10</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>flen2</name></expr></argument>, <argument><expr><name>BC_NUM_BIGDIG_LOG10</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>BC_SETJMP_LOCKED</name><argument_list>(<argument><expr><name>frac_err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_num_one</name><argument_list>(<argument><expr><operator>&amp;</operator><name>flen1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>radix</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>


<expr_stmt><expr><name>n1</name> <operator>=</operator> <operator>&amp;</operator><name>flen1</name></expr>;</expr_stmt>
<expr_stmt><expr><name>n2</name> <operator>=</operator> <operator>&amp;</operator><name>flen2</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fracp2</name><operator>.</operator><name>scale</name></name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>scale</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BC_NUM_RDX_SET_NP</name><argument_list>(<argument><expr><name>fracp2</name></expr></argument>, <argument><expr><call><name>BC_NUM_RDX</name><argument_list>(<argument><expr><name><name>fracp2</name><operator>.</operator><name>scale</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<while>while <condition>(<expr><operator>(</operator><name>idigits</name> <operator>=</operator> <call><name>bc_num_intDigits</name><argument_list>(<argument><expr><name>n1</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;=</operator> <name><name>n</name><operator>-&gt;</operator><name>scale</name></name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><call><name>bc_num_expand</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fracp2</name></expr></argument>, <argument><expr><name><name>fracp1</name><operator>.</operator><name>len</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_mulArray</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fracp1</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fracp2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>nrdx</name> <operator>=</operator> <call><name>BC_NUM_RDX_VAL_NP</name><argument_list>(<argument><expr><name>fracp2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>fracp2</name><operator>.</operator><name>len</name></name> <operator>&lt;</operator> <name>nrdx</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>fracp2</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>nrdx</name></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><name>dig</name> <operator>=</operator> <call><name>bc_num_bigdig2</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fracp2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_num_bigdig2num</name><argument_list>(<argument><expr><operator>&amp;</operator><name>digit</name></expr></argument>, <argument><expr><name>dig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_sub</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fracp2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>digit</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fracp1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>






<expr_stmt><expr><call><name>print</name><argument_list>(<argument><expr><name>dig</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>radix</name></expr></argument>, <argument><expr><operator>!</operator><name>newline</name> <operator>||</operator> <name>idigits</name> <operator>!=</operator> <name><name>n</name><operator>-&gt;</operator><name>scale</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_num_mulArray</name><argument_list>(<argument><expr><name>n1</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>n2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>radix</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>


<expr_stmt><expr><name>temp</name> <operator>=</operator> <name>n1</name></expr>;</expr_stmt>
<expr_stmt><expr><name>n1</name> <operator>=</operator> <name>n2</name></expr>;</expr_stmt>
<expr_stmt><expr><name>n2</name> <operator>=</operator> <name>temp</name></expr>;</expr_stmt>
</block_content>}</block></while>

<label><name>frac_err</name>:</label>
<expr_stmt><expr><name>BC_SIG_MAYLOCK</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>flen2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>flen1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fracp2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>err</name>:</label>
<expr_stmt><expr><name>BC_SIG_MAYLOCK</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fracp1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>intp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_vec_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>BC_LONGJMP_CONT</name></expr>;</expr_stmt>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_num_printBase</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>BcBigDig</name></type> <name>base</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>newline</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>width</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcNumDigitOp</name></type> <name>print</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>neg</name> <init>= <expr><call><name>BC_NUM_NEG</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>



<expr_stmt><expr><call><name>BC_NUM_NEG_CLR</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name>base</name> <operator>&lt;=</operator> <name>BC_NUM_MAX_POSIX_IBASE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>width</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>print</name> <operator>=</operator> <name>bc_num_printHex</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>base</name> <operator>&lt;=</operator> <name>BC_BASE_POW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>width</name> <operator>=</operator> <call><name>bc_num_log10</name><argument_list>(<argument><expr><name>base</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>print</name> <operator>=</operator> <name>bc_num_printDigits</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<expr_stmt><expr><call><name>bc_num_printNum</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><name>print</name></expr></argument>, <argument><expr><name>newline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>rdx</name></name> <operator>=</operator> <call><name>BC_NUM_NEG_VAL</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>neg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>BC_ENABLE_LIBRARY</name></expr></cpp:if>

<function><type><name>void</name></type> <name>bc_num_stream</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>bc_num_printNum</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>BC_NUM_STREAM_BASE</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>bc_num_printChar</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type> <name>bc_num_setup</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>BcDig</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>num</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>cap</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>num</name></name> <operator>=</operator> <name>num</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>cap</name></name> <operator>=</operator> <name>cap</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_zero</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>bc_num_init</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>req</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>BcDig</name> <modifier>*</modifier></type><name>num</name></decl>;</decl_stmt>

<expr_stmt><expr><name>BC_SIG_ASSERT_LOCKED</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>req</name> <operator>=</operator> <ternary><condition><expr><name>req</name> <operator>&gt;=</operator> <name>BC_NUM_DEF_SIZE</name></expr> ?</condition><then> <expr><name>req</name></expr> </then><else>: <expr><name>BC_NUM_DEF_SIZE</name></expr></else></ternary></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>req</name> <operator>!=</operator> <name>BC_NUM_DEF_SIZE</name> <operator>||</operator> <operator>(</operator><name>num</name> <operator>=</operator> <call><name>bc_vm_takeTemp</name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>bc_vm_malloc</name><argument_list>(<argument><expr><call><name>BC_NUM_SIZE</name><argument_list>(<argument><expr><name>req</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>bc_num_setup</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>num</name></expr></argument>, <argument><expr><name>req</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>bc_num_clear</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>num</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>cap</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>bc_num_free</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>num</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><operator>(</operator><name>BcNum</name><operator>*</operator><operator>)</operator> <name>num</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>BC_SIG_ASSERT_LOCKED</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>cap</name></name> <operator>==</operator> <name>BC_NUM_DEF_SIZE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_vm_addTemp</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>bc_num_copy</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BcNum</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>d</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>s</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>d</name> <operator>==</operator> <name>s</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>bc_num_expand</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>



<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>rdx</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>rdx</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>scale</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>scale</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><call><name>BC_NUM_SIZE</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>bc_num_createCopy</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BcNum</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>BC_SIG_ASSERT_LOCKED</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_init</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_copy</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>bc_num_createFromBigdig</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>BcBigDig</name></type> <name>val</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>BC_SIG_ASSERT_LOCKED</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_init</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>BC_NUM_BIGDIG_LOG10</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_bigdig2num</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>bc_num_scale</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name><name>n</name><operator>-&gt;</operator><name>scale</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>bc_num_len</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><name><name>n</name><operator>-&gt;</operator><name>len</name></name></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_NUM_ZERO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><ternary><condition><expr><name><name>n</name><operator>-&gt;</operator><name>scale</name></name></expr> ?</condition><then> <expr><name><name>n</name><operator>-&gt;</operator><name>scale</name></name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>len</name></expr>)</condition> <block>{<block_content>





<decl_stmt><decl><type><name>size_t</name></type> <name>zero</name></decl>, <decl><type ref="prev"/><name>scale</name></decl>;</decl_stmt>


<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>bc_num_nonZeroLen</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>scale</name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>scale</name></name> <operator>%</operator> <name>BC_BASE_DIGS</name></expr>;</expr_stmt>
<expr_stmt><expr><name>scale</name> <operator>=</operator> <ternary><condition><expr><name>scale</name></expr> ?</condition><then> <expr><name>scale</name></expr> </then><else>: <expr><name>BC_BASE_DIGS</name></expr></else></ternary></expr>;</expr_stmt>


<expr_stmt><expr><name>zero</name> <operator>=</operator> <call><name>bc_num_zeroDigits</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>num</name></name> <operator>+</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>len</name> <operator>=</operator> <name>len</name> <operator>*</operator> <name>BC_BASE_DIGS</name> <operator>-</operator> <name>zero</name> <operator>-</operator> <operator>(</operator><name>BC_BASE_DIGS</name> <operator>-</operator> <name>scale</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if>

<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>bc_num_intDigits</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>n</name><operator>-&gt;</operator><name>scale</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>bc_num_parse</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>n</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>BcBigDig</name></type> <name>base</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>val</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>base</name> <operator>&gt;=</operator> <name>BC_NUM_MIN_BASE</name> <operator>&amp;&amp;</operator> <name>base</name> <operator>&lt;=</operator> <name><name>vm</name><operator>.</operator><name>maxes</name><index>[<expr><name>BC_PROG_GLOBALS_IBASE</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>bc_num_strValid</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>val</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>BcBigDig</name></type> <name>dig</name> <init>= <expr><call><name>bc_num_parseChar</name><argument_list>(<argument><expr><name><name>val</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>BC_NUM_MAX_LBASE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>bc_num_bigdig2num</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>dig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>base</name> <operator>==</operator> <name>BC_BASE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_num_parseDecimal</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_num_parseBase</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>bc_num_print</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>BcBigDig</name></type> <name>base</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>newline</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>BC_ENABLE_EXTRA_MATH</name> <operator>||</operator> <name>base</name> <operator>&gt;=</operator> <name>BC_NUM_MIN_BASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_num_printNewline</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BC_NUM_NONZERO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><call><name>BC_NUM_NEG</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_num_putchar</name><argument_list>(<argument><expr><literal type="char">'-'</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>BC_Z</name> <operator>&amp;&amp;</operator> <call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>n</name><operator>-&gt;</operator><name>len</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_num_printHex</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>!</operator><name>newline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_NUM_ZERO</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_num_printHex</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>!</operator><name>newline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>base</name> <operator>==</operator> <name>BC_BASE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_num_printDecimal</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>newline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLE_EXTRA_MATH</name></expr></cpp:if>
<if type="elseif">else if <condition>(<expr><name>base</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>base</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_num_printExponent</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>base</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>newline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_num_printBase</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>newline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>newline</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_num_putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>BcBigDig</name></type> <name>bc_num_bigdig2</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>







<decl_stmt><decl><type><name>BcBigDig</name></type> <name>r</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>nrdx</name> <init>= <expr><call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>BC_NUM_NEG</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>bc_num_cmp</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>max</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <name>nrdx</name> <operator>&lt;=</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<switch>switch <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <name>nrdx</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">3</literal></expr>:</case>
<block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <operator>(</operator><name>BcBigDig</name><operator>)</operator> <name><name>n</name><operator>-&gt;</operator><name>num</name><index>[<expr><name>nrdx</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>BC_FALLTHROUGH</name></macro>

<case>case <expr><literal type="number">2</literal></expr>:</case>
<block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>r</name> <operator>*</operator> <name>BC_BASE_POW</name> <operator>+</operator> <operator>(</operator><name>BcBigDig</name><operator>)</operator> <name><name>n</name><operator>-&gt;</operator><name>num</name><index>[<expr><name>nrdx</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>BC_FALLTHROUGH</name></macro>

<case>case <expr><literal type="number">1</literal></expr>:</case>
<block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>r</name> <operator>*</operator> <name>BC_BASE_POW</name> <operator>+</operator> <operator>(</operator><name>BcBigDig</name><operator>)</operator> <name><name>n</name><operator>-&gt;</operator><name>num</name><index>[<expr><name>nrdx</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block>
</block_content>}</block></switch>

<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>BcBigDig</name></type> <name>bc_num_bigdig</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>






<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><call><name>BC_NUM_NEG</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_err</name><argument_list>(<argument><expr><name>BC_ERR_MATH_NEGATIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><call><name>bc_num_cmp</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>max</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_err</name><argument_list>(<argument><expr><name>BC_ERR_MATH_OVERFLOW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><call><name>bc_num_bigdig2</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>bc_num_bigdig2num</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>BcBigDig</name></type> <name>val</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>BcDig</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_num_zero</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name>val</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>



<expr_stmt><expr><call><name>bc_num_expand</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>BC_NUM_BIGDIG_LOG10</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<for>for <control>(<init><expr><name>ptr</name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>num</name></name></expr><operator>,</operator> <expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>val</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr><operator>,</operator> <expr><name>val</name> <operator>/=</operator> <name>BC_BASE_POW</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ptr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>val</name> <operator>%</operator> <name>BC_BASE_POW</name></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLE_EXTRA_MATH</name></expr></cpp:if>

<function><type><name>void</name></type> <name>bc_num_rng</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>BcRNG</name> <modifier>*</modifier></type><name>rng</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>BcNum</name></type> <name>temp</name></decl>, <decl><type ref="prev"/><name>temp2</name></decl>, <decl><type ref="prev"/><name>intn</name></decl>, <decl><type ref="prev"/><name>frac</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcRand</name></type> <name>state1</name></decl>, <decl><type ref="prev"/><name>state2</name></decl>, <decl><type ref="prev"/><name>inc1</name></decl>, <decl><type ref="prev"/><name>inc2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>nrdx</name> <init>= <expr><call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>






<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_num_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>temp</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>temp2</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>frac</name></expr></argument>, <argument><expr><name>nrdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>intn</name></expr></argument>, <argument><expr><call><name>bc_num_int</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>BC_SETJMP_LOCKED</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID_NP</name><argument_list>(<argument><expr><name><name>vm</name><operator>.</operator><name>max</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>frac</name><operator>.</operator><name>num</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><call><name>BC_NUM_SIZE</name><argument_list>(<argument><expr><name>nrdx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>frac</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>nrdx</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BC_NUM_RDX_SET_NP</name><argument_list>(<argument><expr><name>frac</name></expr></argument>, <argument><expr><name>nrdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>frac</name><operator>.</operator><name>scale</name></name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>scale</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID_NP</name><argument_list>(<argument><expr><name>frac</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID_NP</name><argument_list>(<argument><expr><name><name>vm</name><operator>.</operator><name>max2</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><call><name>bc_num_mul</name><argument_list>(<argument><expr><operator>&amp;</operator><name>frac</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>max2</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>temp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_truncate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>temp</name></expr></argument>, <argument><expr><name><name>temp</name><operator>.</operator><name>scale</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>frac</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>intn</name><operator>.</operator><name>num</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>num</name></name> <operator>+</operator> <name>nrdx</name></expr></argument>, <argument><expr><call><name>BC_NUM_SIZE</name><argument_list>(<argument><expr><call><name>bc_num_int</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>intn</name><operator>.</operator><name>len</name></name> <operator>=</operator> <call><name>bc_num_int</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_NONZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>max</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_NUM_NONZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>frac</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><call><name>bc_num_divmod</name><argument_list>(<argument><expr><operator>&amp;</operator><name>frac</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>max</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>temp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>temp2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>






<expr_stmt><expr><name>state1</name> <operator>=</operator> <operator>(</operator><name>BcRand</name><operator>)</operator> <call><name>bc_num_bigdig2</name><argument_list>(<argument><expr><operator>&amp;</operator><name>temp2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>state2</name> <operator>=</operator> <operator>(</operator><name>BcRand</name><operator>)</operator> <call><name>bc_num_bigdig2</name><argument_list>(<argument><expr><operator>&amp;</operator><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>state1</name> <operator>=</operator> <name>state2</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_NUM_NONZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>intn</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><call><name>bc_num_divmod</name><argument_list>(<argument><expr><operator>&amp;</operator><name>intn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>max</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>temp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>temp2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>inc1</name> <operator>=</operator> <operator>(</operator><name>BcRand</name><operator>)</operator> <call><name>bc_num_bigdig2</name><argument_list>(<argument><expr><operator>&amp;</operator><name>temp2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>bc_num_cmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>temp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>max</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bc_num_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>temp2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_mod</name><argument_list>(<argument><expr><operator>&amp;</operator><name>temp2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>max</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>temp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>



<expr_stmt><expr><name>inc2</name> <operator>=</operator> <operator>(</operator><name>BcRand</name><operator>)</operator> <call><name>bc_num_bigdig2</name><argument_list>(<argument><expr><operator>&amp;</operator><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>inc1</name> <operator>=</operator> <name>inc2</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>bc_rand_seed</name><argument_list>(<argument><expr><name>rng</name></expr></argument>, <argument><expr><name>state1</name></expr></argument>, <argument><expr><name>state2</name></expr></argument>, <argument><expr><name>inc1</name></expr></argument>, <argument><expr><name>inc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>err</name>:</label>
<expr_stmt><expr><name>BC_SIG_MAYLOCK</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>intn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>frac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>temp2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>BC_LONGJMP_CONT</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>bc_num_createFromRNG</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>BcRNG</name> <modifier>*</modifier></type><name>rng</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>BcRand</name></type> <name>s1</name></decl>, <decl><type ref="prev"/><name>s2</name></decl>, <decl><type ref="prev"/><name>i1</name></decl>, <decl><type ref="prev"/><name>i2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcNum</name></type> <name>conv</name></decl>, <decl><type ref="prev"/><name>temp1</name></decl>, <decl><type ref="prev"/><name>temp2</name></decl>, <decl><type ref="prev"/><name>temp3</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcDig</name></type> <name><name>temp1_num</name><index>[<expr><name>BC_RAND_NUM_SIZE</name></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>temp2_num</name><index>[<expr><name>BC_RAND_NUM_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcDig</name></type> <name><name>conv_num</name><index>[<expr><name>BC_NUM_BIGDIG_LOG10</name></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_num_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>temp3</name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>*</operator> <name>BC_RAND_NUM_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>BC_SETJMP_LOCKED</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_num_setup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>temp1</name></expr></argument>, <argument><expr><name>temp1_num</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>temp1_num</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BcDig</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_setup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>temp2</name></expr></argument>, <argument><expr><name>temp2_num</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>temp2_num</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BcDig</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_setup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>conv</name></expr></argument>, <argument><expr><name>conv_num</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>conv_num</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BcDig</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_NONZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>max</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_NONZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>max2</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_rand_getRands</name><argument_list>(<argument><expr><name>rng</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_num_bigdig2num</name><argument_list>(<argument><expr><operator>&amp;</operator><name>conv</name></expr></argument>, <argument><expr><operator>(</operator><name>BcBigDig</name><operator>)</operator> <name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID_NP</name><argument_list>(<argument><expr><name>conv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_num_mul</name><argument_list>(<argument><expr><operator>&amp;</operator><name>conv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>max</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>temp1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_num_bigdig2num</name><argument_list>(<argument><expr><operator>&amp;</operator><name>conv</name></expr></argument>, <argument><expr><operator>(</operator><name>BcBigDig</name><operator>)</operator> <name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>conv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>temp1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>temp2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_num_div</name><argument_list>(<argument><expr><operator>&amp;</operator><name>temp2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>max2</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>temp3</name></expr></argument>, <argument><expr><name>BC_RAND_STATE_BITS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><call><name>bc_num_bigdig2num</name><argument_list>(<argument><expr><operator>&amp;</operator><name>conv</name></expr></argument>, <argument><expr><operator>(</operator><name>BcBigDig</name><operator>)</operator> <name>i2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID_NP</name><argument_list>(<argument><expr><name>conv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_num_mul</name><argument_list>(<argument><expr><operator>&amp;</operator><name>conv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>max</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>temp1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_num_bigdig2num</name><argument_list>(<argument><expr><operator>&amp;</operator><name>conv</name></expr></argument>, <argument><expr><operator>(</operator><name>BcBigDig</name><operator>)</operator> <name>i1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>conv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>temp1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>temp2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_num_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>temp2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>temp3</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>err</name>:</label>
<expr_stmt><expr><name>BC_SIG_MAYLOCK</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>temp3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>BC_LONGJMP_CONT</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>bc_num_irand</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>BcRNG</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>rng</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>BcNum</name></type> <name>atemp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>a</name> <operator>!=</operator> <name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><call><name>BC_NUM_NEG</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_err</name><argument_list>(<argument><expr><name>BC_ERR_MATH_NEGATIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_NUM_ZERO</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>BC_NUM_ONE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><call><name>bc_num_nonInt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>atemp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_err</name><argument_list>(<argument><expr><name>BC_ERR_MATH_NON_INTEGER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>atemp</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>atemp</name><operator>.</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>num</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>BcDig</name><operator>)</operator> <call><name>bc_rand_bounded</name><argument_list>(<argument><expr><name>rng</name></expr></argument>, <argument><expr><name>BC_BASE_POW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>




<if_stmt><if>if <condition>(<expr><name><name>atemp</name><operator>.</operator><name>num</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>num</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>BcDig</name><operator>)</operator> <call><name>bc_rand_bounded</name><argument_list>(<argument><expr><name>rng</name></expr></argument>, <argument><expr><operator>(</operator><name>BcRand</name><operator>)</operator> <name><name>atemp</name><operator>.</operator><name>num</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name><name>atemp</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
</block_content>}</block></if>

<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>bc_num_clean</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>size_t</name></type> <name>bc_num_addReq</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BcNum</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BcNum</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>scale</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>aint</name></decl>, <decl><type ref="prev"/><name>bint</name></decl>, <decl><type ref="prev"/><name>ardx</name></decl>, <decl><type ref="prev"/><name>brdx</name></decl>;</decl_stmt>




<expr_stmt><expr><call><name>BC_UNUSED</name><argument_list>(<argument><expr><name>scale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ardx</name> <operator>=</operator> <call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>aint</name> <operator>=</operator> <call><name>bc_num_int</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>aint</name> <operator>&lt;=</operator> <name><name>a</name><operator>-&gt;</operator><name>len</name></name> <operator>&amp;&amp;</operator> <name>ardx</name> <operator>&lt;=</operator> <name><name>a</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>brdx</name> <operator>=</operator> <call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bint</name> <operator>=</operator> <call><name>bc_num_int</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>bint</name> <operator>&lt;=</operator> <name><name>b</name><operator>-&gt;</operator><name>len</name></name> <operator>&amp;&amp;</operator> <name>brdx</name> <operator>&lt;=</operator> <name><name>b</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ardx</name> <operator>=</operator> <call><name>BC_MAX</name><argument_list>(<argument><expr><name>ardx</name></expr></argument>, <argument><expr><name>brdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>aint</name> <operator>=</operator> <call><name>BC_MAX</name><argument_list>(<argument><expr><name>aint</name></expr></argument>, <argument><expr><name>bint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>bc_vm_growSize</name><argument_list>(<argument><expr><call><name>bc_vm_growSize</name><argument_list>(<argument><expr><name>ardx</name></expr></argument>, <argument><expr><name>aint</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>bc_num_mulReq</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BcNum</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BcNum</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>scale</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>max</name></decl>, <decl><type ref="prev"/><name>rdx</name></decl>;</decl_stmt>



<expr_stmt><expr><name>rdx</name> <operator>=</operator> <call><name>bc_vm_growSize</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>max</name> <operator>=</operator> <call><name>BC_NUM_RDX</name><argument_list>(<argument><expr><name>scale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>max</name> <operator>=</operator> <call><name>bc_vm_growSize</name><argument_list>(<argument><expr><call><name>BC_MAX</name><argument_list>(<argument><expr><name>max</name></expr></argument>, <argument><expr><name>rdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rdx</name> <operator>=</operator> <call><name>bc_vm_growSize</name><argument_list>(<argument><expr><call><name>bc_vm_growSize</name><argument_list>(<argument><expr><call><name>bc_num_int</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>bc_num_int</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>rdx</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>bc_num_divReq</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BcNum</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BcNum</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>scale</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>max</name></decl>, <decl><type ref="prev"/><name>rdx</name></decl>;</decl_stmt>



<expr_stmt><expr><name>rdx</name> <operator>=</operator> <call><name>bc_vm_growSize</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>max</name> <operator>=</operator> <call><name>BC_NUM_RDX</name><argument_list>(<argument><expr><name>scale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>max</name> <operator>=</operator> <call><name>bc_vm_growSize</name><argument_list>(<argument><expr><call><name>BC_MAX</name><argument_list>(<argument><expr><name>max</name></expr></argument>, <argument><expr><name>rdx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rdx</name> <operator>=</operator> <call><name>bc_vm_growSize</name><argument_list>(<argument><expr><call><name>bc_num_int</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>rdx</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>bc_num_powReq</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BcNum</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BcNum</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>scale</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>BC_UNUSED</name><argument_list>(<argument><expr><name>scale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>bc_vm_growSize</name><argument_list>(<argument><expr><call><name>bc_vm_growSize</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLE_EXTRA_MATH</name></expr></cpp:if>
<function><type><name>size_t</name></type> <name>bc_num_placesReq</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BcNum</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BcNum</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>scale</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>BC_UNUSED</name><argument_list>(<argument><expr><name>scale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>a</name><operator>-&gt;</operator><name>len</name></name> <operator>+</operator> <name><name>b</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type> <name>bc_num_add</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>scale</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_binary</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>bc_num_as</name></expr></argument>, <argument><expr><call><name>bc_num_addReq</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>scale</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>bc_num_sub</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>scale</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_binary</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>bc_num_as</name></expr></argument>, <argument><expr><call><name>bc_num_addReq</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>scale</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>bc_num_mul</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>scale</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_binary</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>scale</name></expr></argument>, <argument><expr><name>bc_num_m</name></expr></argument>, <argument><expr><call><name>bc_num_mulReq</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>scale</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>bc_num_div</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>scale</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_binary</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>scale</name></expr></argument>, <argument><expr><name>bc_num_d</name></expr></argument>, <argument><expr><call><name>bc_num_divReq</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>scale</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>bc_num_mod</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>scale</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_binary</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>scale</name></expr></argument>, <argument><expr><name>bc_num_rem</name></expr></argument>, <argument><expr><call><name>bc_num_divReq</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>scale</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>bc_num_pow</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>scale</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_binary</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>scale</name></expr></argument>, <argument><expr><name>bc_num_p</name></expr></argument>, <argument><expr><call><name>bc_num_powReq</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>scale</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLE_EXTRA_MATH</name></expr></cpp:if>
<function><type><name>void</name></type> <name>bc_num_places</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>scale</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_binary</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>scale</name></expr></argument>, <argument><expr><name>bc_num_place</name></expr></argument>, <argument><expr><call><name>bc_num_placesReq</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>scale</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>bc_num_lshift</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>scale</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_binary</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>scale</name></expr></argument>, <argument><expr><name>bc_num_left</name></expr></argument>, <argument><expr><call><name>bc_num_placesReq</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>scale</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>bc_num_rshift</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>scale</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_binary</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>scale</name></expr></argument>, <argument><expr><name>bc_num_right</name></expr></argument>, <argument><expr><call><name>bc_num_placesReq</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>scale</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type> <name>bc_num_sqrt</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>scale</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>BcNum</name></type> <name>num1</name></decl>, <decl><type ref="prev"/><name>num2</name></decl>, <decl><type ref="prev"/><name>half</name></decl>, <decl><type ref="prev"/><name>f</name></decl>, <decl><type ref="prev"/><name>fprime</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>x0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>x1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>temp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>pow</name></decl>, <decl><type ref="prev"/><name>len</name></decl>, <decl><type ref="prev"/><name>rdx</name></decl>, <decl><type ref="prev"/><name>req</name></decl>, <decl><type ref="prev"/><name>resscale</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcDig</name></type> <name><name>half_digs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>a</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>b</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>a</name> <operator>!=</operator> <name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><call><name>BC_NUM_NEG</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_err</name><argument_list>(<argument><expr><name>BC_ERR_MATH_NEGATIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>scale</name></name> <operator>&gt;</operator> <name>scale</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>scale</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>scale</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>bc_vm_growSize</name><argument_list>(<argument><expr><call><name>bc_num_intDigits</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rdx</name> <operator>=</operator> <call><name>BC_NUM_RDX</name><argument_list>(<argument><expr><name>scale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>req</name> <operator>=</operator> <call><name>bc_vm_growSize</name><argument_list>(<argument><expr><call><name>BC_MAX</name><argument_list>(<argument><expr><name>rdx</name></expr></argument>, <argument><expr><call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>




<expr_stmt><expr><call><name>bc_num_init</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><call><name>bc_vm_growSize</name><argument_list>(<argument><expr><name>req</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>a</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>b</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>a</name> <operator>!=</operator> <name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>num</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>b</name><operator>-&gt;</operator><name>num</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_NUM_ZERO</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bc_num_setToZero</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>scale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_NUM_ONE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bc_num_one</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_extend</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>scale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>rdx</name> <operator>=</operator> <call><name>BC_NUM_RDX</name><argument_list>(<argument><expr><name>scale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rdx</name> <operator>=</operator> <call><name>BC_MAX</name><argument_list>(<argument><expr><name>rdx</name></expr></argument>, <argument><expr><call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>bc_vm_growSize</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name>rdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_num_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>num1</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>num2</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_setup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>half</name></expr></argument>, <argument><expr><name>half_digs</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>half_digs</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BcDig</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><call><name>bc_num_one</name><argument_list>(<argument><expr><operator>&amp;</operator><name>half</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>half</name><operator>.</operator><name>num</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>BC_BASE_POW</name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>half</name><operator>.</operator><name>len</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BC_NUM_RDX_SET_NP</name><argument_list>(<argument><expr><name>half</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>half</name><operator>.</operator><name>scale</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_num_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>f</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fprime</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>BC_SETJMP_LOCKED</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>


<expr_stmt><expr><name>x0</name> <operator>=</operator> <operator>&amp;</operator><name>num1</name></expr>;</expr_stmt>
<expr_stmt><expr><name>x1</name> <operator>=</operator> <operator>&amp;</operator><name>num2</name></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_num_one</name><argument_list>(<argument><expr><name>x0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>pow</name> <operator>=</operator> <call><name>bc_num_intDigits</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<if_stmt><if>if <condition>(<expr><name>pow</name></expr>)</condition> <block>{<block_content>



<if_stmt><if>if <condition>(<expr><name>pow</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>x0</name><operator>-&gt;</operator><name>num</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name><name>x0</name><operator>-&gt;</operator><name>num</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">6</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>pow</name> <operator>-=</operator> <literal type="number">2</literal> <operator>-</operator> <operator>(</operator><name>pow</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_shiftLeft</name><argument_list>(<argument><expr><name>x0</name></expr></argument>, <argument><expr><name>pow</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name><name>x0</name><operator>-&gt;</operator><name>scale</name></name> <operator>=</operator> <name><name>x0</name><operator>-&gt;</operator><name>rdx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>resscale</name> <operator>=</operator> <operator>(</operator><name>scale</name> <operator>+</operator> <name>BC_BASE_DIGS</name><operator>)</operator> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>



<while>while <condition>(<expr><call><name>bc_num_cmp</name><argument_list>(<argument><expr><name>x1</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_NONZERO</name><argument_list>(<argument><expr><name>x0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><call><name>bc_num_div</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>f</name></expr></argument>, <argument><expr><name>resscale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_add</name><argument_list>(<argument><expr><name>x0</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>f</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fprime</name></expr></argument>, <argument><expr><name>resscale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID_NP</name><argument_list>(<argument><expr><name>fprime</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID_NP</name><argument_list>(<argument><expr><name>half</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_num_mul</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fprime</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>half</name></expr></argument>, <argument><expr><name>x1</name></expr></argument>, <argument><expr><name>resscale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>temp</name> <operator>=</operator> <name>x0</name></expr>;</expr_stmt>
<expr_stmt><expr><name>x0</name> <operator>=</operator> <name>x1</name></expr>;</expr_stmt>
<expr_stmt><expr><name>x1</name> <operator>=</operator> <name>temp</name></expr>;</expr_stmt>
</block_content>}</block></while>


<expr_stmt><expr><call><name>bc_num_copy</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>x0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>scale</name></name> <operator>&gt;</operator> <name>scale</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_num_truncate</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>scale</name></name> <operator>-</operator> <name>scale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>BC_NUM_NEG</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>BC_NUM_NONZERO</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name><name>b</name><operator>-&gt;</operator><name>len</name></name> <operator>||</operator> <operator>!</operator><name><name>b</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>b</name><operator>-&gt;</operator><name>len</name></name> <operator>||</operator> <name><name>b</name><operator>-&gt;</operator><name>num</name><index>[<expr><name><name>b</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>||</operator> <call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>b</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>err</name>:</label>
<expr_stmt><expr><name>BC_SIG_MAYLOCK</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fprime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>num2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>num1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>BC_LONGJMP_CONT</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>bc_num_divmod</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>scale</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>ts</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>ptr_a</name></decl>, <decl><type ref="prev"/><name>num2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>init</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>





<expr_stmt><expr><name>ts</name> <operator>=</operator> <call><name>BC_MAX</name><argument_list>(<argument><expr><name>scale</name> <operator>+</operator> <name><name>b</name><operator>-&gt;</operator><name>scale</name></name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>scale</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>bc_num_mulReq</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>a</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>b</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>d</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>c</name> <operator>!=</operator> <name>d</name> <operator>&amp;&amp;</operator> <name>a</name> <operator>!=</operator> <name>d</name> <operator>&amp;&amp;</operator> <name>b</name> <operator>!=</operator> <name>d</name> <operator>&amp;&amp;</operator> <name>b</name> <operator>!=</operator> <name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>a</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>num2</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BcNum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ptr_a</name> <operator>=</operator> <operator>&amp;</operator><name>num2</name></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_num_init</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>init</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>BC_SETJMP_LOCKED</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>ptr_a</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_expand</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_NUM_NONZERO</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>b</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>scale</name></expr>)</condition>
<block>{<block_content>
<decl_stmt><decl><type><name>BcBigDig</name></type> <name>rem</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>bc_num_divArray</name><argument_list>(<argument><expr><name>ptr_a</name></expr></argument>, <argument><expr><operator>(</operator><name>BcBigDig</name><operator>)</operator> <name><name>b</name><operator>-&gt;</operator><name>num</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>rem</name> <operator>&lt;</operator> <name>BC_BASE_POW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>num</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>BcDig</name><operator>)</operator> <name>rem</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <operator>(</operator><name>rem</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if>

<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_num_r</name><argument_list>(<argument><expr><name>ptr_a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>scale</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>BC_NUM_NEG</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>BC_NUM_NONZERO</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name><name>c</name><operator>-&gt;</operator><name>len</name></name> <operator>||</operator> <operator>!</operator><name><name>c</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>c</name><operator>-&gt;</operator><name>len</name></name> <operator>||</operator> <name><name>c</name><operator>-&gt;</operator><name>num</name><index>[<expr><name><name>c</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>||</operator> <call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>c</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>BC_NUM_NEG</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>BC_NUM_NONZERO</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name><name>d</name><operator>-&gt;</operator><name>len</name></name> <operator>||</operator> <operator>!</operator><name><name>d</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>d</name><operator>-&gt;</operator><name>len</name></name> <operator>||</operator> <name><name>d</name><operator>-&gt;</operator><name>num</name><index>[<expr><name><name>d</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>||</operator> <call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>d</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>err</name>:</label>

<if_stmt><if>if <condition>(<expr><name>init</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>BC_SIG_MAYLOCK</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>num2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>BC_LONGJMP_CONT</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>bc_num_modexp</name><parameter_list>(<parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>d</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>BcNum</name></type> <name>base</name></decl>, <decl><type ref="prev"/><name>exp</name></decl>, <decl><type ref="prev"/><name>two</name></decl>, <decl><type ref="prev"/><name>temp</name></decl>, <decl><type ref="prev"/><name>atemp</name></decl>, <decl><type ref="prev"/><name>btemp</name></decl>, <decl><type ref="prev"/><name>ctemp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcDig</name></type> <name><name>two_digs</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>a</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>b</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>d</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>a</name> <operator>!=</operator> <name>d</name> <operator>&amp;&amp;</operator> <name>b</name> <operator>!=</operator> <name>d</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><call><name>BC_NUM_ZERO</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_err</name><argument_list>(<argument><expr><name>BC_ERR_MATH_DIVIDE_BY_ZERO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><call><name>BC_NUM_NEG</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_err</name><argument_list>(<argument><expr><name>BC_ERR_MATH_NEGATIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr_stmt><expr><name><name>btemp</name><operator>.</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctemp</name><operator>.</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><call><name>bc_num_nonInt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>atemp</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>bc_num_nonInt</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>btemp</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>bc_num_nonInt</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctemp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>bc_err</name><argument_list>(<argument><expr><name>BC_ERR_MATH_NON_INTEGER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>bc_num_expand</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name><name>ctemp</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_num_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>base</name></expr></argument>, <argument><expr><name><name>ctemp</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_setup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>two</name></expr></argument>, <argument><expr><name>two_digs</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>two_digs</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BcDig</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>temp</name></expr></argument>, <argument><expr><name><name>btemp</name><operator>.</operator><name>len</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_createCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>exp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>btemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>BC_SETJMP_LOCKED</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_num_one</name><argument_list>(<argument><expr><operator>&amp;</operator><name>two</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>two</name><operator>.</operator><name>num</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_one</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_num_rem</name><argument_list>(<argument><expr><operator>&amp;</operator><name>atemp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctemp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>base</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<while>while <condition>(<expr><call><name>BC_NUM_NONZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>exp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><call><name>bc_num_divmod</name><argument_list>(<argument><expr><operator>&amp;</operator><name>exp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>two</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>exp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>temp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BC_NUM_ONE</name><argument_list>(<argument><expr><operator>&amp;</operator><name>temp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>BC_NUM_NEG_NP</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID_NP</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_num_mul</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>temp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_num_rem</name><argument_list>(<argument><expr><operator>&amp;</operator><name>temp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctemp</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID_NP</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_num_mul</name><argument_list>(<argument><expr><operator>&amp;</operator><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>temp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_num_rem</name><argument_list>(<argument><expr><operator>&amp;</operator><name>temp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctemp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>base</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>

<label><name>err</name>:</label>
<expr_stmt><expr><name>BC_SIG_MAYLOCK</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>exp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>BC_LONGJMP_CONT</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>BC_NUM_NEG</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>d</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>d</name><operator>-&gt;</operator><name>len</name></name> <operator>||</operator> <name><name>d</name><operator>-&gt;</operator><name>num</name><index>[<expr><name><name>d</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>||</operator> <call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>d</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_DEBUG_CODE</name></expr></cpp:if>
<function><type><name>void</name></type> <name>bc_num_printDebug</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BcNum</name> <modifier>*</modifier></type><name>n</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>emptyline</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>bc_file_puts</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>fout</name></name></expr></argument>, <argument><expr><name>bc_flush_none</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_file_puts</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>fout</name></name></expr></argument>, <argument><expr><name>bc_flush_none</name></expr></argument>, <argument><expr><literal type="string">": "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_printDecimal</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_file_putchar</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>fout</name></name></expr></argument>, <argument><expr><name>bc_flush_err</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>emptyline</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_file_putchar</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>fout</name></name></expr></argument>, <argument><expr><name>bc_flush_err</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>vm</name><operator>.</operator><name>nchars</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>bc_num_printDigs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BcDig</name> <modifier>*</modifier></type><name>n</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>emptyline</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><operator>--</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_file_printf</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>fout</name></name></expr></argument>, <argument><expr><literal type="string">" %lu"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name><name>n</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><call><name>bc_file_putchar</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>fout</name></name></expr></argument>, <argument><expr><name>bc_flush_err</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>emptyline</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_file_putchar</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>fout</name></name></expr></argument>, <argument><expr><name>bc_flush_err</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>vm</name><operator>.</operator><name>nchars</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>bc_num_printWithDigs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BcNum</name> <modifier>*</modifier></type><name>n</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>emptyline</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>bc_file_puts</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>fout</name></name></expr></argument>, <argument><expr><name>bc_flush_none</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_file_printf</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>fout</name></name></expr></argument>, <argument><expr><literal type="string">" len: %zu, rdx: %zu, scale: %zu\n"</literal></expr></argument>,
<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>scale</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_printDigs</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name>emptyline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>bc_num_dump</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>varname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BcNum</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>ulong</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>scale</name> <init>= <expr><name><name>n</name><operator>-&gt;</operator><name>scale</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>bc_file_printf</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>ferr</name></name></expr></argument>, <argument><expr><literal type="string">"\n%s = %s"</literal></expr></argument>, <argument><expr><name>varname</name></expr></argument>,
<argument><expr><ternary><condition><expr><name><name>n</name><operator>-&gt;</operator><name>len</name></name></expr> ?</condition><then> <expr><operator>(</operator><ternary><condition><expr><call><name>BC_NUM_NEG</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"-"</literal></expr> </then><else>: <expr><literal type="string">"+"</literal></expr></else></ternary><operator>)</operator></expr> </then><else>: <expr><literal type="string">"0 "</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>n</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><operator>--</operator><name>i</name></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal> <operator>==</operator> <call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_file_puts</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>ferr</name></name></expr></argument>, <argument><expr><name>bc_flush_none</name></expr></argument>, <argument><expr><literal type="string">". "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>scale</name> <operator>/</operator> <name>BC_BASE_DIGS</name> <operator>!=</operator> <call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_file_printf</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>ferr</name></name></expr></argument>, <argument><expr><literal type="string">"%lu "</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name><name>n</name><operator>-&gt;</operator><name>num</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>mod</name> <init>= <expr><name>scale</name> <operator>%</operator> <name>BC_BASE_DIGS</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>d</name> <init>= <expr><name>BC_BASE_DIGS</name> <operator>-</operator> <name>mod</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcDig</name></type> <name>div</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>mod</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>div</name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>num</name><index>[<expr><name>i</name></expr>]</index></name> <operator>/</operator> <operator>(</operator><operator>(</operator><name>BcDig</name><operator>)</operator> <name><name>bc_num_pow10</name><index>[<expr><operator>(</operator><name>ulong</name><operator>)</operator> <name>d</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_file_printf</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>ferr</name></name></expr></argument>, <argument><expr><literal type="string">"%lu"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name>div</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>div</name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>num</name><index>[<expr><name>i</name></expr>]</index></name> <operator>%</operator> <operator>(</operator><operator>(</operator><name>BcDig</name><operator>)</operator> <name><name>bc_num_pow10</name><index>[<expr><operator>(</operator><name>ulong</name><operator>)</operator> <name>d</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_file_printf</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>ferr</name></name></expr></argument>, <argument><expr><literal type="string">" ' %lu "</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name>div</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>bc_file_printf</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>ferr</name></name></expr></argument>, <argument><expr><literal type="string">"(%zu | %zu.%zu / %zu) %lu\n"</literal></expr></argument>,
<argument><expr><name><name>n</name><operator>-&gt;</operator><name>scale</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>cap</name></name></expr></argument>,
<argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <operator>(</operator><name>void</name><operator>*</operator><operator>)</operator> <name><name>n</name><operator>-&gt;</operator><name>num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_file_flush</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>ferr</name></name></expr></argument>, <argument><expr><name>bc_flush_err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
