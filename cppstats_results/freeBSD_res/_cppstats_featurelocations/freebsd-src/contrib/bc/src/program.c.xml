<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/bc/src/program.c">


































<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdbool.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;setjmp.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;read.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;parse.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;program.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vm.h&gt;</cpp:file></cpp:include>







<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>bc_program_setVecs</name><parameter_list>(<parameter><decl><type><name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>BcFunc</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>BC_SIG_ASSERT_LOCKED</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>consts</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>f</name><operator>-&gt;</operator><name>consts</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>strs</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>f</name><operator>-&gt;</operator><name>strs</name></name></expr>;</expr_stmt>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>bc_program_type_num</name><parameter_list>(<parameter><decl><type><name>BcResult</name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLED</name></expr></cpp:if>


<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>t</name></name> <operator>!=</operator> <name>BC_RESULT_VOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><operator>!</operator><call><name>BC_PROG_NUM</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_err</name><argument_list>(<argument><expr><name>BC_ERR_EXEC_TYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLED</name></expr></cpp:if>






<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_program_type_match</name><parameter_list>(<parameter><decl><type><name>BcResult</name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><name>BcType</name></type> <name>t</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><operator>(</operator><name><name>r</name><operator>-&gt;</operator><name>t</name></name> <operator>!=</operator> <name>BC_RESULT_ARRAY</name><operator>)</operator> <operator>!=</operator> <operator>(</operator><operator>!</operator><name>t</name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_err</name><argument_list>(<argument><expr><name>BC_ERR_EXEC_TYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>










<function><type><specifier>static</specifier> <name>size_t</name></type> <name>bc_program_index</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>bgn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uchar</name></type> <name>amt</name> <init>= <expr><operator>(</operator><name>uchar</name><operator>)</operator> <name><name>code</name><index>[<expr><operator>(</operator><operator>*</operator><name>bgn</name><operator>)</operator><operator>++</operator></expr>]</index></name></expr></init></decl>, <decl><type ref="prev"/><name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>res</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>amt</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr><operator>,</operator> <expr><operator>++</operator><operator>(</operator><operator>*</operator><name>bgn</name><operator>)</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>temp</name> <init>= <expr><operator>(</operator><operator>(</operator><name>size_t</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>uchar</name><operator>)</operator> <name><name>code</name><index>[<expr><operator>*</operator><name>bgn</name></expr>]</index></name><operator>)</operator> <operator>&amp;</operator> <name>UCHAR_MAX</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>res</name> <operator>|=</operator> <operator>(</operator><name>temp</name> <operator>&lt;&lt;</operator> <operator>(</operator><name>i</name> <operator>*</operator> <name>CHAR_BIT</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></for>

<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>char</name><modifier>*</modifier></type> <name>bc_program_string</name><parameter_list>(<parameter><decl><type><name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BcNum</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>BcFunc</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><call><name>bc_vec_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>fns</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>rdx</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator> <call><name>bc_vec_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>f</name><operator>-&gt;</operator><name>strs</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>scale</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLED</name></expr></cpp:if>







<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_program_prepGlobals</name><parameter_list>(<parameter><decl><type><name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>BC_PROG_GLOBALS_LEN</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_vec_push</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>globals_v</name></name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>globals</name></name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLE_EXTRA_MATH</name></expr></cpp:if>
<expr_stmt><expr><call><name>bc_rand_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>rng</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_program_popGlobals</name><parameter_list>(<parameter><decl><type><name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>reset</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>BC_SIG_ASSERT_LOCKED</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>BC_PROG_GLOBALS_LEN</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>BcVec</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>globals_v</name></name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>bc_vec_npop</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><ternary><condition><expr><name>reset</name></expr> ?</condition><then> <expr><name><name>v</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>globals</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>BC_PROG_GLOBAL</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLE_EXTRA_MATH</name></expr></cpp:if>
<expr_stmt><expr><call><name>bc_rand_pop</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>rng</name></name></expr></argument>, <argument><expr><name>reset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>BcVec</name><modifier>*</modifier></type> <name>bc_program_dereference</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>BcVec</name> <modifier>*</modifier></type><name>vec</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>BcVec</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>vidx</name></decl>, <decl><type ref="prev"/><name>nidx</name></decl>, <decl><type ref="prev"/><name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>vec</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uchar</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>vidx</name> <operator>=</operator> <call><name>bc_program_index</name><argument_list>(<argument><expr><name><name>vec</name><operator>-&gt;</operator><name>v</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nidx</name> <operator>=</operator> <call><name>bc_program_index</name><argument_list>(<argument><expr><name><name>vec</name><operator>-&gt;</operator><name>v</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>bc_vec_item</name><argument_list>(<argument><expr><call><name>bc_vec_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>arrs</name></name></expr></argument>, <argument><expr><name>vidx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>size</name></name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uchar</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>v</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>








<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_program_pushBigdig</name><parameter_list>(<parameter><decl><type><name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>BcBigDig</name></type> <name>dig</name></decl></parameter>, <parameter><decl><type><name>BcResultType</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>BcResult</name></type> <name>res</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>res</name><operator>.</operator><name>t</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_num_createFromBigdig</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>res</name><operator>.</operator><name>d</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><name>dig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_vec_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>bc_program_addString</name><parameter_list>(<parameter><decl><type><name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>fidx</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>BcFunc</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>str_ptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcVec</name> <modifier>*</modifier></type><name>slabs</name></decl>;</decl_stmt>

<expr_stmt><expr><name>BC_SIG_ASSERT_LOCKED</name></expr>;</expr_stmt>


<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>bc_vec_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>fns</name></name></expr></argument>, <argument><expr><name>fidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>str_ptr</name> <operator>=</operator> <call><name>bc_vec_pushEmpty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>f</name><operator>-&gt;</operator><name>strs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>slabs</name> <operator>=</operator> <ternary><condition><expr><name>fidx</name> <operator>==</operator> <name>BC_PROG_MAIN</name> <operator>||</operator> <name>fidx</name> <operator>==</operator> <name>BC_PROG_READ</name></expr> ?</condition><then>
<expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>main_slabs</name></name></expr> </then><else>: <expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>other_slabs</name></name></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>str_ptr</name> <operator>=</operator> <call><name>bc_slabvec_strdup</name><argument_list>(<argument><expr><name>slabs</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name><name>f</name><operator>-&gt;</operator><name>strs</name><operator>.</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>bc_program_search</name><parameter_list>(<parameter><decl><type><name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>var</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>BcVec</name> <modifier>*</modifier></type><name>v</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>BC_SIG_ASSERT_LOCKED</name></expr>;</expr_stmt>


<expr_stmt><expr><name>v</name> <operator>=</operator> <ternary><condition><expr><name>var</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>vars</name></name></expr> </then><else>: <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>arrs</name></name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>map</name> <operator>=</operator> <ternary><condition><expr><name>var</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>var_map</name></name></expr> </then><else>: <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>arr_map</name></name></expr></else></ternary></expr>;</expr_stmt>





<if_stmt><if>if <condition>(<expr><call><name>bc_map_insert</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>BcVec</name> <modifier>*</modifier></type><name>temp</name> <init>= <expr><call><name>bc_vec_pushEmpty</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>bc_array_init</name><argument_list>(<argument><expr><name>temp</name></expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><operator>(</operator><operator>(</operator><name>BcId</name><operator>*</operator><operator>)</operator> <call><name>bc_vec_item</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>idx</name></expr>;</return>
</block_content>}</block></function>









<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>BcVec</name><modifier>*</modifier></type> <name>bc_program_vec</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>idx</name></decl></parameter>, <parameter><decl><type><name>BcType</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>BcVec</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>type</name> <operator>==</operator> <name>BC_TYPE_VAR</name><operator>)</operator></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>vars</name></name></expr> </then><else>: <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>arrs</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>bc_vec_item</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>












<function><type><specifier>static</specifier> <name>BcNum</name><modifier>*</modifier></type> <name>bc_program_num</name><parameter_list>(<parameter><decl><type><name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>BcResult</name> <modifier>*</modifier></type><name>r</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>




<expr_stmt><expr><name>n</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<switch>switch <condition>(<expr><name><name>r</name><operator>-&gt;</operator><name>t</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>BC_RESULT_STR</name></expr>:</case>
<case>case <expr><name>BC_RESULT_TEMP</name></expr>:</case>
<case>case <expr><name>BC_RESULT_IBASE</name></expr>:</case>
<case>case <expr><name>BC_RESULT_SCALE</name></expr>:</case>
<case>case <expr><name>BC_RESULT_OBASE</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLE_EXTRA_MATH</name></expr></cpp:if>
<case>case <expr><name>BC_RESULT_SEED</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>&amp;</operator><name><name>r</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>n</name></name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>

<case>case <expr><name>BC_RESULT_VAR</name></expr>:</case>
<case>case <expr><name>BC_RESULT_ARRAY</name></expr>:</case>
<case>case <expr><name>BC_RESULT_ARRAY_ELEM</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>BcVec</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcType</name></type> <name>type</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>r</name><operator>-&gt;</operator><name>t</name></name> <operator>==</operator> <name>BC_RESULT_VAR</name><operator>)</operator></expr> ?</condition><then> <expr><name>BC_TYPE_VAR</name></expr> </then><else>: <expr><name>BC_TYPE_ARRAY</name></expr></else></ternary></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>bc_program_vec</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>loc</name><operator>.</operator><name>loc</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<if_stmt><if>if <condition>(<expr><name><name>r</name><operator>-&gt;</operator><name>t</name></name> <operator>==</operator> <name>BC_RESULT_ARRAY_ELEM</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>idx</name> <init>= <expr><name><name>r</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>loc</name><operator>.</operator><name>idx</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>bc_vec_top</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLED</name></expr></cpp:if>






<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uchar</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>bc_program_dereference</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BcNum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>






<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>len</name></name> <operator>&lt;=</operator> <name>idx</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_array_expand</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>bc_vm_growSize</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>bc_vec_item</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>


<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>bc_vec_top</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<break>break;</break>
</block_content>}</block>

<case>case <expr><name>BC_RESULT_ZERO</name></expr>:</case>
<block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>zero</name></name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>

<case>case <expr><name>BC_RESULT_ONE</name></expr>:</case>
<block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>one</name></name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLED</name></expr></cpp:if>


<case>case <expr><name>BC_RESULT_VOID</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<block>{<block_content>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<case>case <expr><name>BC_RESULT_LAST</name></expr>:</case>
<block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>last</name></name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></switch>

<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>










<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_program_operand</name><parameter_list>(<parameter><decl><type><name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>BcResult</name> <modifier>*</modifier><modifier>*</modifier></type><name>r</name></decl></parameter>,
<parameter><decl><type><name>BcNum</name> <modifier>*</modifier><modifier>*</modifier></type><name>n</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>idx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>r</name> <operator>=</operator> <call><name>bc_vec_item_rev</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLED</name></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>r</name><operator>)</operator><operator>-&gt;</operator><name>t</name></name> <operator>==</operator> <name>BC_RESULT_VOID</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_err</name><argument_list>(<argument><expr><name>BC_ERR_EXEC_VOID_VAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><operator>*</operator><name>n</name> <operator>=</operator> <call><name>bc_program_num</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>*</operator><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>















<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_program_binPrep</name><parameter_list>(<parameter><decl><type><name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>BcResult</name> <modifier>*</modifier><modifier>*</modifier></type><name>l</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier><modifier>*</modifier></type><name>ln</name></decl></parameter>,
<parameter><decl><type><name>BcResult</name> <modifier>*</modifier><modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier><modifier>*</modifier></type><name>rn</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>idx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>BcResultType</name></type> <name>lt</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>p</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>l</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>ln</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>r</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>rn</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>BC_PROG_NO_STACK_CHECK</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>BC_IS_DC</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><operator>!</operator><call><name>BC_PROG_STACK</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><name>idx</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_err</name><argument_list>(<argument><expr><name>BC_ERR_EXEC_STACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_PROG_STACK</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><name>idx</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_program_operand</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><name>ln</name></expr></argument>, <argument><expr><name>idx</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_program_operand</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>rn</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>lt</name> <operator>=</operator> <name><operator>(</operator><operator>*</operator><name>l</name><operator>)</operator><operator>-&gt;</operator><name>t</name></name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLED</name></expr></cpp:if>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>lt</name> <operator>!=</operator> <name>BC_RESULT_VOID</name> <operator>&amp;&amp;</operator> <name><operator>(</operator><operator>*</operator><name>r</name><operator>)</operator><operator>-&gt;</operator><name>t</name></name> <operator>!=</operator> <name>BC_RESULT_VOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>




<if_stmt><if>if <condition>(<expr><name>lt</name> <operator>==</operator> <name><operator>(</operator><operator>*</operator><name>r</name><operator>)</operator><operator>-&gt;</operator><name>t</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>lt</name> <operator>==</operator> <name>BC_RESULT_VAR</name> <operator>||</operator> <name>lt</name> <operator>==</operator> <name>BC_RESULT_ARRAY_ELEM</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>ln</name> <operator>=</operator> <call><name>bc_program_num</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>*</operator><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><name>lt</name> <operator>==</operator> <name>BC_RESULT_STR</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_err</name><argument_list>(<argument><expr><name>BC_ERR_EXEC_TYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

















<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_program_binOpPrep</name><parameter_list>(<parameter><decl><type><name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>BcResult</name> <modifier>*</modifier><modifier>*</modifier></type><name>l</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier><modifier>*</modifier></type><name>ln</name></decl></parameter>,
<parameter><decl><type><name>BcResult</name> <modifier>*</modifier><modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier><modifier>*</modifier></type><name>rn</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>idx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>bc_program_binPrep</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><name>ln</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>rn</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_program_type_num</name><argument_list>(<argument><expr><operator>*</operator><name>l</name></expr></argument>, <argument><expr><operator>*</operator><name>ln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_program_type_num</name><argument_list>(<argument><expr><operator>*</operator><name>r</name></expr></argument>, <argument><expr><operator>*</operator><name>rn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>













<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_program_assignPrep</name><parameter_list>(<parameter><decl><type><name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>BcResult</name> <modifier>*</modifier><modifier>*</modifier></type><name>l</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier><modifier>*</modifier></type><name>ln</name></decl></parameter>,
<parameter><decl><type><name>BcResult</name> <modifier>*</modifier><modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier><modifier>*</modifier></type><name>rn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>BcResultType</name></type> <name>lt</name></decl>, <decl><type ref="prev"/><name>min</name></decl>;</decl_stmt>


<expr_stmt><expr><name>min</name> <operator>=</operator> <name>BC_RESULT_TEMP</name> <operator>-</operator> <operator>(</operator><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <operator>(</operator><name>BC_IS_BC</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_program_binPrep</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><name>ln</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>rn</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>lt</name> <operator>=</operator> <name><operator>(</operator><operator>*</operator><name>l</name><operator>)</operator><operator>-&gt;</operator><name>t</name></name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><name>lt</name> <operator>&gt;=</operator> <name>min</name> <operator>&amp;&amp;</operator> <name>lt</name> <operator>&lt;=</operator> <name>BC_RESULT_ONE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_err</name><argument_list>(<argument><expr><name>BC_ERR_EXEC_TYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>good</name> <init>= <expr><operator>(</operator><name><operator>(</operator><operator>*</operator><name>r</name><operator>)</operator><operator>-&gt;</operator><name>t</name></name> <operator>==</operator> <name>BC_RESULT_STR</name> <operator>&amp;&amp;</operator> <name>lt</name> <operator>&lt;=</operator> <name>BC_RESULT_ARRAY_ELEM</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_PROG_STR</name><argument_list>(<argument><expr><operator>*</operator><name>rn</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><operator>(</operator><operator>*</operator><name>r</name><operator>)</operator><operator>-&gt;</operator><name>t</name></name> <operator>!=</operator> <name>BC_RESULT_STR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name>good</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_program_type_num</name><argument_list>(<argument><expr><operator>*</operator><name>r</name></expr></argument>, <argument><expr><operator>*</operator><name>rn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_program_prep</name><parameter_list>(<parameter><decl><type><name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>BcResult</name> <modifier>*</modifier><modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier><modifier>*</modifier></type><name>n</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>idx</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>p</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>r</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>n</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>BC_PROG_NO_STACK_CHECK</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>BC_IS_DC</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><operator>!</operator><call><name>BC_PROG_STACK</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><name>idx</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_err</name><argument_list>(<argument><expr><name>BC_ERR_EXEC_STACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_PROG_STACK</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><name>idx</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_program_operand</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_program_type_num</name><argument_list>(<argument><expr><operator>*</operator><name>r</name></expr></argument>, <argument><expr><operator>*</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>BcResult</name><modifier>*</modifier></type> <name>bc_program_prepResult</name><parameter_list>(<parameter><decl><type><name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>BcResult</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>bc_vec_pushEmpty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>bc_result_clear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>










<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_program_const</name><parameter_list>(<parameter><decl><type><name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>code</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>bgn</name></decl></parameter>)</parameter_list> <block>{<block_content>



<decl_stmt><decl><type><name>BcResult</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><call><name>bc_program_prepResult</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcConst</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><call><name>bc_vec_item</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>consts</name></name></expr></argument>, <argument><expr><call><name>bc_program_index</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><name>bgn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcBigDig</name></type> <name>base</name> <init>= <expr><call><name>BC_PROG_IBASE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>base</name></name> <operator>!=</operator> <name>base</name></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>num</name><operator>.</operator><name>num</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><call><name>BC_NUM_RDX</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>bc_num_parse</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <name>base</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_num_createCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>r</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_program_op</name><parameter_list>(<parameter><decl><type><name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>uchar</name></type> <name>inst</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>BcResult</name> <modifier>*</modifier></type><name>opd1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>opd2</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>n1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>n2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>idx</name> <init>= <expr><name>inst</name> <operator>-</operator> <name>BC_INST_POWER</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>bc_program_prepResult</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_program_binOpPrep</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opd1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opd2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>




<macro><name>bc_num_init</name><argument_list>(<argument>&amp;res-&gt;d.n</argument>, <argument>bc_program_opReqs[idx](n1, n2, BC_PROG_SCALE(p))</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID</name><argument_list>(<argument><expr><name>n1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID</name><argument_list>(<argument><expr><name>n2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name><name>bc_program_ops</name><index>[<expr><name>idx</name></expr>]</index></name><operator>(</operator><name>n1</name><operator>,</operator> <name>n2</name><operator>,</operator> <operator>&amp;</operator><name><name>res</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>n</name></name><operator>,</operator> <call><name>BC_PROG_SCALE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_program_retire</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_program_read</name><parameter_list>(<parameter><decl><type><name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>BcStatus</name></type> <name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcInstPtr</name></type> <name>ip</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>is_stdin</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcFunc</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><call><name>bc_vec_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>fns</name></name></expr></argument>, <argument><expr><name>BC_PROG_READ</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>



<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>p</name><operator>-&gt;</operator><name>stack</name><operator>.</operator><name>len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>BcInstPtr</name> <modifier>*</modifier></type><name>ip_ptr</name> <init>= <expr><call><name>bc_vec_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ip_ptr</name><operator>-&gt;</operator><name>func</name></name> <operator>==</operator> <name>BC_PROG_READ</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_err</name><argument_list>(<argument><expr><name>BC_ERR_EXEC_REC_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>


<expr_stmt><expr><name>file</name> <operator>=</operator> <name><name>vm</name><operator>.</operator><name>file</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>is_stdin</name> <operator>=</operator> <name><name>vm</name><operator>.</operator><name>is_stdin</name></name></expr>;</expr_stmt>



<expr_stmt><expr><name><name>vm</name><operator>.</operator><name>is_stdin</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BC_PARSE_IS_INITED</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>read_prs</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>






<expr_stmt><expr><call><name>bc_parse_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>read_prs</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_PROG_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><call><name>bc_vec_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>read_buf</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>BC_DTOR_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>


<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_parse_updateFunc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>read_prs</name></name></expr></argument>, <argument><expr><name>BC_PROG_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>BC_SETJMP_LOCKED</name><argument_list>(<argument><expr><name>exec_err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_lex_file</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>read_prs</name><operator>.</operator><name>l</name></name></expr></argument>, <argument><expr><name>bc_program_stdin_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_vec_popAll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>f</name><operator>-&gt;</operator><name>code</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name>BC_R</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>bc_read_line</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>read_buf</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>bc_read_line</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>read_buf</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name>BC_IS_BC</name></expr> ?</condition><then> <expr><literal type="string">"read&gt; "</literal></expr> </then><else>: <expr><literal type="string">"?&gt; "</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <name>BC_STATUS_EOF</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_err</name><argument_list>(<argument><expr><name>BC_ERR_EXEC_READ_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>bc_parse_text</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>read_prs</name></name></expr></argument>, <argument><expr><name><name>vm</name><operator>.</operator><name>read_buf</name><operator>.</operator><name>v</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>vm</name><operator>.</operator><name>expr</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>read_prs</name></name></expr></argument>, <argument><expr><name>BC_PARSE_NOREAD</name> <operator>|</operator> <name>BC_PARSE_NEEDVAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><name><name>vm</name><operator>.</operator><name>read_prs</name><operator>.</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>!=</operator> <name>BC_LEX_NLINE</name> <operator>&amp;&amp;</operator>
<name><name>vm</name><operator>.</operator><name>read_prs</name><operator>.</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>!=</operator> <name>BC_LEX_EOF</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>bc_err</name><argument_list>(<argument><expr><name>BC_ERR_EXEC_READ_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLED</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>BC_G</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_program_prepGlobals</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<expr_stmt><expr><name><name>ip</name><operator>.</operator><name>func</name></name> <operator>=</operator> <name>BC_PROG_READ</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ip</name><operator>.</operator><name>idx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ip</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>results</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>


<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>bc_vec_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>fns</name></name></expr></argument>, <argument><expr><name>BC_PROG_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_vec_pushByte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>f</name><operator>-&gt;</operator><name>code</name></name></expr></argument>, <argument><expr><name><name>vm</name><operator>.</operator><name>read_ret</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_vec_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DC_ENABLED</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>BC_IS_DC</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>temp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>bc_vec_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>tail_calls</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<label><name>exec_err</name>:</label>
<expr_stmt><expr><name>BC_SIG_MAYLOCK</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vm</name><operator>.</operator><name>is_stdin</name></name> <operator>=</operator> <name>is_stdin</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vm</name><operator>.</operator><name>file</name></name> <operator>=</operator> <name>file</name></expr>;</expr_stmt>
<expr_stmt><expr><name>BC_LONGJMP_CONT</name></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLE_EXTRA_MATH</name></expr></cpp:if>





<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_program_rand</name><parameter_list>(<parameter><decl><type><name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>BcRand</name></type> <name>rand</name> <init>= <expr><call><name>bc_rand_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>rng</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>bc_program_pushBigdig</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>BcBigDig</name><operator>)</operator> <name>rand</name></expr></argument>, <argument><expr><name>BC_RESULT_TEMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>


<block>{<block_content>
<decl_stmt><decl><type><name>BcResult</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><call><name>bc_vec_top</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID_NP</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>n</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>





<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_program_printChars</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><name><name>vm</name><operator>.</operator><name>nchars</name></name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sig_atomic_t</name></type> <name>lock</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>BC_SIG_TRYLOCK</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_file_puts</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>fout</name></name></expr></argument>, <argument><expr><name>bc_flush_save</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>nl</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>nl</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>nl</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>vm</name><operator>.</operator><name>nchars</name></name> <operator>=</operator> <ternary><condition><expr><name>len</name> <operator>&gt;</operator> <name>UINT16_MAX</name></expr> ?</condition><then> <expr><name>UINT16_MAX</name></expr> </then><else>: <expr><operator>(</operator><name>uint16_t</name><operator>)</operator> <name>len</name></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><call><name>BC_SIG_TRYUNLOCK</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_program_printString</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>str</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DC_ENABLED</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>len</name> <operator>&amp;&amp;</operator> <name>BC_IS_DC</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bc_vm_putchar</name><argument_list>(<argument><expr><literal type="char">'\0'</literal></expr></argument>, <argument><expr><name>bc_flush_save</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><name><name>str</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>!=</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>


<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>str</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>bc_program_esc_chars</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'n'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vm</name><operator>.</operator><name>nchars</name></name> <operator>=</operator> <name>UINT16_MAX</name></expr>;</expr_stmt>
<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>bc_program_esc_seqs</name><index>[<expr><operator>(</operator><name>size_t</name><operator>)</operator> <operator>(</operator><name>ptr</name> <operator>-</operator> <name>bc_program_esc_chars</name><operator>)</operator></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>



<expr_stmt><expr><call><name>bc_vm_putchar</name><argument_list>(<argument><expr><literal type="char">'\\'</literal></expr></argument>, <argument><expr><name>bc_flush_save</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>bc_vm_putchar</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>bc_flush_save</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_program_print</name><parameter_list>(<parameter><decl><type><name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>uchar</name></type> <name>inst</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>idx</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>BcResult</name> <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>pop</name> <init>= <expr><operator>(</operator><name>inst</name> <operator>!=</operator> <name>BC_INST_PRINT</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>BC_PROG_NO_STACK_CHECK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>BC_IS_DC</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><operator>!</operator><call><name>BC_PROG_STACK</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><name>idx</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_err</name><argument_list>(<argument><expr><name>BC_ERR_EXEC_STACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_PROG_STACK</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><name>idx</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>bc_vec_item_rev</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLED</name></expr></cpp:if>




<if_stmt><if>if <condition>(<expr><name><name>r</name><operator>-&gt;</operator><name>t</name></name> <operator>==</operator> <name>BC_RESULT_VOID</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><name>pop</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_err</name><argument_list>(<argument><expr><name>BC_ERR_EXEC_VOID_VAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>bc_vec_pop</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>bc_program_num</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_PROG_NUM</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLED</name></expr></cpp:if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>inst</name> <operator>!=</operator> <name>BC_INST_PRINT_STR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<expr_stmt><expr><call><name>bc_num_print</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><call><name>BC_PROG_OBASE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>!</operator><name>pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLED</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>BC_IS_BC</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_num_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>last</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if>
<else>else <block>{<block_content>


<expr_stmt><expr><call><name>bc_file_flush</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>fout</name></name></expr></argument>, <argument><expr><name>bc_flush_save</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>bc_program_string</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLED</name></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>inst</name> <operator>==</operator> <name>BC_INST_PRINT_STR</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_program_printChars</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{<block_content>
<expr_stmt><expr><call><name>bc_program_printString</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>inst</name> <operator>==</operator> <name>BC_INST_PRINT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_vm_putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>bc_flush_err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><name>BC_IS_BC</name> <operator>||</operator> <name>pop</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_vec_pop</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>bc_program_negate</name><parameter_list>(<parameter><decl><type><name>BcResult</name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>bc_num_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>r</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>BC_NUM_NONZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>r</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>BC_NUM_NEG_TGL_NP</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>bc_program_not</name><parameter_list>(<parameter><decl><type><name>BcResult</name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bc_num_cmpZero</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_num_one</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>r</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLE_EXTRA_MATH</name></expr></cpp:if>
<function><type><name>void</name></type> <name>bc_program_trunc</name><parameter_list>(<parameter><decl><type><name>BcResult</name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>bc_num_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>r</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_truncate</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>r</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>scale</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>






<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_program_unary</name><parameter_list>(<parameter><decl><type><name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>uchar</name></type> <name>inst</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>BcResult</name> <modifier>*</modifier></type><name>res</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>num</name></decl>;</decl_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>bc_program_prepResult</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_program_prep</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_num_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>res</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><name><name>num</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>


<expr_stmt><expr><name><name>bc_program_unarys</name><index>[<expr><name>inst</name> <operator>-</operator> <name>BC_INST_NEG</name></expr>]</index></name><operator>(</operator><name>res</name><operator>,</operator> <name>num</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_program_retire</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_program_logical</name><parameter_list>(<parameter><decl><type><name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>uchar</name></type> <name>inst</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>BcResult</name> <modifier>*</modifier></type><name>opd1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>opd2</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>n1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>n2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>cond</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>cmp</name></decl>;</decl_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>bc_program_prepResult</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><call><name>bc_program_binOpPrep</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opd1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opd2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name>inst</name> <operator>==</operator> <name>BC_INST_BOOL_AND</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>cond</name> <operator>=</operator> <operator>(</operator><call><name>bc_num_cmpZero</name><argument_list>(<argument><expr><name>n1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>bc_num_cmpZero</name><argument_list>(<argument><expr><name>n2</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>inst</name> <operator>==</operator> <name>BC_INST_BOOL_OR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>cond</name> <operator>=</operator> <operator>(</operator><call><name>bc_num_cmpZero</name><argument_list>(<argument><expr><name>n1</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>bc_num_cmpZero</name><argument_list>(<argument><expr><name>n2</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>


<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>bc_num_cmp</name><argument_list>(<argument><expr><name>n1</name></expr></argument>, <argument><expr><name>n2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>inst</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>BC_INST_REL_EQ</name></expr>:</case>
<block>{<block_content>
<expr_stmt><expr><name>cond</name> <operator>=</operator> <operator>(</operator><name>cmp</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>

<case>case <expr><name>BC_INST_REL_LE</name></expr>:</case>
<block>{<block_content>
<expr_stmt><expr><name>cond</name> <operator>=</operator> <operator>(</operator><name>cmp</name> <operator>&lt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>

<case>case <expr><name>BC_INST_REL_GE</name></expr>:</case>
<block>{<block_content>
<expr_stmt><expr><name>cond</name> <operator>=</operator> <operator>(</operator><name>cmp</name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>

<case>case <expr><name>BC_INST_REL_NE</name></expr>:</case>
<block>{<block_content>
<expr_stmt><expr><name>cond</name> <operator>=</operator> <operator>(</operator><name>cmp</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>

<case>case <expr><name>BC_INST_REL_LT</name></expr>:</case>
<block>{<block_content>
<expr_stmt><expr><name>cond</name> <operator>=</operator> <operator>(</operator><name>cmp</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>

<case>case <expr><name>BC_INST_REL_GT</name></expr>:</case>
<block>{<block_content>
<expr_stmt><expr><name>cond</name> <operator>=</operator> <operator>(</operator><name>cmp</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<default>default:</default>
<block>{<block_content>

<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></switch>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_num_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>res</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><name>BC_NUM_DEF_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cond</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_num_one</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>res</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>bc_program_retire</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>










<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_program_assignStr</name><parameter_list>(<parameter><decl><type><name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>num</name></decl></parameter>, <parameter><decl><type><name>BcVec</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>push</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_PROG_STACK</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <operator>!</operator><name>push</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>num</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>num</name><operator>-&gt;</operator><name>num</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>num</name><operator>-&gt;</operator><name>cap</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><operator>!</operator><name>push</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_vec_pop</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>bc_vec_npop</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <operator>!</operator><name>push</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>bc_vec_pushEmpty</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>num</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BcNum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>














<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_program_copyToVar</name><parameter_list>(<parameter><decl><type><name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>idx</name></decl></parameter>, <parameter><decl><type><name>BcType</name></type> <name>t</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>last</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>BcResult</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"/><name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcVec</name> <modifier>*</modifier></type><name>vec</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>var</name> <init>= <expr><operator>(</operator><name>t</name> <operator>==</operator> <name>BC_TYPE_VAR</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DC_ENABLED</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>BC_IS_DC</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><operator>!</operator><call><name>BC_PROG_STACK</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_err</name><argument_list>(<argument><expr><name>BC_ERR_EXEC_STACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_PROG_STACK</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_program_operand</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLED</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>BC_IS_BC</name></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><call><name>bc_program_type_match</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><operator>!</operator><name>last</name> <operator>&amp;&amp;</operator> <name>var</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>bc_vec_item_rev</name><argument_list>(<argument><expr><call><name>bc_program_vec</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>loc</name><operator>.</operator><name>loc</name></name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>vec</name> <operator>=</operator> <call><name>bc_program_vec</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name><name>ptr</name><operator>-&gt;</operator><name>t</name></name> <operator>==</operator> <name>BC_RESULT_STR</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_PROG_STR</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><operator>!</operator><name>var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_err</name><argument_list>(<argument><expr><name>BC_ERR_EXEC_TYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>bc_program_assignStr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>vec</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>var</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>BC_PROG_STR</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>r</name><operator>.</operator><name>d</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BcNum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_num_createCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>r</name><operator>.</operator><name>d</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>



<decl_stmt><decl><type><name>BcVec</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><operator>(</operator><name>BcVec</name><operator>*</operator><operator>)</operator> <name>n</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>rv</name> <init>= <expr><operator>&amp;</operator><name><name>r</name><operator>.</operator><name>d</name><operator>.</operator><name>v</name></name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLED</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>BC_IS_BC</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>BcVec</name> <modifier>*</modifier></type><name>parent</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>ref</name></decl>, <decl><type ref="prev"/><name>ref_size</name></decl>;</decl_stmt>




<expr_stmt><expr><name>parent</name> <operator>=</operator> <call><name>bc_program_vec</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>loc</name><operator>.</operator><name>loc</name></name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>parent</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name>last</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>bc_vec_item_rev</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><operator>!</operator><name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>v</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>ref</name> <operator>=</operator> <operator>(</operator><name><name>v</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BcNum</name></expr></argument>)</argument_list></sizeof> <operator>&amp;&amp;</operator> <name>t</name> <operator>==</operator> <name>BC_TYPE_REF</name><operator>)</operator></expr>;</expr_stmt>






<expr_stmt><expr><name>ref_size</name> <operator>=</operator> <operator>(</operator><name><name>v</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uchar</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>ref</name> <operator>||</operator> <operator>(</operator><name>ref_size</name> <operator>&amp;&amp;</operator> <name>t</name> <operator>==</operator> <name>BC_TYPE_REF</name><operator>)</operator></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><call><name>bc_vec_init</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uchar</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>BC_DTOR_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>ref</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;=</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <operator>(</operator><operator>!</operator><name>last</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>vec</name> <operator>=</operator> <call><name>bc_program_vec</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><call><name>bc_vec_pushIndex</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>loc</name><operator>.</operator><name>loc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_vec_pushIndex</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name><name>parent</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <operator>!</operator><name>last</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>


<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_vec_npush</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>len</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uchar</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>



<expr_stmt><expr><call><name>bc_vec_push</name><argument_list>(<argument><expr><name>vec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>r</name><operator>.</operator><name>d</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_vec_pop</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if>


<if type="elseif">else if <condition>(<expr><name>ref_size</name> <operator>&amp;&amp;</operator> <name>t</name> <operator>!=</operator> <name>BC_TYPE_REF</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>bc_program_dereference</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



<expr_stmt><expr><call><name>bc_array_init</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_array_copy</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<expr_stmt><expr><call><name>bc_vec_push</name><argument_list>(<argument><expr><name>vec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>r</name><operator>.</operator><name>d</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_vec_pop</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_program_assign</name><parameter_list>(<parameter><decl><type><name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>uchar</name></type> <name>inst</name></decl></parameter>)</parameter_list> <block>{<block_content>


<decl_stmt><decl><type><name>BcResult</name> <modifier>*</modifier></type><name>left</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>right</name></decl>, <decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>l</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>ob</name></decl>, <decl><type ref="prev"/><name>sc</name></decl>, <decl><type ref="prev"/><name>use_val</name> <init>= <expr><call><name>BC_INST_USE_VAL</name><argument_list>(<argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>bc_program_assignPrep</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>left</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>l</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>right</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>left</name><operator>-&gt;</operator><name>t</name></name> <operator>!=</operator> <name>BC_RESULT_STR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>right</name><operator>-&gt;</operator><name>t</name></name> <operator>==</operator> <name>BC_RESULT_STR</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_PROG_STR</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLED</name></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>inst</name> <operator>!=</operator> <name>BC_INST_ASSIGN</name> <operator>&amp;&amp;</operator> <name>inst</name> <operator>!=</operator> <name>BC_INST_ASSIGN_NO_VAL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_err</name><argument_list>(<argument><expr><name>BC_ERR_EXEC_TYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<if_stmt><if>if <condition>(<expr><name><name>left</name><operator>-&gt;</operator><name>t</name></name> <operator>==</operator> <name>BC_RESULT_ARRAY_ELEM</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_num_free</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BcNum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_vec_npop</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>



<decl_stmt><decl><type><name>BcVec</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>bc_program_vec</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>left</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>loc</name><operator>.</operator><name>loc</name></name></expr></argument>, <argument><expr><name>BC_TYPE_VAR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>bc_program_assignStr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLED</name></expr></cpp:if>



<if_stmt><if>if <condition>(<expr><name>inst</name> <operator>==</operator> <name>BC_INST_ASSIGN</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>res</name><operator>.</operator><name>t</name></name> <operator>=</operator> <name>BC_RESULT_STR</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>res</name><operator>.</operator><name>d</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BcNum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_vec_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<return>return;</return>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_INST_IS_ASSIGN</name><argument_list>(<argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>










<if_stmt><if>if <condition>(<expr><name><name>right</name><operator>-&gt;</operator><name>t</name></name> <operator>==</operator> <name>BC_RESULT_TEMP</name> <operator>||</operator> <name><name>right</name><operator>-&gt;</operator><name>t</name></name> <operator>&gt;=</operator> <name>BC_RESULT_IBASE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_num_free</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BcNum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>right</name><operator>-&gt;</operator><name>t</name></name> <operator>=</operator> <name>BC_RESULT_ZERO</name></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>
</block_content>}</block></if>

<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_num_copy</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLED</name></expr></cpp:if>
<else>else <block>{<block_content>



<decl_stmt><decl><type><name>BcBigDig</name></type> <name>scale</name> <init>= <expr><call><name>BC_PROG_SCALE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>




<if_stmt><if>if <condition>(<expr><call><name>BC_PROG_STR</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_err</name><argument_list>(<argument><expr><name>BC_ERR_EXEC_TYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><operator>!</operator><name>use_val</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>inst</name> <operator>-=</operator> <operator>(</operator><name>BC_INST_ASSIGN_POWER_NO_VAL</name> <operator>-</operator> <name>BC_INST_ASSIGN_POWER</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_NUM_RDX_VALID</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name><name>bc_program_ops</name><index>[<expr><name>inst</name> <operator>-</operator> <name>BC_INST_ASSIGN_POWER</name></expr>]</index></name><operator>(</operator><name>l</name><operator>,</operator> <name>r</name><operator>,</operator> <name>l</name><operator>,</operator> <name>scale</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>ob</name> <operator>=</operator> <operator>(</operator><name><name>left</name><operator>-&gt;</operator><name>t</name></name> <operator>==</operator> <name>BC_RESULT_OBASE</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>sc</name> <operator>=</operator> <operator>(</operator><name><name>left</name><operator>-&gt;</operator><name>t</name></name> <operator>==</operator> <name>BC_RESULT_SCALE</name><operator>)</operator></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name>ob</name> <operator>||</operator> <name>sc</name> <operator>||</operator> <name><name>left</name><operator>-&gt;</operator><name>t</name></name> <operator>==</operator> <name>BC_RESULT_IBASE</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>BcVec</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcBigDig</name> <modifier>*</modifier></type><name>ptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ptr_t</name></decl>, <decl><type ref="prev"/><name>val</name></decl>, <decl><type ref="prev"/><name>max</name></decl>, <decl><type ref="prev"/><name>min</name></decl>;</decl_stmt>


<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>bc_num_bigdig</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>sc</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name>min</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>max</name> <operator>=</operator> <name><name>vm</name><operator>.</operator><name>maxes</name><index>[<expr><name>BC_PROG_GLOBALS_SCALE</name></expr>]</index></name></expr>;</expr_stmt>


<expr_stmt><expr><name>v</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>globals_v</name></name> <operator>+</operator> <name>BC_PROG_GLOBALS_SCALE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ptr_t</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>globals</name></name> <operator>+</operator> <name>BC_PROG_GLOBALS_SCALE</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>


<expr_stmt><expr><name>min</name> <operator>=</operator> <name>BC_NUM_MIN_BASE</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>BC_ENABLE_EXTRA_MATH</name> <operator>&amp;&amp;</operator> <name>ob</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>BC_IS_DC</name> <operator>||</operator> <operator>!</operator><name>BC_IS_POSIX</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>min</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>max</name> <operator>=</operator> <name><name>vm</name><operator>.</operator><name>maxes</name><index>[<expr><name>ob</name> <operator>+</operator> <name>BC_PROG_GLOBALS_IBASE</name></expr>]</index></name></expr>;</expr_stmt>


<expr_stmt><expr><name>v</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>globals_v</name></name> <operator>+</operator> <name>BC_PROG_GLOBALS_IBASE</name> <operator>+</operator> <name>ob</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ptr_t</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>globals</name></name> <operator>+</operator> <name>BC_PROG_GLOBALS_IBASE</name> <operator>+</operator> <name>ob</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><name>val</name> <operator>&gt;</operator> <name>max</name> <operator>||</operator> <name>val</name> <operator>&lt;</operator> <name>min</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>


<decl_stmt><decl><type><name>BcErr</name></type> <name>e</name> <init>= <expr><name><name>left</name><operator>-&gt;</operator><name>t</name></name> <operator>-</operator> <name>BC_RESULT_IBASE</name> <operator>+</operator> <name>BC_ERR_EXEC_IBASE</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>bc_verr</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>bc_vec_top</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>ptr_t</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
</block_content>}</block></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLE_EXTRA_MATH</name></expr></cpp:if>

<if type="elseif">else if <condition>(<expr><name><name>left</name><operator>-&gt;</operator><name>t</name></name> <operator>==</operator> <name>BC_RESULT_SEED</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_num_rng</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>rng</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name>use_val</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bc_num_createCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>res</name><operator>.</operator><name>d</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>res</name><operator>.</operator><name>t</name></name> <operator>=</operator> <name>BC_RESULT_TEMP</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_vec_npop</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_vec_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_vec_npop</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>
</block_content>}</block></function>












<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_program_pushVar</name><parameter_list>(<parameter><decl><type><name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>code</name></decl></parameter>,
<parameter><decl><type><name>size_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>bgn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>pop</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>copy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>BcResult</name></type> <name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>idx</name> <init>= <expr><call><name>bc_program_index</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><name>bgn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><name><name>r</name><operator>.</operator><name>t</name></name> <operator>=</operator> <name>BC_RESULT_VAR</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>r</name><operator>.</operator><name>d</name><operator>.</operator><name>loc</name><operator>.</operator><name>loc</name></name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DC_ENABLED</name></expr></cpp:if>


<if_stmt><if>if <condition>(<expr><name>BC_IS_DC</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>pop</name> <operator>||</operator> <name>copy</name><operator>)</operator></expr>)</condition> <block>{<block_content>


<decl_stmt><decl><type><name>BcVec</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>bc_program_vec</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>BC_TYPE_VAR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>num</name> <init>= <expr><call><name>bc_vec_top</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><operator>!</operator><call><name>BC_PROG_STACK</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>-</operator> <name>copy</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>bc_map_name</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>var_map</name></name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>bc_verr</name><argument_list>(<argument><expr><name>BC_ERR_EXEC_STACK_REGISTER</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_PROG_STACK</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>-</operator> <name>copy</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BC_PROG_STR</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>


<expr_stmt><expr><name><name>r</name><operator>.</operator><name>t</name></name> <operator>=</operator> <name>BC_RESULT_TEMP</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_createCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>r</name><operator>.</operator><name>d</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name>copy</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_vec_pop</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>bc_vec_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>

<return>return;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>


<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>r</name><operator>.</operator><name>d</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><name>num</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BcNum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>r</name><operator>.</operator><name>t</name></name> <operator>=</operator> <name>BC_RESULT_STR</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name>copy</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_vec_pop</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>bc_vec_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>









<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_program_pushArray</name><parameter_list>(<parameter><decl><type><name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>code</name></decl></parameter>,
<parameter><decl><type><name>size_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>bgn</name></decl></parameter>, <parameter><decl><type><name>uchar</name></type> <name>inst</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>BcResult</name></type> <name>r</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>operand</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>num</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcBigDig</name></type> <name>temp</name></decl>;</decl_stmt>


<expr_stmt><expr><name><name>r</name><operator>.</operator><name>d</name><operator>.</operator><name>loc</name><operator>.</operator><name>loc</name></name> <operator>=</operator> <call><name>bc_program_index</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><name>bgn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>inst</name> <operator>==</operator> <name>BC_INST_ARRAY</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>r</name><operator>.</operator><name>t</name></name> <operator>=</operator> <name>BC_RESULT_ARRAY</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_vec_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>bc_program_prep</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>operand</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>temp</name> <operator>=</operator> <call><name>bc_num_bigdig</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name><name>r</name><operator>.</operator><name>t</name></name> <operator>=</operator> <name>BC_RESULT_ARRAY_ELEM</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>r</name><operator>.</operator><name>d</name><operator>.</operator><name>loc</name><operator>.</operator><name>idx</name></name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <name>temp</name></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_vec_pop</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_vec_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLED</name></expr></cpp:if>








<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_program_incdec</name><parameter_list>(<parameter><decl><type><name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>uchar</name></type> <name>inst</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>BcResult</name> <modifier>*</modifier></type><name>ptr</name></decl>, <decl><type ref="prev"/><name>res</name></decl>, <decl><type ref="prev"/><name>copy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>num</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uchar</name></type> <name>inst2</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>bc_program_prep</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>


<expr_stmt><expr><name><name>copy</name><operator>.</operator><name>t</name></name> <operator>=</operator> <name>BC_RESULT_TEMP</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_createCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>copy</name><operator>.</operator><name>d</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>BC_SETJMP_LOCKED</name><argument_list>(<argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>


<expr_stmt><expr><name><name>res</name><operator>.</operator><name>t</name></name> <operator>=</operator> <name>BC_RESULT_ONE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>inst2</name> <operator>=</operator> <name>BC_INST_ASSIGN_PLUS_NO_VAL</name> <operator>+</operator> <operator>(</operator><name>inst</name> <operator>&amp;</operator> <literal type="number">0x01</literal><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_vec_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_program_assign</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>inst2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_vec_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_UNSETJMP</name></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>


<return>return;</return>

<label><name>exit</name>:</label>
<expr_stmt><expr><name>BC_SIG_MAYLOCK</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>copy</name><operator>.</operator><name>d</name><operator>.</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>BC_LONGJMP_CONT</name></expr>;</expr_stmt>
</block_content>}</block></function>










<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_program_call</name><parameter_list>(<parameter><decl><type><name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>code</name></decl></parameter>,
<parameter><decl><type><name>size_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>bgn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>BcInstPtr</name></type> <name>ip</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>nargs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcFunc</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcVec</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcAuto</name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcResult</name> <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>


<expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>bc_program_index</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><name>bgn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name><name>ip</name><operator>.</operator><name>idx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ip</name><operator>.</operator><name>func</name></name> <operator>=</operator> <call><name>bc_program_index</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><name>bgn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>bc_vec_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>fns</name></name></expr></argument>, <argument><expr><name><name>ip</name><operator>.</operator><name>func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><operator>!</operator><name><name>f</name><operator>-&gt;</operator><name>code</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_verr</name><argument_list>(<argument><expr><name>BC_ERR_EXEC_UNDEF_FUNC</name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><name>nargs</name> <operator>!=</operator> <name><name>f</name><operator>-&gt;</operator><name>nparams</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_verr</name><argument_list>(<argument><expr><name>BC_ERR_EXEC_PARAMS</name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>nparams</name></name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><name><name>ip</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>results</name><operator>.</operator><name>len</name></name> <operator>-</operator> <name>nargs</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_PROG_STACK</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>BC_G</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_program_prepGlobals</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>last</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>bc_vec_top</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>t</name></name> <operator>==</operator> <name>BC_RESULT_VOID</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_err</name><argument_list>(<argument><expr><name>BC_ERR_EXEC_VOID_VAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>bc_vec_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>f</name><operator>-&gt;</operator><name>autos</name></name></expr></argument>, <argument><expr><name>nargs</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<if_stmt><if>if <condition>(<expr><name><name>arg</name><operator>-&gt;</operator><name>t</name></name> <operator>==</operator> <name>BC_RESULT_VAR</name> <operator>||</operator> <name><name>arg</name><operator>-&gt;</operator><name>t</name></name> <operator>==</operator> <name>BC_RESULT_ARRAY</name></expr>)</condition> <block>{<block_content>


<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>i</name> <operator>&amp;&amp;</operator> <name>last</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>BcAuto</name> <modifier>*</modifier></type><name>aptr</name> <init>= <expr><call><name>bc_vec_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>f</name><operator>-&gt;</operator><name>autos</name></name></expr></argument>, <argument><expr><name>nargs</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>




<expr_stmt><expr><name>last</name> <operator>=</operator> <operator>(</operator><name><name>arg</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>loc</name><operator>.</operator><name>loc</name></name> <operator>!=</operator> <name><name>aptr</name><operator>-&gt;</operator><name>idx</name></name> <operator>||</operator>
<operator>(</operator><operator>!</operator><name><name>aptr</name><operator>-&gt;</operator><name>type</name></name><operator>)</operator> <operator>!=</operator> <operator>(</operator><name><name>arg</name><operator>-&gt;</operator><name>t</name></name> <operator>==</operator> <name>BC_RESULT_VAR</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>bc_program_copyToVar</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>idx</name></name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>


<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>f</name><operator>-&gt;</operator><name>autos</name><operator>.</operator><name>len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>


<expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>bc_vec_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>f</name><operator>-&gt;</operator><name>autos</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>bc_program_vec</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>idx</name></name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>BC_TYPE_VAR</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>bc_vec_pushEmpty</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>bc_num_init</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>BC_NUM_DEF_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>

<decl_stmt><decl><type><name>BcVec</name> <modifier>*</modifier></type><name>v2</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>BC_TYPE_ARRAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>v2</name> <operator>=</operator> <call><name>bc_vec_pushEmpty</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_array_init</name><argument_list>(<argument><expr><name>v2</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>


<expr_stmt><expr><call><name>bc_vec_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_program_return</name><parameter_list>(<parameter><decl><type><name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>uchar</name></type> <name>inst</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>BcResult</name> <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcFunc</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcInstPtr</name> <modifier>*</modifier></type><name>ip</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>nresults</name></decl>;</decl_stmt>


<expr_stmt><expr><name>ip</name> <operator>=</operator> <call><name>bc_vec_top</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>nresults</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>results</name><operator>.</operator><name>len</name></name> <operator>-</operator> <name><name>ip</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>


<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_PROG_STACK</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_PROG_STACK</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><name><name>ip</name><operator>-&gt;</operator><name>len</name></name> <operator>+</operator> <operator>(</operator><name>inst</name> <operator>==</operator> <name>BC_INST_RET</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>bc_vec_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>fns</name></name></expr></argument>, <argument><expr><name><name>ip</name><operator>-&gt;</operator><name>func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>bc_program_prepResult</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>inst</name> <operator>==</operator> <name>BC_INST_RET</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>num</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcResult</name> <modifier>*</modifier></type><name>operand</name></decl>;</decl_stmt>


<expr_stmt><expr><call><name>bc_program_operand</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>operand</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BC_PROG_STR</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>




<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>t</name></name> <operator>=</operator> <name>BC_RESULT_STR</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>res</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><name>num</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BcNum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>

<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_num_createCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>res</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>inst</name> <operator>==</operator> <name>BC_INST_RET_VOID</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>t</name></name> <operator>=</operator> <name>BC_RESULT_VOID</name></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>

<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_num_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>res</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><name>BC_NUM_DEF_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>BC_SIG_MAYUNLOCK</name></expr>;</expr_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>f</name><operator>-&gt;</operator><name>autos</name><operator>.</operator><name>len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>BcAuto</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>bc_vec_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>f</name><operator>-&gt;</operator><name>autos</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcVec</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>bc_program_vec</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>idx</name></name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>bc_vec_pop</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_program_retire</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>nresults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>BC_G</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_program_popGlobals</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>bc_vec_pop</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>






<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_program_builtin</name><parameter_list>(<parameter><decl><type><name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>uchar</name></type> <name>inst</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>BcResult</name> <modifier>*</modifier></type><name>opd</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>num</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>len</name> <init>= <expr><operator>(</operator><name>inst</name> <operator>==</operator> <name>BC_INST_LENGTH</name><operator>)</operator></expr></init></decl>;</decl_stmt>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLE_EXTRA_MATH</name></expr></cpp:if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>inst</name> <operator>&gt;=</operator> <name>BC_INST_LENGTH</name> <operator>&amp;&amp;</operator> <name>inst</name> <operator>&lt;=</operator> <name>BC_INST_IRAND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>inst</name> <operator>&gt;=</operator> <name>BC_INST_LENGTH</name> <operator>&amp;&amp;</operator> <name>inst</name> <operator>&lt;=</operator> <name>BC_INST_ABS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>BC_PROG_NO_STACK_CHECK</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>BC_IS_DC</name> <operator>&amp;&amp;</operator> <call><name>BC_ERR</name><argument_list>(<argument><expr><operator>!</operator><call><name>BC_PROG_STACK</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_err</name><argument_list>(<argument><expr><name>BC_ERR_EXEC_STACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_PROG_STACK</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>bc_program_prepResult</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_program_operand</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>num</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><operator>!</operator><name>len</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>inst</name> <operator>!=</operator> <name>BC_INST_SCALE_FUNC</name> <operator>||</operator> <name>BC_IS_BC</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_program_type_num</name><argument_list>(<argument><expr><name>opd</name></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>inst</name> <operator>==</operator> <name>BC_INST_SQRT</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_num_sqrt</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>res</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><call><name>BC_PROG_SCALE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>


<if type="elseif">else if <condition>(<expr><name>inst</name> <operator>==</operator> <name>BC_INST_ABS</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_num_createCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>res</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>BC_NUM_NEG_CLR_NP</name><argument_list>(<argument><expr><name><name>res</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLE_EXTRA_MATH</name></expr></cpp:if>

<if type="elseif">else if <condition>(<expr><name>inst</name> <operator>==</operator> <name>BC_INST_IRAND</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_num_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>res</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><name><name>num</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <call><name>BC_NUM_RDX_VAL</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_num_irand</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>res</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>rng</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<else>else <block>{<block_content>

<decl_stmt><decl><type><name>BcBigDig</name></type> <name>val</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name>len</name></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><name><name>opd</name><operator>-&gt;</operator><name>t</name></name> <operator>==</operator> <name>BC_RESULT_ARRAY</name></expr>)</condition> <block>{<block_content>



<decl_stmt><decl><type><name>BcVec</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><operator>(</operator><name>BcVec</name><operator>*</operator><operator>)</operator> <name>num</name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLED</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>BC_IS_BC</name> <operator>&amp;&amp;</operator> <name><name>v</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uchar</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>bc_program_dereference</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BcNum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>val</name> <operator>=</operator> <operator>(</operator><name>BcBigDig</name><operator>)</operator> <name><name>v</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BC_PROG_NUM</name><argument_list>(<argument><expr><name>opd</name></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>


<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>bc_program_string</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>val</name> <operator>=</operator> <operator>(</operator><name>BcBigDig</name><operator>)</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>

<expr_stmt><expr><name>val</name> <operator>=</operator> <operator>(</operator><name>BcBigDig</name><operator>)</operator> <call><name>bc_num_len</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>


<if type="elseif">else if <condition>(<expr><name>BC_IS_BC</name> <operator>||</operator> <call><name>BC_PROG_NUM</name><argument_list>(<argument><expr><name>opd</name></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>val</name> <operator>=</operator> <operator>(</operator><name>BcBigDig</name><operator>)</operator> <call><name>bc_num_scale</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_num_createFromBigdig</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>res</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>bc_program_retire</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_program_divmod</name><parameter_list>(<parameter><decl><type><name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>BcResult</name> <modifier>*</modifier></type><name>opd1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>opd2</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>res</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>res2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>n1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>n2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>req</name></decl>;</decl_stmt>


<expr_stmt><expr><call><name>bc_vec_grow</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>res2</name> <operator>=</operator> <call><name>bc_program_prepResult</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>bc_program_prepResult</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_program_binOpPrep</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opd1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opd2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n2</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>req</name> <operator>=</operator> <call><name>bc_num_mulReq</name><argument_list>(<argument><expr><name>n1</name></expr></argument>, <argument><expr><name>n2</name></expr></argument>, <argument><expr><call><name>BC_PROG_SCALE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_num_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>res</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><name>req</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>res2</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><name>req</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_num_divmod</name><argument_list>(<argument><expr><name>n1</name></expr></argument>, <argument><expr><name>n2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>res2</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>res</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><call><name>BC_PROG_SCALE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_program_retire</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_program_modexp</name><parameter_list>(<parameter><decl><type><name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>BcResult</name> <modifier>*</modifier></type><name>r1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>r2</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>r3</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>n1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>n2</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>n3</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DC_ENABLED</name></expr></cpp:if>


<if_stmt><if>if <condition>(<expr><name>BC_IS_DC</name> <operator>&amp;&amp;</operator> <call><name>BC_ERR</name><argument_list>(<argument><expr><operator>!</operator><call><name>BC_PROG_STACK</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_err</name><argument_list>(<argument><expr><name>BC_ERR_EXEC_STACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_PROG_STACK</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>bc_program_prepResult</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_program_operand</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n1</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_program_type_num</name><argument_list>(<argument><expr><name>r1</name></expr></argument>, <argument><expr><name>n1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_program_binOpPrep</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r3</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n3</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name><name>r1</name><operator>-&gt;</operator><name>t</name></name> <operator>==</operator> <name>BC_RESULT_ARRAY_ELEM</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>r1</name><operator>-&gt;</operator><name>t</name></name> <operator>==</operator> <name><name>r2</name><operator>-&gt;</operator><name>t</name></name> <operator>||</operator> <name><name>r1</name><operator>-&gt;</operator><name>t</name></name> <operator>==</operator> <name><name>r3</name><operator>-&gt;</operator><name>t</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>n1</name> <operator>=</operator> <call><name>bc_program_num</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_num_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>res</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><name><name>n3</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_num_modexp</name><argument_list>(<argument><expr><name>n1</name></expr></argument>, <argument><expr><name>n2</name></expr></argument>, <argument><expr><name>n3</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>res</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_program_retire</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>uchar</name></type> <name>bc_program_asciifyNum</name><parameter_list>(<parameter><decl><type><name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>BcNum</name></type> <name>num</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcBigDig</name></type> <name>val</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr_stmt><expr><name>val</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>bc_num_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>BC_SETJMP</name><argument_list>(<argument><expr><name>num_err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_num_createCopy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>num</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_num_truncate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>num</name></expr></argument>, <argument><expr><name><name>num</name><operator>.</operator><name>scale</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BC_NUM_NEG_CLR_NP</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><call><name>bc_num_mod</name><argument_list>(<argument><expr><operator>&amp;</operator><name>num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>strmb</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>bc_num_bigdig2</name><argument_list>(<argument><expr><operator>&amp;</operator><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>num_err</name>:</label>
<expr_stmt><expr><name>BC_SIG_MAYLOCK</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>BC_LONGJMP_CONT</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>uchar</name><operator>)</operator> <name>val</name></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_program_asciify</name><parameter_list>(<parameter><decl><type><name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>fidx</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>BcResult</name> <modifier>*</modifier></type><name>r</name></decl>, <decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>str</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>str2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uchar</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>idx</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><operator>!</operator><call><name>BC_PROG_STACK</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_err</name><argument_list>(<argument><expr><name>BC_ERR_EXEC_STACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_PROG_STACK</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_program_operand</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_PROG_NUM</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>bc_program_asciifyNum</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>


<expr_stmt><expr><name>str2</name> <operator>=</operator> <call><name>bc_program_string</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>uchar</name><operator>)</operator> <name><name>str2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<expr_stmt><expr><name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator> <name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>


<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>
<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>bc_program_addString</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>fidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>


<expr_stmt><expr><name><name>res</name><operator>.</operator><name>t</name></name> <operator>=</operator> <name>BC_RESULT_STR</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>res</name><operator>.</operator><name>d</name><operator>.</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>res</name><operator>.</operator><name>d</name><operator>.</operator><name>n</name><operator>.</operator><name>rdx</name></name> <operator>=</operator> <name>fidx</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>res</name><operator>.</operator><name>d</name><operator>.</operator><name>n</name><operator>.</operator><name>scale</name></name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_vec_pop</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_vec_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_program_printStream</name><parameter_list>(<parameter><decl><type><name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>BcResult</name> <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><operator>!</operator><call><name>BC_PROG_STACK</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_err</name><argument_list>(<argument><expr><name>BC_ERR_EXEC_STACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_PROG_STACK</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_program_operand</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_PROG_NUM</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_num_stream</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_program_printChars</name><argument_list>(<argument><expr><call><name>bc_program_string</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>


<expr_stmt><expr><call><name>bc_vec_pop</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DC_ENABLED</name></expr></cpp:if>








<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_program_regStackLen</name><parameter_list>(<parameter><decl><type><name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>code</name></decl></parameter>,
<parameter><decl><type><name>size_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>bgn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>idx</name> <init>= <expr><call><name>bc_program_index</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><name>bgn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcVec</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>bc_program_vec</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>BC_TYPE_VAR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>bc_program_pushBigdig</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>BcBigDig</name><operator>)</operator> <name><name>v</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name>BC_RESULT_TEMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_program_stackLen</name><parameter_list>(<parameter><decl><type><name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>bc_program_pushBigdig</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>BcBigDig</name><operator>)</operator> <name><name>p</name><operator>-&gt;</operator><name>results</name><operator>.</operator><name>len</name></name></expr></argument>, <argument><expr><name>BC_RESULT_TEMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_program_nquit</name><parameter_list>(<parameter><decl><type><name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>uchar</name></type> <name>inst</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>BcResult</name> <modifier>*</modifier></type><name>opnd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>num</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcBigDig</name></type> <name>val</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>


<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>stack</name><operator>.</operator><name>len</name></name> <operator>==</operator> <name><name>p</name><operator>-&gt;</operator><name>tail_calls</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>inst</name> <operator>==</operator> <name>BC_INST_QUIT</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>val</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>

<expr_stmt><expr><call><name>bc_program_prep</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opnd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>bc_num_bigdig</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_vec_pop</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>val</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name><name>p</name><operator>-&gt;</operator><name>tail_calls</name><operator>.</operator><name>len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>


<decl_stmt><decl><type><name>size_t</name></type> <name>calls</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>size_t</name><operator>*</operator><operator>)</operator> <call><name>bc_vec_item_rev</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>tail_calls</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name>calls</name> <operator>&gt;=</operator> <name>val</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>val</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>val</name> <operator>-=</operator> <operator>(</operator><name>BcBigDig</name><operator>)</operator> <name>calls</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></for>


<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name><name>p</name><operator>-&gt;</operator><name>stack</name><operator>.</operator><name>len</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>vm</name><operator>.</operator><name>status</name></name> <operator>=</operator> <name>BC_STATUS_QUIT</name></expr>;</expr_stmt>
<expr_stmt><expr><name>BC_JMP</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>




<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_vec_npop</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_vec_npop</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>tail_calls</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_program_execStackLen</name><parameter_list>(<parameter><decl><type><name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>amt</name></decl>, <decl><type ref="prev"/><name>len</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>tail_calls</name><operator>.</operator><name>len</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>amt</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name>amt</name> <operator>+=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>size_t</name><operator>*</operator><operator>)</operator> <call><name>bc_vec_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>tail_calls</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><call><name>bc_program_pushBigdig</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>BcBigDig</name><operator>)</operator> <name>amt</name></expr></argument>, <argument><expr><name>BC_RESULT_TEMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>










<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_program_execStr</name><parameter_list>(<parameter><decl><type><name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>code</name></decl></parameter>,
<parameter><decl><type><name>size_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>bgn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>cond</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>BcResult</name> <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcFunc</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcInstPtr</name></type> <name>ip</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>fidx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>stack</name><operator>.</operator><name>len</name></name> <operator>==</operator> <name><name>p</name><operator>-&gt;</operator><name>tail_calls</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><operator>!</operator><call><name>BC_PROG_STACK</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_err</name><argument_list>(<argument><expr><name>BC_ERR_EXEC_STACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_PROG_STACK</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_program_operand</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>cond</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>bool</name></type> <name>exec</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>idx</name></decl>, <decl><type ref="prev"/><name>then_idx</name></decl>, <decl><type ref="prev"/><name>else_idx</name></decl>;</decl_stmt>


<expr_stmt><expr><name>then_idx</name> <operator>=</operator> <call><name>bc_program_index</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><name>bgn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>else_idx</name> <operator>=</operator> <call><name>bc_program_index</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><name>bgn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>exec</name> <operator>=</operator> <operator>(</operator><name><name>r</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>n</name><operator>.</operator><name>len</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>idx</name> <operator>=</operator> <ternary><condition><expr><name>exec</name></expr> ?</condition><then> <expr><name>then_idx</name></expr> </then><else>: <expr><name>else_idx</name></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BC_SETJMP_LOCKED</name><argument_list>(<argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<if_stmt><if>if <condition>(<expr><name>exec</name> <operator>||</operator> <operator>(</operator><name>else_idx</name> <operator>!=</operator> <name>SIZE_MAX</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>bc_vec_top</name><argument_list>(<argument><expr><call><name>bc_program_vec</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>BC_TYPE_VAR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <goto>goto <name>exit</name>;</goto></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><operator>!</operator><call><name>BC_PROG_STR</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_err</name><argument_list>(<argument><expr><name>BC_ERR_EXEC_TYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>BC_UNSETJMP</name></expr>;</expr_stmt>
<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>




<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>t</name></name> <operator>!=</operator> <name>BC_RESULT_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>r</name><operator>-&gt;</operator><name>t</name></name> <operator>!=</operator> <name>BC_RESULT_STR</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_PROG_STR</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>bc_program_string</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>
<expr_stmt><expr><name>fidx</name> <operator>=</operator> <call><name>bc_program_insertFunc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>
<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>bc_vec_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>fns</name></name></expr></argument>, <argument><expr><name>fidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>f</name><operator>-&gt;</operator><name>code</name><operator>.</operator><name>len</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BC_PARSE_IS_INITED</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>read_prs</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>bc_parse_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>read_prs</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>fidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><call><name>bc_vec_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>read_buf</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>BC_DTOR_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>


<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_parse_updateFunc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>read_prs</name></name></expr></argument>, <argument><expr><name>fidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>bc_lex_file</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>read_prs</name><operator>.</operator><name>l</name></name></expr></argument>, <argument><expr><name><name>vm</name><operator>.</operator><name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>BC_SETJMP_LOCKED</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_parse_text</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>read_prs</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>vm</name><operator>.</operator><name>expr</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>read_prs</name></name></expr></argument>, <argument><expr><name>BC_PARSE_NOCALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_UNSETJMP</name></expr>;</expr_stmt>



<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>vm</name><operator>.</operator><name>read_prs</name><operator>.</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>==</operator> <name>BC_LEX_EOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name><name>ip</name><operator>.</operator><name>idx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ip</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>results</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ip</name><operator>.</operator><name>func</name></name> <operator>=</operator> <name>fidx</name></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_vec_pop</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>stack</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>bgn</name> <operator>==</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>code</name><index>[<expr><operator>*</operator><name>bgn</name></expr>]</index></name> <operator>==</operator> <name>BC_INST_POP_EXEC</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name> <modifier>*</modifier></type><name>call_ptr</name> <init>= <expr><call><name>bc_vec_top</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>tail_calls</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><operator>*</operator><name>call_ptr</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>



<expr_stmt><expr><call><name>bc_vec_pop</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>

<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_vec_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>tail_calls</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ip</name><operator>.</operator><name>idx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>


<expr_stmt><expr><call><name>bc_vec_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>

<return>return;</return>

<label><name>err</name>:</label>
<expr_stmt><expr><name>BC_SIG_MAYLOCK</name></expr>;</expr_stmt>

<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>bc_vec_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>fns</name></name></expr></argument>, <argument><expr><name>fidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_vec_popAll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>f</name><operator>-&gt;</operator><name>code</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>exit</name>:</label>
<expr_stmt><expr><call><name>bc_vec_pop</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>BC_LONGJMP_CONT</name></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_program_printStack</name><parameter_list>(<parameter><decl><type><name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>idx</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <name><name>p</name><operator>-&gt;</operator><name>results</name><operator>.</operator><name>len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>idx</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_program_print</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_INST_PRINT</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>






<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_program_pushGlobal</name><parameter_list>(<parameter><decl><type><name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>uchar</name></type> <name>inst</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>BcResultType</name></type> <name>t</name></decl>;</decl_stmt>


<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>inst</name> <operator>&gt;=</operator> <name>BC_INST_IBASE</name> <operator>&amp;&amp;</operator> <name>inst</name> <operator>&lt;=</operator> <name>BC_INST_SCALE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>t</name> <operator>=</operator> <name>inst</name> <operator>-</operator> <name>BC_INST_IBASE</name> <operator>+</operator> <name>BC_RESULT_IBASE</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_program_pushBigdig</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>globals</name><index>[<expr><name>inst</name> <operator>-</operator> <name>BC_INST_IBASE</name></expr>]</index></name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_program_globalSetting</name><parameter_list>(<parameter><decl><type><name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>uchar</name></type> <name>inst</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>BcBigDig</name></type> <name>val</name></decl>;</decl_stmt>


<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>inst</name> <operator>&gt;=</operator> <name>BC_INST_LINE_LENGTH</name> <operator>&amp;&amp;</operator> <name>inst</name> <operator>&lt;=</operator> <name>BC_INST_LEADING_ZERO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>inst</name> <operator>==</operator> <name>BC_INST_LINE_LENGTH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>val</name> <operator>=</operator> <operator>(</operator><name>BcBigDig</name><operator>)</operator> <name><name>vm</name><operator>.</operator><name>line_len</name></name></expr>;</expr_stmt></block_content></block></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLED</name></expr></cpp:if>
<if type="elseif">else if <condition>(<expr><name>inst</name> <operator>==</operator> <name>BC_INST_GLOBAL_STACKS</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>val</name> <operator>=</operator> <operator>(</operator><name>BC_G</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>val</name> <operator>=</operator> <operator>(</operator><name>BC_Z</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>


<expr_stmt><expr><call><name>bc_program_pushBigdig</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>BC_RESULT_TEMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLE_EXTRA_MATH</name></expr></cpp:if>





<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_program_pushSeed</name><parameter_list>(<parameter><decl><type><name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>BcResult</name> <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>bc_program_prepResult</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>t</name></name> <operator>=</operator> <name>BC_RESULT_SEED</name></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_num_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>res</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>*</operator> <name>BC_RAND_NUM_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_num_createFromRNG</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>res</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>rng</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>







<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_program_addFunc</name><parameter_list>(<parameter><decl><type><name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>BcId</name> <modifier>*</modifier></type><name>id_ptr</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>BcInstPtr</name> <modifier>*</modifier></type><name>ip</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcFunc</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>

<expr_stmt><expr><name>BC_SIG_ASSERT_LOCKED</name></expr>;</expr_stmt>


<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>bc_vec_pushEmpty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>fns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_func_init</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name><name>id_ptr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>stack</name><operator>.</operator><name>len</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ip</name> <operator>=</operator> <call><name>bc_vec_top</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_program_setVecs</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>BcFunc</name><operator>*</operator><operator>)</operator> <call><name>bc_vec_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>fns</name></name></expr></argument>, <argument><expr><name><name>ip</name><operator>-&gt;</operator><name>func</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>bc_program_insertFunc</name><parameter_list>(<parameter><decl><type><name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>BcId</name> <modifier>*</modifier></type><name>id_ptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>new</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>idx</name></decl>;</decl_stmt>

<expr_stmt><expr><name>BC_SIG_ASSERT_LOCKED</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>p</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>name</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>new</name> <operator>=</operator> <call><name>bc_map_insert</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>fn_map</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>fns</name><operator>.</operator><name>len</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>id_ptr</name> <operator>=</operator> <operator>(</operator><name>BcId</name><operator>*</operator><operator>)</operator> <call><name>bc_vec_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>fn_map</name></name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>idx</name> <operator>=</operator> <name><name>id_ptr</name><operator>-&gt;</operator><name>idx</name></name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>new</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><call><name>bc_program_addFunc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>id_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLED</name></expr></cpp:if>

<if type="elseif">else if <condition>(<expr><name>BC_IS_BC</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>BcFunc</name> <modifier>*</modifier></type><name>func</name> <init>= <expr><call><name>bc_vec_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>fns</name></name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>bc_func_reset</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>idx</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>void</name></type> <name>bc_program_free</name><parameter_list>(<parameter><decl><type><name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>BC_SIG_ASSERT_LOCKED</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>BC_PROG_GLOBALS_LEN</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_vec_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>globals_v</name></name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><call><name>bc_vec_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>fns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_vec_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>fn_map</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_vec_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>vars</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_vec_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>var_map</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_vec_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>arrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_vec_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>arr_map</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_vec_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_vec_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLED</name></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>BC_IS_BC</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_num_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>last</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLE_EXTRA_MATH</name></expr></cpp:if>
<expr_stmt><expr><call><name>bc_rand_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>rng</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DC_ENABLED</name></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>BC_IS_DC</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_vec_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>tail_calls</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type> <name>bc_program_init</name><parameter_list>(<parameter><decl><type><name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>BcInstPtr</name></type> <name>ip</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>BC_SIG_ASSERT_LOCKED</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ip</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BcInstPtr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>BC_PROG_GLOBALS_LEN</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>BcBigDig</name></type> <name>val</name> <init>= <expr><ternary><condition><expr><name>i</name> <operator>==</operator> <name>BC_PROG_GLOBALS_SCALE</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>BC_BASE</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>bc_vec_init</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>globals_v</name></name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BcBigDig</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>BC_DTOR_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_vec_push</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>globals_v</name></name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>globals</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
</block_content>}</block></for>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DC_ENABLED</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>BC_IS_DC</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>bc_vec_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>tail_calls</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>BC_DTOR_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_vec_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>tail_calls</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>bc_num_setup</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>strmb</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>strmb_num</name></name></expr></argument>, <argument><expr><name>BC_NUM_BIGDIG_LOG10</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_num_bigdig2num</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>strmb</name></name></expr></argument>, <argument><expr><name>BC_NUM_STREAM_BASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLE_EXTRA_MATH</name></expr></cpp:if>


<expr_stmt><expr><call><name>srand</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_rand_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>rng</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLED</name></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>BC_IS_BC</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_num_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>last</name></name></expr></argument>, <argument><expr><name>BC_NUM_DEF_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>bc_vec_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>fns</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BcFunc</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>BC_DTOR_FUNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>bc_vec_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>fns</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BcFunc</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>BC_DTOR_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>bc_map_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>fn_map</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_program_insertFunc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>bc_func_main</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_program_insertFunc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>bc_func_read</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_vec_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>vars</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BcVec</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>BC_DTOR_VEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_map_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>var_map</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_vec_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>arrs</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BcVec</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>BC_DTOR_VEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_map_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>arr_map</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_vec_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BcResult</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>BC_DTOR_RESULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_vec_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BcInstPtr</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>BC_DTOR_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_vec_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_program_setVecs</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>BcFunc</name><operator>*</operator><operator>)</operator> <call><name>bc_vec_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>fns</name></name></expr></argument>, <argument><expr><name>BC_PROG_MAIN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>consts</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>strs</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>bc_program_reset</name><parameter_list>(<parameter><decl><type><name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>BcFunc</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcInstPtr</name> <modifier>*</modifier></type><name>ip</name></decl>;</decl_stmt>

<expr_stmt><expr><name>BC_SIG_ASSERT_LOCKED</name></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_vec_npop</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>stack</name><operator>.</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_vec_popAll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLED</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>BC_G</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_program_popGlobals</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>bc_vec_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>fns</name></name></expr></argument>, <argument><expr><name>BC_PROG_MAIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_vec_npop</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>f</name><operator>-&gt;</operator><name>code</name></name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>code</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>ip</name> <operator>=</operator> <call><name>bc_vec_top</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_program_setVecs</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BcInstPtr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>vm</name><operator>.</operator><name>sig</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bc_file_write</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>fout</name></name></expr></argument>, <argument><expr><name>bc_flush_none</name></expr></argument>, <argument><expr><name>bc_program_ready_msg</name></expr></argument>,
<argument><expr><name>bc_program_ready_msg_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_file_flush</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>fout</name></name></expr></argument>, <argument><expr><name>bc_flush_err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vm</name><operator>.</operator><name>sig</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>bc_program_exec</name><parameter_list>(<parameter><decl><type><name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>idx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcResult</name></type> <name>r</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcInstPtr</name> <modifier>*</modifier></type><name>ip</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcFunc</name> <modifier>*</modifier></type><name>func</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>code</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>cond</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uchar</name></type> <name>inst</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLED</name></expr></cpp:if>
<decl_stmt><decl><type><name>BcNum</name> <modifier>*</modifier></type><name>num</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>BC_HAS_COMPUTED_GOTO</name></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>size_t</name></type> <name>jmp_bufs_len</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_HAS_COMPUTED_GOTO</name></expr></cpp:if>
<expr_stmt><expr><name>BC_PROG_LBLS</name></expr>;</expr_stmt>
<expr_stmt><expr><name>BC_PROG_LBLS_ASSERT</name></expr>;</expr_stmt>



<expr_stmt><expr><name>func</name> <operator>=</operator> <operator>(</operator><name>BcFunc</name><operator>*</operator><operator>)</operator> <call><name>bc_vec_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>fns</name></name></expr></argument>, <argument><expr><name>BC_PROG_MAIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_vec_pushByte</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>func</name><operator>-&gt;</operator><name>code</name></name></expr></argument>, <argument><expr><name>BC_INST_INVALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>ip</name> <operator>=</operator> <call><name>bc_vec_top</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>func</name> <operator>=</operator> <operator>(</operator><name>BcFunc</name><operator>*</operator><operator>)</operator> <call><name>bc_vec_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>fns</name></name></expr></argument>, <argument><expr><name><name>ip</name><operator>-&gt;</operator><name>func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>code</name> <operator>=</operator> <name><name>func</name><operator>-&gt;</operator><name>code</name><operator>.</operator><name>v</name></name></expr>;</expr_stmt>


<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_program_setVecs</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>BC_HAS_COMPUTED_GOTO</name></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>jmp_bufs_len</name> <operator>=</operator> <name><name>vm</name><operator>.</operator><name>jmp_bufs</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



<while>while <condition>(<expr><name><name>ip</name><operator>-&gt;</operator><name>idx</name></name> <operator>&lt;</operator> <name><name>func</name><operator>-&gt;</operator><name>code</name><operator>.</operator><name>len</name></name></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{<block_content>

<expr_stmt><expr><name>BC_SIG_ASSERT_NOT_LOCKED</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_HAS_COMPUTED_GOTO</name></expr></cpp:if>

<expr_stmt><expr><call><name>BC_PROG_JUMP</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>


<expr_stmt><expr><name>inst</name> <operator>=</operator> <operator>(</operator><name>uchar</name><operator>)</operator> <name><name>code</name><index>[<expr><operator>(</operator><name><name>ip</name><operator>-&gt;</operator><name>idx</name></name><operator>)</operator><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_DEBUG_CODE</name></expr></cpp:if>
<expr_stmt><expr><call><name>bc_file_printf</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>ferr</name></name></expr></argument>, <argument><expr><literal type="string">"inst: %s\n"</literal></expr></argument>, <argument><expr><name><name>bc_inst_names</name><index>[<expr><name>inst</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_file_flush</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>ferr</name></name></expr></argument>, <argument><expr><name>bc_flush_none</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>BC_HAS_COMPUTED_GOTO</name></expr></cpp:if>
<switch>switch <condition>(<expr><name>inst</name></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLED</name></expr></cpp:if>


<expr_stmt><expr><call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_JUMP_ZERO</name></expr></argument>)</argument_list></call><operator>:</operator>
<block>{
<expr><call><name>bc_program_prep</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;

<expr><name>cond</name> <operator>=</operator> <operator>!</operator><call><name>bc_num_cmpZero</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>bc_vec_pop</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>)</argument_list></call></expr>;

<macro><name>BC_PROG_DIRECT_JUMP</name><argument_list>(<argument>BC_INST_JUMP</argument>)</argument_list></macro>
}</block>

<name>BC_PROG_FALLTHROUGH</name>

<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_JUMP</name></expr></argument>)</argument_list></call><operator>:</operator>
<block>{
<expr><name>idx</name> <operator>=</operator> <call><name>bc_program_index</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ip</name><operator>-&gt;</operator><name>idx</name></name></expr></argument>)</argument_list></call></expr>;


<if_stmt><if>if <condition>(<expr><name>inst</name> <operator>==</operator> <name>BC_INST_JUMP</name> <operator>||</operator> <name>cond</name></expr>)</condition> <block>{<block_content>


<decl_stmt><decl><type><name>size_t</name> <modifier>*</modifier></type><name>addr</name> <init>= <expr><call><name>bc_vec_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>func</name><operator>-&gt;</operator><name>labels</name></name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>



<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>*</operator><name>addr</name> <operator>!=</operator> <name>SIZE_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name><name>ip</name><operator>-&gt;</operator><name>idx</name></name> <operator>=</operator> <operator>*</operator><name>addr</name></expr>;</expr_stmt>
<expr_stmt/></block_content></block></if></if_stmt>}</block>

<call><name>BC_PROG_JUMP</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>

<expr_stmt><expr><call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_CALL</name></expr></argument>)</argument_list></call><operator>:</operator>
<block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>BC_IS_BC</name></expr></argument>)</argument_list></call></expr>;

<expr><call><name>bc_program_call</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ip</name><operator>-&gt;</operator><name>idx</name></name></expr></argument>)</argument_list></call></expr>;



<expr><name>BC_SIG_LOCK</name></expr>;
<expr><name>ip</name> <operator>=</operator> <call><name>bc_vec_top</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr>;
<expr><name>func</name> <operator>=</operator> <call><name>bc_vec_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>fns</name></name></expr></argument>, <argument><expr><name><name>ip</name><operator>-&gt;</operator><name>func</name></name></expr></argument>)</argument_list></call></expr>;
<expr><name>code</name> <operator>=</operator> <name><name>func</name><operator>-&gt;</operator><name>code</name><operator>.</operator><name>v</name></name></expr>;
<expr><call><name>bc_program_setVecs</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;
<expr><name>BC_SIG_UNLOCK</name></expr>;

<expr><call><name>BC_PROG_JUMP</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;
}</block>

<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_INC</name></expr></argument>)</argument_list></call><operator>:</operator>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_DEC</name></expr></argument>)</argument_list></call><operator>:</operator>
<block>{
<expr><call><name>bc_program_incdec</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>BC_PROG_JUMP</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;
}</block>

<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_HALT</name></expr></argument>)</argument_list></call><operator>:</operator>
<block>{
<expr><name><name>vm</name><operator>.</operator><name>status</name></name> <operator>=</operator> <name>BC_STATUS_QUIT</name></expr>;


<expr><name>BC_JMP</name></expr>;

<expr><call><name>BC_PROG_JUMP</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;
}</block>

<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_RET</name></expr></argument>)</argument_list></call><operator>:</operator>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_RET0</name></expr></argument>)</argument_list></call><operator>:</operator>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_RET_VOID</name></expr></argument>)</argument_list></call><operator>:</operator>
<block>{
<expr><call><name>bc_program_return</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr>;



<expr><name>BC_SIG_LOCK</name></expr>;
<expr><name>ip</name> <operator>=</operator> <call><name>bc_vec_top</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr>;
<expr><name>func</name> <operator>=</operator> <call><name>bc_vec_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>fns</name></name></expr></argument>, <argument><expr><name><name>ip</name><operator>-&gt;</operator><name>func</name></name></expr></argument>)</argument_list></call></expr>;
<expr><name>code</name> <operator>=</operator> <name><name>func</name><operator>-&gt;</operator><name>code</name><operator>.</operator><name>v</name></name></expr>;
<expr><call><name>bc_program_setVecs</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;
<expr><name>BC_SIG_UNLOCK</name></expr>;

<expr><call><name>BC_PROG_JUMP</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_BOOL_OR</name></expr></argument>)</argument_list></call><operator>:</operator>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_BOOL_AND</name></expr></argument>)</argument_list></call><operator>:</operator>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_REL_EQ</name></expr></argument>)</argument_list></call><operator>:</operator>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_REL_LE</name></expr></argument>)</argument_list></call><operator>:</operator>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_REL_GE</name></expr></argument>)</argument_list></call><operator>:</operator>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_REL_NE</name></expr></argument>)</argument_list></call><operator>:</operator>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_REL_LT</name></expr></argument>)</argument_list></call><operator>:</operator>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_REL_GT</name></expr></argument>)</argument_list></call><operator>:</operator>
<block>{
<expr><call><name>bc_program_logical</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>BC_PROG_JUMP</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;
}</block>

<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_READ</name></expr></argument>)</argument_list></call><operator>:</operator>
<block>{


<expr><call><name>bc_file_flush</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>fout</name></name></expr></argument>, <argument><expr><name>bc_flush_save</name></expr></argument>)</argument_list></call></expr>;

<expr><call><name>bc_program_read</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;



<expr><name>BC_SIG_LOCK</name></expr>;
<expr><name>ip</name> <operator>=</operator> <call><name>bc_vec_top</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr>;
<expr><name>func</name> <operator>=</operator> <call><name>bc_vec_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>fns</name></name></expr></argument>, <argument><expr><name><name>ip</name><operator>-&gt;</operator><name>func</name></name></expr></argument>)</argument_list></call></expr>;
<expr><name>code</name> <operator>=</operator> <name><name>func</name><operator>-&gt;</operator><name>code</name><operator>.</operator><name>v</name></name></expr>;
<expr><call><name>bc_program_setVecs</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;
<expr><name>BC_SIG_UNLOCK</name></expr>;

<expr><call><name>BC_PROG_JUMP</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;
}</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLE_EXTRA_MATH</name></expr></cpp:if>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_RAND</name></expr></argument>)</argument_list></call><operator>:</operator>
<block>{
<expr><call><name>bc_program_rand</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>BC_PROG_JUMP</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_MAXIBASE</name></expr></argument>)</argument_list></call><operator>:</operator>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_MAXOBASE</name></expr></argument>)</argument_list></call><operator>:</operator>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_MAXSCALE</name></expr></argument>)</argument_list></call><operator>:</operator>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLE_EXTRA_MATH</name></expr></cpp:if>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_MAXRAND</name></expr></argument>)</argument_list></call><operator>:</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{
<expr><name>BcBigDig</name> <name>dig</name> <operator>=</operator> <name><name>vm</name><operator>.</operator><name>maxes</name><index>[<expr><name>inst</name> <operator>-</operator> <name>BC_INST_MAXIBASE</name></expr>]</index></name></expr>;
<expr><call><name>bc_program_pushBigdig</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>dig</name></expr></argument>, <argument><expr><name>BC_RESULT_TEMP</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>BC_PROG_JUMP</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;
}</block>

<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_LINE_LENGTH</name></expr></argument>)</argument_list></call><operator>:</operator>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLED</name></expr></cpp:if>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_GLOBAL_STACKS</name></expr></argument>)</argument_list></call><operator>:</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_LEADING_ZERO</name></expr></argument>)</argument_list></call><operator>:</operator>
<block>{
<expr><call><name>bc_program_globalSetting</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>BC_PROG_JUMP</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;
}</block>

<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_VAR</name></expr></argument>)</argument_list></call><operator>:</operator>
<block>{
<expr><call><name>bc_program_pushVar</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ip</name><operator>-&gt;</operator><name>idx</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>BC_PROG_JUMP</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;
}</block>

<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_ARRAY_ELEM</name></expr></argument>)</argument_list></call><operator>:</operator>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_ARRAY</name></expr></argument>)</argument_list></call><operator>:</operator>
<block>{
<expr><call><name>bc_program_pushArray</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ip</name><operator>-&gt;</operator><name>idx</name></name></expr></argument>, <argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>BC_PROG_JUMP</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;
}</block>

<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_IBASE</name></expr></argument>)</argument_list></call><operator>:</operator>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_SCALE</name></expr></argument>)</argument_list></call><operator>:</operator>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_OBASE</name></expr></argument>)</argument_list></call><operator>:</operator>
<block>{
<expr><call><name>bc_program_pushGlobal</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>BC_PROG_JUMP</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;
}</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLE_EXTRA_MATH</name></expr></cpp:if>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_SEED</name></expr></argument>)</argument_list></call><operator>:</operator>
<block>{
<expr><call><name>bc_program_pushSeed</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>BC_PROG_JUMP</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_LENGTH</name></expr></argument>)</argument_list></call><operator>:</operator>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_SCALE_FUNC</name></expr></argument>)</argument_list></call><operator>:</operator>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_SQRT</name></expr></argument>)</argument_list></call><operator>:</operator>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_ABS</name></expr></argument>)</argument_list></call><operator>:</operator>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLE_EXTRA_MATH</name></expr></cpp:if>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_IRAND</name></expr></argument>)</argument_list></call><operator>:</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{
<expr><call><name>bc_program_builtin</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>BC_PROG_JUMP</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;
}</block>

<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_ASCIIFY</name></expr></argument>)</argument_list></call><operator>:</operator>
<block>{
<expr><call><name>bc_program_asciify</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>ip</name><operator>-&gt;</operator><name>func</name></name></expr></argument>)</argument_list></call></expr>;



<expr><name>BC_SIG_LOCK</name></expr>;
<expr><name>ip</name> <operator>=</operator> <call><name>bc_vec_top</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr>;
<expr><name>func</name> <operator>=</operator> <call><name>bc_vec_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>fns</name></name></expr></argument>, <argument><expr><name><name>ip</name><operator>-&gt;</operator><name>func</name></name></expr></argument>)</argument_list></call></expr>;
<expr><name>code</name> <operator>=</operator> <name><name>func</name><operator>-&gt;</operator><name>code</name><operator>.</operator><name>v</name></name></expr>;
<expr><call><name>bc_program_setVecs</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;
<expr><name>BC_SIG_UNLOCK</name></expr>;

<expr><call><name>BC_PROG_JUMP</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;
}</block>

<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_NUM</name></expr></argument>)</argument_list></call><operator>:</operator>
<block>{
<expr><call><name>bc_program_const</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ip</name><operator>-&gt;</operator><name>idx</name></name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>BC_PROG_JUMP</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;
}</block>

<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_ZERO</name></expr></argument>)</argument_list></call><operator>:</operator>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_ONE</name></expr></argument>)</argument_list></call><operator>:</operator>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLED</name></expr></cpp:if>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_LAST</name></expr></argument>)</argument_list></call><operator>:</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{
<expr><name><name>r</name><operator>.</operator><name>t</name></name> <operator>=</operator> <name>BC_RESULT_ZERO</name> <operator>+</operator> <operator>(</operator><name>inst</name> <operator>-</operator> <name>BC_INST_ZERO</name><operator>)</operator></expr>;
<expr><call><name>bc_vec_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>BC_PROG_JUMP</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;
}</block>

<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_PRINT</name></expr></argument>)</argument_list></call><operator>:</operator>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_PRINT_POP</name></expr></argument>)</argument_list></call><operator>:</operator>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLED</name></expr></cpp:if>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_PRINT_STR</name></expr></argument>)</argument_list></call><operator>:</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{
<expr><call><name>bc_program_print</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>inst</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;



<expr><call><name>bc_file_flush</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>fout</name></name></expr></argument>, <argument><expr><name>bc_flush_save</name></expr></argument>)</argument_list></call></expr>;

<expr><call><name>BC_PROG_JUMP</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;
}</block>

<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_STR</name></expr></argument>)</argument_list></call><operator>:</operator>
<block>{

<expr><name><name>r</name><operator>.</operator><name>t</name></name> <operator>=</operator> <name>BC_RESULT_STR</name></expr>;
<expr><call><name>bc_num_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>r</name><operator>.</operator><name>d</name><operator>.</operator><name>n</name></name></expr></argument>)</argument_list></call></expr>;
<expr><name><name>r</name><operator>.</operator><name>d</name><operator>.</operator><name>n</name><operator>.</operator><name>rdx</name></name> <operator>=</operator> <call><name>bc_program_index</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ip</name><operator>-&gt;</operator><name>idx</name></name></expr></argument>)</argument_list></call></expr>;
<expr><name><name>r</name><operator>.</operator><name>d</name><operator>.</operator><name>n</name><operator>.</operator><name>scale</name></name> <operator>=</operator> <call><name>bc_program_index</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ip</name><operator>-&gt;</operator><name>idx</name></name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>bc_vec_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>BC_PROG_JUMP</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;
}</block>

<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_POWER</name></expr></argument>)</argument_list></call><operator>:</operator>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_MULTIPLY</name></expr></argument>)</argument_list></call><operator>:</operator>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_DIVIDE</name></expr></argument>)</argument_list></call><operator>:</operator>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_MODULUS</name></expr></argument>)</argument_list></call><operator>:</operator>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_PLUS</name></expr></argument>)</argument_list></call><operator>:</operator>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_MINUS</name></expr></argument>)</argument_list></call><operator>:</operator>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLE_EXTRA_MATH</name></expr></cpp:if>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_PLACES</name></expr></argument>)</argument_list></call><operator>:</operator>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_LSHIFT</name></expr></argument>)</argument_list></call><operator>:</operator>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_RSHIFT</name></expr></argument>)</argument_list></call><operator>:</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{
<expr><call><name>bc_program_op</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>BC_PROG_JUMP</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;
}</block>

<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_NEG</name></expr></argument>)</argument_list></call><operator>:</operator>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_BOOL_NOT</name></expr></argument>)</argument_list></call><operator>:</operator>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLE_EXTRA_MATH</name></expr></cpp:if>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_TRUNC</name></expr></argument>)</argument_list></call><operator>:</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{
<expr><call><name>bc_program_unary</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>BC_PROG_JUMP</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;
}</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLED</name></expr></cpp:if>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_ASSIGN_POWER</name></expr></argument>)</argument_list></call><operator>:</operator>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_ASSIGN_MULTIPLY</name></expr></argument>)</argument_list></call><operator>:</operator>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_ASSIGN_DIVIDE</name></expr></argument>)</argument_list></call><operator>:</operator>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_ASSIGN_MODULUS</name></expr></argument>)</argument_list></call><operator>:</operator>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_ASSIGN_PLUS</name></expr></argument>)</argument_list></call><operator>:</operator>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_ASSIGN_MINUS</name></expr></argument>)</argument_list></call><operator>:</operator>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLE_EXTRA_MATH</name></expr></cpp:if>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_ASSIGN_PLACES</name></expr></argument>)</argument_list></call><operator>:</operator>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_ASSIGN_LSHIFT</name></expr></argument>)</argument_list></call><operator>:</operator>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_ASSIGN_RSHIFT</name></expr></argument>)</argument_list></call><operator>:</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_ASSIGN</name></expr></argument>)</argument_list></call><operator>:</operator>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_ASSIGN_POWER_NO_VAL</name></expr></argument>)</argument_list></call><operator>:</operator>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_ASSIGN_MULTIPLY_NO_VAL</name></expr></argument>)</argument_list></call><operator>:</operator>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_ASSIGN_DIVIDE_NO_VAL</name></expr></argument>)</argument_list></call><operator>:</operator>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_ASSIGN_MODULUS_NO_VAL</name></expr></argument>)</argument_list></call><operator>:</operator>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_ASSIGN_PLUS_NO_VAL</name></expr></argument>)</argument_list></call><operator>:</operator>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_ASSIGN_MINUS_NO_VAL</name></expr></argument>)</argument_list></call><operator>:</operator>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLE_EXTRA_MATH</name></expr></cpp:if>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_ASSIGN_PLACES_NO_VAL</name></expr></argument>)</argument_list></call><operator>:</operator>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_ASSIGN_LSHIFT_NO_VAL</name></expr></argument>)</argument_list></call><operator>:</operator>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_ASSIGN_RSHIFT_NO_VAL</name></expr></argument>)</argument_list></call><operator>:</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_ASSIGN_NO_VAL</name></expr></argument>)</argument_list></call><operator>:</operator>
<block>{
<expr><call><name>bc_program_assign</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>BC_PROG_JUMP</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;
}</block>

<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_POP</name></expr></argument>)</argument_list></call><operator>:</operator>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>BC_PROG_NO_STACK_CHECK</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>BC_IS_DC</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><operator>!</operator><call><name>BC_PROG_STACK</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_err</name><argument_list>(<argument><expr><name>BC_ERR_EXEC_STACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt/></block_content></block></if></if_stmt>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<call><name>assert</name><argument_list>(<argument><expr><call><name>BC_PROG_STACK</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_vec_pop</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>BC_PROG_JUMP</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>

<expr_stmt><expr><call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_SWAP</name></expr></argument>)</argument_list></call><operator>:</operator>
<block>{
<expr><name>BcResult</name> <operator>*</operator><name>ptr2</name></expr>;


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><operator>!</operator><call><name>BC_PROG_STACK</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_err</name><argument_list>(<argument><expr><name>BC_ERR_EXEC_STACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<call><name>assert</name><argument_list>(<argument><expr><call><name>BC_PROG_STACK</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>


<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>bc_vec_item_rev</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ptr2</name> <operator>=</operator> <call><name>bc_vec_item_rev</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BcResult</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ptr2</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BcResult</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BcResult</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>BC_PROG_JUMP</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_MODEXP</name></expr></argument>)</argument_list></call><operator>:</operator>
<block>{
<expr><call><name>bc_program_modexp</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>BC_PROG_JUMP</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;
}</block>

<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_DIVMOD</name></expr></argument>)</argument_list></call><operator>:</operator>
<block>{
<expr><call><name>bc_program_divmod</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>BC_PROG_JUMP</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;
}</block>

<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_PRINT_STREAM</name></expr></argument>)</argument_list></call><operator>:</operator>
<block>{
<expr><call><name>bc_program_printStream</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>BC_PROG_JUMP</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;
}</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DC_ENABLED</name></expr></cpp:if>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_POP_EXEC</name></expr></argument>)</argument_list></call><operator>:</operator>
<block>{

<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>BC_PROG_STACK</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;


<expr><call><name>bc_vec_pop</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>bc_vec_pop</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>tail_calls</name></name></expr></argument>)</argument_list></call></expr>;



<expr><name>BC_SIG_LOCK</name></expr>;
<expr><name>ip</name> <operator>=</operator> <call><name>bc_vec_top</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr>;
<expr><name>func</name> <operator>=</operator> <call><name>bc_vec_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>fns</name></name></expr></argument>, <argument><expr><name><name>ip</name><operator>-&gt;</operator><name>func</name></name></expr></argument>)</argument_list></call></expr>;
<expr><name>code</name> <operator>=</operator> <name><name>func</name><operator>-&gt;</operator><name>code</name><operator>.</operator><name>v</name></name></expr>;
<expr><call><name>bc_program_setVecs</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;
<expr><name>BC_SIG_UNLOCK</name></expr>;

<expr><call><name>BC_PROG_JUMP</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;
}</block>

<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_EXECUTE</name></expr></argument>)</argument_list></call><operator>:</operator>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_EXEC_COND</name></expr></argument>)</argument_list></call><operator>:</operator>
<block>{
<expr><name>cond</name> <operator>=</operator> <operator>(</operator><name>inst</name> <operator>==</operator> <name>BC_INST_EXEC_COND</name><operator>)</operator></expr>;

<expr><call><name>bc_program_execStr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ip</name><operator>-&gt;</operator><name>idx</name></name></expr></argument>, <argument><expr><name>cond</name></expr></argument>, <argument><expr><name><name>func</name><operator>-&gt;</operator><name>code</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;



<expr><name>BC_SIG_LOCK</name></expr>;
<expr><name>ip</name> <operator>=</operator> <call><name>bc_vec_top</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr>;
<expr><name>func</name> <operator>=</operator> <call><name>bc_vec_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>fns</name></name></expr></argument>, <argument><expr><name><name>ip</name><operator>-&gt;</operator><name>func</name></name></expr></argument>)</argument_list></call></expr>;
<expr><name>code</name> <operator>=</operator> <name><name>func</name><operator>-&gt;</operator><name>code</name><operator>.</operator><name>v</name></name></expr>;
<expr><call><name>bc_program_setVecs</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;
<expr><name>BC_SIG_UNLOCK</name></expr>;

<expr><call><name>BC_PROG_JUMP</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;
}</block>

<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_PRINT_STACK</name></expr></argument>)</argument_list></call><operator>:</operator>
<block>{
<expr><call><name>bc_program_printStack</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>BC_PROG_JUMP</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;
}</block>

<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_CLEAR_STACK</name></expr></argument>)</argument_list></call><operator>:</operator>
<block>{
<expr><call><name>bc_vec_popAll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>BC_PROG_JUMP</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;
}</block>

<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_REG_STACK_LEN</name></expr></argument>)</argument_list></call><operator>:</operator>
<block>{
<expr><call><name>bc_program_regStackLen</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ip</name><operator>-&gt;</operator><name>idx</name></name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>BC_PROG_JUMP</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;
}</block>

<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_STACK_LEN</name></expr></argument>)</argument_list></call><operator>:</operator>
<block>{
<expr><call><name>bc_program_stackLen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>BC_PROG_JUMP</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;
}</block>

<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_DUPLICATE</name></expr></argument>)</argument_list></call><operator>:</operator>
<block>{

<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><operator>!</operator><call><name>BC_PROG_STACK</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_err</name><argument_list>(<argument><expr><name>BC_ERR_EXEC_STACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<call><name>assert</name><argument_list>(<argument><expr><call><name>BC_PROG_STACK</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>


<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>bc_vec_top</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_LOCK</name></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_result_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_vec_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>BC_SIG_UNLOCK</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>BC_PROG_JUMP</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}

BC_PROG_LBL<expr_stmt><expr><operator>(</operator><name>BC_INST_LOAD</name><operator>)</operator><operator>:</operator>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_PUSH_VAR</name></expr></argument>)</argument_list></call><operator>:</operator>
<block>{
<expr><name>bool</name> <name>copy</name> <operator>=</operator> <operator>(</operator><name>inst</name> <operator>==</operator> <name>BC_INST_LOAD</name><operator>)</operator></expr>;
<expr><call><name>bc_program_pushVar</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ip</name><operator>-&gt;</operator><name>idx</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>BC_PROG_JUMP</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;
}</block>

<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_PUSH_TO_VAR</name></expr></argument>)</argument_list></call><operator>:</operator>
<block>{
<expr><name>idx</name> <operator>=</operator> <call><name>bc_program_index</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ip</name><operator>-&gt;</operator><name>idx</name></name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>bc_program_copyToVar</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>BC_TYPE_VAR</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>BC_PROG_JUMP</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;
}</block>

<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_QUIT</name></expr></argument>)</argument_list></call><operator>:</operator>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_NQUIT</name></expr></argument>)</argument_list></call><operator>:</operator>
<block>{
<expr><call><name>bc_program_nquit</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr>;



<expr><name>BC_SIG_LOCK</name></expr>;
<expr><name>ip</name> <operator>=</operator> <call><name>bc_vec_top</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr>;
<expr><name>func</name> <operator>=</operator> <call><name>bc_vec_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>fns</name></name></expr></argument>, <argument><expr><name><name>ip</name><operator>-&gt;</operator><name>func</name></name></expr></argument>)</argument_list></call></expr>;
<expr><name>code</name> <operator>=</operator> <name><name>func</name><operator>-&gt;</operator><name>code</name><operator>.</operator><name>v</name></name></expr>;
<expr><call><name>bc_program_setVecs</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;
<expr><name>BC_SIG_UNLOCK</name></expr>;

<expr><call><name>BC_PROG_JUMP</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;
}</block>

<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_EXEC_STACK_LEN</name></expr></argument>)</argument_list></call><operator>:</operator>
<block>{
<expr><call><name>bc_program_execStackLen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>BC_PROG_JUMP</name><argument_list>(<argument><expr><name>inst</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_HAS_COMPUTED_GOTO</name></expr></cpp:if>
<call><name>BC_PROG_LBL</name><argument_list>(<argument><expr><name>BC_INST_INVALID</name></expr></argument>)</argument_list></call><operator>:</operator>
<block>{
<return>return;</return>
}</block></expr></expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<default>default:</default>
<block>{<block_content>
<function_decl><type><name>BC_UNREACHABLE</name></type>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<name>abort</name><parameter_list>()</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>BC_HAS_COMPUTED_GOTO</name></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>



assert<expr_stmt><expr><operator>(</operator><name>jmp_bufs_len</name> <operator>==</operator> <name><name>vm</name><operator>.</operator><name>jmp_bufs</name><operator>.</operator><name>len</name></name><operator>)</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}
}

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_DEBUG_CODE</name></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLED</name> <operator>&amp;&amp;</operator> <name>DC_ENABLED</name></expr></cpp:if>
<function><type><name>void</name></type> <name>bc_program_printStackDebug</name><parameter_list>(<parameter><decl><type><name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>bc_file_puts</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>fout</name></name></expr></argument>, <argument><expr><name>bc_flush_err</name></expr></argument>, <argument><expr><literal type="string">"-------------- Stack ----------\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_program_printStack</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_file_puts</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>fout</name></name></expr></argument>, <argument><expr><name>bc_flush_err</name></expr></argument>, <argument><expr><literal type="string">"-------------- Stack End ------\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_program_printIndex</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>code</name></decl></parameter>,
<parameter><decl><type><name>size_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>bgn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uchar</name></type> <name>byte</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>bytes</name> <init>= <expr><operator>(</operator><name>uchar</name><operator>)</operator> <name><name>code</name><index>[<expr><operator>(</operator><operator>*</operator><name>bgn</name><operator>)</operator><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ulong</name></type> <name>val</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>byte</name> <operator>=</operator> <literal type="number">1</literal></expr><operator>,</operator> <expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>byte</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name>bytes</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>byte</name> <operator>=</operator> <operator>(</operator><name>uchar</name><operator>)</operator> <name><name>code</name><index>[<expr><operator>(</operator><operator>*</operator><name>bgn</name><operator>)</operator><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>byte</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>val</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>ulong</name><operator>)</operator> <name>byte</name><operator>)</operator> <operator>&lt;&lt;</operator> <operator>(</operator><name>CHAR_BIT</name> <operator>*</operator> <name>i</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>bc_vm_printf</name><argument_list>(<argument><expr><literal type="string">" (%lu) "</literal></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_program_printStr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>code</name></decl></parameter>,
<parameter><decl><type><name>size_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>bgn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>idx</name> <init>= <expr><call><name>bc_program_index</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><name>bgn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator> <call><name>bc_vec_item</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>strs</name></name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_vm_printf</name><argument_list>(<argument><expr><literal type="string">" (\"%s\") "</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>bc_program_printInst</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BcProgram</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>code</name></decl></parameter>,
<parameter><decl><type><name>size_t</name> <modifier>*</modifier><specifier>restrict</specifier></type> <name>bgn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uchar</name></type> <name>inst</name> <init>= <expr><operator>(</operator><name>uchar</name><operator>)</operator> <name><name>code</name><index>[<expr><operator>(</operator><operator>*</operator><name>bgn</name><operator>)</operator><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>bc_vm_printf</name><argument_list>(<argument><expr><literal type="string">"Inst[%zu]: %s [%lu]; "</literal></expr></argument>, <argument><expr><operator>*</operator><name>bgn</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
<argument><expr><name><name>bc_inst_names</name><index>[<expr><name>inst</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>inst</name> <operator>==</operator> <name>BC_INST_VAR</name> <operator>||</operator> <name>inst</name> <operator>==</operator> <name>BC_INST_ARRAY_ELEM</name> <operator>||</operator>
<name>inst</name> <operator>==</operator> <name>BC_INST_ARRAY</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>bc_program_printIndex</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><name>bgn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>inst</name> <operator>==</operator> <name>BC_INST_STR</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_program_printStr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>bgn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>inst</name> <operator>==</operator> <name>BC_INST_NUM</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>idx</name> <init>= <expr><call><name>bc_program_index</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><name>bgn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcConst</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><call><name>bc_vec_item</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>consts</name></name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>bc_vm_printf</name><argument_list>(<argument><expr><literal type="string">"(%s)"</literal></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>inst</name> <operator>==</operator> <name>BC_INST_CALL</name> <operator>||</operator>
<operator>(</operator><name>inst</name> <operator>&gt;</operator> <name>BC_INST_STR</name> <operator>&amp;&amp;</operator> <name>inst</name> <operator>&lt;=</operator> <name>BC_INST_JUMP_ZERO</name><operator>)</operator></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>bc_program_printIndex</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><name>bgn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>inst</name> <operator>==</operator> <name>BC_INST_CALL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_program_printIndex</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><name>bgn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>bc_vm_putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>bc_flush_err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>bc_program_code</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BcProgram</name><modifier>*</modifier></type> <name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>BcFunc</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>code</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcInstPtr</name></type> <name>ip</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>p</name><operator>-&gt;</operator><name>fns</name><operator>.</operator><name>len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>ip</name><operator>.</operator><name>idx</name></name> <operator>=</operator> <name><name>ip</name><operator>.</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ip</name><operator>.</operator><name>func</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>bc_vec_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>fns</name></name></expr></argument>, <argument><expr><name><name>ip</name><operator>.</operator><name>func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>code</name> <operator>=</operator> <name><name>f</name><operator>-&gt;</operator><name>code</name><operator>.</operator><name>v</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_vm_printf</name><argument_list>(<argument><expr><literal type="string">"func[%zu]:\n"</literal></expr></argument>, <argument><expr><name><name>ip</name><operator>.</operator><name>func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name><name>ip</name><operator>.</operator><name>idx</name></name> <operator>&lt;</operator> <name><name>f</name><operator>-&gt;</operator><name>code</name><operator>.</operator><name>len</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_program_printInst</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ip</name><operator>.</operator><name>idx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><call><name>bc_file_puts</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>fout</name></name></expr></argument>, <argument><expr><name>bc_flush_err</name></expr></argument>, <argument><expr><literal type="string">"\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
