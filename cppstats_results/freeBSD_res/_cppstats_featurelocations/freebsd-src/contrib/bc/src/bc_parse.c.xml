<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/bc/src/bc_parse.c">


































<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLED</name></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdbool.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;setjmp.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;bc.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;num.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vm.h&gt;</cpp:file></cpp:include>










<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>bc_parse_else</name><parameter_list>(<parameter><decl><type><name>BcParse</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>bc_parse_stmt</name><parameter_list>(<parameter><decl><type><name>BcParse</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>BcParseStatus</name></type> <name>bc_parse_expr_err</name><parameter_list>(<parameter><decl><type><name>BcParse</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>flags</name></decl></parameter>,
<parameter><decl><type><name>BcParseNext</name></type> <name>next</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>bc_parse_expr_status</name><parameter_list>(<parameter><decl><type><name>BcParse</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>BcParseNext</name></type> <name>next</name></decl></parameter>)</parameter_list>;</function_decl>






<function><type><specifier>static</specifier> <name>bool</name></type> <name>bc_parse_inst_isLeaf</name><parameter_list>(<parameter><decl><type><name>BcInst</name></type> <name>t</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><operator>(</operator><name>t</name> <operator>&gt;=</operator> <name>BC_INST_NUM</name> <operator>&amp;&amp;</operator> <name>t</name> <operator>&lt;=</operator> <name>BC_INST_MAXSCALE</name><operator>)</operator> <operator>||</operator>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLE_EXTRA_MATH</name></expr></cpp:if>
<name>t</name> <operator>==</operator> <name>BC_INST_TRUNC</name> <operator>||</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<name>t</name> <operator>&lt;=</operator> <name>BC_INST_DEC</name></expr>;</return>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>bool</name></type> <name>bc_parse_isDelimiter</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BcParse</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>BcLexType</name></type> <name>t</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>good</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_PARSE_DELIMITER</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>good</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>




<if_stmt><if>if <condition>(<expr><name>t</name> <operator>==</operator> <name>BC_LEX_KW_ELSE</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>fptr</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"/><name>flags</name> <init>= <expr><name>BC_PARSE_FLAG_ELSE</name></expr></init></decl>;</decl_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>p</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>len</name></name> <operator>&amp;&amp;</operator> <call><name>BC_PARSE_BLOCK_STMT</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>fptr</name> <operator>=</operator> <call><name>bc_vec_item_rev</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>flags</name> <operator>=</operator> <operator>*</operator><name>fptr</name></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>BC_PARSE_FLAG_BRACE</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>last</name></name> <operator>!=</operator> <name>BC_LEX_RBRACE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>


<expr_stmt><expr><name>good</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>BC_PARSE_FLAG_IF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>t</name> <operator>==</operator> <name>BC_LEX_RBRACE</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>!</operator><name>good</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name><name>p</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>fptr</name> <init>= <expr><call><name>bc_vec_item_rev</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>good</name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><operator>*</operator><name>fptr</name><operator>)</operator> <operator>&amp;</operator> <name>BC_PARSE_FLAG_BRACE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>good</name></expr>;</return>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>bool</name></type> <name>bc_parse_TopFunc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BcParse</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>bool</name></type> <name>good</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>len</name></name> <operator>==</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint16_t</name></type> <name>val</name> <init>= <expr><name>BC_PARSE_FLAG_BRACE</name> <operator>|</operator> <name>BC_PARSE_FLAG_FUNC_INNER</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>val</name> <operator>|=</operator> <name>BC_PARSE_FLAG_FUNC</name></expr>;</expr_stmt>

<return>return <expr><name>good</name> <operator>&amp;&amp;</operator> <call><name>BC_PARSE_TOP_FLAG</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>val</name></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_parse_setLabel</name><parameter_list>(<parameter><decl><type><name>BcParse</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>BcFunc</name> <modifier>*</modifier></type><name>func</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>func</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcInstPtr</name> <modifier>*</modifier></type><name>ip</name> <init>= <expr><call><name>bc_vec_top</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>exits</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name> <modifier>*</modifier></type><name>label</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>func</name> <operator>==</operator> <call><name>bc_vec_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>prog</name><operator>-&gt;</operator><name>fns</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>fidx</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>label</name> <operator>=</operator> <call><name>bc_vec_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>func</name><operator>-&gt;</operator><name>labels</name></name></expr></argument>, <argument><expr><name><name>ip</name><operator>-&gt;</operator><name>idx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>label</name> <operator>=</operator> <name><name>func</name><operator>-&gt;</operator><name>code</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_vec_pop</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>exits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_parse_createLabel</name><parameter_list>(<parameter><decl><type><name>BcParse</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>idx</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>bc_vec_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>func</name><operator>-&gt;</operator><name>labels</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_parse_createCondLabel</name><parameter_list>(<parameter><decl><type><name>BcParse</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>idx</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>bc_parse_createLabel</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>func</name><operator>-&gt;</operator><name>code</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_vec_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>conds</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>















<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_parse_createExitLabel</name><parameter_list>(<parameter><decl><type><name>BcParse</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>idx</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>loop</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>BcInstPtr</name></type> <name>ip</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>func</name></name> <operator>==</operator> <call><name>bc_vec_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>prog</name><operator>-&gt;</operator><name>fns</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>fidx</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ip</name><operator>.</operator><name>func</name></name> <operator>=</operator> <name>loop</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ip</name><operator>.</operator><name>idx</name></name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ip</name><operator>.</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_vec_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>exits</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_parse_createLabel</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SIZE_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>













<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_parse_operator</name><parameter_list>(<parameter><decl><type><name>BcParse</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>BcLexType</name></type> <name>type</name></decl></parameter>,
<parameter><decl><type><name>size_t</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>nexprs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>BcLexType</name></type> <name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uchar</name></type> <name>l</name></decl>, <decl><type ref="prev"/><name>r</name> <init>= <expr><call><name>BC_PARSE_OP_PREC</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uchar</name></type> <name>left</name> <init>= <expr><call><name>BC_PARSE_OP_LEFT</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<while>while <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>ops</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <name>start</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>BC_PARSE_TOP_OP</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name>t</name> <operator>==</operator> <name>BC_LEX_LPAREN</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>





<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>BC_PARSE_OP_PREC</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>l</name> <operator>&gt;=</operator> <name>r</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>l</name> <operator>!=</operator> <name>r</name> <operator>||</operator> <operator>!</operator><name>left</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>



<expr_stmt><expr><call><name>bc_parse_push</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>BC_PARSE_TOKEN_INST</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_vec_pop</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>ops</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>nexprs</name> <operator>-=</operator> <operator>!</operator><call><name>BC_PARSE_OP_PREFIX</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>

<expr_stmt><expr><call><name>bc_vec_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>ops</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>









<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_parse_rightParen</name><parameter_list>(<parameter><decl><type><name>BcParse</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>nexprs</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>BcLexType</name></type> <name>top</name></decl>;</decl_stmt>


<while>while <condition>(<expr><operator>(</operator><name>top</name> <operator>=</operator> <call><name>BC_PARSE_TOP_OP</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>BC_LEX_LPAREN</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bc_parse_push</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>BC_PARSE_TOKEN_INST</name><argument_list>(<argument><expr><name>top</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_vec_pop</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>ops</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>nexprs</name> <operator>-=</operator> <operator>!</operator><call><name>BC_PARSE_OP_PREFIX</name><argument_list>(<argument><expr><name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>


<expr_stmt><expr><call><name>bc_vec_pop</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>ops</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_parse_args</name><parameter_list>(<parameter><decl><type><name>BcParse</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>flags</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>bool</name></type> <name>comma</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>nargs</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>BC_PARSE_PRINT</name> <operator>|</operator> <name>BC_PARSE_REL</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <operator>(</operator><name>BC_PARSE_ARRAY</name> <operator>|</operator> <name>BC_PARSE_NEEDVAL</name><operator>)</operator></expr>;</expr_stmt>


<for>for <control>(<init><expr><name>nargs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>!=</operator> <name>BC_LEX_RPAREN</name></expr>;</condition> <incr><expr><operator>++</operator><name>nargs</name></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>bc_parse_expr_status</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>bc_parse_next_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>comma</name> <operator>=</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>==</operator> <name>BC_LEX_COMMA</name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>comma</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><name>comma</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_TOKEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>bc_parse_push</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_INST_CALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_parse_pushIndex</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_parse_call</name><parameter_list>(<parameter><decl><type><name>BcParse</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>flags</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>idx</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>bc_parse_args</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>==</operator> <name>BC_LEX_RPAREN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>bc_map_index</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>prog</name><operator>-&gt;</operator><name>fn_map</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>==</operator> <name>BC_VEC_INVALID_IDX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>bc_program_insertFunc</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>prog</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>idx</name> <operator>!=</operator> <name>BC_VEC_INVALID_IDX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>func</name></name> <operator>=</operator> <call><name>bc_vec_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>prog</name><operator>-&gt;</operator><name>fns</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>fidx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>

<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>idx</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>BcId</name><operator>*</operator><operator>)</operator> <call><name>bc_vec_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>prog</name><operator>-&gt;</operator><name>fn_map</name></name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>idx</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>bc_parse_pushIndex</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_parse_name</name><parameter_list>(<parameter><decl><type><name>BcParse</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>BcInst</name> <modifier>*</modifier></type><name>type</name></decl></parameter>,
<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>can_assign</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

<expr_stmt><expr><name>BC_SIG_ASSERT_LOCKED</name></expr>;</expr_stmt>


<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>bc_vm_strdup</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>str</name><operator>.</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>BC_SETJMP_LOCKED</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>==</operator> <name>BC_LEX_LBRACKET</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>==</operator> <name>BC_LEX_RBRACKET</name></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>BC_PARSE_ARRAY</name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>type</name> <operator>=</operator> <name>BC_INST_ARRAY</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>can_assign</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>



<decl_stmt><decl><type><name>uint8_t</name></type> <name>flags2</name> <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>BC_PARSE_PRINT</name> <operator>|</operator> <name>BC_PARSE_REL</name><operator>)</operator><operator>)</operator> <operator>|</operator>
<name>BC_PARSE_NEEDVAL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>bc_parse_expr_status</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>flags2</name></expr></argument>, <argument><expr><name>bc_parse_next_elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>!=</operator> <name>BC_LEX_RBRACKET</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_TOKEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>type</name> <operator>=</operator> <name>BC_INST_ARRAY_ELEM</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>can_assign</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_parse_push</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>*</operator><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_parse_pushName</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>==</operator> <name>BC_LEX_LPAREN</name></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><name>flags</name> <operator>&amp;</operator> <name>BC_PARSE_NOCALL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_TOKEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>type</name> <operator>=</operator> <name>BC_INST_CALL</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>can_assign</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_parse_call</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>type</name> <operator>=</operator> <name>BC_INST_VAR</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>can_assign</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_parse_push</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_INST_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_parse_pushName</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<label><name>err</name>:</label>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>BC_LONGJMP_CONT</name></expr>;</expr_stmt>
<expr_stmt><expr><name>BC_SIG_MAYLOCK</name></expr>;</expr_stmt>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_parse_noArgBuiltin</name><parameter_list>(<parameter><decl><type><name>BcParse</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>BcInst</name></type> <name>inst</name></decl></parameter>)</parameter_list> <block>{<block_content>


<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>!=</operator> <name>BC_LEX_LPAREN</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_TOKEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>!=</operator> <name>BC_LEX_RPAREN</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_TOKEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>bc_parse_push</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>









<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_parse_builtin</name><parameter_list>(<parameter><decl><type><name>BcParse</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>BcLexType</name></type> <name>type</name></decl></parameter>,
<parameter><decl><type><name>uint8_t</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>BcInst</name> <modifier>*</modifier></type><name>prev</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>!=</operator> <name>BC_LEX_LPAREN</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_TOKEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>BC_PARSE_PRINT</name> <operator>|</operator> <name>BC_PARSE_REL</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>BC_PARSE_NEEDVAL</name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>BC_LEX_KW_LENGTH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>BC_PARSE_ARRAY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>bc_parse_expr_status</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>bc_parse_next_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>!=</operator> <name>BC_LEX_RPAREN</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_TOKEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><operator>*</operator><name>prev</name> <operator>=</operator> <name>type</name> <operator>-</operator> <name>BC_LEX_KW_LENGTH</name> <operator>+</operator> <name>BC_INST_LENGTH</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_parse_push</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>*</operator><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_parse_builtin3</name><parameter_list>(<parameter><decl><type><name>BcParse</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>BcLexType</name></type> <name>type</name></decl></parameter>,
<parameter><decl><type><name>uint8_t</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>BcInst</name> <modifier>*</modifier></type><name>prev</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>type</name> <operator>==</operator> <name>BC_LEX_KW_MODEXP</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>BC_LEX_KW_DIVMOD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>!=</operator> <name>BC_LEX_LPAREN</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_TOKEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>BC_PARSE_PRINT</name> <operator>|</operator> <name>BC_PARSE_REL</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>BC_PARSE_NEEDVAL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_parse_expr_status</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>bc_parse_next_builtin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>!=</operator> <name>BC_LEX_COMMA</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_TOKEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_parse_expr_status</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>bc_parse_next_builtin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>!=</operator> <name>BC_LEX_COMMA</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_TOKEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>BC_LEX_KW_DIVMOD</name></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>!=</operator> <name>BC_LEX_NAME</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_TOKEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>!=</operator> <name>BC_LEX_LBRACKET</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_TOKEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>!=</operator> <name>BC_LEX_RBRACKET</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_TOKEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_parse_expr_status</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>bc_parse_next_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>!=</operator> <name>BC_LEX_RPAREN</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_TOKEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><operator>*</operator><name>prev</name> <operator>=</operator> <name>type</name> <operator>-</operator> <name>BC_LEX_KW_MODEXP</name> <operator>+</operator> <name>BC_INST_MODEXP</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_parse_push</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>*</operator><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>BC_LEX_KW_DIVMOD</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><call><name>bc_parse_push</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_INST_ZERO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_parse_push</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_INST_ARRAY_ELEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_parse_pushName</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>str</name><operator>.</operator><name>v</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><call><name>bc_parse_push</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_INST_SWAP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_parse_push</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_INST_ASSIGN_NO_VAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>










<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_parse_scale</name><parameter_list>(<parameter><decl><type><name>BcParse</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>BcInst</name> <modifier>*</modifier></type><name>type</name></decl></parameter>,
<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>can_assign</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>!=</operator> <name>BC_LEX_LPAREN</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><operator>*</operator><name>type</name> <operator>=</operator> <name>BC_INST_SCALE</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>can_assign</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_parse_push</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_INST_SCALE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><operator>*</operator><name>type</name> <operator>=</operator> <name>BC_INST_SCALE_FUNC</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>can_assign</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>


<expr_stmt><expr><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>BC_PARSE_PRINT</name> <operator>|</operator> <name>BC_PARSE_REL</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>BC_PARSE_NEEDVAL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_parse_expr_status</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>bc_parse_next_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>!=</operator> <name>BC_LEX_RPAREN</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_TOKEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>bc_parse_push</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_INST_SCALE_FUNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_parse_incdec</name><parameter_list>(<parameter><decl><type><name>BcParse</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>BcInst</name> <modifier>*</modifier></type><name>prev</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>can_assign</name></decl></parameter>,
<parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>nexs</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>BcLexType</name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uchar</name></type> <name>inst</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcInst</name></type> <name>etype</name> <init>= <expr><operator>*</operator><name>prev</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcLexType</name></type> <name>last</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>last</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>prev</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>can_assign</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><name>last</name> <operator>==</operator> <name>BC_LEX_OP_INC</name> <operator>||</operator> <name>last</name> <operator>==</operator> <name>BC_LEX_OP_DEC</name> <operator>||</operator>
<name>last</name> <operator>==</operator> <name>BC_LEX_RPAREN</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_ASSIGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_PARSE_INST_VAR</name><argument_list>(<argument><expr><name>etype</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>can_assign</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_ASSIGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><operator>*</operator><name>prev</name> <operator>=</operator> <name>inst</name> <operator>=</operator> <name>BC_INST_INC</name> <operator>+</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>!=</operator> <name>BC_LEX_OP_INC</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_parse_push</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>can_assign</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>



<expr_stmt><expr><operator>*</operator><name>prev</name> <operator>=</operator> <name>inst</name> <operator>=</operator> <name>BC_INST_ASSIGN_PLUS</name> <operator>+</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>!=</operator> <name>BC_LEX_OP_INC</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>type</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name></expr>;</expr_stmt>



<expr_stmt><expr><operator>*</operator><name>nexs</name> <operator>=</operator> <operator>*</operator><name>nexs</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>BC_LEX_NAME</name></expr>)</condition> <block>{<block_content>


<decl_stmt><decl><type><name>uint8_t</name></type> <name>flags2</name> <init>= <expr><name>flags</name> <operator>&amp;</operator> <operator>~</operator><name>BC_PARSE_ARRAY</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>bc_parse_name</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>, <argument><expr><name>can_assign</name></expr></argument>, <argument><expr><name>flags2</name> <operator>|</operator> <name>BC_PARSE_NOCALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>type</name> <operator>&gt;=</operator> <name>BC_LEX_KW_LAST</name> <operator>&amp;&amp;</operator> <name>type</name> <operator>&lt;=</operator> <name>BC_LEX_KW_OBASE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bc_parse_push</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>type</name> <operator>-</operator> <name>BC_LEX_KW_LAST</name> <operator>+</operator> <name>BC_INST_LAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>BC_NO_ERR</name><argument_list>(<argument><expr><name>type</name> <operator>==</operator> <name>BC_LEX_KW_SCALE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>==</operator> <name>BC_LEX_LPAREN</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_TOKEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_parse_push</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_INST_SCALE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if>

<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_TOKEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><operator>*</operator><name>can_assign</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_parse_push</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_INST_ONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_parse_push</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_parse_minus</name><parameter_list>(<parameter><decl><type><name>BcParse</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>BcInst</name> <modifier>*</modifier></type><name>prev</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>ops_bgn</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>rparen</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>binlast</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>nexprs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>BcLexType</name></type> <name>type</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>type</name> <operator>=</operator> <ternary><condition><expr><call><name>BC_PARSE_LEAF</name><argument_list>(<argument><expr><operator>*</operator><name>prev</name></expr></argument>, <argument><expr><name>binlast</name></expr></argument>, <argument><expr><name>rparen</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>BC_LEX_OP_MINUS</name></expr> </then><else>: <expr><name>BC_LEX_NEG</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>prev</name> <operator>=</operator> <call><name>BC_PARSE_TOKEN_INST</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>BC_LEX_OP_MINUS</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_vec_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>ops</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_parse_operator</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>ops_bgn</name></expr></argument>, <argument><expr><name>nexprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_parse_str</name><parameter_list>(<parameter><decl><type><name>BcParse</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>BcInst</name></type> <name>inst</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>bc_parse_addString</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_parse_push</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_parse_print</name><parameter_list>(<parameter><decl><type><name>BcParse</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>BcLexType</name></type> <name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>BcLexType</name></type> <name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>comma</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcInst</name></type> <name>inst</name> <init>= <expr><ternary><condition><expr><name>type</name> <operator>==</operator> <name>BC_LEX_KW_STREAM</name></expr> ?</condition><then>
<expr><name>BC_INST_PRINT_STREAM</name></expr> </then><else>: <expr><name>BC_INST_PRINT_POP</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>t</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>bc_parse_isDelimiter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_PRINT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<do>do <block>{<block_content>



<if_stmt><if>if <condition>(<expr><name>t</name> <operator>==</operator> <name>BC_LEX_STR</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_parse_str</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>

<expr_stmt><expr><call><name>bc_parse_expr_status</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_PARSE_NEEDVAL</name></expr></argument>, <argument><expr><name>bc_parse_next_print</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_parse_push</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<expr_stmt><expr><name>comma</name> <operator>=</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>==</operator> <name>BC_LEX_COMMA</name><operator>)</operator></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>comma</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bc_parse_isDelimiter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_TOKEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <break>break;</break></block_content></block></else></if_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>t</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name></expr>;</expr_stmt>

</block_content>}</block> while <condition>(<expr><name>true</name></expr>)</condition>;</do>


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><name>comma</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_TOKEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_parse_return</name><parameter_list>(<parameter><decl><type><name>BcParse</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>BcLexType</name></type> <name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>paren</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uchar</name></type> <name>inst</name> <init>= <expr><name>BC_INST_RET0</name></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><operator>!</operator><call><name>BC_PARSE_FUNC</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_TOKEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>func</name><operator>-&gt;</operator><name>voidfn</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>inst</name> <operator>=</operator> <name>BC_INST_RET_VOID</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>t</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>paren</name> <operator>=</operator> <operator>(</operator><name>t</name> <operator>==</operator> <name>BC_LEX_LPAREN</name><operator>)</operator></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>bc_parse_isDelimiter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_parse_push</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>

<decl_stmt><decl><type><name>BcParseStatus</name></type> <name>s</name></decl>;</decl_stmt>


<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>bc_parse_expr_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_PARSE_NEEDVAL</name></expr></argument>, <argument><expr><name>bc_parse_next_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <name>BC_PARSE_STATUS_EMPTY_EXPR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bc_parse_push</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name>paren</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>last</name></name> <operator>!=</operator> <name>BC_LEX_RPAREN</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_POSIX_RET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>func</name><operator>-&gt;</operator><name>voidfn</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>s</name> <operator>!=</operator> <name>BC_PARSE_STATUS_EMPTY_EXPR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_verr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_RET_VOID</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>func</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if>


<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_parse_push</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_INST_RET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_parse_noElse</name><parameter_list>(<parameter><decl><type><name>BcParse</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>flag_ptr</name> <init>= <expr><call><name>BC_PARSE_TOP_FLAG_PTR</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>flag_ptr</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>flag_ptr</name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>BC_PARSE_FLAG_IF_END</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_parse_setLabel</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_parse_endBody</name><parameter_list>(<parameter><decl><type><name>BcParse</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>brace</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>bool</name></type> <name>has_brace</name></decl>, <decl><type ref="prev"/><name>new_else</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>len</name></name> <operator>&lt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_TOKEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>brace</name></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>==</operator> <name>BC_LEX_RBRACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><operator>!</operator><call><name>bc_parse_isDelimiter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>bc_parse_TopFunc</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_TOKEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>has_brace</name> <operator>=</operator> <operator>(</operator><call><name>BC_PARSE_BRACE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

<do>do <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>len</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>loop</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name>has_brace</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>brace</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_TOKEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><name>loop</name> <operator>=</operator> <operator>(</operator><call><name>BC_PARSE_LOOP_INNER</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>loop</name> <operator>||</operator> <call><name>BC_PARSE_ELSE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><name>loop</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name> <modifier>*</modifier></type><name>label</name> <init>= <expr><call><name>bc_vec_top</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>conds</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>bc_parse_push</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_INST_JUMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_parse_pushIndex</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>*</operator><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_vec_pop</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>conds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>bc_parse_setLabel</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_vec_pop</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>BC_PARSE_FUNC_INNER</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>BcInst</name></type> <name>inst</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name><name>p</name><operator>-&gt;</operator><name>func</name><operator>-&gt;</operator><name>voidfn</name></name></expr> ?</condition><then> <expr><name>BC_INST_RET_VOID</name></expr> </then><else>: <expr><name>BC_INST_RET0</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>bc_parse_push</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_parse_updateFunc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_PROG_MAIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_vec_pop</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>


<if type="elseif">else if <condition>(<expr><name>has_brace</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>BC_PARSE_IF</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_vec_pop</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_PARSE_IF</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>len</name> <operator>==</operator> <name><name>p</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>len</name></name> <operator>||</operator> <operator>!</operator><call><name>BC_PARSE_BRACE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>


<while>while <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>==</operator> <name>BC_LEX_NLINE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>


<expr_stmt><expr><call><name>bc_vec_pop</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name>BC_S</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><operator>*</operator><operator>(</operator><call><name>BC_PARSE_TOP_FLAG_PTR</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>|=</operator> <name>BC_PARSE_FLAG_IF_END</name></expr>;</expr_stmt>
<expr_stmt><expr><name>new_else</name> <operator>=</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>==</operator> <name>BC_LEX_KW_ELSE</name><operator>)</operator></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>new_else</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_parse_else</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><name>has_brace</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>BC_PARSE_IF_END</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>brace</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_noElse</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if>

<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_parse_noElse</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>brace</name> <operator>&amp;&amp;</operator> <name>has_brace</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>brace</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>






</block_content>}</block> while <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>new_else</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>BC_PARSE_IF_END</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>brace</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>!</operator><operator>(</operator><name>has_brace</name> <operator>=</operator> <operator>(</operator><call><name>BC_PARSE_BRACE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>)</condition>;</do>


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>len</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>brace</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_TOKEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>brace</name> <operator>&amp;&amp;</operator> <call><name>BC_PARSE_BRACE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>


<decl_stmt><decl><type><name>uint16_t</name></type> <name>flags</name> <init>= <expr><call><name>BC_PARSE_TOP_FLAG</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>



<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>BC_PARSE_FLAG_FUNC_INNER</name> <operator>|</operator> <name>BC_PARSE_FLAG_LOOP_INNER</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>BC_PARSE_FLAG_IF</name> <operator>|</operator> <name>BC_PARSE_FLAG_ELSE</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>BC_PARSE_FLAG_IF_END</name><operator>)</operator><operator>)</operator></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>bc_vec_pop</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_parse_startBody</name><parameter_list>(<parameter><decl><type><name>BcParse</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>flags</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <operator>(</operator><call><name>BC_PARSE_TOP_FLAG</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>(</operator><name>BC_PARSE_FLAG_FUNC</name> <operator>|</operator> <name>BC_PARSE_FLAG_LOOP</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>BC_PARSE_FLAG_BODY</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_vec_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>bc_parse_endif</name><parameter_list>(<parameter><decl><type><name>BcParse</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>good</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_NO_ERR</name><argument_list>(<argument><expr><operator>!</operator><call><name>BC_PARSE_NO_EXEC</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>good</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>



<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>good</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name><name>p</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>uint16_t</name></type> <name>flag</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint16_t</name><operator>*</operator><operator>)</operator> <call><name>bc_vec_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>good</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>flag</name> <operator>&amp;</operator> <name>BC_PARSE_FLAG_BRACE</name><operator>)</operator> <operator>!=</operator> <name>BC_PARSE_FLAG_BRACE</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></for>


<if_stmt><if>if <condition>(<expr><name>good</name></expr>)</condition> <block>{<block_content>



<decl_stmt><decl><type><name>bool</name></type> <name>is_stdin</name> <init>= <expr><name><name>vm</name><operator>.</operator><name>is_stdin</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>vm</name><operator>.</operator><name>is_stdin</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>


<while>while <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator> <call><name>BC_PARSE_IF_END</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>BC_PARSE_IF_END</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_parse_noElse</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_parse_endBody</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></while>

<expr_stmt><expr><name><name>vm</name><operator>.</operator><name>is_stdin</name></name> <operator>=</operator> <name>is_stdin</name></expr>;</expr_stmt>
</block_content>}</block></if>

<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vm</name><operator>.</operator><name>prs</name></name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_BLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_parse_if</name><parameter_list>(<parameter><decl><type><name>BcParse</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>


<decl_stmt><decl><type><name>size_t</name></type> <name>idx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>flags</name> <init>= <expr><operator>(</operator><name>BC_PARSE_REL</name> <operator>|</operator> <name>BC_PARSE_NEEDVAL</name><operator>)</operator></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>!=</operator> <name>BC_LEX_LPAREN</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_TOKEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_parse_expr_status</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>bc_parse_next_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>!=</operator> <name>BC_LEX_RPAREN</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_TOKEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_parse_push</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_INST_JUMP_ZERO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>idx</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>func</name><operator>-&gt;</operator><name>labels</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>



<expr_stmt><expr><call><name>bc_parse_pushIndex</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_parse_createExitLabel</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_parse_startBody</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_PARSE_FLAG_IF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_parse_else</name><parameter_list>(<parameter><decl><type><name>BcParse</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>idx</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>func</name><operator>-&gt;</operator><name>labels</name><operator>.</operator><name>len</name></name></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><operator>!</operator><call><name>BC_PARSE_IF_END</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_TOKEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>



<expr_stmt><expr><call><name>bc_parse_push</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_INST_JUMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_parse_pushIndex</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><call><name>bc_parse_noElse</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_parse_createExitLabel</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_parse_startBody</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_PARSE_FLAG_ELSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_parse_while</name><parameter_list>(<parameter><decl><type><name>BcParse</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>


<decl_stmt><decl><type><name>size_t</name></type> <name>idx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>flags</name> <init>= <expr><operator>(</operator><name>BC_PARSE_REL</name> <operator>|</operator> <name>BC_PARSE_NEEDVAL</name><operator>)</operator></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>!=</operator> <name>BC_LEX_LPAREN</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_TOKEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_parse_createCondLabel</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>func</name><operator>-&gt;</operator><name>labels</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>idx</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>func</name><operator>-&gt;</operator><name>labels</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_parse_createExitLabel</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_parse_expr_status</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>bc_parse_next_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>!=</operator> <name>BC_LEX_RPAREN</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_TOKEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_parse_push</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_INST_JUMP_ZERO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_parse_pushIndex</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_parse_startBody</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_PARSE_FLAG_LOOP</name> <operator>|</operator> <name>BC_PARSE_FLAG_LOOP_INNER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_parse_for</name><parameter_list>(<parameter><decl><type><name>BcParse</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>cond_idx</name></decl>, <decl><type ref="prev"/><name>exit_idx</name></decl>, <decl><type ref="prev"/><name>body_idx</name></decl>, <decl><type ref="prev"/><name>update_idx</name></decl>;</decl_stmt>


<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>!=</operator> <name>BC_LEX_LPAREN</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_TOKEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>!=</operator> <name>BC_LEX_SCOLON</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_expr_status</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>bc_parse_next_for</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_POSIX_FOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>!=</operator> <name>BC_LEX_SCOLON</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_TOKEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><name>cond_idx</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>func</name><operator>-&gt;</operator><name>labels</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>update_idx</name> <operator>=</operator> <name>cond_idx</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>body_idx</name> <operator>=</operator> <name>update_idx</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>exit_idx</name> <operator>=</operator> <name>body_idx</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_parse_createLabel</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>func</name><operator>-&gt;</operator><name>code</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>!=</operator> <name>BC_LEX_SCOLON</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>flags</name> <init>= <expr><operator>(</operator><name>BC_PARSE_REL</name> <operator>|</operator> <name>BC_PARSE_NEEDVAL</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>bc_parse_expr_status</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>bc_parse_next_for</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>





<expr_stmt><expr><call><name>bc_vec_string</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>str</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bc_parse_one</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>bc_parse_one</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_parse_number</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_POSIX_FOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>!=</operator> <name>BC_LEX_SCOLON</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_TOKEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><call><name>bc_parse_push</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_INST_JUMP_ZERO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_parse_pushIndex</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>exit_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_parse_push</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_INST_JUMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_parse_pushIndex</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>body_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_parse_createCondLabel</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>update_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>!=</operator> <name>BC_LEX_RPAREN</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_expr_status</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>bc_parse_next_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_POSIX_FOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>!=</operator> <name>BC_LEX_RPAREN</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_TOKEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>bc_parse_push</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_INST_JUMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_parse_pushIndex</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>cond_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_parse_createLabel</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>func</name><operator>-&gt;</operator><name>code</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_parse_createExitLabel</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>exit_idx</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_parse_startBody</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_PARSE_FLAG_LOOP</name> <operator>|</operator> <name>BC_PARSE_FLAG_LOOP_INNER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_parse_loopExit</name><parameter_list>(<parameter><decl><type><name>BcParse</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>BcLexType</name></type> <name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcInstPtr</name> <modifier>*</modifier></type><name>ip</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><operator>!</operator><call><name>BC_PARSE_LOOP</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_TOKEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>BC_LEX_KW_BREAK</name></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>exits</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_TOKEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>exits</name><operator>.</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>ip</name> <operator>=</operator> <call><name>bc_vec_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>exits</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<while>while <condition>(<expr><operator>!</operator><name><name>ip</name><operator>-&gt;</operator><name>func</name></name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name><name>p</name><operator>-&gt;</operator><name>exits</name><operator>.</operator><name>len</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ip</name> <operator>=</operator> <call><name>bc_vec_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>exits</name></name></expr></argument>, <argument><expr><name>i</name><operator>--</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>


<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ip</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>i</name> <operator>&lt;</operator> <name><name>p</name><operator>-&gt;</operator><name>exits</name><operator>.</operator><name>len</name></name> <operator>||</operator> <name><name>ip</name><operator>-&gt;</operator><name>func</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>ip</name><operator>-&gt;</operator><name>idx</name></name></expr>;</expr_stmt>
</block_content>}</block></if>


<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>i</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>size_t</name><operator>*</operator><operator>)</operator> <call><name>bc_vec_top</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>conds</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>


<expr_stmt><expr><call><name>bc_parse_push</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_INST_JUMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_parse_pushIndex</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_parse_func</name><parameter_list>(<parameter><decl><type><name>BcParse</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>bool</name></type> <name>comma</name> <init>= <expr><name>false</name></expr></init></decl>, <decl><type ref="prev"/><name>voidfn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint16_t</name></type> <name>flags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>idx</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>!=</operator> <name>BC_LEX_NAME</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_FUNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><name>voidfn</name> <operator>=</operator> <operator>(</operator><operator>!</operator><name>BC_IS_POSIX</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>==</operator> <name>BC_LEX_NAME</name> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>str</name><operator>.</operator><name>v</name></name></expr></argument>, <argument><expr><literal type="string">"void"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>



<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>voidfn</name> <operator>=</operator> <operator>(</operator><name>voidfn</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>==</operator> <name>BC_LEX_NAME</name><operator>)</operator></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>voidfn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_POSIX_VOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>!=</operator> <name>BC_LEX_LPAREN</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_FUNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>prog</name><operator>-&gt;</operator><name>fns</name><operator>.</operator><name>len</name></name> <operator>==</operator> <name><name>p</name><operator>-&gt;</operator><name>prog</name><operator>-&gt;</operator><name>fn_map</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>bc_program_insertFunc</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>prog</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>str</name><operator>.</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_parse_updateFunc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>func</name><operator>-&gt;</operator><name>voidfn</name></name> <operator>=</operator> <name>voidfn</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<while>while <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>!=</operator> <name>BC_LEX_RPAREN</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>BcType</name></type> <name>t</name> <init>= <expr><name>BC_TYPE_VAR</name></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>==</operator> <name>BC_LEX_OP_MULTIPLY</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>t</name> <operator>=</operator> <name>BC_TYPE_REF</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_POSIX_REF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>!=</operator> <name>BC_LEX_NAME</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_FUNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>func</name><operator>-&gt;</operator><name>nparams</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_vec_string</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>str</name><operator>.</operator><name>len</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>str</name><operator>.</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>==</operator> <name>BC_LEX_LBRACKET</name></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><name>t</name> <operator>==</operator> <name>BC_TYPE_VAR</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>t</name> <operator>=</operator> <name>BC_TYPE_ARRAY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>!=</operator> <name>BC_LEX_RBRACKET</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_FUNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>


<if type="elseif">else if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><name>t</name> <operator>==</operator> <name>BC_TYPE_REF</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_verr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_REF_VAR</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>buf</name><operator>.</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><name>comma</name> <operator>=</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>==</operator> <name>BC_LEX_COMMA</name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>comma</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>bc_func_insert</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>func</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>prog</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>buf</name><operator>.</operator><name>v</name></name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>line</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><name>comma</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_FUNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><name>flags</name> <operator>=</operator> <name>BC_PARSE_FLAG_FUNC</name> <operator>|</operator> <name>BC_PARSE_FLAG_FUNC_INNER</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_parse_startBody</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>!=</operator> <name>BC_LEX_LBRACE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_POSIX_BRACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_parse_auto</name><parameter_list>(<parameter><decl><type><name>BcParse</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>bool</name></type> <name>comma</name></decl>, <decl><type ref="prev"/><name>one</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>auto_part</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_TOKEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>auto_part</name></name> <operator>=</operator> <name>comma</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>


<expr_stmt><expr><name>one</name> <operator>=</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>==</operator> <name>BC_LEX_NAME</name><operator>)</operator></expr>;</expr_stmt>


<while>while <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>==</operator> <name>BC_LEX_NAME</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>BcType</name></type> <name>t</name></decl>;</decl_stmt>


<expr_stmt><expr><call><name>bc_vec_string</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>str</name><operator>.</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>str</name><operator>.</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>==</operator> <name>BC_LEX_LBRACKET</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>t</name> <operator>=</operator> <name>BC_TYPE_ARRAY</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>!=</operator> <name>BC_LEX_RBRACKET</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_FUNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>t</name> <operator>=</operator> <name>BC_TYPE_VAR</name></expr>;</expr_stmt></block_content></block></else></if_stmt>


<expr_stmt><expr><name>comma</name> <operator>=</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>==</operator> <name>BC_LEX_COMMA</name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>comma</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>bc_func_insert</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>func</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>prog</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>buf</name><operator>.</operator><name>v</name></name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>line</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><name>comma</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_FUNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><operator>!</operator><name>one</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_NO_AUTO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><operator>!</operator><call><name>bc_parse_isDelimiter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_TOKEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_parse_body</name><parameter_list>(<parameter><decl><type><name>BcParse</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>brace</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>flag_ptr</name> <init>= <expr><call><name>BC_PARSE_TOP_FLAG_PTR</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>flag_ptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>len</name></name> <operator>&gt;=</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><operator>*</operator><name>flag_ptr</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>BC_PARSE_FLAG_BODY</name><operator>)</operator></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><operator>*</operator><name>flag_ptr</name> <operator>&amp;</operator> <name>BC_PARSE_FLAG_FUNC_INNER</name></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><operator>!</operator><name>brace</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_TOKEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>auto_part</name></name> <operator>=</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>!=</operator> <name>BC_LEX_KW_AUTO</name><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>auto_part</name></name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>auto_part</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_parse_auto</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>==</operator> <name>BC_LEX_NLINE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>


<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>len</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>*</operator><name>flag_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_parse_stmt</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<if_stmt><if>if <condition>(<expr><operator>!</operator><name>brace</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>BC_PARSE_BODY</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>len</name> <operator>&lt;=</operator> <name><name>p</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>len</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_endBody</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_parse_stmt</name><parameter_list>(<parameter><decl><type><name>BcParse</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint16_t</name></type> <name>flags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcLexType</name></type> <name>type</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>BC_LEX_NLINE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>BC_LEX_KW_AUTO</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bc_parse_auto</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>auto_part</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>BC_LEX_KW_ELSE</name></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><call><name>BC_PARSE_IF_END</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><call><name>bc_parse_noElse</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>BC_PARSE_BRACE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_endBody</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return;</return>
</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>BC_LEX_LBRACE</name></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BC_PARSE_BODY</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bc_parse_startBody</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_PARSE_FLAG_BRACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>



<else>else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><operator>(</operator><call><name>BC_PARSE_TOP_FLAG_PTR</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>|=</operator> <name>BC_PARSE_FLAG_BRACE</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_parse_body</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>



<return>return;</return>
</block_content>}</block></if>



<if type="elseif">else if <condition>(<expr><call><name>BC_PARSE_BODY</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>BC_PARSE_BRACE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bc_parse_body</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>BC_PARSE_TOP_FLAG</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>


<case>case <expr><name>BC_LEX_OP_INC</name></expr>:</case>
<case>case <expr><name>BC_LEX_OP_DEC</name></expr>:</case>
<case>case <expr><name>BC_LEX_OP_MINUS</name></expr>:</case>
<case>case <expr><name>BC_LEX_OP_BOOL_NOT</name></expr>:</case>
<case>case <expr><name>BC_LEX_LPAREN</name></expr>:</case>
<case>case <expr><name>BC_LEX_NAME</name></expr>:</case>
<case>case <expr><name>BC_LEX_NUMBER</name></expr>:</case>
<case>case <expr><name>BC_LEX_KW_IBASE</name></expr>:</case>
<case>case <expr><name>BC_LEX_KW_LAST</name></expr>:</case>
<case>case <expr><name>BC_LEX_KW_LENGTH</name></expr>:</case>
<case>case <expr><name>BC_LEX_KW_OBASE</name></expr>:</case>
<case>case <expr><name>BC_LEX_KW_SCALE</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLE_EXTRA_MATH</name></expr></cpp:if>
<case>case <expr><name>BC_LEX_KW_SEED</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<case>case <expr><name>BC_LEX_KW_SQRT</name></expr>:</case>
<case>case <expr><name>BC_LEX_KW_ABS</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLE_EXTRA_MATH</name></expr></cpp:if>
<case>case <expr><name>BC_LEX_KW_IRAND</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<case>case <expr><name>BC_LEX_KW_ASCIIFY</name></expr>:</case>
<case>case <expr><name>BC_LEX_KW_MODEXP</name></expr>:</case>
<case>case <expr><name>BC_LEX_KW_DIVMOD</name></expr>:</case>
<case>case <expr><name>BC_LEX_KW_READ</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLE_EXTRA_MATH</name></expr></cpp:if>
<case>case <expr><name>BC_LEX_KW_RAND</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<case>case <expr><name>BC_LEX_KW_MAXIBASE</name></expr>:</case>
<case>case <expr><name>BC_LEX_KW_MAXOBASE</name></expr>:</case>
<case>case <expr><name>BC_LEX_KW_MAXSCALE</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLE_EXTRA_MATH</name></expr></cpp:if>
<case>case <expr><name>BC_LEX_KW_MAXRAND</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<case>case <expr><name>BC_LEX_KW_LINE_LENGTH</name></expr>:</case>
<case>case <expr><name>BC_LEX_KW_GLOBAL_STACKS</name></expr>:</case>
<case>case <expr><name>BC_LEX_KW_LEADING_ZERO</name></expr>:</case>
<block>{<block_content>
<expr_stmt><expr><call><name>bc_parse_expr_status</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_PARSE_PRINT</name></expr></argument>, <argument><expr><name>bc_parse_next_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>

<case>case <expr><name>BC_LEX_KW_ELSE</name></expr>:</case>
<block>{<block_content>
<expr_stmt><expr><call><name>bc_parse_else</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>


<case>case <expr><name>BC_LEX_SCOLON</name></expr>:</case>
<block>{<block_content>

<break>break;</break>
</block_content>}</block>

<case>case <expr><name>BC_LEX_RBRACE</name></expr>:</case>
<block>{<block_content>
<expr_stmt><expr><call><name>bc_parse_endBody</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>

<case>case <expr><name>BC_LEX_STR</name></expr>:</case>
<block>{<block_content>
<expr_stmt><expr><call><name>bc_parse_str</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_INST_PRINT_STR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>

<case>case <expr><name>BC_LEX_KW_BREAK</name></expr>:</case>
<case>case <expr><name>BC_LEX_KW_CONTINUE</name></expr>:</case>
<block>{<block_content>
<expr_stmt><expr><call><name>bc_parse_loopExit</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>

<case>case <expr><name>BC_LEX_KW_FOR</name></expr>:</case>
<block>{<block_content>
<expr_stmt><expr><call><name>bc_parse_for</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>

<case>case <expr><name>BC_LEX_KW_HALT</name></expr>:</case>
<block>{<block_content>
<expr_stmt><expr><call><name>bc_parse_push</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_INST_HALT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>

<case>case <expr><name>BC_LEX_KW_IF</name></expr>:</case>
<block>{<block_content>
<expr_stmt><expr><call><name>bc_parse_if</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>

<case>case <expr><name>BC_LEX_KW_LIMITS</name></expr>:</case>
<block>{<block_content>

<expr_stmt><expr><call><name>bc_vm_printf</name><argument_list>(<argument><expr><literal type="string">"BC_LONG_BIT = %lu\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>ulong</name><operator>)</operator> <name>BC_LONG_BIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_vm_printf</name><argument_list>(<argument><expr><literal type="string">"BC_BASE_DIGS = %lu\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>ulong</name><operator>)</operator> <name>BC_BASE_DIGS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_vm_printf</name><argument_list>(<argument><expr><literal type="string">"BC_BASE_POW = %lu\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>ulong</name><operator>)</operator> <name>BC_BASE_POW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_vm_printf</name><argument_list>(<argument><expr><literal type="string">"BC_OVERFLOW_MAX = %lu\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>ulong</name><operator>)</operator> <name>BC_NUM_BIGDIG_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_vm_printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_vm_printf</name><argument_list>(<argument><expr><literal type="string">"BC_BASE_MAX = %lu\n"</literal></expr></argument>, <argument><expr><name>BC_MAX_OBASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_vm_printf</name><argument_list>(<argument><expr><literal type="string">"BC_DIM_MAX = %lu\n"</literal></expr></argument>, <argument><expr><name>BC_MAX_DIM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_vm_printf</name><argument_list>(<argument><expr><literal type="string">"BC_SCALE_MAX = %lu\n"</literal></expr></argument>, <argument><expr><name>BC_MAX_SCALE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_vm_printf</name><argument_list>(<argument><expr><literal type="string">"BC_STRING_MAX = %lu\n"</literal></expr></argument>, <argument><expr><name>BC_MAX_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_vm_printf</name><argument_list>(<argument><expr><literal type="string">"BC_NAME_MAX = %lu\n"</literal></expr></argument>, <argument><expr><name>BC_MAX_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_vm_printf</name><argument_list>(<argument><expr><literal type="string">"BC_NUM_MAX = %lu\n"</literal></expr></argument>, <argument><expr><name>BC_MAX_NUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLE_EXTRA_MATH</name></expr></cpp:if>
<expr_stmt><expr><call><name>bc_vm_printf</name><argument_list>(<argument><expr><literal type="string">"BC_RAND_MAX = %lu\n"</literal></expr></argument>, <argument><expr><name>BC_MAX_RAND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>bc_vm_printf</name><argument_list>(<argument><expr><literal type="string">"MAX Exponent = %lu\n"</literal></expr></argument>, <argument><expr><name>BC_MAX_EXP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_vm_printf</name><argument_list>(<argument><expr><literal type="string">"Number of vars = %lu\n"</literal></expr></argument>, <argument><expr><name>BC_MAX_VARS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>
</block_content>}</block>

<case>case <expr><name>BC_LEX_KW_STREAM</name></expr>:</case>
<case>case <expr><name>BC_LEX_KW_PRINT</name></expr>:</case>
<block>{<block_content>
<expr_stmt><expr><call><name>bc_parse_print</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>

<case>case <expr><name>BC_LEX_KW_QUIT</name></expr>:</case>
<block>{<block_content>


<expr_stmt><expr><name><name>vm</name><operator>.</operator><name>status</name></name> <operator>=</operator> <name>BC_STATUS_QUIT</name></expr>;</expr_stmt>
<expr_stmt><expr><name>BC_JMP</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>

<case>case <expr><name>BC_LEX_KW_RETURN</name></expr>:</case>
<block>{<block_content>
<expr_stmt><expr><call><name>bc_parse_return</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>

<case>case <expr><name>BC_LEX_KW_WHILE</name></expr>:</case>
<block>{<block_content>
<expr_stmt><expr><call><name>bc_parse_while</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>

<default>default:</default>
<block>{<block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_TOKEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
</block_content>}</block></switch>


<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <name><name>p</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>len</name></name> <operator>&amp;&amp;</operator> <name>flags</name> <operator>==</operator> <call><name>BC_PARSE_TOP_FLAG</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><operator>!</operator><call><name>bc_parse_isDelimiter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_TOKEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<while>while <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>==</operator> <name>BC_LEX_SCOLON</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>




<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>last</name></name> <operator>==</operator> <name>BC_LEX_SCOLON</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>==</operator> <name>BC_LEX_KW_DEFINE</name> <operator>&amp;&amp;</operator> <name>BC_IS_POSIX</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_POSIX_FUNC_AFTER_SEMICOLON</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>bc_parse_parse</name><parameter_list>(<parameter><decl><type><name>BcParse</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>BC_SETJMP_LOCKED</name><argument_list>(<argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>==</operator> <name>BC_LEX_EOF</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_EOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>


<if type="elseif">else if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>==</operator> <name>BC_LEX_KW_DEFINE</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><call><name>BC_PARSE_NO_EXEC</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bc_parse_endif</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><call><name>BC_PARSE_NO_EXEC</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_TOKEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>bc_parse_func</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>


<else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_parse_stmt</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<label><name>exit</name>:</label>


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name><name>vm</name><operator>.</operator><name>status</name></name> <operator>&amp;&amp;</operator> <name><name>vm</name><operator>.</operator><name>status</name></name> <operator>!=</operator> <name>BC_STATUS_QUIT</name><operator>)</operator> <operator>||</operator> <name><name>vm</name><operator>.</operator><name>sig</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_reset</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>BC_LONGJMP_CONT</name></expr>;</expr_stmt>
<expr_stmt><expr><name>BC_SIG_MAYLOCK</name></expr>;</expr_stmt>
</block_content>}</block></function>












<function><type><specifier>static</specifier> <name>BcParseStatus</name></type> <name>bc_parse_expr_err</name><parameter_list>(<parameter><decl><type><name>BcParse</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>flags</name></decl></parameter>,
<parameter><decl><type><name>BcParseNext</name></type> <name>next</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>BcInst</name></type> <name>prev</name> <init>= <expr><name>BC_INST_PRINT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uchar</name></type> <name>inst</name> <init>= <expr><name>BC_INST_INVALID</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BcLexType</name></type> <name>top</name></decl>, <decl><type ref="prev"/><name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>nexprs</name></decl>, <decl><type ref="prev"/><name>ops_bgn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>nparens</name></decl>, <decl><type ref="prev"/><name>nrelops</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>pfirst</name></decl>, <decl><type ref="prev"/><name>rprn</name></decl>, <decl><type ref="prev"/><name>done</name></decl>, <decl><type ref="prev"/><name>get_token</name></decl>, <decl><type ref="prev"/><name>assign</name></decl>, <decl><type ref="prev"/><name>bin_last</name></decl>, <decl><type ref="prev"/><name>incdec</name></decl>, <decl><type ref="prev"/><name>can_assign</name></decl>;</decl_stmt>


<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>BC_PARSE_PRINT</name><operator>)</operator> <operator>||</operator> <operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>BC_PARSE_NEEDVAL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>



















<expr_stmt><expr><name>t</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>pfirst</name> <operator>=</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>==</operator> <name>BC_LEX_LPAREN</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>nparens</name> <operator>=</operator> <name>nrelops</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>nexprs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>ops_bgn</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>ops</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>rprn</name> <operator>=</operator> <name>done</name> <operator>=</operator> <name>get_token</name> <operator>=</operator> <name>assign</name> <operator>=</operator> <name>incdec</name> <operator>=</operator> <name>can_assign</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>bin_last</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>BC_PARSE_NOREAD</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<while>while <condition>(<expr><operator>(</operator><name>t</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name><operator>)</operator> <operator>==</operator> <name>BC_LEX_NLINE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></if></if_stmt>


<for>for <control>(<init>;</init> <condition><expr><operator>!</operator><name>done</name> <operator>&amp;&amp;</operator> <call><name>BC_PARSE_EXPR</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>t</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name></expr></incr>)</control>
<block>{<block_content>
<switch>switch <condition>(<expr><name>t</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>BC_LEX_OP_INC</name></expr>:</case>
<case>case <expr><name>BC_LEX_OP_DEC</name></expr>:</case>
<block>{<block_content>


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><name>incdec</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_ASSIGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>bc_parse_incdec</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prev</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>can_assign</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nexprs</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rprn</name> <operator>=</operator> <name>get_token</name> <operator>=</operator> <name>bin_last</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>incdec</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>BC_PARSE_ARRAY</name><operator>)</operator></expr>;</expr_stmt>

<break>break;</break>
</block_content>}</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLE_EXTRA_MATH</name></expr></cpp:if>
<case>case <expr><name>BC_LEX_OP_TRUNC</name></expr>:</case>
<block>{<block_content>


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><operator>!</operator><call><name>BC_PARSE_LEAF</name><argument_list>(<argument><expr><name>prev</name></expr></argument>, <argument><expr><name>bin_last</name></expr></argument>, <argument><expr><name>rprn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_TOKEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>



<expr_stmt><expr><call><name>bc_parse_push</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_INST_TRUNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rprn</name> <operator>=</operator> <name>can_assign</name> <operator>=</operator> <name>incdec</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>get_token</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>BC_PARSE_ARRAY</name><operator>)</operator></expr>;</expr_stmt>

<break>break;</break>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<case>case <expr><name>BC_LEX_OP_MINUS</name></expr>:</case>
<block>{<block_content>
<expr_stmt><expr><call><name>bc_parse_minus</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prev</name></expr></argument>, <argument><expr><name>ops_bgn</name></expr></argument>, <argument><expr><name>rprn</name></expr></argument>, <argument><expr><name>bin_last</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nexprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rprn</name> <operator>=</operator> <name>get_token</name> <operator>=</operator> <name>can_assign</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>


<expr_stmt><expr><name>bin_last</name> <operator>=</operator> <operator>(</operator><name>prev</name> <operator>==</operator> <name>BC_INST_MINUS</name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bin_last</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>incdec</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>BC_PARSE_ARRAY</name><operator>)</operator></expr>;</expr_stmt>

<break>break;</break>
</block_content>}</block>



<case>case <expr><name>BC_LEX_OP_ASSIGN_POWER</name></expr>:</case>
<case>case <expr><name>BC_LEX_OP_ASSIGN_MULTIPLY</name></expr>:</case>
<case>case <expr><name>BC_LEX_OP_ASSIGN_DIVIDE</name></expr>:</case>
<case>case <expr><name>BC_LEX_OP_ASSIGN_MODULUS</name></expr>:</case>
<case>case <expr><name>BC_LEX_OP_ASSIGN_PLUS</name></expr>:</case>
<case>case <expr><name>BC_LEX_OP_ASSIGN_MINUS</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLE_EXTRA_MATH</name></expr></cpp:if>
<case>case <expr><name>BC_LEX_OP_ASSIGN_PLACES</name></expr>:</case>
<case>case <expr><name>BC_LEX_OP_ASSIGN_LSHIFT</name></expr>:</case>
<case>case <expr><name>BC_LEX_OP_ASSIGN_RSHIFT</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<case>case <expr><name>BC_LEX_OP_ASSIGN</name></expr>:</case>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BC_PARSE_INST_VAR</name><argument_list>(<argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_ASSIGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>

<macro><name>BC_FALLTHROUGH</name></macro>

<case>case <expr><name>BC_LEX_OP_POWER</name></expr>:</case>
<case>case <expr><name>BC_LEX_OP_MULTIPLY</name></expr>:</case>
<case>case <expr><name>BC_LEX_OP_DIVIDE</name></expr>:</case>
<case>case <expr><name>BC_LEX_OP_MODULUS</name></expr>:</case>
<case>case <expr><name>BC_LEX_OP_PLUS</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLE_EXTRA_MATH</name></expr></cpp:if>
<case>case <expr><name>BC_LEX_OP_PLACES</name></expr>:</case>
<case>case <expr><name>BC_LEX_OP_LSHIFT</name></expr>:</case>
<case>case <expr><name>BC_LEX_OP_RSHIFT</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<case>case <expr><name>BC_LEX_OP_REL_EQ</name></expr>:</case>
<case>case <expr><name>BC_LEX_OP_REL_LE</name></expr>:</case>
<case>case <expr><name>BC_LEX_OP_REL_GE</name></expr>:</case>
<case>case <expr><name>BC_LEX_OP_REL_NE</name></expr>:</case>
<case>case <expr><name>BC_LEX_OP_REL_LT</name></expr>:</case>
<case>case <expr><name>BC_LEX_OP_REL_GT</name></expr>:</case>
<case>case <expr><name>BC_LEX_OP_BOOL_NOT</name></expr>:</case>
<case>case <expr><name>BC_LEX_OP_BOOL_OR</name></expr>:</case>
<case>case <expr><name>BC_LEX_OP_BOOL_AND</name></expr>:</case>
<block>{<block_content>


<if_stmt><if>if <condition>(<expr><call><name>BC_PARSE_OP_PREFIX</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>



<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><operator>!</operator><name>bin_last</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>BC_PARSE_OP_PREFIX</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>last</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if>



<if type="elseif">else if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><call><name>BC_PARSE_PREV_PREFIX</name><argument_list>(<argument><expr><name>prev</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>bin_last</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>nrelops</name> <operator>+=</operator> <operator>(</operator><name>t</name> <operator>&gt;=</operator> <name>BC_LEX_OP_REL_EQ</name> <operator>&amp;&amp;</operator> <name>t</name> <operator>&lt;=</operator> <name>BC_LEX_OP_REL_GT</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>prev</name> <operator>=</operator> <call><name>BC_PARSE_TOKEN_INST</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_parse_operator</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>ops_bgn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nexprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rprn</name> <operator>=</operator> <name>incdec</name> <operator>=</operator> <name>can_assign</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>get_token</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name>bin_last</name> <operator>=</operator> <operator>!</operator><call><name>BC_PARSE_OP_PREFIX</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>BC_PARSE_ARRAY</name><operator>)</operator></expr>;</expr_stmt>

<break>break;</break>
</block_content>}</block>

<case>case <expr><name>BC_LEX_LPAREN</name></expr>:</case>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><call><name>BC_PARSE_LEAF</name><argument_list>(<argument><expr><name>prev</name></expr></argument>, <argument><expr><name>bin_last</name></expr></argument>, <argument><expr><name>rprn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>nparens</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>rprn</name> <operator>=</operator> <name>incdec</name> <operator>=</operator> <name>can_assign</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>get_token</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>


<expr_stmt><expr><call><name>bc_vec_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>ops</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>
</block_content>}</block>

<case>case <expr><name>BC_LEX_RPAREN</name></expr>:</case>
<block>{<block_content>


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>last</name></name> <operator>==</operator> <name>BC_LEX_LPAREN</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>BC_PARSE_STATUS_EMPTY_EXPR</name></expr>;</return></block_content></block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><name>bin_last</name> <operator>||</operator> <call><name>BC_PARSE_PREV_PREFIX</name><argument_list>(<argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nparens</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name>get_token</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>nparens</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>rprn</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name>get_token</name> <operator>=</operator> <name>bin_last</name> <operator>=</operator> <name>incdec</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_parse_rightParen</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nexprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>
</block_content>}</block>

<case>case <expr><name>BC_LEX_STR</name></expr>:</case>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>BC_IS_POSIX</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_POSIX_EXPR_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><call><name>BC_PARSE_LEAF</name><argument_list>(<argument><expr><name>prev</name></expr></argument>, <argument><expr><name>bin_last</name></expr></argument>, <argument><expr><name>rprn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>bc_parse_addString</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>get_token</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name>bin_last</name> <operator>=</operator> <name>rprn</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>nexprs</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>
</block_content>}</block>

<case>case <expr><name>BC_LEX_NAME</name></expr>:</case>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><call><name>BC_PARSE_LEAF</name><argument_list>(<argument><expr><name>prev</name></expr></argument>, <argument><expr><name>bin_last</name></expr></argument>, <argument><expr><name>rprn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>get_token</name> <operator>=</operator> <name>bin_last</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bc_parse_name</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prev</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>can_assign</name></expr></argument>, <argument><expr><name>flags</name> <operator>&amp;</operator> <operator>~</operator><name>BC_PARSE_NOCALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rprn</name> <operator>=</operator> <operator>(</operator><name>prev</name> <operator>==</operator> <name>BC_INST_CALL</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>nexprs</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>BC_PARSE_ARRAY</name><operator>)</operator></expr>;</expr_stmt>

<break>break;</break>
</block_content>}</block>

<case>case <expr><name>BC_LEX_NUMBER</name></expr>:</case>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><call><name>BC_PARSE_LEAF</name><argument_list>(<argument><expr><name>prev</name></expr></argument>, <argument><expr><name>bin_last</name></expr></argument>, <argument><expr><name>rprn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>bc_parse_number</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>nexprs</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>BC_INST_NUM</name></expr>;</expr_stmt>
<expr_stmt><expr><name>get_token</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name>rprn</name> <operator>=</operator> <name>bin_last</name> <operator>=</operator> <name>can_assign</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>BC_PARSE_ARRAY</name><operator>)</operator></expr>;</expr_stmt>

<break>break;</break>
</block_content>}</block>

<case>case <expr><name>BC_LEX_KW_IBASE</name></expr>:</case>
<case>case <expr><name>BC_LEX_KW_LAST</name></expr>:</case>
<case>case <expr><name>BC_LEX_KW_OBASE</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLE_EXTRA_MATH</name></expr></cpp:if>
<case>case <expr><name>BC_LEX_KW_SEED</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><call><name>BC_PARSE_LEAF</name><argument_list>(<argument><expr><name>prev</name></expr></argument>, <argument><expr><name>bin_last</name></expr></argument>, <argument><expr><name>rprn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>t</name> <operator>-</operator> <name>BC_LEX_KW_LAST</name> <operator>+</operator> <name>BC_INST_LAST</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_parse_push</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>get_token</name> <operator>=</operator> <name>can_assign</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name>rprn</name> <operator>=</operator> <name>bin_last</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>nexprs</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>BC_PARSE_ARRAY</name><operator>)</operator></expr>;</expr_stmt>

<break>break;</break>
</block_content>}</block>

<case>case <expr><name>BC_LEX_KW_LENGTH</name></expr>:</case>
<case>case <expr><name>BC_LEX_KW_SQRT</name></expr>:</case>
<case>case <expr><name>BC_LEX_KW_ABS</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLE_EXTRA_MATH</name></expr></cpp:if>
<case>case <expr><name>BC_LEX_KW_IRAND</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<case>case <expr><name>BC_LEX_KW_ASCIIFY</name></expr>:</case>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><call><name>BC_PARSE_LEAF</name><argument_list>(<argument><expr><name>prev</name></expr></argument>, <argument><expr><name>bin_last</name></expr></argument>, <argument><expr><name>rprn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>bc_parse_builtin</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rprn</name> <operator>=</operator> <name>get_token</name> <operator>=</operator> <name>bin_last</name> <operator>=</operator> <name>incdec</name> <operator>=</operator> <name>can_assign</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>nexprs</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>BC_PARSE_ARRAY</name><operator>)</operator></expr>;</expr_stmt>

<break>break;</break>
</block_content>}</block>

<case>case <expr><name>BC_LEX_KW_READ</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLE_EXTRA_MATH</name></expr></cpp:if>
<case>case <expr><name>BC_LEX_KW_RAND</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<case>case <expr><name>BC_LEX_KW_MAXIBASE</name></expr>:</case>
<case>case <expr><name>BC_LEX_KW_MAXOBASE</name></expr>:</case>
<case>case <expr><name>BC_LEX_KW_MAXSCALE</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BC_ENABLE_EXTRA_MATH</name></expr></cpp:if>
<case>case <expr><name>BC_LEX_KW_MAXRAND</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<case>case <expr><name>BC_LEX_KW_LINE_LENGTH</name></expr>:</case>
<case>case <expr><name>BC_LEX_KW_GLOBAL_STACKS</name></expr>:</case>
<case>case <expr><name>BC_LEX_KW_LEADING_ZERO</name></expr>:</case>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><call><name>BC_PARSE_LEAF</name><argument_list>(<argument><expr><name>prev</name></expr></argument>, <argument><expr><name>bin_last</name></expr></argument>, <argument><expr><name>rprn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>


<if type="elseif">else if <condition>(<expr><name>t</name> <operator>==</operator> <name>BC_LEX_KW_READ</name> <operator>&amp;&amp;</operator> <call><name>BC_ERR</name><argument_list>(<argument><expr><name>flags</name> <operator>&amp;</operator> <name>BC_PARSE_NOREAD</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_EXEC_REC_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>t</name> <operator>-</operator> <name>BC_LEX_KW_READ</name> <operator>+</operator> <name>BC_INST_READ</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_parse_noArgBuiltin</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rprn</name> <operator>=</operator> <name>get_token</name> <operator>=</operator> <name>bin_last</name> <operator>=</operator> <name>incdec</name> <operator>=</operator> <name>can_assign</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>nexprs</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>BC_PARSE_ARRAY</name><operator>)</operator></expr>;</expr_stmt>

<break>break;</break>
</block_content>}</block>

<case>case <expr><name>BC_LEX_KW_SCALE</name></expr>:</case>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><call><name>BC_PARSE_LEAF</name><argument_list>(<argument><expr><name>prev</name></expr></argument>, <argument><expr><name>bin_last</name></expr></argument>, <argument><expr><name>rprn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>



<expr_stmt><expr><call><name>bc_parse_scale</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prev</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>can_assign</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rprn</name> <operator>=</operator> <name>get_token</name> <operator>=</operator> <name>bin_last</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>nexprs</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>BC_PARSE_ARRAY</name><operator>)</operator></expr>;</expr_stmt>

<break>break;</break>
</block_content>}</block>

<case>case <expr><name>BC_LEX_KW_MODEXP</name></expr>:</case>
<case>case <expr><name>BC_LEX_KW_DIVMOD</name></expr>:</case>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><call><name>BC_PARSE_LEAF</name><argument_list>(<argument><expr><name>prev</name></expr></argument>, <argument><expr><name>bin_last</name></expr></argument>, <argument><expr><name>rprn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>bc_parse_builtin3</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rprn</name> <operator>=</operator> <name>get_token</name> <operator>=</operator> <name>bin_last</name> <operator>=</operator> <name>incdec</name> <operator>=</operator> <name>can_assign</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>nexprs</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>BC_PARSE_ARRAY</name><operator>)</operator></expr>;</expr_stmt>

<break>break;</break>
</block_content>}</block>

<default>default:</default>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_TOKEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block>
</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>get_token</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>



<while>while <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>ops</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <name>ops_bgn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>top</name> <operator>=</operator> <call><name>BC_PARSE_TOP_OP</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>assign</name> <operator>=</operator> <name>top</name> <operator>&gt;=</operator> <name>BC_LEX_OP_ASSIGN_POWER</name> <operator>&amp;&amp;</operator> <name>top</name> <operator>&lt;=</operator> <name>BC_LEX_OP_ASSIGN</name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><name>top</name> <operator>==</operator> <name>BC_LEX_LPAREN</name> <operator>||</operator> <name>top</name> <operator>==</operator> <name>BC_LEX_RPAREN</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>bc_parse_push</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>BC_PARSE_TOKEN_INST</name><argument_list>(<argument><expr><name>top</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>nexprs</name> <operator>-=</operator> <operator>!</operator><call><name>BC_PARSE_OP_PREFIX</name><argument_list>(<argument><expr><name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_vec_pop</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>ops</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>incdec</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></while>


<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><name>nexprs</name> <operator>!=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>next</name><operator>.</operator><name>len</name></name> <operator>&amp;&amp;</operator> <name>t</name> <operator>!=</operator> <name><name>next</name><operator>.</operator><name>tokens</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><name>i</name> <operator>==</operator> <name><name>next</name><operator>.</operator><name>len</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>bc_parse_isDelimiter</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>BC_PARSE_REL</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>nrelops</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_POSIX_REL_POS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>BC_PARSE_REL</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>nrelops</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_POSIX_MULTIREL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>BC_PARSE_NEEDVAL</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name>pfirst</name></expr>)</condition> <block>{<block_content>



<if_stmt><if>if <condition>(<expr><name>assign</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>inst</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>uchar</name><operator>*</operator><operator>)</operator> <call><name>bc_vec_top</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>func</name><operator>-&gt;</operator><name>code</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>inst</name> <operator>+=</operator> <operator>(</operator><name>BC_INST_ASSIGN_POWER_NO_VAL</name> <operator>-</operator> <name>BC_INST_ASSIGN_POWER</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>incdec</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></if>


<if type="elseif">else if <condition>(<expr><name>incdec</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>BC_PARSE_PRINT</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>inst</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>uchar</name><operator>*</operator><operator>)</operator> <call><name>bc_vec_top</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>func</name><operator>-&gt;</operator><name>code</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>incdec</name> <operator>=</operator> <operator>(</operator><name>inst</name> <operator>&lt;=</operator> <name>BC_INST_DEC</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>inst</name> <operator>=</operator> <name>BC_INST_ASSIGN_PLUS_NO_VAL</name> <operator>+</operator> <operator>(</operator><name>inst</name> <operator>!=</operator> <name>BC_INST_INC</name> <operator>&amp;&amp;</operator>
<name>inst</name> <operator>!=</operator> <name>BC_INST_ASSIGN_PLUS</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>





<if_stmt><if>if <condition>(<expr><name>inst</name> <operator>&gt;=</operator> <name>BC_INST_ASSIGN_POWER_NO_VAL</name> <operator>&amp;&amp;</operator>
<name>inst</name> <operator>&lt;=</operator> <name>BC_INST_ASSIGN_NO_VAL</name></expr>)</condition>
<block>{<block_content>



<expr_stmt><expr><call><name>bc_vec_pop</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>func</name><operator>-&gt;</operator><name>code</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>incdec</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_parse_push</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_INST_ONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>bc_parse_push</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>BC_PARSE_PRINT</name><operator>)</operator></expr>)</condition> <block>{<block_content>



<if_stmt><if>if <condition>(<expr><name>pfirst</name> <operator>||</operator> <operator>!</operator><name>assign</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_parse_push</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_INST_PRINT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if>


<if type="elseif">else if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>BC_PARSE_NEEDVAL</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>inst</name> <argument_list type="generic">&lt; <argument><expr><name>BC_INST_ASSIGN_POWER_NO_VAL</name> <operator>||</operator>
<name>inst</name></expr></argument> &gt;</argument_list></name> <name>BC_INST_ASSIGN_NO_VAL</name><operator>)</operator></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>bc_parse_push</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_INST_POP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>






<for>for <control>(<init><expr><name>incdec</name> <operator>=</operator> <name>true</name></expr><operator>,</operator> <expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>next</name><operator>.</operator><name>len</name></name> <operator>&amp;&amp;</operator> <name>incdec</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name>incdec</name> <operator>=</operator> <operator>(</operator><name><name>next</name><operator>.</operator><name>tokens</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>BC_LEX_NLINE</name><operator>)</operator></expr>;</expr_stmt></block_content></block></for>
<if_stmt><if>if <condition>(<expr><name>incdec</name></expr>)</condition> <block>{<block_content>
<while>while <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>t</name></name> <operator>==</operator> <name>BC_LEX_NLINE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>bc_lex_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>BC_PARSE_STATUS_SUCCESS</name></expr>;</return>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>void</name></type> <name>bc_parse_expr_status</name><parameter_list>(<parameter><decl><type><name>BcParse</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>BcParseNext</name></type> <name>next</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>BcParseStatus</name></type> <name>s</name> <init>= <expr><call><name>bc_parse_expr_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BC_ERR</name><argument_list>(<argument><expr><name>s</name> <operator>==</operator> <name>BC_PARSE_STATUS_EMPTY_EXPR</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bc_parse_err</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BC_ERR_PARSE_EMPTY_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>bc_parse_expr</name><parameter_list>(<parameter><decl><type><name>BcParse</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>flags</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bc_parse_expr_status</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>bc_parse_next_read</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
