<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/bzip2/bzip2.c">
























<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BZ_UNIX</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>








<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BZ_LCCWIN32</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BZ_LCCWIN32</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BZ_LCCWIN32</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BZ_UNIX</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BZ_UNIX</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>







<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bzlib.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERROR_IF_EOF</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ if ((i) == EOF) ioError(); }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERROR_IF_NOT_ZERO</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ if ((i) != 0) ioError(); }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERROR_IF_MINUS_ONE</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ if ((i) == (-1)) ioError(); }</cpp:value></cpp:define>







<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BZ_UNIX</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utime.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/times.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PATH_SEP</name></cpp:macro> <cpp:value>'/'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MY_LSTAT</name></cpp:macro> <cpp:value>lstat</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MY_STAT</name></cpp:macro> <cpp:value>stat</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MY_S_ISREG</name></cpp:macro> <cpp:value>S_ISREG</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MY_S_ISDIR</name></cpp:macro> <cpp:value>S_ISDIR</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APPEND_FILESPEC</name><parameter_list>(<parameter><type><name>root</name></type></parameter>, <parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>root=snocString((root), (name))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APPEND_FLAG</name><parameter_list>(<parameter><type><name>root</name></type></parameter>, <parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>root=snocString((root), (name))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_BINARY_MODE</name><parameter_list>(<parameter><type><name>fd</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NORETURN</name></cpp:macro> <cpp:value>__attribute__ ((noreturn))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NORETURN</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__DJGPP__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;io.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MY_LSTAT</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MY_STAT</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MY_LSTAT</name></cpp:macro> <cpp:value>stat</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MY_STAT</name></cpp:macro> <cpp:value>stat</cpp:value></cpp:define>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SET_BINARY_MODE</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_BINARY_MODE</name><parameter_list>(<parameter><type><name>fd</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { int retVal = setmode ( fileno ( fd ), O_BINARY ); ERROR_IF_MINUS_ONE ( retVal ); } while ( 0 )</cpp:value></cpp:define>





<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;io.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SET_BINARY_MODE</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_BINARY_MODE</name><parameter_list>(<parameter><type><name>fd</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { int retVal = setmode ( fileno ( fd ), O_BINARY ); ERROR_IF_MINUS_ONE ( retVal ); } while ( 0 )</cpp:value></cpp:define>





<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BZ_LCCWIN32</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;io.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NORETURN</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PATH_SEP</name></cpp:macro> <cpp:value>'\\'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MY_LSTAT</name></cpp:macro> <cpp:value>_stati64</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MY_STAT</name></cpp:macro> <cpp:value>_stati64</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MY_S_ISREG</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((x) &amp; _S_IFREG)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MY_S_ISDIR</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((x) &amp; _S_IFDIR)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APPEND_FLAG</name><parameter_list>(<parameter><type><name>root</name></type></parameter>, <parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>root=snocString((root), (name))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APPEND_FILESPEC</name><parameter_list>(<parameter><type><name>root</name></type></parameter>, <parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>root = snocString ((root), (name))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SET_BINARY_MODE</name><parameter_list>(<parameter><type><name>fd</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { int retVal = setmode ( fileno ( fd ), O_BINARY ); ERROR_IF_MINUS_ONE ( retVal ); } while ( 0 )</cpp:value></cpp:define>






<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>







<typedef>typedef <type><name>char</name></type> <name>Char</name>;</typedef>
<typedef>typedef <type><name>unsigned</name> <name>char</name></type> <name>Bool</name>;</typedef>
<typedef>typedef <type><name>unsigned</name> <name>char</name></type> <name>UChar</name>;</typedef>
<typedef>typedef <type><name>int</name></type> <name>Int32</name>;</typedef>
<typedef>typedef <type><name>unsigned</name> <name>int</name></type> <name>UInt32</name>;</typedef>
<typedef>typedef <type><name>short</name></type> <name>Int16</name>;</typedef>
<typedef>typedef <type><name>unsigned</name> <name>short</name></type> <name>UInt16</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>True</name></cpp:macro> <cpp:value>((Bool)1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>False</name></cpp:macro> <cpp:value>((Bool)0)</cpp:value></cpp:define>





<typedef>typedef <type><name>int</name></type> <name>IntNative</name>;</typedef>






<decl_stmt><decl><type><name>Int32</name></type> <name>verbosity</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Bool</name></type> <name>keepInputFiles</name></decl>, <decl><type ref="prev"/><name>smallMode</name></decl>, <decl><type ref="prev"/><name>deleteOutputOnInterrupt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Bool</name></type> <name>forceOverwrite</name></decl>, <decl><type ref="prev"/><name>testFailsExist</name></decl>, <decl><type ref="prev"/><name>unzFailsExist</name></decl>, <decl><type ref="prev"/><name>noisy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Int32</name></type> <name>numFileNames</name></decl>, <decl><type ref="prev"/><name>numFilesProcessed</name></decl>, <decl><type ref="prev"/><name>blockSize100k</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Int32</name></type> <name>exitValue</name></decl>;</decl_stmt>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SM_I2O</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SM_F2O</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SM_F2F</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OM_Z</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OM_UNZ</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OM_TEST</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>

<decl_stmt><decl><type><name>Int32</name></type> <name>opMode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Int32</name></type> <name>srcMode</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FILE_NAME_LEN</name></cpp:macro> <cpp:value>1034</cpp:value></cpp:define>

<decl_stmt><decl><type><name>Int32</name></type> <name>longestFileName</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Char</name></type> <name><name>inName</name> <index>[<expr><name>FILE_NAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Char</name></type> <name><name>outName</name><index>[<expr><name>FILE_NAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Char</name></type> <name><name>tmpName</name><index>[<expr><name>FILE_NAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Char</name> <modifier>*</modifier></type><name>progName</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Char</name></type> <name><name>progNameReally</name><index>[<expr><name>FILE_NAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>outputHandleJustInCase</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Int32</name></type> <name>workFactor</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type> <name>panic</name> <argument_list>( <argument><expr><specifier>const</specifier> <name>Char</name><operator>*</operator></expr></argument> )</argument_list> <name>NORETURN</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type> <name>ioError</name> <argument_list>( <argument><expr><name>void</name></expr></argument> )</argument_list> <name>NORETURN</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type> <name>outOfMemory</name> <argument_list>( <argument><expr><name>void</name></expr></argument> )</argument_list> <name>NORETURN</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type> <name>configError</name> <argument_list>( <argument><expr><name>void</name></expr></argument> )</argument_list> <name>NORETURN</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type> <name>crcError</name> <argument_list>( <argument><expr><name>void</name></expr></argument> )</argument_list> <name>NORETURN</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type> <name>cleanUpAndFail</name> <argument_list>( <argument><expr><name>Int32</name></expr></argument> )</argument_list> <name>NORETURN</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type> <name>compressedStreamEOF</name> <argument_list>( <argument><expr><name>void</name></expr></argument> )</argument_list> <name>NORETURN</name></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>copyFileName</name> <parameter_list>( <parameter><decl><type><name>Char</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>Char</name><modifier>*</modifier></type></decl></parameter> )</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name><modifier>*</modifier></type> <name>myMalloc</name> <parameter_list>( <parameter><decl><type><name>Int32</name></type></decl></parameter> )</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>applySavedFileAttrToOutputFile</name> <parameter_list>( <parameter><decl><type><name>IntNative</name></type> <name>fd</name></decl></parameter> )</parameter_list>;</function_decl>








<typedef>typedef
<type><struct>struct <block>{ <decl_stmt><decl><type><name>UChar</name></type> <name><name>b</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt> }</block></struct></type>
<name>UInt64</name>;</typedef>


<function><type><specifier>static</specifier>
<name>void</name></type> <name>uInt64_from_UInt32s</name> <parameter_list>( <parameter><decl><type><name>UInt64</name><modifier>*</modifier></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>UInt32</name></type> <name>lo32</name></decl></parameter>, <parameter><decl><type><name>UInt32</name></type> <name>hi32</name></decl></parameter> )</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>b</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>UChar</name><operator>)</operator><operator>(</operator><operator>(</operator><name>hi32</name> <operator>&gt;&gt;</operator> <literal type="number">24</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFF</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>b</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>UChar</name><operator>)</operator><operator>(</operator><operator>(</operator><name>hi32</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFF</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>b</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>UChar</name><operator>)</operator><operator>(</operator><operator>(</operator><name>hi32</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFF</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>b</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>UChar</name><operator>)</operator> <operator>(</operator><name>hi32</name> <operator>&amp;</operator> <literal type="number">0xFF</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>b</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>UChar</name><operator>)</operator><operator>(</operator><operator>(</operator><name>lo32</name> <operator>&gt;&gt;</operator> <literal type="number">24</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFF</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>b</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>UChar</name><operator>)</operator><operator>(</operator><operator>(</operator><name>lo32</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFF</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>b</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>UChar</name><operator>)</operator><operator>(</operator><operator>(</operator><name>lo32</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFF</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>UChar</name><operator>)</operator> <operator>(</operator><name>lo32</name> <operator>&amp;</operator> <literal type="number">0xFF</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier>
<name>double</name></type> <name>uInt64_to_double</name> <parameter_list>( <parameter><decl><type><name>UInt64</name><modifier>*</modifier></type> <name>n</name></decl></parameter> )</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Int32</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>base</name> <init>= <expr><literal type="number">1.0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>sum</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">8</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>sum</name> <operator>+=</operator> <name>base</name> <operator>*</operator> <operator>(</operator><name>double</name><operator>)</operator><operator>(</operator><name><name>n</name><operator>-&gt;</operator><name>b</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>base</name> <operator>*=</operator> <literal type="number">256.0</literal></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>sum</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier>
<name>Bool</name></type> <name>uInt64_isZero</name> <parameter_list>( <parameter><decl><type><name>UInt64</name><modifier>*</modifier></type> <name>n</name></decl></parameter> )</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Int32</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">8</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>b</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier>
<name>Int32</name></type> <name>uInt64_qrm10</name> <parameter_list>( <parameter><decl><type><name>UInt64</name><modifier>*</modifier></type> <name>n</name></decl></parameter> )</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>UInt32</name></type> <name>rem</name></decl>, <decl><type ref="prev"/><name>tmp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Int32</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><name>rem</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">7</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <name>rem</name> <operator>*</operator> <literal type="number">256</literal> <operator>+</operator> <name><name>n</name><operator>-&gt;</operator><name>b</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>b</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>tmp</name> <operator>/</operator> <literal type="number">10</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>rem</name> <operator>=</operator> <name>tmp</name> <operator>%</operator> <literal type="number">10</literal></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>rem</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier>
<name>void</name></type> <name>uInt64_toAscii</name> <parameter_list>( <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>outbuf</name></decl></parameter>, <parameter><decl><type><name>UInt64</name><modifier>*</modifier></type> <name>n</name></decl></parameter> )</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Int32</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>q</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name></type> <name><name>buf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Int32</name></type> <name>nBuf</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UInt64</name></type> <name>n_copy</name> <init>= <expr><operator>*</operator><name>n</name></expr></init></decl>;</decl_stmt>
<do>do <block>{<block_content>
<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>uInt64_qrm10</name> <argument_list>( <argument><expr><operator>&amp;</operator><name>n_copy</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>nBuf</name></expr>]</index></name> <operator>=</operator> <name>q</name> <operator>+</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>nBuf</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><operator>!</operator><call><name>uInt64_isZero</name><argument_list>(<argument><expr><operator>&amp;</operator><name>n_copy</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
<expr_stmt><expr><name><name>outbuf</name><index>[<expr><name>nBuf</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nBuf</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>outbuf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>buf</name><index>[<expr><name>nBuf</name><operator>-</operator><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>







<function><type><specifier>static</specifier>
<name>Bool</name></type> <name>myfeof</name> <parameter_list>( <parameter><decl><type><name>FILE</name><modifier>*</modifier></type> <name>f</name></decl></parameter> )</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Int32</name></type> <name>c</name> <init>= <expr><call><name>fgetc</name> <argument_list>( <argument><expr><name>f</name></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>True</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>ungetc</name> <argument_list>( <argument><expr><name>c</name></expr></argument>, <argument><expr><name>f</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>False</name></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier>
<name>void</name></type> <name>compressStream</name> <parameter_list>( <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>stream</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>zStream</name></decl></parameter> )</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>BZFILE</name><modifier>*</modifier></type> <name>bzf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name></type> <name><name>ibuf</name><index>[<expr><literal type="number">5000</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Int32</name></type> <name>nIbuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UInt32</name></type> <name>nbytes_in_lo32</name></decl>, <decl><type ref="prev"/><name>nbytes_in_hi32</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UInt32</name></type> <name>nbytes_out_lo32</name></decl>, <decl><type ref="prev"/><name>nbytes_out_hi32</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Int32</name></type> <name>bzerr</name></decl>, <decl><type ref="prev"/><name>bzerr_dummy</name></decl>, <decl><type ref="prev"/><name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>SET_BINARY_MODE</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET_BINARY_MODE</name><argument_list>(<argument><expr><name>zStream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>errhandler_io</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name>zStream</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>errhandler_io</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>bzf</name> <operator>=</operator> <call><name>BZ2_bzWriteOpen</name> <argument_list>( <argument><expr><operator>&amp;</operator><name>bzerr</name></expr></argument>, <argument><expr><name>zStream</name></expr></argument>,
<argument><expr><name>blockSize100k</name></expr></argument>, <argument><expr><name>verbosity</name></expr></argument>, <argument><expr><name>workFactor</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bzerr</name> <operator>!=</operator> <name>BZ_OK</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>errhandler</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>verbosity</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<while>while <condition>(<expr><name>True</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>myfeof</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>nIbuf</name> <operator>=</operator> <call><name>fread</name> <argument_list>( <argument><expr><name>ibuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>UChar</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">5000</literal></expr></argument>, <argument><expr><name>stream</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>errhandler_io</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>nIbuf</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>BZ2_bzWrite</name> <argument_list>( <argument><expr><operator>&amp;</operator><name>bzerr</name></expr></argument>, <argument><expr><name>bzf</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>ibuf</name></expr></argument>, <argument><expr><name>nIbuf</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>bzerr</name> <operator>!=</operator> <name>BZ_OK</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>errhandler</name>;</goto></block_content></block></if></if_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>BZ2_bzWriteClose64</name> <argument_list>( <argument><expr><operator>&amp;</operator><name>bzerr</name></expr></argument>, <argument><expr><name>bzf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
<argument><expr><operator>&amp;</operator><name>nbytes_in_lo32</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nbytes_in_hi32</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>nbytes_out_lo32</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nbytes_out_hi32</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bzerr</name> <operator>!=</operator> <name>BZ_OK</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>errhandler</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name>zStream</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>errhandler_io</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>fflush</name> <argument_list>( <argument><expr><name>zStream</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>errhandler_io</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>zStream</name> <operator>!=</operator> <name>stdout</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>Int32</name></type> <name>fd</name> <init>= <expr><call><name>fileno</name> <argument_list>( <argument><expr><name>zStream</name></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>errhandler_io</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>applySavedFileAttrToOutputFile</name> <argument_list>( <argument><expr><name>fd</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>fclose</name> <argument_list>( <argument><expr><name>zStream</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>outputHandleJustInCase</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>errhandler_io</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>outputHandleJustInCase</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>errhandler_io</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>fclose</name> <argument_list>( <argument><expr><name>stream</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>errhandler_io</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>verbosity</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>nbytes_in_lo32</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nbytes_in_hi32</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">" no data compressed.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>Char</name></type> <name><name>buf_nin</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>buf_nout</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UInt64</name></type> <name>nbytes_in</name></decl>, <decl><type ref="prev"/><name>nbytes_out</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>nbytes_in_d</name></decl>, <decl><type ref="prev"/><name>nbytes_out_d</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>uInt64_from_UInt32s</name> <argument_list>( <argument><expr><operator>&amp;</operator><name>nbytes_in</name></expr></argument>,
<argument><expr><name>nbytes_in_lo32</name></expr></argument>, <argument><expr><name>nbytes_in_hi32</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>uInt64_from_UInt32s</name> <argument_list>( <argument><expr><operator>&amp;</operator><name>nbytes_out</name></expr></argument>,
<argument><expr><name>nbytes_out_lo32</name></expr></argument>, <argument><expr><name>nbytes_out_hi32</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nbytes_in_d</name> <operator>=</operator> <call><name>uInt64_to_double</name> <argument_list>( <argument><expr><operator>&amp;</operator><name>nbytes_in</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nbytes_out_d</name> <operator>=</operator> <call><name>uInt64_to_double</name> <argument_list>( <argument><expr><operator>&amp;</operator><name>nbytes_out</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>uInt64_toAscii</name> <argument_list>( <argument><expr><name>buf_nin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nbytes_in</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>uInt64_toAscii</name> <argument_list>( <argument><expr><name>buf_nout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nbytes_out</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%6.3f:1, %6.3f bits/byte, "</literal>
<literal type="string">"%5.2f%% saved, %s in, %s out.\n"</literal></expr></argument>,
<argument><expr><name>nbytes_in_d</name> <operator>/</operator> <name>nbytes_out_d</name></expr></argument>,
<argument><expr><operator>(</operator><literal type="number">8.0</literal> <operator>*</operator> <name>nbytes_out_d</name><operator>)</operator> <operator>/</operator> <name>nbytes_in_d</name></expr></argument>,
<argument><expr><literal type="number">100.0</literal> <operator>*</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name>nbytes_out_d</name> <operator>/</operator> <name>nbytes_in_d</name><operator>)</operator></expr></argument>,
<argument><expr><name>buf_nin</name></expr></argument>,
<argument><expr><name>buf_nout</name></expr></argument>
)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<return>return;</return>

<label><name>errhandler</name>:</label>
<expr_stmt><expr><call><name>BZ2_bzWriteClose64</name> <argument_list>( <argument><expr><operator>&amp;</operator><name>bzerr_dummy</name></expr></argument>, <argument><expr><name>bzf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
<argument><expr><operator>&amp;</operator><name>nbytes_in_lo32</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nbytes_in_hi32</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>nbytes_out_lo32</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nbytes_out_hi32</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>bzerr</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>BZ_CONFIG_ERROR</name></expr>:</case>
<expr_stmt><expr><call><name>configError</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>BZ_MEM_ERROR</name></expr>:</case>
<expr_stmt><expr><call><name>outOfMemory</name> <argument_list>()</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>BZ_IO_ERROR</name></expr>:</case>
<label><name>errhandler_io</name>:</label>
<expr_stmt><expr><call><name>ioError</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>panic</name> <argument_list>( <argument><expr><literal type="string">"compress:unexpected error"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>

<expr_stmt><expr><call><name>panic</name> <argument_list>( <argument><expr><literal type="string">"compress:end"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>




<function><type><specifier>static</specifier>
<name>Bool</name></type> <name>uncompressStream</name> <parameter_list>( <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>zStream</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>stream</name></decl></parameter> )</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>BZFILE</name><modifier>*</modifier></type> <name>bzf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Int32</name></type> <name>bzerr</name></decl>, <decl><type ref="prev"/><name>bzerr_dummy</name></decl>, <decl><type ref="prev"/><name>ret</name></decl>, <decl><type ref="prev"/><name>nread</name></decl>, <decl><type ref="prev"/><name>streamNo</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name></type> <name><name>obuf</name><index>[<expr><literal type="number">5000</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name></type> <name><name>unused</name><index>[<expr><name>BZ_MAX_UNUSED</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Int32</name></type> <name>nUnused</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>unusedTmpV</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name><modifier>*</modifier></type> <name>unusedTmp</name></decl>;</decl_stmt>

<expr_stmt><expr><name>nUnused</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>streamNo</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET_BINARY_MODE</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SET_BINARY_MODE</name><argument_list>(<argument><expr><name>zStream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>errhandler_io</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name>zStream</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>errhandler_io</name>;</goto></block_content></block></if></if_stmt>

<while>while <condition>(<expr><name>True</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>bzf</name> <operator>=</operator> <call><name>BZ2_bzReadOpen</name> <argument_list>(
<argument><expr><operator>&amp;</operator><name>bzerr</name></expr></argument>, <argument><expr><name>zStream</name></expr></argument>, <argument><expr><name>verbosity</name></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>smallMode</name></expr></argument>, <argument><expr><name>unused</name></expr></argument>, <argument><expr><name>nUnused</name></expr></argument>
)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bzf</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>bzerr</name> <operator>!=</operator> <name>BZ_OK</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>errhandler</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>streamNo</name><operator>++</operator></expr>;</expr_stmt>

<while>while <condition>(<expr><name>bzerr</name> <operator>==</operator> <name>BZ_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>nread</name> <operator>=</operator> <call><name>BZ2_bzRead</name> <argument_list>( <argument><expr><operator>&amp;</operator><name>bzerr</name></expr></argument>, <argument><expr><name>bzf</name></expr></argument>, <argument><expr><name>obuf</name></expr></argument>, <argument><expr><literal type="number">5000</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bzerr</name> <operator>==</operator> <name>BZ_DATA_ERROR_MAGIC</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>trycat</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>bzerr</name> <operator>==</operator> <name>BZ_OK</name> <operator>||</operator> <name>bzerr</name> <operator>==</operator> <name>BZ_STREAM_END</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>nread</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fwrite</name> <argument_list>( <argument><expr><name>obuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>UChar</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>nread</name></expr></argument>, <argument><expr><name>stream</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>errhandler_io</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>bzerr</name> <operator>!=</operator> <name>BZ_STREAM_END</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>errhandler</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>BZ2_bzReadGetUnused</name> <argument_list>( <argument><expr><operator>&amp;</operator><name>bzerr</name></expr></argument>, <argument><expr><name>bzf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>unusedTmpV</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nUnused</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bzerr</name> <operator>!=</operator> <name>BZ_OK</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>panic</name> <argument_list>( <argument><expr><literal type="string">"decompress:bzReadGetUnused"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>unusedTmp</name> <operator>=</operator> <operator>(</operator><name>UChar</name><operator>*</operator><operator>)</operator><name>unusedTmpV</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nUnused</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>unused</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>unusedTmp</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><call><name>BZ2_bzReadClose</name> <argument_list>( <argument><expr><operator>&amp;</operator><name>bzerr</name></expr></argument>, <argument><expr><name>bzf</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bzerr</name> <operator>!=</operator> <name>BZ_OK</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>panic</name> <argument_list>( <argument><expr><literal type="string">"decompress:bzReadGetUnused"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>nUnused</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>myfeof</name><argument_list>(<argument><expr><name>zStream</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></while>

<label><name>closeok</name>:</label>
<if_stmt><if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name>zStream</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>errhandler_io</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>stream</name> <operator>!=</operator> <name>stdout</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>Int32</name></type> <name>fd</name> <init>= <expr><call><name>fileno</name> <argument_list>( <argument><expr><name>stream</name></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>errhandler_io</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>applySavedFileAttrToOutputFile</name> <argument_list>( <argument><expr><name>fd</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>fclose</name> <argument_list>( <argument><expr><name>zStream</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>errhandler_io</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>errhandler_io</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>fflush</name> <argument_list>( <argument><expr><name>stream</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>errhandler_io</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>stream</name> <operator>!=</operator> <name>stdout</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>fclose</name> <argument_list>( <argument><expr><name>stream</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>outputHandleJustInCase</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>errhandler_io</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>outputHandleJustInCase</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>verbosity</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\n "</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>True</name></expr>;</return>

<label><name>trycat</name>:</label>
<if_stmt><if>if <condition>(<expr><name>forceOverwrite</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rewind</name><argument_list>(<argument><expr><name>zStream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>True</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>myfeof</name><argument_list>(<argument><expr><name>zStream</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>nread</name> <operator>=</operator> <call><name>fread</name> <argument_list>( <argument><expr><name>obuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>UChar</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">5000</literal></expr></argument>, <argument><expr><name>zStream</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name>zStream</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>errhandler_io</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>nread</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fwrite</name> <argument_list>( <argument><expr><name>obuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>UChar</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>nread</name></expr></argument>, <argument><expr><name>stream</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>errhandler_io</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></while>
<goto>goto <name>closeok</name>;</goto>
</block_content>}</block></if></if_stmt>

<label><name>errhandler</name>:</label>
<expr_stmt><expr><call><name>BZ2_bzReadClose</name> <argument_list>( <argument><expr><operator>&amp;</operator><name>bzerr_dummy</name></expr></argument>, <argument><expr><name>bzf</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>bzerr</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>BZ_CONFIG_ERROR</name></expr>:</case>
<expr_stmt><expr><call><name>configError</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>BZ_IO_ERROR</name></expr>:</case>
<label><name>errhandler_io</name>:</label>
<expr_stmt><expr><call><name>ioError</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>BZ_DATA_ERROR</name></expr>:</case>
<expr_stmt><expr><call><name>crcError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<case>case <expr><name>BZ_MEM_ERROR</name></expr>:</case>
<expr_stmt><expr><call><name>outOfMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<case>case <expr><name>BZ_UNEXPECTED_EOF</name></expr>:</case>
<expr_stmt><expr><call><name>compressedStreamEOF</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<case>case <expr><name>BZ_DATA_ERROR_MAGIC</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>zStream</name> <operator>!=</operator> <name>stdin</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>zStream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>stream</name> <operator>!=</operator> <name>stdout</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>streamNo</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>False</name></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>noisy</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"\n%s: %s: trailing garbage after EOF ignored\n"</literal></expr></argument>,
<argument><expr><name>progName</name></expr></argument>, <argument><expr><name>inName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>True</name></expr>;</return>
</block_content>}</block></else></if_stmt>
<default>default:</default>
<expr_stmt><expr><call><name>panic</name> <argument_list>( <argument><expr><literal type="string">"decompress:unexpected error"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>

<expr_stmt><expr><call><name>panic</name> <argument_list>( <argument><expr><literal type="string">"decompress:end"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>True</name></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier>
<name>Bool</name></type> <name>testStream</name> <parameter_list>( <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>zStream</name></decl></parameter> )</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>BZFILE</name><modifier>*</modifier></type> <name>bzf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Int32</name></type> <name>bzerr</name></decl>, <decl><type ref="prev"/><name>bzerr_dummy</name></decl>, <decl><type ref="prev"/><name>ret</name></decl>, <decl><type ref="prev"/><name>streamNo</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name></type> <name><name>obuf</name><index>[<expr><literal type="number">5000</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name></type> <name><name>unused</name><index>[<expr><name>BZ_MAX_UNUSED</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Int32</name></type> <name>nUnused</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>unusedTmpV</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UChar</name><modifier>*</modifier></type> <name>unusedTmp</name></decl>;</decl_stmt>

<expr_stmt><expr><name>nUnused</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>streamNo</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SET_BINARY_MODE</name><argument_list>(<argument><expr><name>zStream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name>zStream</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>errhandler_io</name>;</goto></block_content></block></if></if_stmt>

<while>while <condition>(<expr><name>True</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>bzf</name> <operator>=</operator> <call><name>BZ2_bzReadOpen</name> <argument_list>(
<argument><expr><operator>&amp;</operator><name>bzerr</name></expr></argument>, <argument><expr><name>zStream</name></expr></argument>, <argument><expr><name>verbosity</name></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>smallMode</name></expr></argument>, <argument><expr><name>unused</name></expr></argument>, <argument><expr><name>nUnused</name></expr></argument>
)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bzf</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>bzerr</name> <operator>!=</operator> <name>BZ_OK</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>errhandler</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>streamNo</name><operator>++</operator></expr>;</expr_stmt>

<while>while <condition>(<expr><name>bzerr</name> <operator>==</operator> <name>BZ_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>BZ2_bzRead</name> <argument_list>( <argument><expr><operator>&amp;</operator><name>bzerr</name></expr></argument>, <argument><expr><name>bzf</name></expr></argument>, <argument><expr><name>obuf</name></expr></argument>, <argument><expr><literal type="number">5000</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bzerr</name> <operator>==</operator> <name>BZ_DATA_ERROR_MAGIC</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>errhandler</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>bzerr</name> <operator>!=</operator> <name>BZ_STREAM_END</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>errhandler</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>BZ2_bzReadGetUnused</name> <argument_list>( <argument><expr><operator>&amp;</operator><name>bzerr</name></expr></argument>, <argument><expr><name>bzf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>unusedTmpV</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nUnused</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bzerr</name> <operator>!=</operator> <name>BZ_OK</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>panic</name> <argument_list>( <argument><expr><literal type="string">"test:bzReadGetUnused"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>unusedTmp</name> <operator>=</operator> <operator>(</operator><name>UChar</name><operator>*</operator><operator>)</operator><name>unusedTmpV</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nUnused</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>unused</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>unusedTmp</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><call><name>BZ2_bzReadClose</name> <argument_list>( <argument><expr><operator>&amp;</operator><name>bzerr</name></expr></argument>, <argument><expr><name>bzf</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bzerr</name> <operator>!=</operator> <name>BZ_OK</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>panic</name> <argument_list>( <argument><expr><literal type="string">"test:bzReadGetUnused"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>nUnused</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>myfeof</name><argument_list>(<argument><expr><name>zStream</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name>zStream</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>errhandler_io</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>fclose</name> <argument_list>( <argument><expr><name>zStream</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>errhandler_io</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>verbosity</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\n "</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>True</name></expr>;</return>

<label><name>errhandler</name>:</label>
<expr_stmt><expr><call><name>BZ2_bzReadClose</name> <argument_list>( <argument><expr><operator>&amp;</operator><name>bzerr_dummy</name></expr></argument>, <argument><expr><name>bzf</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>verbosity</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: %s: "</literal></expr></argument>, <argument><expr><name>progName</name></expr></argument>, <argument><expr><name>inName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<switch>switch <condition>(<expr><name>bzerr</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>BZ_CONFIG_ERROR</name></expr>:</case>
<expr_stmt><expr><call><name>configError</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>BZ_IO_ERROR</name></expr>:</case>
<label><name>errhandler_io</name>:</label>
<expr_stmt><expr><call><name>ioError</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>BZ_DATA_ERROR</name></expr>:</case>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"data integrity (CRC) error in data\n"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>False</name></expr>;</return>
<case>case <expr><name>BZ_MEM_ERROR</name></expr>:</case>
<expr_stmt><expr><call><name>outOfMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<case>case <expr><name>BZ_UNEXPECTED_EOF</name></expr>:</case>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"file ends unexpectedly\n"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>False</name></expr>;</return>
<case>case <expr><name>BZ_DATA_ERROR_MAGIC</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>zStream</name> <operator>!=</operator> <name>stdin</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>zStream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>streamNo</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"bad magic number (file not created by bzip2)\n"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>False</name></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>noisy</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"trailing garbage after EOF ignored\n"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>True</name></expr>;</return>
</block_content>}</block></else></if_stmt>
<default>default:</default>
<expr_stmt><expr><call><name>panic</name> <argument_list>( <argument><expr><literal type="string">"test:unexpected error"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>

<expr_stmt><expr><call><name>panic</name> <argument_list>( <argument><expr><literal type="string">"test:end"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>True</name></expr>;</return>
</block_content>}</block></function>







<function><type><specifier>static</specifier>
<name>void</name></type> <name>setExit</name> <parameter_list>( <parameter><decl><type><name>Int32</name></type> <name>v</name></decl></parameter> )</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>v</name> <operator>&gt;</operator> <name>exitValue</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>exitValue</name> <operator>=</operator> <name>v</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>



<function><type><specifier>static</specifier>
<name>void</name></type> <name>cadvise</name> <parameter_list>( <parameter><decl><type><name>void</name></type></decl></parameter> )</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>noisy</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>(
<argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"\nIt is possible that the compressed file(s) have become corrupted.\n"</literal>
<literal type="string">"You can use the -tvv option to test integrity of such files.\n\n"</literal>
<literal type="string">"You can use the `bzip2recover' program to attempt to recover\n"</literal>
<literal type="string">"data from undamaged sections of corrupted files.\n\n"</literal></expr></argument>
)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>



<function><type><specifier>static</specifier>
<name>void</name></type> <name>showFileNames</name> <parameter_list>( <parameter><decl><type><name>void</name></type></decl></parameter> )</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>noisy</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>(
<argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"\tInput file = %s, output file = %s\n"</literal></expr></argument>,
<argument><expr><name>inName</name></expr></argument>, <argument><expr><name>outName</name></expr></argument>
)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>



<function><type><specifier>static</specifier>
<name>void</name></type> <name>cleanUpAndFail</name> <parameter_list>( <parameter><decl><type><name>Int32</name></type> <name>ec</name></decl></parameter> )</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>IntNative</name></type> <name>retVal</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>MY_STAT</name></name></type> <name>statBuf</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>( <expr><name>srcMode</name> <operator>==</operator> <name>SM_F2F</name>
<operator>&amp;&amp;</operator> <name>opMode</name> <operator>!=</operator> <name>OM_TEST</name>
<operator>&amp;&amp;</operator> <name>deleteOutputOnInterrupt</name></expr> )</condition> <block>{<block_content>






<expr_stmt><expr><name>retVal</name> <operator>=</operator> <call><name>MY_STAT</name> <argument_list>( <argument><expr><name>inName</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statBuf</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>retVal</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>noisy</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"%s: Deleting output file %s, if it exists.\n"</literal></expr></argument>,
<argument><expr><name>progName</name></expr></argument>, <argument><expr><name>outName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>outputHandleJustInCase</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fclose</name> <argument_list>( <argument><expr><name>outputHandleJustInCase</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>retVal</name> <operator>=</operator> <call><name>remove</name> <argument_list>( <argument><expr><name>outName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>retVal</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"%s: WARNING: deletion of output file "</literal>
<literal type="string">"(apparently) failed.\n"</literal></expr></argument>,
<argument><expr><name>progName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"%s: WARNING: deletion of output file suppressed\n"</literal></expr></argument>,
<argument><expr><name>progName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"%s: since input file no longer exists. Output file\n"</literal></expr></argument>,
<argument><expr><name>progName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"%s: `%s' may be incomplete.\n"</literal></expr></argument>,
<argument><expr><name>progName</name></expr></argument>, <argument><expr><name>outName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"%s: I suggest doing an integrity test (bzip2 -tv)"</literal>
<literal type="string">" of it.\n"</literal></expr></argument>,
<argument><expr><name>progName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>noisy</name> <operator>&amp;&amp;</operator> <name>numFileNames</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>numFilesProcessed</name> <operator>&lt;</operator> <name>numFileNames</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"%s: WARNING: some files have not been processed:\n"</literal>
<literal type="string">"%s: %d specified on command line, %d not processed yet.\n\n"</literal></expr></argument>,
<argument><expr><name>progName</name></expr></argument>, <argument><expr><name>progName</name></expr></argument>,
<argument><expr><name>numFileNames</name></expr></argument>, <argument><expr><name>numFileNames</name> <operator>-</operator> <name>numFilesProcessed</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>setExit</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>exitValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<function><type><specifier>static</specifier>
<name>void</name></type> <name>panic</name> <parameter_list>( <parameter><decl><type><specifier>const</specifier> <name>Char</name><modifier>*</modifier></type> <name>s</name></decl></parameter> )</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"\n%s: PANIC -- internal consistency error:\n"</literal>
<literal type="string">"\t%s\n"</literal>
<literal type="string">"\tThis is a BUG. Please report it to:\n"</literal>
<literal type="string">"\tbzip2-devel@sourceware.org\n"</literal></expr></argument>,
<argument><expr><name>progName</name></expr></argument>, <argument><expr><name>s</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>showFileNames</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cleanUpAndFail</name><argument_list>( <argument><expr><literal type="number">3</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<function><type><specifier>static</specifier>
<name>void</name></type> <name>crcError</name> <parameter_list>( <parameter><decl><type><name>void</name></type></decl></parameter> )</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"\n%s: Data integrity error when decompressing.\n"</literal></expr></argument>,
<argument><expr><name>progName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>showFileNames</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cadvise</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cleanUpAndFail</name><argument_list>( <argument><expr><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<function><type><specifier>static</specifier>
<name>void</name></type> <name>compressedStreamEOF</name> <parameter_list>( <parameter><decl><type><name>void</name></type></decl></parameter> )</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>noisy</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"\n%s: Compressed file ends unexpectedly;\n\t"</literal>
<literal type="string">"perhaps it is corrupted? *Possible* reason follows.\n"</literal></expr></argument>,
<argument><expr><name>progName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>perror</name> <argument_list>( <argument><expr><name>progName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>showFileNames</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cadvise</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>cleanUpAndFail</name><argument_list>( <argument><expr><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<function><type><specifier>static</specifier>
<name>void</name></type> <name>ioError</name> <parameter_list>( <parameter><decl><type><name>void</name></type></decl></parameter> )</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"\n%s: I/O or other error, bailing out. "</literal>
<literal type="string">"Possible reason follows.\n"</literal></expr></argument>,
<argument><expr><name>progName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>perror</name> <argument_list>( <argument><expr><name>progName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>showFileNames</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cleanUpAndFail</name><argument_list>( <argument><expr><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<function><type><specifier>static</specifier>
<name>void</name></type> <name>mySignalCatcher</name> <parameter_list>( <parameter><decl><type><name>IntNative</name></type> <name>n</name></decl></parameter> )</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"\n%s: Control-C or similar caught, quitting.\n"</literal></expr></argument>,
<argument><expr><name>progName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cleanUpAndFail</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<function><type><specifier>static</specifier>
<name>void</name></type> <name>mySIGSEGVorSIGBUScatcher</name> <parameter_list>( <parameter><decl><type><name>IntNative</name></type> <name>n</name></decl></parameter> )</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>opMode</name> <operator>==</operator> <name>OM_Z</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>(
<argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"\n%s: Caught a SIGSEGV or SIGBUS whilst compressing.\n"</literal>
<literal type="string">"\n"</literal>
<literal type="string">" Possible causes are (most likely first):\n"</literal>
<literal type="string">" (1) This computer has unreliable memory or cache hardware\n"</literal>
<literal type="string">" (a surprisingly common problem; try a different machine.)\n"</literal>
<literal type="string">" (2) A bug in the compiler used to create this executable\n"</literal>
<literal type="string">" (unlikely, if you didn't compile bzip2 yourself.)\n"</literal>
<literal type="string">" (3) A real bug in bzip2 -- I hope this should never be the case.\n"</literal>
<literal type="string">" The user's manual, Section 4.3, has more info on (1) and (2).\n"</literal>
<literal type="string">" \n"</literal>
<literal type="string">" If you suspect this is a bug in bzip2, or are unsure about (1)\n"</literal>
<literal type="string">" or (2), feel free to report it to: bzip2-devel@sourceware.org.\n"</literal>
<literal type="string">" Section 4.3 of the user's manual describes the info a useful\n"</literal>
<literal type="string">" bug report should have. If the manual is available on your\n"</literal>
<literal type="string">" system, please try and read it before mailing me. If you don't\n"</literal>
<literal type="string">" have the manual or can't be bothered to read it, mail me anyway.\n"</literal>
<literal type="string">"\n"</literal></expr></argument>,
<argument><expr><name>progName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>(
<argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"\n%s: Caught a SIGSEGV or SIGBUS whilst decompressing.\n"</literal>
<literal type="string">"\n"</literal>
<literal type="string">" Possible causes are (most likely first):\n"</literal>
<literal type="string">" (1) The compressed data is corrupted, and bzip2's usual checks\n"</literal>
<literal type="string">" failed to detect this. Try bzip2 -tvv my_file.bz2.\n"</literal>
<literal type="string">" (2) This computer has unreliable memory or cache hardware\n"</literal>
<literal type="string">" (a surprisingly common problem; try a different machine.)\n"</literal>
<literal type="string">" (3) A bug in the compiler used to create this executable\n"</literal>
<literal type="string">" (unlikely, if you didn't compile bzip2 yourself.)\n"</literal>
<literal type="string">" (4) A real bug in bzip2 -- I hope this should never be the case.\n"</literal>
<literal type="string">" The user's manual, Section 4.3, has more info on (2) and (3).\n"</literal>
<literal type="string">" \n"</literal>
<literal type="string">" If you suspect this is a bug in bzip2, or are unsure about (2)\n"</literal>
<literal type="string">" or (3), feel free to report it to: bzip2-devel@sourceware.org.\n"</literal>
<literal type="string">" Section 4.3 of the user's manual describes the info a useful\n"</literal>
<literal type="string">" bug report should have. If the manual is available on your\n"</literal>
<literal type="string">" system, please try and read it before mailing me. If you don't\n"</literal>
<literal type="string">" have the manual or can't be bothered to read it, mail me anyway.\n"</literal>
<literal type="string">"\n"</literal></expr></argument>,
<argument><expr><name>progName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>showFileNames</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>opMode</name> <operator>==</operator> <name>OM_Z</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>cleanUpAndFail</name><argument_list>( <argument><expr><literal type="number">3</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if> <else>else
<block>{<block_content> <expr_stmt><expr><call><name>cadvise</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>cleanUpAndFail</name><argument_list>( <argument><expr><literal type="number">2</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> </block_content>}</block></else></if_stmt>
</block_content>}</block></function>



<function><type><specifier>static</specifier>
<name>void</name></type> <name>outOfMemory</name> <parameter_list>( <parameter><decl><type><name>void</name></type></decl></parameter> )</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"\n%s: couldn't allocate enough memory\n"</literal></expr></argument>,
<argument><expr><name>progName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>showFileNames</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cleanUpAndFail</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<function><type><specifier>static</specifier>
<name>void</name></type> <name>configError</name> <parameter_list>( <parameter><decl><type><name>void</name></type></decl></parameter> )</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"bzip2: I'm not configured correctly for this platform!\n"</literal>
<literal type="string">"\tI require Int32, Int16 and Char to have sizes\n"</literal>
<literal type="string">"\tof 4, 2 and 1 bytes to run properly, and they don't.\n"</literal>
<literal type="string">"\tProbably you can fix this by defining them correctly,\n"</literal>
<literal type="string">"\tand recompiling. Bye!\n"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setExit</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>exitValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>












<function><type><specifier>static</specifier>
<name>void</name></type> <name>pad</name> <parameter_list>( <parameter><decl><type><name>Char</name> <modifier>*</modifier></type><name>s</name></decl></parameter> )</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Int32</name></type> <name>i</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>( <expr><operator>(</operator><name>Int32</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>longestFileName</name></expr> )</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>longestFileName</name> <operator>-</operator> <operator>(</operator><name>Int32</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>



<function><type><specifier>static</specifier>
<name>void</name></type> <name>copyFileName</name> <parameter_list>( <parameter><decl><type><name>Char</name><modifier>*</modifier></type> <name>to</name></decl></parameter>, <parameter><decl><type><name>Char</name><modifier>*</modifier></type> <name>from</name></decl></parameter> )</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>( <expr><call><name>strlen</name><argument_list>(<argument><expr><name>from</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>FILE_NAME_LEN</name><operator>-</operator><literal type="number">10</literal></expr> )</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>(
<argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"bzip2: file name\n`%s'\n"</literal>
<literal type="string">"is suspiciously (more than %d chars) long.\n"</literal>
<literal type="string">"Try using a reasonable file name instead. Sorry! :-)\n"</literal></expr></argument>,
<argument><expr><name>from</name></expr></argument>, <argument><expr><name>FILE_NAME_LEN</name><operator>-</operator><literal type="number">10</literal></expr></argument>
)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setExit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>exitValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>to</name></expr></argument>,<argument><expr><name>from</name></expr></argument>,<argument><expr><name>FILE_NAME_LEN</name><operator>-</operator><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>to</name><index>[<expr><name>FILE_NAME_LEN</name><operator>-</operator><literal type="number">10</literal></expr>]</index></name><operator>=</operator><literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></function>



<function><type><specifier>static</specifier>
<name>Bool</name></type> <name>fileExists</name> <parameter_list>( <parameter><decl><type><name>Char</name><modifier>*</modifier></type> <name>name</name></decl></parameter> )</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><call><name>fopen</name> <argument_list>( <argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"rb"</literal></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Bool</name></type> <name>exists</name> <init>= <expr><operator>(</operator><name>tmp</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>tmp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fclose</name> <argument_list>( <argument><expr><name>tmp</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>exists</name></expr>;</return>
</block_content>}</block></function>












<function><type><specifier>static</specifier>
<name>FILE</name><modifier>*</modifier></type> <name>fopen_output_safely</name> <parameter_list>( <parameter><decl><type><name>Char</name><modifier>*</modifier></type> <name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>mode</name></decl></parameter> )</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BZ_UNIX</name></expr></cpp:if>
<decl_stmt><decl><type><name>FILE</name><modifier>*</modifier></type> <name>fp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IntNative</name></type> <name>fh</name></decl>;</decl_stmt>
<expr_stmt><expr><name>fh</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>O_WRONLY</name><operator>|</operator><name>O_CREAT</name><operator>|</operator><name>O_EXCL</name></expr></argument>, <argument><expr><name>S_IWUSR</name><operator>|</operator><name>S_IRUSR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fh</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>fdopen</name><argument_list>(<argument><expr><name>fh</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>fp</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><call><name>fopen</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>






<function><type><specifier>static</specifier>
<name>Bool</name></type> <name>notAStandardFile</name> <parameter_list>( <parameter><decl><type><name>Char</name><modifier>*</modifier></type> <name>name</name></decl></parameter> )</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>IntNative</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>MY_STAT</name></name></type> <name>statBuf</name></decl>;</decl_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>MY_LSTAT</name> <argument_list>( <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statBuf</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>True</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>MY_S_ISREG</name><argument_list>(<argument><expr><name><name>statBuf</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>False</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>True</name></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier>
<name>Int32</name></type> <name>countHardLinks</name> <parameter_list>( <parameter><decl><type><name>Char</name><modifier>*</modifier></type> <name>name</name></decl></parameter> )</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>IntNative</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>MY_STAT</name></name></type> <name>statBuf</name></decl>;</decl_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>MY_LSTAT</name> <argument_list>( <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statBuf</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><name><name>statBuf</name><operator>.</operator><name>st_nlink</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

























<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BZ_UNIX</name></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier>
<name><name>struct</name> <name>MY_STAT</name></name></type> <name>fileMetaInfo</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier>
<name>void</name></type> <name>saveInputFileMetaInfo</name> <parameter_list>( <parameter><decl><type><name>Char</name> <modifier>*</modifier></type><name>srcName</name></decl></parameter> )</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BZ_UNIX</name></expr></cpp:if>
<decl_stmt><decl><type><name>IntNative</name></type> <name>retVal</name></decl>;</decl_stmt>

<expr_stmt><expr><name>retVal</name> <operator>=</operator> <call><name>MY_STAT</name><argument_list>( <argument><expr><name>srcName</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fileMetaInfo</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ERROR_IF_NOT_ZERO</name> <argument_list>( <argument><expr><name>retVal</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<function><type><specifier>static</specifier>
<name>void</name></type> <name>applySavedTimeInfoToOutputFile</name> <parameter_list>( <parameter><decl><type><name>Char</name> <modifier>*</modifier></type><name>dstName</name></decl></parameter> )</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BZ_UNIX</name></expr></cpp:if>
<decl_stmt><decl><type><name>IntNative</name></type> <name>retVal</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>utimbuf</name></name></type> <name>uTimBuf</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>uTimBuf</name><operator>.</operator><name>actime</name></name> <operator>=</operator> <name><name>fileMetaInfo</name><operator>.</operator><name>st_atime</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>uTimBuf</name><operator>.</operator><name>modtime</name></name> <operator>=</operator> <name><name>fileMetaInfo</name><operator>.</operator><name>st_mtime</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>retVal</name> <operator>=</operator> <call><name>utime</name> <argument_list>( <argument><expr><name>dstName</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>uTimBuf</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ERROR_IF_NOT_ZERO</name> <argument_list>( <argument><expr><name>retVal</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier>
<name>void</name></type> <name>applySavedFileAttrToOutputFile</name> <parameter_list>( <parameter><decl><type><name>IntNative</name></type> <name>fd</name></decl></parameter> )</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BZ_UNIX</name></expr></cpp:if>
<decl_stmt><decl><type><name>IntNative</name></type> <name>retVal</name></decl>;</decl_stmt>

<expr_stmt><expr><name>retVal</name> <operator>=</operator> <call><name>fchmod</name> <argument_list>( <argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>fileMetaInfo</name><operator>.</operator><name>st_mode</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ERROR_IF_NOT_ZERO</name> <argument_list>( <argument><expr><name>retVal</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fchown</name> <argument_list>( <argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>fileMetaInfo</name><operator>.</operator><name>st_uid</name></name></expr></argument>, <argument><expr><name><name>fileMetaInfo</name><operator>.</operator><name>st_gid</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>



<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>



<function><type><specifier>static</specifier>
<name>Bool</name></type> <name>containsDubiousChars</name> <parameter_list>( <parameter><decl><type><name>Char</name><modifier>*</modifier></type> <name>name</name></decl></parameter> )</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BZ_UNIX</name></expr></cpp:if>



<return>return <expr><name>False</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>



<for>for <control>(<init>;</init> <condition><expr><operator>*</operator><name>name</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>name</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>name</name> <operator>==</operator> <literal type="char">'?'</literal> <operator>||</operator> <operator>*</operator><name>name</name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>True</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
<return>return <expr><name>False</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BZ_N_SUFFIX_PAIRS</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>const</specifier> <name>Char</name><modifier>*</modifier></type> <name><name>zSuffix</name><index>[<expr><name>BZ_N_SUFFIX_PAIRS</name></expr>]</index></name>
<init>= <expr><block>{ <expr><literal type="string">".bz2"</literal></expr>, <expr><literal type="string">".bz"</literal></expr>, <expr><literal type="string">".tbz2"</literal></expr>, <expr><literal type="string">".tbz"</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Char</name><modifier>*</modifier></type> <name><name>unzSuffix</name><index>[<expr><name>BZ_N_SUFFIX_PAIRS</name></expr>]</index></name>
<init>= <expr><block>{ <expr><literal type="string">""</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">".tar"</literal></expr>, <expr><literal type="string">".tar"</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier>
<name>Bool</name></type> <name>hasSuffix</name> <parameter_list>( <parameter><decl><type><name>Char</name><modifier>*</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Char</name><modifier>*</modifier></type> <name>suffix</name></decl></parameter> )</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Int32</name></type> <name>ns</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Int32</name></type> <name>nx</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>suffix</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ns</name> <operator>&lt;</operator> <name>nx</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>False</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>s</name> <operator>+</operator> <name>ns</name> <operator>-</operator> <name>nx</name></expr></argument>, <argument><expr><name>suffix</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>True</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>False</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier>
<name>Bool</name></type> <name>mapSuffix</name> <parameter_list>( <parameter><decl><type><name>Char</name><modifier>*</modifier></type> <name>name</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Char</name><modifier>*</modifier></type> <name>oldSuffix</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Char</name><modifier>*</modifier></type> <name>newSuffix</name></decl></parameter> )</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasSuffix</name><argument_list>(<argument><expr><name>name</name></expr></argument>,<argument><expr><name>oldSuffix</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>False</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>name</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>-</operator><call><name>strlen</name><argument_list>(<argument><expr><name>oldSuffix</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strcat</name> <argument_list>( <argument><expr><name>name</name></expr></argument>, <argument><expr><name>newSuffix</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>True</name></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier>
<name>void</name></type> <name>compress</name> <parameter_list>( <parameter><decl><type><name>Char</name> <modifier>*</modifier></type><name>name</name></decl></parameter> )</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>inStr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>outStr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Int32</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>MY_STAT</name></name></type> <name>statBuf</name></decl>;</decl_stmt>

<expr_stmt><expr><name>deleteOutputOnInterrupt</name> <operator>=</operator> <name>False</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>name</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>srcMode</name> <operator>!=</operator> <name>SM_I2O</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>panic</name> <argument_list>( <argument><expr><literal type="string">"compress: bad modes\n"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name>srcMode</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>SM_I2O</name></expr>:</case>
<expr_stmt><expr><call><name>copyFileName</name> <argument_list>( <argument><expr><name>inName</name></expr></argument>, <argument><expr><operator>(</operator><name>Char</name><operator>*</operator><operator>)</operator><literal type="string">"(stdin)"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>copyFileName</name> <argument_list>( <argument><expr><name>outName</name></expr></argument>, <argument><expr><operator>(</operator><name>Char</name><operator>*</operator><operator>)</operator><literal type="string">"(stdout)"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>SM_F2F</name></expr>:</case>
<expr_stmt><expr><call><name>copyFileName</name> <argument_list>( <argument><expr><name>inName</name></expr></argument>, <argument><expr><name>name</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>copyFileName</name> <argument_list>( <argument><expr><name>outName</name></expr></argument>, <argument><expr><name>name</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strcat</name> <argument_list>( <argument><expr><name>outName</name></expr></argument>, <argument><expr><literal type="string">".bz2"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>SM_F2O</name></expr>:</case>
<expr_stmt><expr><call><name>copyFileName</name> <argument_list>( <argument><expr><name>inName</name></expr></argument>, <argument><expr><name>name</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>copyFileName</name> <argument_list>( <argument><expr><name>outName</name></expr></argument>, <argument><expr><operator>(</operator><name>Char</name><operator>*</operator><operator>)</operator><literal type="string">"(stdout)"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>

<if_stmt><if>if <condition>( <expr><name>srcMode</name> <operator>!=</operator> <name>SM_I2O</name> <operator>&amp;&amp;</operator> <call><name>containsDubiousChars</name> <argument_list>( <argument><expr><name>inName</name></expr></argument> )</argument_list></call></expr> )</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>noisy</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: There are no files matching `%s'.\n"</literal></expr></argument>,
<argument><expr><name>progName</name></expr></argument>, <argument><expr><name>inName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>setExit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>( <expr><name>srcMode</name> <operator>!=</operator> <name>SM_I2O</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>fileExists</name> <argument_list>( <argument><expr><name>inName</name></expr></argument> )</argument_list></call></expr> )</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: Can't open input file %s: %s.\n"</literal></expr></argument>,
<argument><expr><name>progName</name></expr></argument>, <argument><expr><name>inName</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setExit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>BZ_N_SUFFIX_PAIRS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>hasSuffix</name><argument_list>(<argument><expr><name>inName</name></expr></argument>, <argument><expr><name><name>zSuffix</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>noisy</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"%s: Input file %s already has %s suffix.\n"</literal></expr></argument>,
<argument><expr><name>progName</name></expr></argument>, <argument><expr><name>inName</name></expr></argument>, <argument><expr><name><name>zSuffix</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>setExit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>( <expr><name>srcMode</name> <operator>==</operator> <name>SM_F2F</name> <operator>||</operator> <name>srcMode</name> <operator>==</operator> <name>SM_F2O</name></expr> )</condition> <block>{<block_content>
<expr_stmt><expr><call><name>MY_STAT</name><argument_list>(<argument><expr><name>inName</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>( <expr><call><name>MY_S_ISDIR</name><argument_list>(<argument><expr><name><name>statBuf</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr> )</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>( <argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"%s: Input file %s is a directory.\n"</literal></expr></argument>,
<argument><expr><name>progName</name></expr></argument>,<argument><expr><name>inName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setExit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>( <expr><name>srcMode</name> <operator>==</operator> <name>SM_F2F</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>forceOverwrite</name> <operator>&amp;&amp;</operator> <call><name>notAStandardFile</name> <argument_list>( <argument><expr><name>inName</name></expr></argument> )</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>noisy</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: Input file %s is not a normal file.\n"</literal></expr></argument>,
<argument><expr><name>progName</name></expr></argument>, <argument><expr><name>inName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>setExit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>( <expr><name>srcMode</name> <operator>==</operator> <name>SM_F2F</name> <operator>&amp;&amp;</operator> <call><name>fileExists</name> <argument_list>( <argument><expr><name>outName</name></expr></argument> )</argument_list></call></expr> )</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>forceOverwrite</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>remove</name><argument_list>(<argument><expr><name>outName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: Output file %s already exists.\n"</literal></expr></argument>,
<argument><expr><name>progName</name></expr></argument>, <argument><expr><name>outName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setExit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>( <expr><name>srcMode</name> <operator>==</operator> <name>SM_F2F</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>forceOverwrite</name> <operator>&amp;&amp;</operator>
<operator>(</operator><name>n</name><operator>=</operator><call><name>countHardLinks</name> <argument_list>( <argument><expr><name>inName</name></expr></argument> )</argument_list></call><operator>)</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: Input file %s has %d other link%s.\n"</literal></expr></argument>,
<argument><expr><name>progName</name></expr></argument>, <argument><expr><name>inName</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><ternary><condition><expr><name>n</name> <operator>&gt;</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><literal type="string">"s"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setExit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>( <expr><name>srcMode</name> <operator>==</operator> <name>SM_F2F</name></expr> )</condition> <block>{<block_content>


<expr_stmt><expr><call><name>saveInputFileMetaInfo</name> <argument_list>( <argument><expr><name>inName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<switch>switch <condition>( <expr><name>srcMode</name></expr> )</condition> <block>{<block_content>

<case>case <expr><name>SM_I2O</name></expr>:</case>
<expr_stmt><expr><name>inStr</name> <operator>=</operator> <name>stdin</name></expr>;</expr_stmt>
<expr_stmt><expr><name>outStr</name> <operator>=</operator> <name>stdout</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>( <expr><call><name>isatty</name> <argument_list>( <argument><expr><call><name>fileno</name> <argument_list>( <argument><expr><name>stdout</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr> )</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"%s: I won't write compressed data to a terminal.\n"</literal></expr></argument>,
<argument><expr><name>progName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: For help, type: `%s --help'.\n"</literal></expr></argument>,
<argument><expr><name>progName</name></expr></argument>, <argument><expr><name>progName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setExit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt><empty_stmt>;</empty_stmt>
<break>break;</break>

<case>case <expr><name>SM_F2O</name></expr>:</case>
<expr_stmt><expr><name>inStr</name> <operator>=</operator> <call><name>fopen</name> <argument_list>( <argument><expr><name>inName</name></expr></argument>, <argument><expr><literal type="string">"rb"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>outStr</name> <operator>=</operator> <name>stdout</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>( <expr><call><name>isatty</name> <argument_list>( <argument><expr><call><name>fileno</name> <argument_list>( <argument><expr><name>stdout</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr> )</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"%s: I won't write compressed data to a terminal.\n"</literal></expr></argument>,
<argument><expr><name>progName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: For help, type: `%s --help'.\n"</literal></expr></argument>,
<argument><expr><name>progName</name></expr></argument>, <argument><expr><name>progName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>( <expr><name>inStr</name> <operator>!=</operator> <name>NULL</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fclose</name> <argument_list>( <argument><expr><name>inStr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>setExit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt><empty_stmt>;</empty_stmt>
<if_stmt><if>if <condition>( <expr><name>inStr</name> <operator>==</operator> <name>NULL</name></expr> )</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: Can't open input file %s: %s.\n"</literal></expr></argument>,
<argument><expr><name>progName</name></expr></argument>, <argument><expr><name>inName</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setExit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt><empty_stmt>;</empty_stmt>
<break>break;</break>

<case>case <expr><name>SM_F2F</name></expr>:</case>
<expr_stmt><expr><name>inStr</name> <operator>=</operator> <call><name>fopen</name> <argument_list>( <argument><expr><name>inName</name></expr></argument>, <argument><expr><literal type="string">"rb"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>outStr</name> <operator>=</operator> <call><name>fopen_output_safely</name> <argument_list>( <argument><expr><name>outName</name></expr></argument>, <argument><expr><literal type="string">"wb"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>( <expr><name>outStr</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: Can't create output file %s: %s.\n"</literal></expr></argument>,
<argument><expr><name>progName</name></expr></argument>, <argument><expr><name>outName</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>( <expr><name>inStr</name> <operator>!=</operator> <name>NULL</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fclose</name> <argument_list>( <argument><expr><name>inStr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>setExit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>( <expr><name>inStr</name> <operator>==</operator> <name>NULL</name></expr> )</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: Can't open input file %s: %s.\n"</literal></expr></argument>,
<argument><expr><name>progName</name></expr></argument>, <argument><expr><name>inName</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>( <expr><name>outStr</name> <operator>!=</operator> <name>NULL</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fclose</name> <argument_list>( <argument><expr><name>outStr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>setExit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt><empty_stmt>;</empty_stmt>
<break>break;</break>

<default>default:</default>
<expr_stmt><expr><call><name>panic</name> <argument_list>( <argument><expr><literal type="string">"compress: bad srcMode"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>verbosity</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">" %s: "</literal></expr></argument>, <argument><expr><name>inName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pad</name> <argument_list>( <argument><expr><name>inName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fflush</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>outputHandleJustInCase</name> <operator>=</operator> <name>outStr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>deleteOutputOnInterrupt</name> <operator>=</operator> <name>True</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compressStream</name> <argument_list>( <argument><expr><name>inStr</name></expr></argument>, <argument><expr><name>outStr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>outputHandleJustInCase</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>


<if_stmt><if>if <condition>( <expr><name>srcMode</name> <operator>==</operator> <name>SM_F2F</name></expr> )</condition> <block>{<block_content>
<expr_stmt><expr><call><name>applySavedTimeInfoToOutputFile</name> <argument_list>( <argument><expr><name>outName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>deleteOutputOnInterrupt</name> <operator>=</operator> <name>False</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>( <expr><operator>!</operator><name>keepInputFiles</name></expr> )</condition> <block>{<block_content>
<decl_stmt><decl><type><name>IntNative</name></type> <name>retVal</name> <init>= <expr><call><name>remove</name> <argument_list>( <argument><expr><name>inName</name></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ERROR_IF_NOT_ZERO</name> <argument_list>( <argument><expr><name>retVal</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>deleteOutputOnInterrupt</name> <operator>=</operator> <name>False</name></expr>;</expr_stmt>
</block_content>}</block></function>



<function><type><specifier>static</specifier>
<name>void</name></type> <name>uncompress</name> <parameter_list>( <parameter><decl><type><name>Char</name> <modifier>*</modifier></type><name>name</name></decl></parameter> )</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>inStr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>outStr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Int32</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Bool</name></type> <name>magicNumberOK</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Bool</name></type> <name>cantGuess</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>MY_STAT</name></name></type> <name>statBuf</name></decl>;</decl_stmt>

<expr_stmt><expr><name>deleteOutputOnInterrupt</name> <operator>=</operator> <name>False</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>name</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>srcMode</name> <operator>!=</operator> <name>SM_I2O</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>panic</name> <argument_list>( <argument><expr><literal type="string">"uncompress: bad modes\n"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>cantGuess</name> <operator>=</operator> <name>False</name></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>srcMode</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>SM_I2O</name></expr>:</case>
<expr_stmt><expr><call><name>copyFileName</name> <argument_list>( <argument><expr><name>inName</name></expr></argument>, <argument><expr><operator>(</operator><name>Char</name><operator>*</operator><operator>)</operator><literal type="string">"(stdin)"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>copyFileName</name> <argument_list>( <argument><expr><name>outName</name></expr></argument>, <argument><expr><operator>(</operator><name>Char</name><operator>*</operator><operator>)</operator><literal type="string">"(stdout)"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>SM_F2F</name></expr>:</case>
<expr_stmt><expr><call><name>copyFileName</name> <argument_list>( <argument><expr><name>inName</name></expr></argument>, <argument><expr><name>name</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>copyFileName</name> <argument_list>( <argument><expr><name>outName</name></expr></argument>, <argument><expr><name>name</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>BZ_N_SUFFIX_PAIRS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name>mapSuffix</name><argument_list>(<argument><expr><name>outName</name></expr></argument>,<argument><expr><name><name>zSuffix</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><name><name>unzSuffix</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>zzz</name>;</goto></block_content></block></if></if_stmt></block_content></block></for>
<expr_stmt><expr><name>cantGuess</name> <operator>=</operator> <name>True</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strcat</name> <argument_list>( <argument><expr><name>outName</name></expr></argument>, <argument><expr><literal type="string">".out"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>SM_F2O</name></expr>:</case>
<expr_stmt><expr><call><name>copyFileName</name> <argument_list>( <argument><expr><name>inName</name></expr></argument>, <argument><expr><name>name</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>copyFileName</name> <argument_list>( <argument><expr><name>outName</name></expr></argument>, <argument><expr><operator>(</operator><name>Char</name><operator>*</operator><operator>)</operator><literal type="string">"(stdout)"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>

<label><name>zzz</name>:</label>
<if_stmt><if>if <condition>( <expr><name>srcMode</name> <operator>!=</operator> <name>SM_I2O</name> <operator>&amp;&amp;</operator> <call><name>containsDubiousChars</name> <argument_list>( <argument><expr><name>inName</name></expr></argument> )</argument_list></call></expr> )</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>noisy</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: There are no files matching `%s'.\n"</literal></expr></argument>,
<argument><expr><name>progName</name></expr></argument>, <argument><expr><name>inName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>setExit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>( <expr><name>srcMode</name> <operator>!=</operator> <name>SM_I2O</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>fileExists</name> <argument_list>( <argument><expr><name>inName</name></expr></argument> )</argument_list></call></expr> )</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: Can't open input file %s: %s.\n"</literal></expr></argument>,
<argument><expr><name>progName</name></expr></argument>, <argument><expr><name>inName</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setExit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>( <expr><name>srcMode</name> <operator>==</operator> <name>SM_F2F</name> <operator>||</operator> <name>srcMode</name> <operator>==</operator> <name>SM_F2O</name></expr> )</condition> <block>{<block_content>
<expr_stmt><expr><call><name>MY_STAT</name><argument_list>(<argument><expr><name>inName</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>( <expr><call><name>MY_S_ISDIR</name><argument_list>(<argument><expr><name><name>statBuf</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr> )</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>( <argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"%s: Input file %s is a directory.\n"</literal></expr></argument>,
<argument><expr><name>progName</name></expr></argument>,<argument><expr><name>inName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setExit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>( <expr><name>srcMode</name> <operator>==</operator> <name>SM_F2F</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>forceOverwrite</name> <operator>&amp;&amp;</operator> <call><name>notAStandardFile</name> <argument_list>( <argument><expr><name>inName</name></expr></argument> )</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>noisy</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: Input file %s is not a normal file.\n"</literal></expr></argument>,
<argument><expr><name>progName</name></expr></argument>, <argument><expr><name>inName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>setExit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>( <expr><name>cantGuess</name></expr> )</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>noisy</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"%s: Can't guess original name for %s -- using %s\n"</literal></expr></argument>,
<argument><expr><name>progName</name></expr></argument>, <argument><expr><name>inName</name></expr></argument>, <argument><expr><name>outName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>( <expr><name>srcMode</name> <operator>==</operator> <name>SM_F2F</name> <operator>&amp;&amp;</operator> <call><name>fileExists</name> <argument_list>( <argument><expr><name>outName</name></expr></argument> )</argument_list></call></expr> )</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>forceOverwrite</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>remove</name><argument_list>(<argument><expr><name>outName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: Output file %s already exists.\n"</literal></expr></argument>,
<argument><expr><name>progName</name></expr></argument>, <argument><expr><name>outName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setExit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>( <expr><name>srcMode</name> <operator>==</operator> <name>SM_F2F</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>forceOverwrite</name> <operator>&amp;&amp;</operator>
<operator>(</operator><name>n</name><operator>=</operator><call><name>countHardLinks</name> <argument_list>( <argument><expr><name>inName</name></expr></argument> )</argument_list></call> <operator>)</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: Input file %s has %d other link%s.\n"</literal></expr></argument>,
<argument><expr><name>progName</name></expr></argument>, <argument><expr><name>inName</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><ternary><condition><expr><name>n</name> <operator>&gt;</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><literal type="string">"s"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setExit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>( <expr><name>srcMode</name> <operator>==</operator> <name>SM_F2F</name></expr> )</condition> <block>{<block_content>


<expr_stmt><expr><call><name>saveInputFileMetaInfo</name> <argument_list>( <argument><expr><name>inName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<switch>switch <condition>( <expr><name>srcMode</name></expr> )</condition> <block>{<block_content>

<case>case <expr><name>SM_I2O</name></expr>:</case>
<expr_stmt><expr><name>inStr</name> <operator>=</operator> <name>stdin</name></expr>;</expr_stmt>
<expr_stmt><expr><name>outStr</name> <operator>=</operator> <name>stdout</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>( <expr><call><name>isatty</name> <argument_list>( <argument><expr><call><name>fileno</name> <argument_list>( <argument><expr><name>stdin</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr> )</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"%s: I won't read compressed data from a terminal.\n"</literal></expr></argument>,
<argument><expr><name>progName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: For help, type: `%s --help'.\n"</literal></expr></argument>,
<argument><expr><name>progName</name></expr></argument>, <argument><expr><name>progName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setExit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt><empty_stmt>;</empty_stmt>
<break>break;</break>

<case>case <expr><name>SM_F2O</name></expr>:</case>
<expr_stmt><expr><name>inStr</name> <operator>=</operator> <call><name>fopen</name> <argument_list>( <argument><expr><name>inName</name></expr></argument>, <argument><expr><literal type="string">"rb"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>outStr</name> <operator>=</operator> <name>stdout</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>( <expr><name>inStr</name> <operator>==</operator> <name>NULL</name></expr> )</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: Can't open input file %s:%s.\n"</literal></expr></argument>,
<argument><expr><name>progName</name></expr></argument>, <argument><expr><name>inName</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>( <expr><name>inStr</name> <operator>!=</operator> <name>NULL</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fclose</name> <argument_list>( <argument><expr><name>inStr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>setExit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt><empty_stmt>;</empty_stmt>
<break>break;</break>

<case>case <expr><name>SM_F2F</name></expr>:</case>
<expr_stmt><expr><name>inStr</name> <operator>=</operator> <call><name>fopen</name> <argument_list>( <argument><expr><name>inName</name></expr></argument>, <argument><expr><literal type="string">"rb"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>outStr</name> <operator>=</operator> <call><name>fopen_output_safely</name> <argument_list>( <argument><expr><name>outName</name></expr></argument>, <argument><expr><literal type="string">"wb"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>( <expr><name>outStr</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: Can't create output file %s: %s.\n"</literal></expr></argument>,
<argument><expr><name>progName</name></expr></argument>, <argument><expr><name>outName</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>( <expr><name>inStr</name> <operator>!=</operator> <name>NULL</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fclose</name> <argument_list>( <argument><expr><name>inStr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>setExit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>( <expr><name>inStr</name> <operator>==</operator> <name>NULL</name></expr> )</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: Can't open input file %s: %s.\n"</literal></expr></argument>,
<argument><expr><name>progName</name></expr></argument>, <argument><expr><name>inName</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>( <expr><name>outStr</name> <operator>!=</operator> <name>NULL</name></expr> )</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fclose</name> <argument_list>( <argument><expr><name>outStr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>setExit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt><empty_stmt>;</empty_stmt>
<break>break;</break>

<default>default:</default>
<expr_stmt><expr><call><name>panic</name> <argument_list>( <argument><expr><literal type="string">"uncompress: bad srcMode"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>verbosity</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">" %s: "</literal></expr></argument>, <argument><expr><name>inName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pad</name> <argument_list>( <argument><expr><name>inName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fflush</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>outputHandleJustInCase</name> <operator>=</operator> <name>outStr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>deleteOutputOnInterrupt</name> <operator>=</operator> <name>True</name></expr>;</expr_stmt>
<expr_stmt><expr><name>magicNumberOK</name> <operator>=</operator> <call><name>uncompressStream</name> <argument_list>( <argument><expr><name>inStr</name></expr></argument>, <argument><expr><name>outStr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>outputHandleJustInCase</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>


<if_stmt><if>if <condition>( <expr><name>magicNumberOK</name></expr> )</condition> <block>{<block_content>
<if_stmt><if>if <condition>( <expr><name>srcMode</name> <operator>==</operator> <name>SM_F2F</name></expr> )</condition> <block>{<block_content>
<expr_stmt><expr><call><name>applySavedTimeInfoToOutputFile</name> <argument_list>( <argument><expr><name>outName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>deleteOutputOnInterrupt</name> <operator>=</operator> <name>False</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>( <expr><operator>!</operator><name>keepInputFiles</name></expr> )</condition> <block>{<block_content>
<decl_stmt><decl><type><name>IntNative</name></type> <name>retVal</name> <init>= <expr><call><name>remove</name> <argument_list>( <argument><expr><name>inName</name></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ERROR_IF_NOT_ZERO</name> <argument_list>( <argument><expr><name>retVal</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>unzFailsExist</name> <operator>=</operator> <name>True</name></expr>;</expr_stmt>
<expr_stmt><expr><name>deleteOutputOnInterrupt</name> <operator>=</operator> <name>False</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>( <expr><name>srcMode</name> <operator>==</operator> <name>SM_F2F</name></expr> )</condition> <block>{<block_content>
<decl_stmt><decl><type><name>IntNative</name></type> <name>retVal</name> <init>= <expr><call><name>remove</name> <argument_list>( <argument><expr><name>outName</name></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ERROR_IF_NOT_ZERO</name> <argument_list>( <argument><expr><name>retVal</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>deleteOutputOnInterrupt</name> <operator>=</operator> <name>False</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>( <expr><name>magicNumberOK</name></expr> )</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>verbosity</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"done\n"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>setExit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>verbosity</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"not a bzip2 file.\n"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"%s: %s is not a bzip2 file.\n"</literal></expr></argument>,
<argument><expr><name>progName</name></expr></argument>, <argument><expr><name>inName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></else></if_stmt>

</block_content>}</block></function>



<function><type><specifier>static</specifier>
<name>void</name></type> <name>testf</name> <parameter_list>( <parameter><decl><type><name>Char</name> <modifier>*</modifier></type><name>name</name></decl></parameter> )</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>inStr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Bool</name></type> <name>allOK</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>MY_STAT</name></name></type> <name>statBuf</name></decl>;</decl_stmt>

<expr_stmt><expr><name>deleteOutputOnInterrupt</name> <operator>=</operator> <name>False</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>name</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>srcMode</name> <operator>!=</operator> <name>SM_I2O</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>panic</name> <argument_list>( <argument><expr><literal type="string">"testf: bad modes\n"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>copyFileName</name> <argument_list>( <argument><expr><name>outName</name></expr></argument>, <argument><expr><operator>(</operator><name>Char</name><operator>*</operator><operator>)</operator><literal type="string">"(none)"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>srcMode</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>SM_I2O</name></expr>:</case> <expr_stmt><expr><call><name>copyFileName</name> <argument_list>( <argument><expr><name>inName</name></expr></argument>, <argument><expr><operator>(</operator><name>Char</name><operator>*</operator><operator>)</operator><literal type="string">"(stdin)"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>SM_F2F</name></expr>:</case> <expr_stmt><expr><call><name>copyFileName</name> <argument_list>( <argument><expr><name>inName</name></expr></argument>, <argument><expr><name>name</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>SM_F2O</name></expr>:</case> <expr_stmt><expr><call><name>copyFileName</name> <argument_list>( <argument><expr><name>inName</name></expr></argument>, <argument><expr><name>name</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <break>break;</break>
</block_content>}</block></switch>

<if_stmt><if>if <condition>( <expr><name>srcMode</name> <operator>!=</operator> <name>SM_I2O</name> <operator>&amp;&amp;</operator> <call><name>containsDubiousChars</name> <argument_list>( <argument><expr><name>inName</name></expr></argument> )</argument_list></call></expr> )</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>noisy</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: There are no files matching `%s'.\n"</literal></expr></argument>,
<argument><expr><name>progName</name></expr></argument>, <argument><expr><name>inName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>setExit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>( <expr><name>srcMode</name> <operator>!=</operator> <name>SM_I2O</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>fileExists</name> <argument_list>( <argument><expr><name>inName</name></expr></argument> )</argument_list></call></expr> )</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: Can't open input %s: %s.\n"</literal></expr></argument>,
<argument><expr><name>progName</name></expr></argument>, <argument><expr><name>inName</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setExit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>( <expr><name>srcMode</name> <operator>!=</operator> <name>SM_I2O</name></expr> )</condition> <block>{<block_content>
<expr_stmt><expr><call><name>MY_STAT</name><argument_list>(<argument><expr><name>inName</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>( <expr><call><name>MY_S_ISDIR</name><argument_list>(<argument><expr><name><name>statBuf</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr> )</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>( <argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"%s: Input file %s is a directory.\n"</literal></expr></argument>,
<argument><expr><name>progName</name></expr></argument>,<argument><expr><name>inName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setExit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<switch>switch <condition>( <expr><name>srcMode</name></expr> )</condition> <block>{<block_content>

<case>case <expr><name>SM_I2O</name></expr>:</case>
<if_stmt><if>if <condition>( <expr><call><name>isatty</name> <argument_list>( <argument><expr><call><name>fileno</name> <argument_list>( <argument><expr><name>stdin</name></expr></argument> )</argument_list></call></expr></argument> )</argument_list></call></expr> )</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"%s: I won't read compressed data from a terminal.\n"</literal></expr></argument>,
<argument><expr><name>progName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: For help, type: `%s --help'.\n"</literal></expr></argument>,
<argument><expr><name>progName</name></expr></argument>, <argument><expr><name>progName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setExit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt><empty_stmt>;</empty_stmt>
<expr_stmt><expr><name>inStr</name> <operator>=</operator> <name>stdin</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>SM_F2O</name></expr>:</case> <case>case <expr><name>SM_F2F</name></expr>:</case>
<expr_stmt><expr><name>inStr</name> <operator>=</operator> <call><name>fopen</name> <argument_list>( <argument><expr><name>inName</name></expr></argument>, <argument><expr><literal type="string">"rb"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>( <expr><name>inStr</name> <operator>==</operator> <name>NULL</name></expr> )</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: Can't open input file %s:%s.\n"</literal></expr></argument>,
<argument><expr><name>progName</name></expr></argument>, <argument><expr><name>inName</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setExit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt><empty_stmt>;</empty_stmt>
<break>break;</break>

<default>default:</default>
<expr_stmt><expr><call><name>panic</name> <argument_list>( <argument><expr><literal type="string">"testf: bad srcMode"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>verbosity</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">" %s: "</literal></expr></argument>, <argument><expr><name>inName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pad</name> <argument_list>( <argument><expr><name>inName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fflush</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>outputHandleJustInCase</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>allOK</name> <operator>=</operator> <call><name>testStream</name> <argument_list>( <argument><expr><name>inStr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>allOK</name> <operator>&amp;&amp;</operator> <name>verbosity</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"ok\n"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>allOK</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>testFailsExist</name> <operator>=</operator> <name>True</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>



<function><type><specifier>static</specifier>
<name>void</name></type> <name>license</name> <parameter_list>( <parameter><decl><type><name>void</name></type></decl></parameter> )</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>,

<argument><expr><literal type="string">"bzip2, a block-sorting file compressor. "</literal>
<literal type="string">"Version %s.\n"</literal>
<literal type="string">" \n"</literal>
<literal type="string">" Copyright (C) 1996-2019 by Julian Seward.\n"</literal>
<literal type="string">" \n"</literal>
<literal type="string">" This program is free software; you can redistribute it and/or modify\n"</literal>
<literal type="string">" it under the terms set out in the LICENSE file, which is included\n"</literal>
<literal type="string">" in the bzip2 source distribution.\n"</literal>
<literal type="string">" \n"</literal>
<literal type="string">" This program is distributed in the hope that it will be useful,\n"</literal>
<literal type="string">" but WITHOUT ANY WARRANTY; without even the implied warranty of\n"</literal>
<literal type="string">" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n"</literal>
<literal type="string">" LICENSE file for more details.\n"</literal>
<literal type="string">" \n"</literal></expr></argument>,
<argument><expr><call><name>BZ2_bzlibVersion</name><argument_list>()</argument_list></call></expr></argument>
)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<function><type><specifier>static</specifier>
<name>void</name></type> <name>usage</name> <parameter_list>( <parameter><decl><type><name>Char</name> <modifier>*</modifier></type><name>fullProgName</name></decl></parameter> )</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>(
<argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"bzip2, a block-sorting file compressor. "</literal>
<literal type="string">"Version %s.\n"</literal>
<literal type="string">"\n usage: %s [flags and input files in any order]\n"</literal>
<literal type="string">"\n"</literal>
<literal type="string">" -h --help print this message\n"</literal>
<literal type="string">" -d --decompress force decompression\n"</literal>
<literal type="string">" -z --compress force compression\n"</literal>
<literal type="string">" -k --keep keep (don't delete) input files\n"</literal>
<literal type="string">" -f --force overwrite existing output files\n"</literal>
<literal type="string">" -t --test test compressed file integrity\n"</literal>
<literal type="string">" -c --stdout output to standard out\n"</literal>
<literal type="string">" -q --quiet suppress noncritical error messages\n"</literal>
<literal type="string">" -v --verbose be verbose (a 2nd -v gives more)\n"</literal>
<literal type="string">" -L --license display software version &amp; license\n"</literal>
<literal type="string">" -V --version display software version &amp; license\n"</literal>
<literal type="string">" -s --small use less memory (at most 2500k)\n"</literal>
<literal type="string">" -1 .. -9 set block size to 100k .. 900k\n"</literal>
<literal type="string">" --fast alias for -1\n"</literal>
<literal type="string">" --best alias for -9\n"</literal>
<literal type="string">"\n"</literal>
<literal type="string">" If invoked as `bzip2', default action is to compress.\n"</literal>
<literal type="string">" as `bunzip2', default action is to decompress.\n"</literal>
<literal type="string">" as `bzcat', default action is to decompress to stdout.\n"</literal>
<literal type="string">"\n"</literal>
<literal type="string">" If no file names are given, bzip2 compresses or decompresses\n"</literal>
<literal type="string">" from standard input to standard output. You can combine\n"</literal>
<literal type="string">" short flags, so `-v -4' means the same as -v4 or -4v, &amp;c.\n"</literal>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BZ_UNIX</name></expr></cpp:if>
<literal type="string">"\n"</literal></expr></argument>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
,

<argument><expr><call><name>BZ2_bzlibVersion</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>fullProgName</name></expr></argument>
)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<function><type><specifier>static</specifier>
<name>void</name></type> <name>redundant</name> <parameter_list>( <parameter><decl><type><name>Char</name><modifier>*</modifier></type> <name>flag</name></decl></parameter> )</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>(
<argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"%s: %s is redundant in versions 0.9.5 and above\n"</literal></expr></argument>,
<argument><expr><name>progName</name></expr></argument>, <argument><expr><name>flag</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

















<typedef>typedef
<type><struct>struct <name>zzzz</name> <block>{
<decl_stmt><decl><type><name>Char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>zzzz</name></name> <modifier>*</modifier></type><name>link</name></decl>;</decl_stmt>
}</block></struct></type>
<name>Cell</name>;</typedef>



<function><type><specifier>static</specifier>
<name>void</name> <modifier>*</modifier></type><name>myMalloc</name> <parameter_list>( <parameter><decl><type><name>Int32</name></type> <name>n</name></decl></parameter> )</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>p</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>malloc</name> <argument_list>( <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>n</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>outOfMemory</name> <argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier>
<name>Cell</name> <modifier>*</modifier></type><name>mkCell</name> <parameter_list>( <parameter><decl><type><name>void</name></type></decl></parameter> )</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Cell</name> <modifier>*</modifier></type><name>c</name></decl>;</decl_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>Cell</name><operator>*</operator><operator>)</operator> <call><name>myMalloc</name> <argument_list>( <argument><expr><sizeof>sizeof <argument_list>( <argument><expr><name>Cell</name></expr></argument> )</argument_list></sizeof></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>link</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><name>c</name></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier>
<name>Cell</name> <modifier>*</modifier></type><name>snocString</name> <parameter_list>( <parameter><decl><type><name>Cell</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Char</name> <modifier>*</modifier></type><name>name</name></decl></parameter> )</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>root</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>Cell</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><call><name>mkCell</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <operator>(</operator><name>Char</name><operator>*</operator><operator>)</operator> <call><name>myMalloc</name> <argument_list>( <argument><expr><literal type="number">5</literal> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strcpy</name> <argument_list>( <argument><expr><name><name>tmp</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>tmp</name></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>Cell</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><name>root</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name><name>tmp</name><operator>-&gt;</operator><name>link</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>tmp</name> <operator>=</operator> <name><name>tmp</name><operator>-&gt;</operator><name>link</name></name></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>link</name></name> <operator>=</operator> <call><name>snocString</name> <argument_list>( <argument><expr><name><name>tmp</name><operator>-&gt;</operator><name>link</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>root</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>



<function><type><specifier>static</specifier>
<name>void</name></type> <name>addFlagsFromEnvVar</name> <parameter_list>( <parameter><decl><type><name>Cell</name><modifier>*</modifier><modifier>*</modifier></type> <name>argList</name></decl></parameter>, <parameter><decl><type><name>Char</name><modifier>*</modifier></type> <name>varName</name></decl></parameter> )</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Int32</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Char</name> <modifier>*</modifier></type><name>envbase</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<expr_stmt><expr><name>envbase</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><name>varName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>envbase</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>envbase</name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name>True</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>Int32</name><operator>)</operator><operator>(</operator><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<while>while <condition>(<expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>Int32</name><operator>)</operator><operator>(</operator><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>k</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt> <if_stmt><if>if <condition>(<expr><name>k</name> <operator>&gt;</operator> <name>FILE_NAME_LEN</name><operator>-</operator><literal type="number">10</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>k</name> <operator>=</operator> <name>FILE_NAME_LEN</name><operator>-</operator><literal type="number">10</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>k</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>tmpName</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>p</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><name><name>tmpName</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>APPEND_FLAG</name><argument_list>(<argument><expr><operator>*</operator><name>argList</name></expr></argument>, <argument><expr><name>tmpName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISFLAG</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(strcmp(aa-&gt;name, (s))==0)</cpp:value></cpp:define>

<function><type><name>IntNative</name></type> <name>main</name> <parameter_list>( <parameter><decl><type><name>IntNative</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>Char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter> )</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Int32</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Char</name> <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Cell</name> <modifier>*</modifier></type><name>argList</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Cell</name> <modifier>*</modifier></type><name>aa</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Bool</name></type> <name>decode</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><sizeof>sizeof<argument_list>(<argument><expr><name>Int32</name></expr></argument>)</argument_list></sizeof> <operator>!=</operator> <literal type="number">4</literal> <operator>||</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>UInt32</name></expr></argument>)</argument_list></sizeof> <operator>!=</operator> <literal type="number">4</literal> <operator>||</operator>
<sizeof>sizeof<argument_list>(<argument><expr><name>Int16</name></expr></argument>)</argument_list></sizeof> <operator>!=</operator> <literal type="number">2</literal> <operator>||</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>UInt16</name></expr></argument>)</argument_list></sizeof> <operator>!=</operator> <literal type="number">2</literal> <operator>||</operator>
<sizeof>sizeof<argument_list>(<argument><expr><name>Char</name></expr></argument>)</argument_list></sizeof> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>UChar</name></expr></argument>)</argument_list></sizeof> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>configError</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><name>outputHandleJustInCase</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>smallMode</name> <operator>=</operator> <name>False</name></expr>;</expr_stmt>
<expr_stmt><expr><name>keepInputFiles</name> <operator>=</operator> <name>False</name></expr>;</expr_stmt>
<expr_stmt><expr><name>forceOverwrite</name> <operator>=</operator> <name>False</name></expr>;</expr_stmt>
<expr_stmt><expr><name>noisy</name> <operator>=</operator> <name>True</name></expr>;</expr_stmt>
<expr_stmt><expr><name>verbosity</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>blockSize100k</name> <operator>=</operator> <literal type="number">9</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>testFailsExist</name> <operator>=</operator> <name>False</name></expr>;</expr_stmt>
<expr_stmt><expr><name>unzFailsExist</name> <operator>=</operator> <name>False</name></expr>;</expr_stmt>
<expr_stmt><expr><name>numFileNames</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>numFilesProcessed</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>workFactor</name> <operator>=</operator> <literal type="number">30</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>deleteOutputOnInterrupt</name> <operator>=</operator> <name>False</name></expr>;</expr_stmt>
<expr_stmt><expr><name>exitValue</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>


<expr_stmt><expr><call><name>signal</name> <argument_list>(<argument><expr><name>SIGSEGV</name></expr></argument>, <argument><expr><name>mySIGSEGVorSIGBUScatcher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BZ_UNIX</name></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__DJGPP__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>signal</name> <argument_list>(<argument><expr><name>SIGBUS</name></expr></argument>, <argument><expr><name>mySIGSEGVorSIGBUScatcher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>copyFileName</name> <argument_list>( <argument><expr><name>inName</name></expr></argument>, <argument><expr><operator>(</operator><name>Char</name><operator>*</operator><operator>)</operator><literal type="string">"(none)"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>copyFileName</name> <argument_list>( <argument><expr><name>outName</name></expr></argument>, <argument><expr><operator>(</operator><name>Char</name><operator>*</operator><operator>)</operator><literal type="string">"(none)"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>copyFileName</name> <argument_list>( <argument><expr><name>progNameReally</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>progName</name> <operator>=</operator> <operator>&amp;</operator><name><name>progNameReally</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>tmp</name> <operator>=</operator> <operator>&amp;</operator><name><name>progNameReally</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</init> <condition><expr><operator>*</operator><name>tmp</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>tmp</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>tmp</name> <operator>==</operator> <name>PATH_SEP</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>progName</name> <operator>=</operator> <name>tmp</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>





<expr_stmt><expr><name>argList</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addFlagsFromEnvVar</name> <argument_list>( <argument><expr><operator>&amp;</operator><name>argList</name></expr></argument>, <argument><expr><operator>(</operator><name>Char</name><operator>*</operator><operator>)</operator><literal type="string">"BZIP2"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addFlagsFromEnvVar</name> <argument_list>( <argument><expr><operator>&amp;</operator><name>argList</name></expr></argument>, <argument><expr><operator>(</operator><name>Char</name><operator>*</operator><operator>)</operator><literal type="string">"BZIP"</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>argc</name><operator>-</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>APPEND_FILESPEC</name><argument_list>(<argument><expr><name>argList</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>



<expr_stmt><expr><name>longestFileName</name> <operator>=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>numFileNames</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>decode</name> <operator>=</operator> <name>True</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>aa</name> <operator>=</operator> <name>argList</name></expr>;</init> <condition><expr><name>aa</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>aa</name> <operator>=</operator> <name><name>aa</name><operator>-&gt;</operator><name>link</name></name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ISFLAG</name><argument_list>(<argument><expr><literal type="string">"--"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>decode</name> <operator>=</operator> <name>False</name></expr>;</expr_stmt> <continue>continue;</continue> </block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>aa</name><operator>-&gt;</operator><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <name>decode</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name>numFileNames</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>longestFileName</name> <operator>&lt;</operator> <operator>(</operator><name>Int32</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>aa</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr> )</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>longestFileName</name> <operator>=</operator> <operator>(</operator><name>Int32</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>aa</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>



<if_stmt><if>if <condition>(<expr><name>numFileNames</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>srcMode</name> <operator>=</operator> <name>SM_I2O</name></expr>;</expr_stmt></block_content></block></if> <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>srcMode</name> <operator>=</operator> <name>SM_F2F</name></expr>;</expr_stmt></block_content></block></else></if_stmt>




<expr_stmt><expr><name>opMode</name> <operator>=</operator> <name>OM_Z</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>( <expr><operator>(</operator><call><name>strstr</name> <argument_list>( <argument><expr><name>progName</name></expr></argument>, <argument><expr><literal type="string">"unzip"</literal></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
<operator>(</operator><call><name>strstr</name> <argument_list>( <argument><expr><name>progName</name></expr></argument>, <argument><expr><literal type="string">"UNZIP"</literal></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr> )</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>opMode</name> <operator>=</operator> <name>OM_UNZ</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>( <expr><operator>(</operator><call><name>strstr</name> <argument_list>( <argument><expr><name>progName</name></expr></argument>, <argument><expr><literal type="string">"z2cat"</literal></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
<operator>(</operator><call><name>strstr</name> <argument_list>( <argument><expr><name>progName</name></expr></argument>, <argument><expr><literal type="string">"Z2CAT"</literal></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
<operator>(</operator><call><name>strstr</name> <argument_list>( <argument><expr><name>progName</name></expr></argument>, <argument><expr><literal type="string">"zcat"</literal></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
<operator>(</operator><call><name>strstr</name> <argument_list>( <argument><expr><name>progName</name></expr></argument>, <argument><expr><literal type="string">"ZCAT"</literal></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr> )</condition> <block>{<block_content>
<expr_stmt><expr><name>opMode</name> <operator>=</operator> <name>OM_UNZ</name></expr>;</expr_stmt>
<expr_stmt><expr><name>srcMode</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>numFileNames</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>SM_I2O</name></expr> </then><else>: <expr><name>SM_F2O</name></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>



<for>for <control>(<init><expr><name>aa</name> <operator>=</operator> <name>argList</name></expr>;</init> <condition><expr><name>aa</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>aa</name> <operator>=</operator> <name><name>aa</name><operator>-&gt;</operator><name>link</name></name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ISFLAG</name><argument_list>(<argument><expr><literal type="string">"--"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>aa</name><operator>-&gt;</operator><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <name><name>aa</name><operator>-&gt;</operator><name>name</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name><name>aa</name><operator>-&gt;</operator><name>name</name><index>[<expr><name>j</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<switch>switch <condition>(<expr><name><name>aa</name><operator>-&gt;</operator><name>name</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'c'</literal></expr>:</case> <expr_stmt><expr><name>srcMode</name> <operator>=</operator> <name>SM_F2O</name></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'d'</literal></expr>:</case> <expr_stmt><expr><name>opMode</name> <operator>=</operator> <name>OM_UNZ</name></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'z'</literal></expr>:</case> <expr_stmt><expr><name>opMode</name> <operator>=</operator> <name>OM_Z</name></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'f'</literal></expr>:</case> <expr_stmt><expr><name>forceOverwrite</name> <operator>=</operator> <name>True</name></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'t'</literal></expr>:</case> <expr_stmt><expr><name>opMode</name> <operator>=</operator> <name>OM_TEST</name></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'k'</literal></expr>:</case> <expr_stmt><expr><name>keepInputFiles</name> <operator>=</operator> <name>True</name></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'s'</literal></expr>:</case> <expr_stmt><expr><name>smallMode</name> <operator>=</operator> <name>True</name></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'q'</literal></expr>:</case> <expr_stmt><expr><name>noisy</name> <operator>=</operator> <name>False</name></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'1'</literal></expr>:</case> <expr_stmt><expr><name>blockSize100k</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'2'</literal></expr>:</case> <expr_stmt><expr><name>blockSize100k</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'3'</literal></expr>:</case> <expr_stmt><expr><name>blockSize100k</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'4'</literal></expr>:</case> <expr_stmt><expr><name>blockSize100k</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'5'</literal></expr>:</case> <expr_stmt><expr><name>blockSize100k</name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'6'</literal></expr>:</case> <expr_stmt><expr><name>blockSize100k</name> <operator>=</operator> <literal type="number">6</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'7'</literal></expr>:</case> <expr_stmt><expr><name>blockSize100k</name> <operator>=</operator> <literal type="number">7</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'8'</literal></expr>:</case> <expr_stmt><expr><name>blockSize100k</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'9'</literal></expr>:</case> <expr_stmt><expr><name>blockSize100k</name> <operator>=</operator> <literal type="number">9</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'V'</literal></expr>:</case>
<case>case <expr><literal type="char">'L'</literal></expr>:</case> <expr_stmt><expr><call><name>license</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name> <argument_list>( <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'v'</literal></expr>:</case> <expr_stmt><expr><name>verbosity</name><operator>++</operator></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'h'</literal></expr>:</case> <expr_stmt><expr><call><name>usage</name> <argument_list>( <argument><expr><name>progName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name> <argument_list>( <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default> <expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: Bad flag `%s'\n"</literal></expr></argument>,
<argument><expr><name>progName</name></expr></argument>, <argument><expr><name><name>aa</name><operator>-&gt;</operator><name>name</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>usage</name> <argument_list>( <argument><expr><name>progName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name> <argument_list>( <argument><expr><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>


<for>for <control>(<init><expr><name>aa</name> <operator>=</operator> <name>argList</name></expr>;</init> <condition><expr><name>aa</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>aa</name> <operator>=</operator> <name><name>aa</name><operator>-&gt;</operator><name>link</name></name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ISFLAG</name><argument_list>(<argument><expr><literal type="string">"--"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ISFLAG</name><argument_list>(<argument><expr><literal type="string">"--stdout"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>srcMode</name> <operator>=</operator> <name>SM_F2O</name></expr>;</expr_stmt></block_content></block></if> <if type="elseif">else
if <condition>(<expr><call><name>ISFLAG</name><argument_list>(<argument><expr><literal type="string">"--decompress"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>opMode</name> <operator>=</operator> <name>OM_UNZ</name></expr>;</expr_stmt></block_content></block></if> <if type="elseif">else
if <condition>(<expr><call><name>ISFLAG</name><argument_list>(<argument><expr><literal type="string">"--compress"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>opMode</name> <operator>=</operator> <name>OM_Z</name></expr>;</expr_stmt></block_content></block></if> <if type="elseif">else
if <condition>(<expr><call><name>ISFLAG</name><argument_list>(<argument><expr><literal type="string">"--force"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>forceOverwrite</name> <operator>=</operator> <name>True</name></expr>;</expr_stmt></block_content></block></if> <if type="elseif">else
if <condition>(<expr><call><name>ISFLAG</name><argument_list>(<argument><expr><literal type="string">"--test"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>opMode</name> <operator>=</operator> <name>OM_TEST</name></expr>;</expr_stmt></block_content></block></if> <if type="elseif">else
if <condition>(<expr><call><name>ISFLAG</name><argument_list>(<argument><expr><literal type="string">"--keep"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>keepInputFiles</name> <operator>=</operator> <name>True</name></expr>;</expr_stmt></block_content></block></if> <if type="elseif">else
if <condition>(<expr><call><name>ISFLAG</name><argument_list>(<argument><expr><literal type="string">"--small"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>smallMode</name> <operator>=</operator> <name>True</name></expr>;</expr_stmt></block_content></block></if> <if type="elseif">else
if <condition>(<expr><call><name>ISFLAG</name><argument_list>(<argument><expr><literal type="string">"--quiet"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>noisy</name> <operator>=</operator> <name>False</name></expr>;</expr_stmt></block_content></block></if> <if type="elseif">else
if <condition>(<expr><call><name>ISFLAG</name><argument_list>(<argument><expr><literal type="string">"--version"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> <expr_stmt><expr><call><name>license</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>exit</name> <argument_list>( <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if> <if type="elseif">else
if <condition>(<expr><call><name>ISFLAG</name><argument_list>(<argument><expr><literal type="string">"--license"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> <expr_stmt><expr><call><name>license</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>exit</name> <argument_list>( <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if> <if type="elseif">else
if <condition>(<expr><call><name>ISFLAG</name><argument_list>(<argument><expr><literal type="string">"--exponential"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>workFactor</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if> <if type="elseif">else
if <condition>(<expr><call><name>ISFLAG</name><argument_list>(<argument><expr><literal type="string">"--repetitive-best"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>redundant</name><argument_list>(<argument><expr><name><name>aa</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if> <if type="elseif">else
if <condition>(<expr><call><name>ISFLAG</name><argument_list>(<argument><expr><literal type="string">"--repetitive-fast"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>redundant</name><argument_list>(<argument><expr><name><name>aa</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if> <if type="elseif">else
if <condition>(<expr><call><name>ISFLAG</name><argument_list>(<argument><expr><literal type="string">"--fast"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>blockSize100k</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if> <if type="elseif">else
if <condition>(<expr><call><name>ISFLAG</name><argument_list>(<argument><expr><literal type="string">"--best"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>blockSize100k</name> <operator>=</operator> <literal type="number">9</literal></expr>;</expr_stmt></block_content></block></if> <if type="elseif">else
if <condition>(<expr><call><name>ISFLAG</name><argument_list>(<argument><expr><literal type="string">"--verbose"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>verbosity</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if> <if type="elseif">else
if <condition>(<expr><call><name>ISFLAG</name><argument_list>(<argument><expr><literal type="string">"--help"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> <expr_stmt><expr><call><name>usage</name> <argument_list>( <argument><expr><name>progName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>exit</name> <argument_list>( <argument><expr><literal type="number">0</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt> </block_content>}</block></if>
<if type="elseif">else
if <condition>(<expr><call><name>strncmp</name> <argument_list>( <argument><expr><name><name>aa</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"--"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: Bad flag `%s'\n"</literal></expr></argument>, <argument><expr><name>progName</name></expr></argument>, <argument><expr><name><name>aa</name><operator>-&gt;</operator><name>name</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>usage</name> <argument_list>( <argument><expr><name>progName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name> <argument_list>( <argument><expr><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>verbosity</name> <operator>&gt;</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>verbosity</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>opMode</name> <operator>==</operator> <name>OM_Z</name> <operator>&amp;&amp;</operator> <name>smallMode</name> <operator>&amp;&amp;</operator> <name>blockSize100k</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>blockSize100k</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>opMode</name> <operator>==</operator> <name>OM_TEST</name> <operator>&amp;&amp;</operator> <name>srcMode</name> <operator>==</operator> <name>SM_F2O</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: -c and -t cannot be used together.\n"</literal></expr></argument>,
<argument><expr><name>progName</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name> <argument_list>( <argument><expr><literal type="number">1</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>srcMode</name> <operator>==</operator> <name>SM_F2O</name> <operator>&amp;&amp;</operator> <name>numFileNames</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>srcMode</name> <operator>=</operator> <name>SM_I2O</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>opMode</name> <operator>!=</operator> <name>OM_Z</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>blockSize100k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>srcMode</name> <operator>==</operator> <name>SM_F2F</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>signal</name> <argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>mySignalCatcher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>signal</name> <argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><name>mySignalCatcher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BZ_UNIX</name></expr></cpp:if>
<expr_stmt><expr><call><name>signal</name> <argument_list>(<argument><expr><name>SIGHUP</name></expr></argument>, <argument><expr><name>mySignalCatcher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>opMode</name> <operator>==</operator> <name>OM_Z</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>srcMode</name> <operator>==</operator> <name>SM_I2O</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>compress</name> <argument_list>( <argument><expr><name>NULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>decode</name> <operator>=</operator> <name>True</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>aa</name> <operator>=</operator> <name>argList</name></expr>;</init> <condition><expr><name>aa</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>aa</name> <operator>=</operator> <name><name>aa</name><operator>-&gt;</operator><name>link</name></name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ISFLAG</name><argument_list>(<argument><expr><literal type="string">"--"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>decode</name> <operator>=</operator> <name>False</name></expr>;</expr_stmt> <continue>continue;</continue> </block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>aa</name><operator>-&gt;</operator><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <name>decode</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name>numFilesProcessed</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compress</name> <argument_list>( <argument><expr><name><name>aa</name><operator>-&gt;</operator><name>name</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<if type="elseif">else

if <condition>(<expr><name>opMode</name> <operator>==</operator> <name>OM_UNZ</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>unzFailsExist</name> <operator>=</operator> <name>False</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>srcMode</name> <operator>==</operator> <name>SM_I2O</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>uncompress</name> <argument_list>( <argument><expr><name>NULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>decode</name> <operator>=</operator> <name>True</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>aa</name> <operator>=</operator> <name>argList</name></expr>;</init> <condition><expr><name>aa</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>aa</name> <operator>=</operator> <name><name>aa</name><operator>-&gt;</operator><name>link</name></name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ISFLAG</name><argument_list>(<argument><expr><literal type="string">"--"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>decode</name> <operator>=</operator> <name>False</name></expr>;</expr_stmt> <continue>continue;</continue> </block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>aa</name><operator>-&gt;</operator><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <name>decode</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name>numFilesProcessed</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>uncompress</name> <argument_list>( <argument><expr><name><name>aa</name><operator>-&gt;</operator><name>name</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>unzFailsExist</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>setExit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>exitValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>

<else>else <block>{<block_content>
<expr_stmt><expr><name>testFailsExist</name> <operator>=</operator> <name>False</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>srcMode</name> <operator>==</operator> <name>SM_I2O</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>testf</name> <argument_list>( <argument><expr><name>NULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>decode</name> <operator>=</operator> <name>True</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>aa</name> <operator>=</operator> <name>argList</name></expr>;</init> <condition><expr><name>aa</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>aa</name> <operator>=</operator> <name><name>aa</name><operator>-&gt;</operator><name>link</name></name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ISFLAG</name><argument_list>(<argument><expr><literal type="string">"--"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>decode</name> <operator>=</operator> <name>False</name></expr>;</expr_stmt> <continue>continue;</continue> </block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>aa</name><operator>-&gt;</operator><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <name>decode</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name>numFilesProcessed</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>testf</name> <argument_list>( <argument><expr><name><name>aa</name><operator>-&gt;</operator><name>name</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>testFailsExist</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>noisy</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>( <argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"\n"</literal>
<literal type="string">"You can use the `bzip2recover' program to attempt to recover\n"</literal>
<literal type="string">"data from undamaged sections of corrupted files.\n\n"</literal></expr></argument>
)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>setExit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>exitValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>




<expr_stmt><expr><name>aa</name> <operator>=</operator> <name>argList</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>aa</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>Cell</name><modifier>*</modifier></type> <name>aa2</name> <init>= <expr><name><name>aa</name><operator>-&gt;</operator><name>link</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>aa</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>aa</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>aa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>aa</name> <operator>=</operator> <name>aa2</name></expr>;</expr_stmt>
</block_content>}</block></while>

<return>return <expr><name>exitValue</name></expr>;</return>
</block_content>}</block></function>





</unit>
