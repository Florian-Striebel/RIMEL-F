<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/bsnmp/snmpd/main.c">






































<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/queue.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/param.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/un.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/ucred.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/uio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stddef.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;syslog.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dlfcn.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_TCPWRAPPERS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;arpa/inet.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;tcpd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"support.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"snmpmod.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"snmpd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"oid.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"trans_inet.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PATH_PID</name></cpp:macro> <cpp:value>"/var/run/%s.pid"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PATH_CONFIG</name></cpp:macro> <cpp:value>"/etc/%s.config"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PATH_ENGINE</name></cpp:macro> <cpp:value>"/var/%s.engine"</cpp:value></cpp:define>

<decl_stmt><decl><type><name>uint64_t</name></type> <name>this_tick</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>start_tick</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>systemg</name></name></type> <name>systemg</name> <init>= <expr><block>{
<expr><name>NULL</name></expr>,
<expr><block>{ <expr><literal type="number">8</literal></expr>, <expr><block>{ <expr><literal type="number">1</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1115</literal></expr>, <expr><literal type="number">7352</literal></expr> }</block></expr>}</block></expr>,
<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
<expr><literal type="number">64</literal> <operator>+</operator> <literal type="number">8</literal> <operator>+</operator> <literal type="number">4</literal></expr>,
<expr><literal type="number">0</literal></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>debug</name></name></type> <name>debug</name> <init>= <expr><block>{
<expr><literal type="number">0</literal></expr>,
<expr><name>LOG_DEBUG</name></expr>,
<expr><literal type="number">0</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>snmpd</name></name></type> <name>snmpd</name> <init>= <expr><block>{
<expr><literal type="number">2048</literal></expr>,
<expr><literal type="number">2048</literal></expr>,
<expr><literal type="number">0</literal></expr>,
<expr><literal type="number">0</literal></expr>,
<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,
<expr><name>VERS_ENABLE_ALL</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>snmpd_stats</name></name></type> <name>snmpd_stats</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>snmpd_usmstat</name></name></type> <name>snmpd_usmstats</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name><name>struct</name> <name>snmp_engine</name></name></type> <name>snmpd_engine</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>int32_t</name></type> <name>snmp_serial_no</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>snmpd_target_stats</name></name></type> <name>snmpd_target_stats</name></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>syspath</name> <init>= <expr><name>PATH_SYSCONFIG</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name><name>struct</name> <name>lmodules</name></name></type> <name>lmodules</name> <init>= <expr><call><name>TAILQ_HEAD_INITIALIZER</name><argument_list>(<argument><expr><name>lmodules</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>lmodules</name></name></type> <name>modules_start</name> <init>= <expr><call><name>TAILQ_HEAD_INITIALIZER</name><argument_list>(<argument><expr><name>modules_start</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name><name>struct</name> <name>community_list</name></name></type> <name>community_list</name> <init>= <expr><call><name>TAILQ_HEAD_INITIALIZER</name><argument_list>(<argument><expr><name>community_list</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>usm_userlist</name></name></type> <name>usm_userlist</name> <init>= <expr><call><name>SLIST_HEAD_INITIALIZER</name><argument_list>(<argument><expr><name>usm_userlist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>vacm_userlist</name></name></type> <name>vacm_userlist</name> <init>=
<expr><call><name>SLIST_HEAD_INITIALIZER</name><argument_list>(<argument><expr><name>vacm_userlist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>vacm_grouplist</name></name></type> <name>vacm_grouplist</name> <init>=
<expr><call><name>SLIST_HEAD_INITIALIZER</name><argument_list>(<argument><expr><name>vacm_grouplist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>vacm_group</name></name></type> <name>vacm_default_group</name> <init>= <expr><block>{
<expr><operator>.</operator><name>groupname</name> <operator>=</operator> <literal type="string">""</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>vacm_accesslist</name></name></type> <name>vacm_accesslist</name> <init>=
<expr><call><name>TAILQ_HEAD_INITIALIZER</name><argument_list>(<argument><expr><name>vacm_accesslist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>vacm_viewlist</name></name></type> <name>vacm_viewlist</name> <init>=
<expr><call><name>SLIST_HEAD_INITIALIZER</name><argument_list>(<argument><expr><name>vacm_viewlist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>vacm_contextlist</name></name></type> <name>vacm_contextlist</name> <init>=
<expr><call><name>SLIST_HEAD_INITIALIZER</name><argument_list>(<argument><expr><name>vacm_contextlist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name><name>struct</name> <name>objres_list</name></name></type> <name>objres_list</name> <init>= <expr><call><name>TAILQ_HEAD_INITIALIZER</name><argument_list>(<argument><expr><name>objres_list</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name>u_int</name></type> <name>next_community_index</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name><name>struct</name> <name>idrange_list</name></name></type> <name>idrange_list</name> <init>= <expr><call><name>TAILQ_HEAD_INITIALIZER</name><argument_list>(<argument><expr><name>idrange_list</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>u_int</name></type> <name>next_idrange</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name><name>struct</name> <name>timer_list</name></name></type> <name>timer_list</name> <init>= <expr><call><name>LIST_HEAD_INITIALIZER</name><argument_list>(<argument><expr><name>timer_list</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name><name>struct</name> <name>fdesc_list</name></name></type> <name>fdesc_list</name> <init>= <expr><call><name>LIST_HEAD_INITIALIZER</name><argument_list>(<argument><expr><name>fdesc_list</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>progargs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>nprogargs</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>u_int</name></type> <name>community</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>community</name></name> <modifier>*</modifier></type><name>comm</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name><name>struct</name> <name>usm_user</name></name> <modifier>*</modifier></type><name>usm_user</name></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>config_file</name><index>[<expr><name>MAXPATHLEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>pid_file</name><index>[<expr><name>MAXPATHLEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>engine_file</name><index>[<expr><name>MAXPATHLEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>USE_LIBBEGEMOT</name></expr></argument>)</argument_list></call></expr></cpp:if>

<decl_stmt><decl><type><specifier>static</specifier> <name>evContext</name></type> <name>evctx</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<decl_stmt><decl><type><specifier>static</specifier> <name>sigset_t</name></type> <name>blocked_sigs</name></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>work</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WORK_DOINFO</name></cpp:macro> <cpp:value>0x0001</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WORK_RECONFIG</name></cpp:macro> <cpp:value>0x0002</cpp:value></cpp:define>


<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>asn_oid</name></name></type>
<name>oid_snmpMIB</name> <init>= <expr><name>OIDX_snmpMIB</name></expr></init></decl>,
<decl><type ref="prev"/><name>oid_begemotSnmpd</name> <init>= <expr><name>OIDX_begemotSnmpd</name></expr></init></decl>,
<decl><type ref="prev"/><name>oid_coldStart</name> <init>= <expr><name>OIDX_coldStart</name></expr></init></decl>,
<decl><type ref="prev"/><name>oid_authenticationFailure</name> <init>= <expr><name>OIDX_authenticationFailure</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>asn_oid</name></name></type> <name>oid_zeroDotZero</name> <init>= <expr><block>{ <expr><literal type="number">2</literal></expr>, <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>asn_oid</name></name></type> <name>oid_usmUnknownEngineIDs</name> <init>=
<expr><block>{ <expr><literal type="number">11</literal></expr>, <expr><block>{ <expr><literal type="number">1</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>asn_oid</name></name></type> <name>oid_usmNotInTimeWindows</name> <init>=
<expr><block>{ <expr><literal type="number">11</literal></expr>, <expr><block>{ <expr><literal type="number">1</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">15</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>u_int</name></type> <name>trap_reqid</name></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>usgtxt</name><index>[]</index></name> <init>= <expr><literal type="string">"\
Begemot simple SNMP daemon. Copyright (c) 2001-2002 Fraunhofer Institute for\n\
Open Communication Systems (FhG Fokus). All rights reserved.\n\
Copyright (c) 2010 The FreeBSD Foundation. All rights reserved.\n\
usage: snmpd [-dh] [-c file] [-D options] [-e file] [-I path]\n\
[-l prefix] [-m variable=value] [-p file]\n\
options:\n\
-d don't daemonize\n\
-h print this info\n\
-c file specify configuration file\n\
-D options debugging options\n\
-e file specify engine id file\n\
-I path system include path\n\
-l prefix default basename for pid and config file\n\
-m var=val define variable\n\
-p file specify pid file\n\
"</literal></expr></init></decl>;</decl_stmt>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_TCPWRAPPERS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>request_info</name></name></type> <name>req</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name><name>struct</name> <name>transport_def</name></name></type> <name>udp_trans</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name><name>struct</name> <name>transport_def</name></name></type> <name>lsock_trans</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>transport_list</name></name></type> <name>transport_list</name> <init>= <expr><call><name>TAILQ_HEAD_INITIALIZER</name><argument_list>(<argument><expr><name>transport_list</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>snmp_printf_func</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>snmp_error_func</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>err</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>snmp_debug_func</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>err</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>asn_error_func</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>asn_buf</name></name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>err</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>;</function_decl>




<function><type><name>void</name> <modifier>*</modifier></type>
<name>buf_alloc</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>tx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>buf</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><ternary><condition><expr><name>tx</name></expr> ?</condition><then> <expr><name><name>snmpd</name><operator>.</operator><name>txbuf</name></name></expr> </then><else>: <expr><name><name>snmpd</name><operator>.</operator><name>rxbuf</name></name></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_CRIT</name></expr></argument>, <argument><expr><literal type="string">"cannot allocate buffer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tx</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>snmpd_stats</name><operator>.</operator><name>noTxbuf</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>snmpd_stats</name><operator>.</operator><name>noRxbuf</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name>buf</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>




<function><type><name>size_t</name></type>
<name>buf_size</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>tx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><ternary><condition><expr><name>tx</name></expr> ?</condition><then> <expr><name><name>snmpd</name><operator>.</operator><name>txbuf</name></name></expr> </then><else>: <expr><name><name>snmpd</name><operator>.</operator><name>rxbuf</name></name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>




<function><type><name>void</name></type>
<name>snmp_output</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>snmp_pdu</name></name> <modifier>*</modifier></type><name>pdu</name></decl></parameter>, <parameter><decl><type><name>u_char</name> <modifier>*</modifier></type><name>sndbuf</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>sndlen</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>asn_buf</name></name></type> <name>resp_b</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>snmp_code</name></name></type> <name>code</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>resp_b</name><operator>.</operator><name>asn_ptr</name></name> <operator>=</operator> <name>sndbuf</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>resp_b</name><operator>.</operator><name>asn_len</name></name> <operator>=</operator> <name><name>snmpd</name><operator>.</operator><name>txbuf</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>code</name> <operator>=</operator> <call><name>snmp_pdu_encode</name><argument_list>(<argument><expr><name>pdu</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>resp_b</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>SNMP_CODE_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><literal type="string">"cannot encode message (code=%d)"</literal></expr></argument>, <argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>debug</name><operator>.</operator><name>dump_pdus</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>snmp_printf</name><argument_list>(<argument><expr><literal type="string">"%s &lt;- "</literal></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>snmp_pdu_dump</name><argument_list>(<argument><expr><name>pdu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>sndlen</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name><name>resp_b</name><operator>.</operator><name>asn_ptr</name></name> <operator>-</operator> <name>sndbuf</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name><name>enum</name> <name>snmp_code</name></name></type>
<name>snmp_pdu_auth_user</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>snmp_pdu</name></name> <modifier>*</modifier></type><name>pdu</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>usm_user</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>pdu</name><operator>-&gt;</operator><name>engine</name><operator>.</operator><name>engine_len</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>pdu</name><operator>-&gt;</operator><name>user</name><operator>.</operator><name>sec_name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>pdu</name><operator>-&gt;</operator><name>engine</name><operator>.</operator><name>engine_len</name></name> <operator>=</operator> <name><name>snmpd_engine</name><operator>.</operator><name>engine_len</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pdu</name><operator>-&gt;</operator><name>engine</name><operator>.</operator><name>engine_id</name></name></expr></argument>, <argument><expr><name><name>snmpd_engine</name><operator>.</operator><name>engine_id</name></name></expr></argument>,
<argument><expr><name><name>snmpd_engine</name><operator>.</operator><name>engine_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>update_snmpd_engine_time</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pdu</name><operator>-&gt;</operator><name>engine</name><operator>.</operator><name>engine_boots</name></name> <operator>=</operator> <name><name>snmpd_engine</name><operator>.</operator><name>engine_boots</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pdu</name><operator>-&gt;</operator><name>engine</name><operator>.</operator><name>engine_time</name></name> <operator>=</operator> <name><name>snmpd_engine</name><operator>.</operator><name>engine_time</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pdu</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>SNMP_MSG_AUTODISCOVER</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>SNMP_CODE_OK</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>usm_user</name> <operator>=</operator> <call><name>usm_find_user</name><argument_list>(<argument><expr><name><name>pdu</name><operator>-&gt;</operator><name>engine</name><operator>.</operator><name>engine_id</name></name></expr></argument>,
<argument><expr><name><name>pdu</name><operator>-&gt;</operator><name>engine</name><operator>.</operator><name>engine_len</name></name></expr></argument>, <argument><expr><name><name>pdu</name><operator>-&gt;</operator><name>user</name><operator>.</operator><name>sec_name</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>||</operator>
<name><name>usm_user</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>SNMP_CODE_BADUSER</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>usm_user</name><operator>-&gt;</operator><name>user_engine_len</name></name> <operator>!=</operator> <name><name>snmpd_engine</name><operator>.</operator><name>engine_len</name></name> <operator>||</operator>
<call><name>memcmp</name><argument_list>(<argument><expr><name><name>usm_user</name><operator>-&gt;</operator><name>user_engine_id</name></name></expr></argument>, <argument><expr><name><name>snmpd_engine</name><operator>.</operator><name>engine_id</name></name></expr></argument>,
<argument><expr><name><name>snmpd_engine</name><operator>.</operator><name>engine_len</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>SNMP_CODE_BADENGINE</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>pdu</name><operator>-&gt;</operator><name>user</name><operator>.</operator><name>priv_proto</name></name> <operator>=</operator> <name><name>usm_user</name><operator>-&gt;</operator><name>suser</name><operator>.</operator><name>priv_proto</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pdu</name><operator>-&gt;</operator><name>user</name><operator>.</operator><name>priv_key</name></name></expr></argument>, <argument><expr><name><name>usm_user</name><operator>-&gt;</operator><name>suser</name><operator>.</operator><name>priv_key</name></name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pdu</name><operator>-&gt;</operator><name>user</name><operator>.</operator><name>priv_key</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pdu</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SNMP_MSG_AUTH_FLAG</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>update_snmpd_engine_time</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pdu</name><operator>-&gt;</operator><name>user</name><operator>.</operator><name>auth_proto</name></name> <operator>=</operator> <name><name>usm_user</name><operator>-&gt;</operator><name>suser</name><operator>.</operator><name>auth_proto</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pdu</name><operator>-&gt;</operator><name>user</name><operator>.</operator><name>auth_key</name></name></expr></argument>, <argument><expr><name><name>usm_user</name><operator>-&gt;</operator><name>suser</name><operator>.</operator><name>auth_key</name></name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pdu</name><operator>-&gt;</operator><name>user</name><operator>.</operator><name>auth_key</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>pdu</name><operator>-&gt;</operator><name>engine</name><operator>.</operator><name>engine_boots</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<name><name>pdu</name><operator>-&gt;</operator><name>engine</name><operator>.</operator><name>engine_time</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>update_snmpd_engine_time</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pdu</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>SNMP_MSG_AUTODISCOVER</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>SNMP_CODE_OK</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>pdu</name><operator>-&gt;</operator><name>engine</name><operator>.</operator><name>engine_boots</name></name> <operator>!=</operator> <name><name>snmpd_engine</name><operator>.</operator><name>engine_boots</name></name> <operator>||</operator>
<call><name>abs</name><argument_list>(<argument><expr><name><name>pdu</name><operator>-&gt;</operator><name>engine</name><operator>.</operator><name>engine_time</name></name> <operator>-</operator> <name><name>snmpd_engine</name><operator>.</operator><name>engine_time</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator>
<name>SNMP_TIME_WINDOW</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>SNMP_CODE_NOTINTIME</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name><name>pdu</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SNMP_MSG_PRIV_FLAG</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>pdu</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SNMP_MSG_AUTH_FLAG</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
<operator>(</operator><operator>(</operator><name><name>pdu</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SNMP_MSG_AUTH_FLAG</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<name><name>usm_user</name><operator>-&gt;</operator><name>suser</name><operator>.</operator><name>auth_proto</name></name> <operator>!=</operator> <name>SNMP_AUTH_NOAUTH</name><operator>)</operator> <operator>||</operator>
<operator>(</operator><operator>(</operator><name><name>pdu</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SNMP_MSG_PRIV_FLAG</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<name><name>usm_user</name><operator>-&gt;</operator><name>suser</name><operator>.</operator><name>priv_proto</name></name> <operator>!=</operator> <name>SNMP_PRIV_NOPRIV</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>SNMP_CODE_BADSECLEVEL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><name>SNMP_CODE_OK</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>





<function><type><name><name>enum</name> <name>snmp_code</name></name></type>
<name>snmp_pdu_auth_access</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>snmp_pdu</name></name> <modifier>*</modifier></type><name>pdu</name></decl></parameter>, <parameter><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>ip</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>uname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name></type> <name>suboid</name></decl>, <decl><type ref="prev"/><name>smodel</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>vacm_user</name></name> <modifier>*</modifier></type><name>vuser</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>vacm_access</name></name> <modifier>*</modifier></type><name>acl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>vacm_context</name></name> <modifier>*</modifier></type><name>vacmctx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>vacm_view</name></name> <modifier>*</modifier></type><name>view</name></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><call><name>SLIST_EMPTY</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vacm_contextlist</name></expr></argument>)</argument_list></call> <operator>||</operator>
<operator>(</operator><name><name>pdu</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SNMP_MSG_AUTODISCOVER</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>SNMP_CODE_OK</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>pdu</name><operator>-&gt;</operator><name>version</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>SNMP_V1</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>uname</name> <operator>=</operator> <call><name>comm_string</name><argument_list>(<argument><expr><name>community</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>SNMP_CODE_FAILED</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>smodel</name> <operator>=</operator> <name>SNMP_SECMODEL_SNMPv1</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>SNMP_V2c</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>uname</name> <operator>=</operator> <call><name>comm_string</name><argument_list>(<argument><expr><name>community</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>SNMP_CODE_FAILED</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>smodel</name> <operator>=</operator> <name>SNMP_SECMODEL_SNMPv2c</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>SNMP_V3</name></expr>:</case>
<expr_stmt><expr><name>uname</name> <operator>=</operator> <name><name>pdu</name><operator>-&gt;</operator><name>user</name><operator>.</operator><name>sec_name</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>smodel</name> <operator>=</operator> <name><name>pdu</name><operator>-&gt;</operator><name>security_model</name></name><operator>)</operator> <operator>!=</operator> <name>SNMP_SECMODEL_USM</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>SNMP_CODE_FAILED</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>pdu</name><operator>-&gt;</operator><name>context_engine_len</name></name> <operator>!=</operator> <name><name>snmpd_engine</name><operator>.</operator><name>engine_len</name></name> <operator>||</operator>
<call><name>memcmp</name><argument_list>(<argument><expr><name><name>pdu</name><operator>-&gt;</operator><name>context_engine</name></name></expr></argument>, <argument><expr><name><name>snmpd_engine</name><operator>.</operator><name>engine_id</name></name></expr></argument>,
<argument><expr><name><name>snmpd_engine</name><operator>.</operator><name>engine_len</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>SNMP_CODE_FAILED</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<break>break;</break>

<default>default:</default>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>

<macro><name>SLIST_FOREACH</name><argument_list>(<argument>vuser</argument>, <argument>&amp;vacm_userlist</argument>, <argument>vvu</argument>)</argument_list></macro>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>uname</name></expr></argument>, <argument><expr><name><name>vuser</name><operator>-&gt;</operator><name>secname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<name><name>vuser</name><operator>-&gt;</operator><name>sec_model</name></name> <operator>==</operator> <name>smodel</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>vuser</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>vuser</name><operator>-&gt;</operator><name>group</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>SNMP_CODE_FAILED</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>


<macro><name>TAILQ_FOREACH_REVERSE</name><argument_list>(<argument>acl</argument>, <argument>&amp;vacm_accesslist</argument>, <argument>vacm_accesslist</argument>, <argument>vva</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>acl</name><operator>-&gt;</operator><name>group</name></name> <operator>!=</operator> <name><name>vuser</name><operator>-&gt;</operator><name>group</name></name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<macro><name>SLIST_FOREACH</name><argument_list>(<argument>vacmctx</argument>, <argument>&amp;vacm_contextlist</argument>, <argument>vcl</argument>)</argument_list></macro>
<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name><name>vacmctx</name><operator>-&gt;</operator><name>ctxname</name></name></expr></argument>, <argument><expr><name><name>acl</name><operator>-&gt;</operator><name>ctx_prefix</name></name></expr></argument>,
<argument><expr><name><name>acl</name><operator>-&gt;</operator><name>ctx_match</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>match</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block>

<return>return <expr><operator>(</operator><name>SNMP_CODE_FAILED</name><operator>)</operator></expr>;</return>

<label><name>match</name>:</label>

<switch>switch <condition>(<expr><name><name>pdu</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>SNMP_PDU_GET</name></expr>:</case>
<case>case <expr><name>SNMP_PDU_GETNEXT</name></expr>:</case>
<case>case <expr><name>SNMP_PDU_GETBULK</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>view</name> <operator>=</operator> <name><name>acl</name><operator>-&gt;</operator><name>read_view</name></name><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>SNMP_CODE_FAILED</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>SNMP_PDU_SET</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>view</name> <operator>=</operator> <name><name>acl</name><operator>-&gt;</operator><name>write_view</name></name><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>SNMP_CODE_FAILED</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>SNMP_PDU_TRAP</name></expr>:</case>
<case>case <expr><name>SNMP_PDU_INFORM</name></expr>:</case>
<case>case <expr><name>SNMP_PDU_TRAP2</name></expr>:</case>
<case>case <expr><name>SNMP_PDU_REPORT</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>view</name> <operator>=</operator> <name><name>acl</name><operator>-&gt;</operator><name>notify_view</name></name><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>SNMP_CODE_FAILED</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>SNMP_PDU_RESPONSE</name></expr>:</case>

<return>return <expr><operator>(</operator><name>SNMP_CODE_FAILED</name><operator>)</operator></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pdu</name><operator>-&gt;</operator><name>nbindings</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>suboid</name> <operator>=</operator> <call><name>asn_is_suboid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>view</name><operator>-&gt;</operator><name>subtree</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pdu</name><operator>-&gt;</operator><name>bindings</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><name>suboid</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>view</name><operator>-&gt;</operator><name>exclude</name></name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>suboid</name> <operator>&amp;&amp;</operator> <name><name>view</name><operator>-&gt;</operator><name>exclude</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>ip</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>SNMP_CODE_FAILED</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<return>return <expr><operator>(</operator><name>SNMP_CODE_OK</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>




<function><type><name><name>enum</name> <name>snmpd_input_err</name></name></type>
<name>snmp_input_start</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>u_char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>source</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>snmp_pdu</name></name> <modifier>*</modifier></type><name>pdu</name></decl></parameter>, <parameter><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>ip</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>pdulen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>asn_buf</name></name></type> <name>b</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>snmp_code</name></name></type> <name>code</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>snmpd_input_err</name></name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sret</name></decl>;</decl_stmt>


<expr_stmt><expr><name>this_tick</name> <operator>=</operator> <call><name>get_ticks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>b</name><operator>.</operator><name>asn_cptr</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name><operator>.</operator><name>asn_len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>SNMPD_INPUT_OK</name></expr>;</expr_stmt>


<switch>switch <condition>(<expr><name>sret</name> <operator>=</operator> <call><name>snmp_pdu_snoop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case>
<return>return <expr><operator>(</operator><name>SNMPD_INPUT_TRUNC</name><operator>)</operator></expr>;</return>

<case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case>
<expr_stmt><expr><name><name>snmpd_stats</name><operator>.</operator><name>inASNParseErrs</name></name><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>SNMPD_INPUT_FAILED</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
<expr_stmt><expr><name><name>b</name><operator>.</operator><name>asn_len</name></name> <operator>=</operator> <operator>*</operator><name>pdulen</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>sret</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pdu</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pdu</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>code</name> <operator>=</operator> <call><name>snmp_pdu_decode_header</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><name>pdu</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>SNMP_CODE_OK</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>decoded</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>pdu</name><operator>-&gt;</operator><name>version</name></name> <operator>==</operator> <name>SNMP_V3</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>pdu</name><operator>-&gt;</operator><name>security_model</name></name> <operator>!=</operator> <name>SNMP_SECMODEL_USM</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>code</name> <operator>=</operator> <name>SNMP_CODE_FAILED</name></expr>;</expr_stmt>
<goto>goto <name>decoded</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>code</name> <operator>=</operator> <call><name>snmp_pdu_auth_user</name><argument_list>(<argument><expr><name>pdu</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>SNMP_CODE_OK</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>decoded</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>code</name> <operator>=</operator> <call><name>snmp_pdu_decode_secmode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><name>pdu</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>SNMP_CODE_OK</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>decoded</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>snmp_pdu_decode_scoped</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><name>pdu</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>decoded</name>:</label>
<expr_stmt><expr><name><name>snmpd_stats</name><operator>.</operator><name>inPkts</name></name><operator>++</operator></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>code</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>SNMP_CODE_FAILED</name></expr>:</case>
<expr_stmt><expr><name><name>snmpd_stats</name><operator>.</operator><name>inASNParseErrs</name></name><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>SNMPD_INPUT_FAILED</name><operator>)</operator></expr>;</return>

<case>case <expr><name>SNMP_CODE_BADVERS</name></expr>:</case>
<label><name>bad_vers</name>:</label>
<expr_stmt><expr><name><name>snmpd_stats</name><operator>.</operator><name>inBadVersions</name></name><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>SNMPD_INPUT_FAILED</name><operator>)</operator></expr>;</return>

<case>case <expr><name>SNMP_CODE_BADLEN</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>pdu</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>SNMP_OP_SET</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>SNMPD_INPUT_VALBADLEN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>SNMP_CODE_OORANGE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>pdu</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>SNMP_OP_SET</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>SNMPD_INPUT_VALRANGE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>SNMP_CODE_BADENC</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>pdu</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>SNMP_OP_SET</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>SNMPD_INPUT_VALBADENC</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>SNMP_CODE_BADSECLEVEL</name></expr>:</case>
<expr_stmt><expr><name><name>snmpd_usmstats</name><operator>.</operator><name>unsupported_seclevels</name></name><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>SNMPD_INPUT_FAILED</name><operator>)</operator></expr>;</return>

<case>case <expr><name>SNMP_CODE_NOTINTIME</name></expr>:</case>
<expr_stmt><expr><name><name>snmpd_usmstats</name><operator>.</operator><name>not_in_time_windows</name></name><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>SNMPD_INPUT_FAILED</name><operator>)</operator></expr>;</return>

<case>case <expr><name>SNMP_CODE_BADUSER</name></expr>:</case>
<expr_stmt><expr><name><name>snmpd_usmstats</name><operator>.</operator><name>unknown_users</name></name><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>SNMPD_INPUT_FAILED</name><operator>)</operator></expr>;</return>

<case>case <expr><name>SNMP_CODE_BADENGINE</name></expr>:</case>
<expr_stmt><expr><name><name>snmpd_usmstats</name><operator>.</operator><name>unknown_engine_ids</name></name><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>SNMPD_INPUT_FAILED</name><operator>)</operator></expr>;</return>

<case>case <expr><name>SNMP_CODE_BADDIGEST</name></expr>:</case>
<expr_stmt><expr><name><name>snmpd_usmstats</name><operator>.</operator><name>wrong_digests</name></name><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>SNMPD_INPUT_FAILED</name><operator>)</operator></expr>;</return>

<case>case <expr><name>SNMP_CODE_EDECRYPT</name></expr>:</case>
<expr_stmt><expr><name><name>snmpd_usmstats</name><operator>.</operator><name>decrypt_errors</name></name><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>SNMPD_INPUT_FAILED</name><operator>)</operator></expr>;</return>

<case>case <expr><name>SNMP_CODE_OK</name></expr>:</case>
<switch>switch <condition>(<expr><name><name>pdu</name><operator>-&gt;</operator><name>version</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>SNMP_V1</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>snmpd</name><operator>.</operator><name>version_enable</name></name> <operator>&amp;</operator> <name>VERS_ENABLE_V1</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>bad_vers</name>;</goto></block_content></block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>SNMP_V2c</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>snmpd</name><operator>.</operator><name>version_enable</name></name> <operator>&amp;</operator> <name>VERS_ENABLE_V2C</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>bad_vers</name>;</goto></block_content></block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>SNMP_V3</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>snmpd</name><operator>.</operator><name>version_enable</name></name> <operator>&amp;</operator> <name>VERS_ENABLE_V3</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>bad_vers</name>;</goto></block_content></block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>SNMP_Verr</name></expr>:</case>
<goto>goto <name>bad_vers</name>;</goto>
</block_content>}</block></switch>
<break>break;</break>
</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name><name>debug</name><operator>.</operator><name>dump_pdus</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>snmp_printf</name><argument_list>(<argument><expr><literal type="string">"%s -&gt; "</literal></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>snmp_pdu_dump</name><argument_list>(<argument><expr><name>pdu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>





<if_stmt><if>if <condition>(<expr><name><name>pdu</name><operator>-&gt;</operator><name>version</name></name> <operator>!=</operator> <name>SNMP_V3</name></expr>)</condition> <block>{<block_content>
<macro><name>TAILQ_FOREACH</name><argument_list>(<argument>comm</argument>, <argument>&amp;community_list</argument>, <argument>link</argument>)</argument_list></macro>
<if_stmt><if>if <condition>(<expr><name><name>comm</name><operator>-&gt;</operator><name>string</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
<call><name>strcmp</name><argument_list>(<argument><expr><name><name>comm</name><operator>-&gt;</operator><name>string</name></name></expr></argument>, <argument><expr><name><name>pdu</name><operator>-&gt;</operator><name>community</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>comm</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>snmpd_stats</name><operator>.</operator><name>inBadCommunityNames</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>snmp_pdu_free</name><argument_list>(<argument><expr><name>pdu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>snmpd</name><operator>.</operator><name>auth_traps</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>snmp_send_trap</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid_authenticationFailure</name></expr></argument>,
<argument><expr><operator>(</operator>struct <name>snmp_value</name> <operator>*</operator><operator>)</operator><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>SNMPD_INPUT_BAD_COMM</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>community</name> <operator>=</operator> <name><name>comm</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>pdu</name><operator>-&gt;</operator><name>nbindings</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>pdu</name><operator>-&gt;</operator><name>user</name><operator>.</operator><name>sec_name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>asn_append_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pdu</name><operator>-&gt;</operator><name>bindings</name><index>[<expr><name><name>pdu</name><operator>-&gt;</operator><name>nbindings</name></name><operator>++</operator></expr>]</index></name><operator>.</operator><name>var</name><operator>)</operator></expr></argument>,
<argument><expr><operator>&amp;</operator><name>oid_usmUnknownEngineIDs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pdu</name><operator>-&gt;</operator><name>context_engine_len</name></name> <operator>=</operator> <name><name>snmpd_engine</name><operator>.</operator><name>engine_len</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pdu</name><operator>-&gt;</operator><name>context_engine</name></name></expr></argument>, <argument><expr><name><name>snmpd_engine</name><operator>.</operator><name>engine_id</name></name></expr></argument>,
<argument><expr><name><name>snmpd_engine</name><operator>.</operator><name>engine_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>pdu</name><operator>-&gt;</operator><name>engine</name><operator>.</operator><name>engine_boots</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<name><name>pdu</name><operator>-&gt;</operator><name>engine</name><operator>.</operator><name>engine_time</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>asn_append_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pdu</name><operator>-&gt;</operator><name>bindings</name><index>[<expr><name><name>pdu</name><operator>-&gt;</operator><name>nbindings</name></name><operator>++</operator></expr>]</index></name><operator>.</operator><name>var</name><operator>)</operator></expr></argument>,
<argument><expr><operator>&amp;</operator><name>oid_usmNotInTimeWindows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>update_snmpd_engine_time</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pdu</name><operator>-&gt;</operator><name>engine</name><operator>.</operator><name>engine_boots</name></name> <operator>=</operator> <name><name>snmpd_engine</name><operator>.</operator><name>engine_boots</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pdu</name><operator>-&gt;</operator><name>engine</name><operator>.</operator><name>engine_time</name></name> <operator>=</operator> <name><name>snmpd_engine</name><operator>.</operator><name>engine_time</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>pdu</name><operator>-&gt;</operator><name>user</name><operator>.</operator><name>auth_proto</name></name> <operator>!=</operator> <name>SNMP_AUTH_NOAUTH</name> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>pdu</name><operator>-&gt;</operator><name>engine</name><operator>.</operator><name>engine_boots</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>pdu</name><operator>-&gt;</operator><name>engine</name><operator>.</operator><name>engine_time</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>snmpd_usmstats</name><operator>.</operator><name>not_in_time_windows</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>SNMPD_INPUT_FAILED</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>code</name> <operator>=</operator> <call><name>snmp_pdu_auth_access</name><argument_list>(<argument><expr><name>pdu</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>SNMP_CODE_OK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>SNMPD_INPUT_FAILED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><name>ret</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>




<function><type><name><name>enum</name> <name>snmpd_input_err</name></name></type>
<name>snmp_input_finish</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>snmp_pdu</name></name> <modifier>*</modifier></type><name>pdu</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>u_char</name> <modifier>*</modifier></type><name>rcvbuf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>rcvlen</name></decl></parameter>,
<parameter><decl><type><name>u_char</name> <modifier>*</modifier></type><name>sndbuf</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>sndlen</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>source</name></decl></parameter>,
<parameter><decl><type><name><name>enum</name> <name>snmpd_input_err</name></name></type> <name>ierr</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>ivar</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>snmp_pdu</name></name></type> <name>resp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>asn_buf</name></name></type> <name>resp_b</name></decl>, <decl><type ref="prev"/><name>pdu_b</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>snmp_ret</name></name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>resp_b</name><operator>.</operator><name>asn_ptr</name></name> <operator>=</operator> <name>sndbuf</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>resp_b</name><operator>.</operator><name>asn_len</name></name> <operator>=</operator> <name><name>snmpd</name><operator>.</operator><name>txbuf</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pdu_b</name><operator>.</operator><name>asn_cptr</name></name> <operator>=</operator> <name>rcvbuf</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pdu_b</name><operator>.</operator><name>asn_len</name></name> <operator>=</operator> <name>rcvlen</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ierr</name> <operator>!=</operator> <name>SNMPD_INPUT_OK</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>pdu</name><operator>-&gt;</operator><name>version</name></name> <operator>==</operator> <name>SNMP_V1</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>pdu</name><operator>-&gt;</operator><name>error_status</name></name> <operator>=</operator> <name>SNMP_ERR_BADVALUE</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>ierr</name> <operator>==</operator> <name>SNMPD_INPUT_VALBADLEN</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>pdu</name><operator>-&gt;</operator><name>error_status</name></name> <operator>=</operator> <name>SNMP_ERR_WRONG_LENGTH</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>ierr</name> <operator>==</operator> <name>SNMPD_INPUT_VALRANGE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>pdu</name><operator>-&gt;</operator><name>error_status</name></name> <operator>=</operator> <name>SNMP_ERR_WRONG_VALUE</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>pdu</name><operator>-&gt;</operator><name>error_status</name></name> <operator>=</operator> <name>SNMP_ERR_WRONG_ENCODING</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name><name>pdu</name><operator>-&gt;</operator><name>error_index</name></name> <operator>=</operator> <name>ivar</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>snmp_make_errresp</name><argument_list>(<argument><expr><name>pdu</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pdu_b</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>resp_b</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SNMP_RET_IGN</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_WARNING</name></expr></argument>, <argument><expr><literal type="string">"could not encode error response"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>snmpd_stats</name><operator>.</operator><name>silentDrops</name></name><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>SNMPD_INPUT_FAILED</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>debug</name><operator>.</operator><name>dump_pdus</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>snmp_printf</name><argument_list>(<argument><expr><literal type="string">"%s &lt;- "</literal></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>snmp_pdu_dump</name><argument_list>(<argument><expr><name>pdu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>sndlen</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name><name>resp_b</name><operator>.</operator><name>asn_ptr</name></name> <operator>-</operator> <name>sndbuf</name><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>SNMPD_INPUT_OK</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>pdu</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>SNMP_PDU_GET</name></expr>:</case>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>snmp_get</name><argument_list>(<argument><expr><name>pdu</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>resp_b</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>resp</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>SNMP_PDU_GETNEXT</name></expr>:</case>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>snmp_getnext</name><argument_list>(<argument><expr><name>pdu</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>resp_b</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>resp</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>SNMP_PDU_SET</name></expr>:</case>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>snmp_set</name><argument_list>(<argument><expr><name>pdu</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>resp_b</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>resp</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>SNMP_PDU_GETBULK</name></expr>:</case>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>snmp_getbulk</name><argument_list>(<argument><expr><name>pdu</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>resp_b</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>resp</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<default>default:</default>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>SNMP_RET_IGN</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>

<switch>switch <condition>(<expr><name>ret</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>SNMP_RET_OK</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>debug</name><operator>.</operator><name>dump_pdus</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>snmp_printf</name><argument_list>(<argument><expr><literal type="string">"%s &lt;- "</literal></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>snmp_pdu_dump</name><argument_list>(<argument><expr><operator>&amp;</operator><name>resp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>sndlen</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name><name>resp_b</name><operator>.</operator><name>asn_ptr</name></name> <operator>-</operator> <name>sndbuf</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>snmp_pdu_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>resp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>SNMPD_INPUT_OK</name><operator>)</operator></expr>;</return>

<case>case <expr><name>SNMP_RET_IGN</name></expr>:</case>

<expr_stmt><expr><name><name>snmpd_stats</name><operator>.</operator><name>silentDrops</name></name><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>SNMPD_INPUT_FAILED</name><operator>)</operator></expr>;</return>

<case>case <expr><name>SNMP_RET_ERR</name></expr>:</case>


<expr_stmt><expr><name><name>resp_b</name><operator>.</operator><name>asn_ptr</name></name> <operator>=</operator> <name>sndbuf</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>resp_b</name><operator>.</operator><name>asn_len</name></name> <operator>=</operator> <name><name>snmpd</name><operator>.</operator><name>txbuf</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>snmp_make_errresp</name><argument_list>(<argument><expr><name>pdu</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pdu_b</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>resp_b</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SNMP_RET_IGN</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_WARNING</name></expr></argument>, <argument><expr><literal type="string">"could not encode error response"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>snmpd_stats</name><operator>.</operator><name>silentDrops</name></name><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>SNMPD_INPUT_FAILED</name><operator>)</operator></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>debug</name><operator>.</operator><name>dump_pdus</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>snmp_printf</name><argument_list>(<argument><expr><literal type="string">"%s &lt;- "</literal></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>snmp_pdu_dump</name><argument_list>(<argument><expr><name>pdu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>sndlen</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name><name>resp_b</name><operator>.</operator><name>asn_ptr</name></name> <operator>-</operator> <name>sndbuf</name><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>SNMPD_INPUT_OK</name><operator>)</operator></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><name>void</name></type>
<name>trans_insert_port</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>transport</name></name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>tport</name></name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>tport</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>transport</name></name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
<macro><name>TAILQ_FOREACH</name><argument_list>(<argument>p</argument>, <argument>&amp;t-&gt;table</argument>, <argument>link</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>asn_compare_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>port</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>TAILQ_INSERT_BEFORE</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<expr_stmt><expr><call><name>TAILQ_INSERT_TAIL</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>t</name><operator>-&gt;</operator><name>table</name></name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><name>void</name></type>
<name>trans_remove_port</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>tport</name></name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<expr_stmt><expr><call><name>TAILQ_REMOVE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>port</name><operator>-&gt;</operator><name>transport</name><operator>-&gt;</operator><name>table</name></name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><name><name>struct</name> <name>tport</name></name> <modifier>*</modifier></type>
<name>trans_find_port</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>transport</name></name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>asn_oid</name></name> <modifier>*</modifier></type><name>idx</name></decl></parameter>, <parameter><decl><type><name>u_int</name></type> <name>sub</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<return>return <expr><operator>(</operator><call><name>FIND_OBJECT_OID</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>t</name><operator>-&gt;</operator><name>table</name></name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>sub</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>




<function><type><name><name>struct</name> <name>tport</name></name> <modifier>*</modifier></type>
<name>trans_next_port</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>transport</name></name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>asn_oid</name></name> <modifier>*</modifier></type><name>idx</name></decl></parameter>, <parameter><decl><type><name>u_int</name></type> <name>sub</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<return>return <expr><operator>(</operator><call><name>NEXT_OBJECT_OID</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>t</name><operator>-&gt;</operator><name>table</name></name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>sub</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>




<function><type><name><name>struct</name> <name>tport</name></name> <modifier>*</modifier></type>
<name>trans_first_port</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>transport</name></name> <modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<return>return <expr><operator>(</operator><call><name>TAILQ_FIRST</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>t</name><operator>-&gt;</operator><name>table</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>




<function><type><name><name>struct</name> <name>tport</name></name> <modifier>*</modifier></type>
<name>trans_iter_port</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>transport</name></name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><name><name>struct</name> <name>tport</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>intptr_t</name></type></decl></parameter>)</parameter_list></function_decl></parameter>,
<parameter><decl><type><name>intptr_t</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>tport</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<macro><name>TAILQ_FOREACH</name><argument_list>(<argument>p</argument>, <argument>&amp;t-&gt;table</argument>, <argument>link</argument>)</argument_list></macro>
<if_stmt><if>if <condition>(<expr><call><name>func</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>p</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>




<function><type><name>int</name></type>
<name>trans_register</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>transport_def</name></name> <modifier>*</modifier></type><name>def</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>transport</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>u_int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>or_descr</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>pp</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><operator>*</operator><name>pp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>SNMP_ERR_GENERR</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-&gt;</operator><name><name>index</name><operator>.</operator><name>len</name></name></name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-&gt;</operator><name><name>index</name><operator>.</operator><name>subs</name></name></name><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-&gt;</operator><name><name>index</name><operator>.</operator><name>subs</name></name></name><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-&gt;</operator><name><name>index</name><operator>.</operator><name>subs</name></name></name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index> <operator>=</operator> <name><name>def</name><operator>-&gt;</operator><name>name</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-&gt;</operator><name>vtab</name></name> <operator>=</operator> <name>def</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>FIND_OBJECT_OID</name><argument_list>(<argument><expr><operator>&amp;</operator><name>transport_list</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>*</operator><name>pp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>SNMP_ERR_INCONS_VALUE</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>or_descr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>or_descr</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s transport mapping"</literal></expr></argument>, <argument><expr><name><name>def</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-&gt;</operator><name>or_index</name></name> <operator>=</operator> <call><name>or_register</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>def</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><name>or_descr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>*</operator><name>pp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>SNMP_ERR_GENERR</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>INSERT_OBJECT_OID</name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>transport_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>TAILQ_INIT</name><argument_list>(<argument><expr><operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>pp</name><operator>)</operator><operator>-&gt;</operator><name>table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>SNMP_ERR_NOERROR</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>




<function><type><name>int</name></type>
<name>trans_unregister</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>transport</name></name> <modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TAILQ_EMPTY</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>t</name><operator>-&gt;</operator><name>table</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>SNMP_ERR_INCONS_VALUE</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>or_unregister</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>or_index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TAILQ_REMOVE</name><argument_list>(<argument><expr><operator>&amp;</operator><name>transport_list</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>SNMP_ERR_NOERROR</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>




<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_LIBBEGEMOT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type>
<name>input</name><argument_list>(<argument><expr><name>int</name> <name>fd</name></expr></argument>, <argument><expr><name>int</name> <name>mask</name> <name>__unused</name></expr></argument>, <argument><expr><name>void</name> <operator>*</operator><name>uap</name></expr></argument>)</argument_list>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
static <name>void</name>
<name>input</name><argument_list>(<argument><expr><name>evContext</name> <name>ctx</name> <name>__unused</name></expr></argument>, <argument><expr><name>void</name> <operator>*</operator><name>uap</name></expr></argument>, <argument><expr><name>int</name> <name>fd</name></expr></argument>, <argument><expr><name>int</name> <name>mask</name> <name>__unused</name></expr></argument>)</argument_list>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>fdesc</name></name> <modifier>*</modifier></type><name>f</name> <init>= <expr><name>uap</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call>(<modifier>*</modifier><name><name>f</name><operator>-&gt;</operator><name>func</name></name>)<argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>udata</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<function><type><name>void</name></type>
<name>fd_suspend</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>fdesc</name></name> <modifier>*</modifier></type><name>f</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_LIBBEGEMOT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>id</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>poll_unregister</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if_stmt><if>if <condition>(<expr><call><name>evTestID</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>evDeselectFD</name><argument_list>(<argument><expr><name>evctx</name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evInitID</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>f</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>fd_resume</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>fdesc</name></name> <modifier>*</modifier></type><name>f</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_LIBBEGEMOT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>id</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>f</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <call><name>poll_register</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>RPOLL_IN</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>err</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><literal type="string">"select fd %d: %m"</literal></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>err</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if_stmt><if>if <condition>(<expr><call><name>evTestID</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>evSelectFD</name><argument_list>(<argument><expr><name>evctx</name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>EV_READ</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>f</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>err</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><literal type="string">"select fd %d: %m"</literal></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>err</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>
<name>fd_select</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>udata</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>lmodule</name></name> <modifier>*</modifier></type><name>mod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>fdesc</name></name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>f</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>fdesc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>err</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><literal type="string">"fd_select: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>err</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>fd</name></name> <operator>=</operator> <name>fd</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>func</name></name> <operator>=</operator> <name>func</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>udata</name></name> <operator>=</operator> <name>udata</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>owner</name></name> <operator>=</operator> <name>mod</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_LIBBEGEMOT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>evInitID</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>f</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><call><name>fd_resume</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>err</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>err</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>LIST_INSERT_HEAD</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fdesc_list</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>f</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>fd_deselect</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>fdesc</name></name> <modifier>*</modifier></type><name>f</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>LIST_REMOVE</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fd_suspend</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>fd_flush</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>lmodule</name></name> <modifier>*</modifier></type><name>mod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>fdesc</name></name> <modifier>*</modifier></type><name>t</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>t1</name></decl>;</decl_stmt>

<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>LIST_FIRST</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fdesc_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>t</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>t1</name> <operator>=</operator> <call><name>LIST_NEXT</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>owner</name></name> <operator>==</operator> <name>mod</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fd_deselect</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>t</name> <operator>=</operator> <name>t1</name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>snmp_input_consume</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>port_input</name></name> <modifier>*</modifier></type><name>pi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pi</name><operator>-&gt;</operator><name>stream</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>pi</name><operator>-&gt;</operator><name>length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>pi</name><operator>-&gt;</operator><name>consumed</name></name> <operator>&gt;=</operator> <name><name>pi</name><operator>-&gt;</operator><name>length</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>pi</name><operator>-&gt;</operator><name>length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>pi</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>pi</name><operator>-&gt;</operator><name>buf</name></name> <operator>+</operator> <name><name>pi</name><operator>-&gt;</operator><name>consumed</name></name></expr></argument>, <argument><expr><name><name>pi</name><operator>-&gt;</operator><name>length</name></name> <operator>-</operator> <name><name>pi</name><operator>-&gt;</operator><name>consumed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pi</name><operator>-&gt;</operator><name>length</name></name> <operator>-=</operator> <name><name>pi</name><operator>-&gt;</operator><name>consumed</name></name></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><name>int</name></type>
<name>snmpd_input</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>port_input</name></name> <modifier>*</modifier></type><name>pi</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>tport</name></name> <modifier>*</modifier></type><name>tport</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>u_char</name> <modifier>*</modifier></type><name>sndbuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>sndlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>snmp_pdu</name></name></type> <name>pdu</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>snmpd_input_err</name></name></type> <name>ierr</name></decl>, <decl><type ref="prev"/><name>ferr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>snmpd_proxy_err</name></name></type> <name>perr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>ret</name></decl>, <decl><type ref="prev"/><name>slen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name></type> <name>vi</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_TCPWRAPPERS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>char</name></type> <name><name>client</name><index>[<expr><name>INET6_ADDRSTRLEN</name></expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name><name>tport</name><operator>-&gt;</operator><name>transport</name><operator>-&gt;</operator><name>vtab</name><operator>-&gt;</operator><name>recv</name></name><argument_list>(<argument><expr><name>tport</name></expr></argument>, <argument><expr><name>pi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_TCPWRAPPERS</name></expr></argument>)</argument_list></call></expr></cpp:if>



<if_stmt><if>if <condition>(<expr><name><name>pi</name><operator>-&gt;</operator><name>peer</name><operator>-&gt;</operator><name>sa_family</name></name> <operator>!=</operator> <name>AF_LOCAL</name> <operator>&amp;&amp;</operator>
<call><name>inet_ntop</name><argument_list>(<argument><expr><name><name>pi</name><operator>-&gt;</operator><name>peer</name><operator>-&gt;</operator><name>sa_family</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> struct <name>sockaddr_in</name> <operator>*</operator><operator>)</operator><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name><name>pi</name><operator>-&gt;</operator><name>peer</name></name><operator>)</operator><operator>-&gt;</operator><name>sin_addr</name></expr></argument>,
<argument><expr><name>client</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>request_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name>req</name></expr></argument>, <argument><expr><name>RQ_CLIENT_ADDR</name></expr></argument>, <argument><expr><name>client</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>hosts_access</name><argument_list>(<argument><expr><operator>&amp;</operator><name>req</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><literal type="string">"refused connection from %.500s"</literal></expr></argument>,
<argument><expr><call><name>eval_client</name><argument_list>(<argument><expr><operator>&amp;</operator><name>req</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>pi</name><operator>-&gt;</operator><name>peer</name><operator>-&gt;</operator><name>sa_family</name></name> <operator>!=</operator> <name>AF_LOCAL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><literal type="string">"inet_ntop(): %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>




<expr_stmt><expr><name>ierr</name> <operator>=</operator> <call><name>snmp_input_start</name><argument_list>(<argument><expr><name><name>pi</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>pi</name><operator>-&gt;</operator><name>length</name></name></expr></argument>, <argument><expr><literal type="string">"SNMP"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pdu</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vi</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>pi</name><operator>-&gt;</operator><name>consumed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ierr</name> <operator>==</operator> <name>SNMPD_INPUT_TRUNC</name></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><name><name>pi</name><operator>-&gt;</operator><name>stream</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>pi</name><operator>-&gt;</operator><name>length</name></name> <operator>==</operator> <call><name>buf_size</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>snmpd_stats</name><operator>.</operator><name>silentDrops</name></name><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>snmpd_stats</name><operator>.</operator><name>silentDrops</name></name><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><name>ierr</name> <operator>==</operator> <name>SNMPD_INPUT_FAILED</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>pi</name><operator>-&gt;</operator><name>stream</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>snmp_input_consume</name><argument_list>(<argument><expr><name>pi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ierr</name> <operator>==</operator> <name>SNMPD_INPUT_BAD_COMM</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>snmp_input_consume</name><argument_list>(<argument><expr><name>pi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>





<if_stmt><if>if <condition>(<expr><name>comm</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>comm</name><operator>-&gt;</operator><name>owner</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
<name><name>comm</name><operator>-&gt;</operator><name>owner</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>proxy</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>perr</name> <operator>=</operator> <call>(<modifier>*</modifier><name><name>comm</name><operator>-&gt;</operator><name>owner</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>proxy</name></name>)<argument_list>(<argument><expr><operator>&amp;</operator><name>pdu</name></expr></argument>, <argument><expr><name><name>tport</name><operator>-&gt;</operator><name>transport</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>tport</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name><name>pi</name><operator>-&gt;</operator><name>peer</name></name></expr></argument>, <argument><expr><name><name>pi</name><operator>-&gt;</operator><name>peerlen</name></name></expr></argument>, <argument><expr><name>ierr</name></expr></argument>, <argument><expr><name>vi</name></expr></argument>,
<argument><expr><operator>!</operator><name><name>pi</name><operator>-&gt;</operator><name>cred</name></name> <operator>||</operator> <name><name>pi</name><operator>-&gt;</operator><name>priv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>perr</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>SNMPD_PROXY_OK</name></expr>:</case>
<expr_stmt><expr><call><name>snmp_input_consume</name><argument_list>(<argument><expr><name>pi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>

<case>case <expr><name>SNMPD_PROXY_REJ</name></expr>:</case>
<break>break;</break>

<case>case <expr><name>SNMPD_PROXY_DROP</name></expr>:</case>
<expr_stmt><expr><call><name>snmp_input_consume</name><argument_list>(<argument><expr><name>pi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>snmp_pdu_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pdu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>snmpd_stats</name><operator>.</operator><name>proxyDrops</name></name><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>

<case>case <expr><name>SNMPD_PROXY_BADCOMM</name></expr>:</case>
<expr_stmt><expr><call><name>snmp_input_consume</name><argument_list>(<argument><expr><name>pi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>snmp_pdu_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pdu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>snmpd_stats</name><operator>.</operator><name>inBadCommunityNames</name></name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>snmpd</name><operator>.</operator><name>auth_traps</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>snmp_send_trap</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid_authenticationFailure</name></expr></argument>,
<argument><expr><operator>(</operator>struct <name>snmp_value</name> <operator>*</operator><operator>)</operator><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>

<case>case <expr><name>SNMPD_PROXY_BADCOMMUSE</name></expr>:</case>
<expr_stmt><expr><call><name>snmp_input_consume</name><argument_list>(<argument><expr><name>pi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>snmp_pdu_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pdu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>snmpd_stats</name><operator>.</operator><name>inBadCommunityUses</name></name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>snmpd</name><operator>.</operator><name>auth_traps</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>snmp_send_trap</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid_authenticationFailure</name></expr></argument>,
<argument><expr><operator>(</operator>struct <name>snmp_value</name> <operator>*</operator><operator>)</operator><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><name><name>pdu</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>SNMP_PDU_RESPONSE</name> <operator>||</operator>
<name><name>pdu</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>SNMP_PDU_TRAP</name> <operator>||</operator>
<name><name>pdu</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>SNMP_PDU_TRAP2</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>snmpd_stats</name><operator>.</operator><name>silentDrops</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>snmpd_stats</name><operator>.</operator><name>inBadPduTypes</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>snmp_pdu_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pdu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>snmp_input_consume</name><argument_list>(<argument><expr><name>pi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><name><name>pdu</name><operator>.</operator><name>version</name></name> <operator>&lt;</operator> <name>SNMP_V3</name> <operator>&amp;&amp;</operator>
<operator>(</operator><operator>(</operator><name><name>pi</name><operator>-&gt;</operator><name>cred</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pi</name><operator>-&gt;</operator><name>priv</name></name> <operator>&amp;&amp;</operator> <name><name>pdu</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>SNMP_PDU_SET</name><operator>)</operator> <operator>||</operator>
<operator>(</operator><name>comm</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>comm</name><operator>-&gt;</operator><name>private</name></name> <operator>!=</operator> <name>COMM_WRITE</name> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>pdu</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>SNMP_PDU_SET</name> <operator>||</operator> <name><name>comm</name><operator>-&gt;</operator><name>private</name></name> <operator>!=</operator> <name>COMM_READ</name><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>snmpd_stats</name><operator>.</operator><name>inBadCommunityUses</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>snmp_pdu_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pdu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>snmp_input_consume</name><argument_list>(<argument><expr><name>pi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>snmpd</name><operator>.</operator><name>auth_traps</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>snmp_send_trap</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid_authenticationFailure</name></expr></argument>,
<argument><expr><operator>(</operator>struct <name>snmp_value</name> <operator>*</operator><operator>)</operator><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><operator>(</operator><name>sndbuf</name> <operator>=</operator> <call><name>buf_alloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>snmpd_stats</name><operator>.</operator><name>silentDrops</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>snmp_pdu_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pdu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>snmp_input_consume</name><argument_list>(<argument><expr><name>pi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ferr</name> <operator>=</operator> <call><name>snmp_input_finish</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pdu</name></expr></argument>, <argument><expr><name><name>pi</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>pi</name><operator>-&gt;</operator><name>length</name></name></expr></argument>,
<argument><expr><name>sndbuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sndlen</name></expr></argument>, <argument><expr><literal type="string">"SNMP"</literal></expr></argument>, <argument><expr><name>ierr</name></expr></argument>, <argument><expr><name>vi</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ferr</name> <operator>==</operator> <name>SNMPD_INPUT_OK</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>tport</name><operator>-&gt;</operator><name>transport</name><operator>-&gt;</operator><name>vtab</name><operator>-&gt;</operator><name>send</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>slen</name> <operator>=</operator> <call><name><name>tport</name><operator>-&gt;</operator><name>transport</name><operator>-&gt;</operator><name>vtab</name><operator>-&gt;</operator><name>send</name></name><argument_list>(<argument><expr><name>tport</name></expr></argument>, <argument><expr><name>sndbuf</name></expr></argument>,
<argument><expr><name>sndlen</name></expr></argument>, <argument><expr><name><name>pi</name><operator>-&gt;</operator><name>peer</name></name></expr></argument>, <argument><expr><name><name>pi</name><operator>-&gt;</operator><name>peerlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>slen</name> <operator>=</operator> <call><name><name>tport</name><operator>-&gt;</operator><name>transport</name><operator>-&gt;</operator><name>vtab</name><operator>-&gt;</operator><name>send2</name></name><argument_list>(<argument><expr><name>tport</name></expr></argument>, <argument><expr><name>sndbuf</name></expr></argument>,
<argument><expr><name>sndlen</name></expr></argument>, <argument><expr><name>pi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>slen</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><literal type="string">"send*: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>(</operator><name>size_t</name><operator>)</operator><name>slen</name> <operator>!=</operator> <name>sndlen</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><literal type="string">"send*: short write %zu/%zu"</literal></expr></argument>, <argument><expr><name>sndlen</name></expr></argument>,
<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>snmp_pdu_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pdu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>sndbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>snmp_input_consume</name><argument_list>(<argument><expr><name>pi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>





<function><type><name>void</name></type>
<name>snmp_send_port</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>targ</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>asn_oid</name></name> <modifier>*</modifier></type><name>port</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>snmp_pdu</name></name> <modifier>*</modifier></type><name>pdu</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>sockaddr</name></name> <modifier>*</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><name>socklen_t</name></type> <name>addrlen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>transport</name></name> <modifier>*</modifier></type><name>trans</name> <init>= <expr><name>targ</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>tport</name></name> <modifier>*</modifier></type><name>tp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>u_char</name> <modifier>*</modifier></type><name>sndbuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>sndlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>len</name></decl>;</decl_stmt>

<macro><name>TAILQ_FOREACH</name><argument_list>(<argument>tp</argument>, <argument>&amp;trans-&gt;table</argument>, <argument>link</argument>)</argument_list></macro>
<if_stmt><if>if <condition>(<expr><call><name>asn_compare_oid</name><argument_list>(<argument><expr><name>port</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tp</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>tp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>sndbuf</name> <operator>=</operator> <call><name>buf_alloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>snmp_output</name><argument_list>(<argument><expr><name>pdu</name></expr></argument>, <argument><expr><name>sndbuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sndlen</name></expr></argument>, <argument><expr><literal type="string">"SNMP PROXY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>trans</name><operator>-&gt;</operator><name>vtab</name><operator>-&gt;</operator><name>send</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name><name>trans</name><operator>-&gt;</operator><name>vtab</name><operator>-&gt;</operator><name>send</name></name><argument_list>(<argument><expr><name>tp</name></expr></argument>, <argument><expr><name>sndbuf</name></expr></argument>, <argument><expr><name>sndlen</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>addrlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name><name>trans</name><operator>-&gt;</operator><name>vtab</name><operator>-&gt;</operator><name>send2</name></name><argument_list>(<argument><expr><name>tp</name></expr></argument>, <argument><expr><name>sndbuf</name></expr></argument>, <argument><expr><name>sndlen</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><literal type="string">"sendto: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>(</operator><name>size_t</name><operator>)</operator><name>len</name> <operator>!=</operator> <name>sndlen</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><literal type="string">"sendto: short write %zu/%zu"</literal></expr></argument>,
<argument><expr><name>sndlen</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>sndbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>







<function><type><name>void</name></type>
<name>snmpd_input_close</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>port_input</name></name> <modifier>*</modifier></type><name>pi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>pi</name><operator>-&gt;</operator><name>id</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fd_deselect</name><argument_list>(<argument><expr><name><name>pi</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pi</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>pi</name><operator>-&gt;</operator><name>fd</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>close</name><argument_list>(<argument><expr><name><name>pi</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pi</name><operator>-&gt;</operator><name>fd</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>pi</name><operator>-&gt;</operator><name>buf</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>pi</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pi</name><operator>-&gt;</operator><name>buf</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>






<function><type><name>void</name></type>
<name>snmpd_input_init</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>port_input</name></name> <modifier>*</modifier></type><name>pi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>pi</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pi</name><operator>-&gt;</operator><name>fd</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pi</name><operator>-&gt;</operator><name>buf</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>




<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_LIBBEGEMOT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type>
<name>info_func</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
static <name>void</name>
<name>info_func</name><argument_list>(<argument><expr><name>evContext</name> <name>ctx</name> <name>__unused</name></expr></argument>, <argument><expr><name>void</name> <operator>*</operator><name>uap</name> <name>__unused</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>void</name> <operator>*</operator><name>tag</name> <name>__unused</name></expr></argument>)</argument_list>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>lmodule</name></name> <modifier>*</modifier></type><name>m</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>u_int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">10000</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"Dump of SNMPd %lu\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>u_long</name><operator>)</operator><call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>tree_size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<switch>switch <condition>(<expr><name><name>tree</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>SNMP_NODE_LEAF</name></expr>:</case>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"LEAF: %s %s"</literal></expr></argument>, <argument><expr><name><name>tree</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>,
<argument><expr><call><name>asn_oid2str</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tree</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>SNMP_NODE_COLUMN</name></expr>:</case>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"COL: %s %s"</literal></expr></argument>, <argument><expr><name><name>tree</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>,
<argument><expr><call><name>asn_oid2str</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tree</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<macro><name>TAILQ_FOREACH</name><argument_list>(<argument>m</argument>, <argument>&amp;lmodules</argument>, <argument>link</argument>)</argument_list></macro>
<if_stmt><if>if <condition>(<expr><name><name>m</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>dump</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call>(<modifier>*</modifier><name><name>m</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>dump</name></name>)<argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></decl></decl_stmt>




<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_LIBBEGEMOT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type>
<name>config_func</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
static <name>void</name>
<name>config_func</name><argument_list>(<argument><expr><name>evContext</name> <name>ctx</name> <name>__unused</name></expr></argument>, <argument><expr><name>void</name> <operator>*</operator><name>uap</name> <name>__unused</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>void</name> <operator>*</operator><name>tag</name> <name>__unused</name></expr></argument>)</argument_list>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>lmodule</name></name> <modifier>*</modifier></type><name>m</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>read_config</name><argument_list>(<argument><expr><name>config_file</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><literal type="string">"error reading config file '%s'"</literal></expr></argument>, <argument><expr><name>config_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<macro><name>TAILQ_FOREACH</name><argument_list>(<argument>m</argument>, <argument>&amp;lmodules</argument>, <argument>link</argument>)</argument_list></macro>
<if_stmt><if>if <condition>(<expr><name><name>m</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>config</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call>(<modifier>*</modifier><name><name>m</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>config</name></name>)<argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></decl></decl_stmt>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>onusr1</name><parameter_list>(<parameter><decl><type><name>int</name> <name>s</name></type> <name>__unused</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<expr_stmt><expr><name>work</name> <operator>|=</operator> <name>WORK_DOINFO</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>onhup</name><parameter_list>(<parameter><decl><type><name>int</name> <name>s</name></type> <name>__unused</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<expr_stmt><expr><name>work</name> <operator>|=</operator> <name>WORK_RECONFIG</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>onterm</name><parameter_list>(<parameter><decl><type><name>int</name> <name>s</name></type> <name>__unused</name></decl></parameter>)</parameter_list>
<block>{<block_content>


<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_sigs</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>sigaction</name></name></type> <name>sa</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>sa</name><operator>.</operator><name>sa_handler</name></name> <operator>=</operator> <name>onusr1</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sa</name><operator>.</operator><name>sa_flags</name></name> <operator>=</operator> <name>SA_RESTART</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sigemptyset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sa</name><operator>.</operator><name>sa_mask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>sigaction</name><argument_list>(<argument><expr><name>SIGUSR1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sa</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><literal type="string">"sigaction: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>sa</name><operator>.</operator><name>sa_handler</name></name> <operator>=</operator> <name>onhup</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>sigaction</name><argument_list>(<argument><expr><name>SIGHUP</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sa</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><literal type="string">"sigaction: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>sa</name><operator>.</operator><name>sa_handler</name></name> <operator>=</operator> <name>onterm</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sa</name><operator>.</operator><name>sa_flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sigemptyset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sa</name><operator>.</operator><name>sa_mask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>sigaction</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sa</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><literal type="string">"sigaction: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>sigaction</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sa</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><literal type="string">"sigaction: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>block_sigs</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>sigset_t</name></type> <name>set</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sigfillset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>sigprocmask</name><argument_list>(<argument><expr><name>SIG_BLOCK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>set</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blocked_sigs</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><literal type="string">"SIG_BLOCK: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>unblock_sigs</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>sigprocmask</name><argument_list>(<argument><expr><name>SIG_SETMASK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>blocked_sigs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><literal type="string">"SIG_SETMASK: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>term</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>unlink</name><argument_list>(<argument><expr><name>pid_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>trans_stop</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>transport</name></name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>

<macro><name>TAILQ_FOREACH</name><argument_list>(<argument>t</argument>, <argument>&amp;transport_list</argument>, <argument>link</argument>)</argument_list></macro>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name><name>t</name><operator>-&gt;</operator><name>vtab</name><operator>-&gt;</operator><name>stop</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>do_macro</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>eq</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>eq</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>define_macro</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>eq</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>define_macro</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>eq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>err</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><literal type="string">"cannot save macro: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type>
<name>getsubopt1</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>options</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>valp</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>optp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>delim</name> <init>= <expr><literal type="string">",\t "</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>u_int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>optp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>


<for>for <control>(<init><expr><name>ptr</name> <operator>=</operator> <operator>*</operator><name>arg</name></expr>;</init> <condition><expr><operator>*</operator><name>ptr</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>ptr</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>delim</name></expr></argument>, <argument><expr><operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>optp</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>


<while>while <condition>(<expr><operator>*</operator><operator>++</operator><name>ptr</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>delim</name></expr></argument>, <argument><expr><operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt></block_content></block></while>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>ptr</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>valp</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>ptr</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>delim</name></expr></argument>, <argument><expr><operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>ptr</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>ptr</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>*</operator><name>options</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>options</name><operator>++</operator></expr><operator>,</operator> <expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><operator>*</operator><name>optp</name></expr></argument>, <argument><expr><operator>*</operator><name>options</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>i</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>opt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>background</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>tport</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name> <init>= <expr><literal type="string">"snmpd"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>lmodule</name></name> <modifier>*</modifier></type><name>m</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>option</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>transport</name></name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DBG_DUMP</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DBG_EVENTS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DBG_TRACE</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>debug_opts</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"dump"</literal></expr>,
<expr><literal type="string">"events"</literal></expr>,
<expr><literal type="string">"trace"</literal></expr>,
<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>snmp_printf</name> <operator>=</operator> <name>snmp_printf_func</name></expr>;</expr_stmt>
<expr_stmt><expr><name>snmp_error</name> <operator>=</operator> <name>snmp_error_func</name></expr>;</expr_stmt>
<expr_stmt><expr><name>snmp_debug</name> <operator>=</operator> <name>snmp_debug_func</name></expr>;</expr_stmt>
<expr_stmt><expr><name>asn_error</name> <operator>=</operator> <name>asn_error_func</name></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>(</operator><name>opt</name> <operator>=</operator> <call><name>getopt</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"c:dD:e:hI:l:m:p:"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content>
<switch>switch <condition>(<expr><name>opt</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'c'</literal></expr>:</case>
<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>config_file</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>config_file</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'d'</literal></expr>:</case>
<expr_stmt><expr><name>background</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'D'</literal></expr>:</case>
<while>while <condition>(<expr><operator>*</operator><name>optarg</name></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><call><name>getsubopt1</name><argument_list>(<argument><expr><operator>&amp;</operator><name>optarg</name></expr></argument>, <argument><expr><name>debug_opts</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>option</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>DBG_DUMP</name></expr>:</case>
<expr_stmt><expr><name><name>debug</name><operator>.</operator><name>dump_pdus</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DBG_EVENTS</name></expr>:</case>
<expr_stmt><expr><name><name>debug</name><operator>.</operator><name>evdebug</name></name><operator>++</operator></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DBG_TRACE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>value</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>,
<argument><expr><literal type="string">"no value for 'trace'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>snmp_trace</name> <operator>=</operator> <call><name>strtoul</name><argument_list>(<argument><expr><name>value</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<break>break;</break>

<case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>suboptarg</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>,
<argument><expr><literal type="string">"unknown debug flag '%s'"</literal></expr></argument>,
<argument><expr><name>option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>,
<argument><expr><literal type="string">"missing debug flag"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></while>
<break>break;</break>

<case>case <expr><literal type="char">'e'</literal></expr>:</case>
<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>engine_file</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>engine_file</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'h'</literal></expr>:</case>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>usgtxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><literal type="char">'I'</literal></expr>:</case>
<expr_stmt><expr><name>syspath</name> <operator>=</operator> <name>optarg</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'l'</literal></expr>:</case>
<expr_stmt><expr><name>prefix</name> <operator>=</operator> <name>optarg</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'m'</literal></expr>:</case>
<expr_stmt><expr><call><name>do_macro</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'p'</literal></expr>:</case>
<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>pid_file</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pid_file</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch></block_content></block></while>

<expr_stmt><expr><call><name>openlog</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>LOG_PID</name> <operator>|</operator> <operator>(</operator><ternary><condition><expr><name>background</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>LOG_PERROR</name></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name>LOG_USER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setlogmask</name><argument_list>(<argument><expr><call><name>LOG_UPTO</name><argument_list>(<argument><expr><name><name>debug</name><operator>.</operator><name>logpri</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>background</name> <operator>&amp;&amp;</operator> <call><name>daemon</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><literal type="string">"daemon: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>argc</name> <operator>-=</operator> <name>optind</name></expr>;</expr_stmt>
<expr_stmt><expr><name>argv</name> <operator>+=</operator> <name>optind</name></expr>;</expr_stmt>

<expr_stmt><expr><name>progargs</name> <operator>=</operator> <name>argv</name></expr>;</expr_stmt>
<expr_stmt><expr><name>nprogargs</name> <operator>=</operator> <name>argc</name></expr>;</expr_stmt>

<expr_stmt><expr><name>snmp_serial_no</name> <operator>=</operator> <call><name>arc4random</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_TCPWRAPPERS</name></expr></argument>)</argument_list></call></expr></cpp:if>



<expr_stmt><expr><call><name>request_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>req</name></expr></argument>, <argument><expr><name>RQ_DAEMON</name></expr></argument>, <argument><expr><literal type="string">"snmpd"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sock_methods</name><argument_list>(<argument><expr><operator>&amp;</operator><name>req</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>




<if_stmt><if>if <condition>(<expr><operator>(</operator><name>tree</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>snmp_node</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>CTREE_SIZE</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><literal type="string">"%m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>ctree</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>snmp_node</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>CTREE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tree_size</name> <operator>=</operator> <name>CTREE_SIZE</name></expr>;</expr_stmt>




<expr_stmt><expr><call><name>comm_define</name><argument_list>(<argument><expr><name>COMM_READ</name></expr></argument>, <argument><expr><literal type="string">"SNMP read"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>comm_define</name><argument_list>(<argument><expr><name>COMM_WRITE</name></expr></argument>, <argument><expr><literal type="string">"SNMP write"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>community</name> <operator>=</operator> <name>COMM_INITIALIZE</name></expr>;</expr_stmt>

<expr_stmt><expr><name>trap_reqid</name> <operator>=</operator> <call><name>reqid_allocate</name><argument_list>(<argument><expr><literal type="number">512</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>config_file</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>config_file</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>config_file</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>PATH_CONFIG</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>init_actvals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>init_snmpd_engine</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>this_tick</name> <operator>=</operator> <call><name>get_ticks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>start_tick</name> <operator>=</operator> <name>this_tick</name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>atexit</name><argument_list>(<argument><expr><name>trans_stop</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><literal type="string">"atexit failed: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>udp_trans</name><operator>.</operator><name>start</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>SNMP_ERR_NOERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_WARNING</name></expr></argument>, <argument><expr><literal type="string">"cannot start UDP transport"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>lsock_trans</name><operator>.</operator><name>start</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>SNMP_ERR_NOERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_WARNING</name></expr></argument>, <argument><expr><literal type="string">"cannot start LSOCK transport"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>inet_trans</name><operator>.</operator><name>start</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>SNMP_ERR_NOERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_WARNING</name></expr></argument>, <argument><expr><literal type="string">"cannot start INET transport"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_LIBBEGEMOT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>debug</name><operator>.</operator><name>evdebug</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>rpoll_trace</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if_stmt><if>if <condition>(<expr><call><name>evCreate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>evctx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><literal type="string">"evCreate: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>debug</name><operator>.</operator><name>evdebug</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>evSetDebug</name><argument_list>(<argument><expr><name>evctx</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name><name>engine_file</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>engine_file</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>engine_file</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>PATH_ENGINE</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>read_config</name><argument_list>(<argument><expr><name>config_file</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><literal type="string">"error in config file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<macro><name>TAILQ_FOREACH</name><argument_list>(<argument>t</argument>, <argument>&amp;transport_list</argument>, <argument>link</argument>)</argument_list></macro>
<macro><name>TAILQ_FOREACH</name><argument_list>(<argument>p</argument>, <argument>&amp;t-&gt;table</argument>, <argument>link</argument>)</argument_list></macro>
<expr_stmt><expr><call><name><name>t</name><operator>-&gt;</operator><name>vtab</name><operator>-&gt;</operator><name>init_port</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>init_sigs</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>pid_file</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>pid_file</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pid_file</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>PATH_PID</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fp</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>pid_file</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>atexit</name><argument_list>(<argument><expr><name>term</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><literal type="string">"atexit failed: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>remove</name><argument_list>(<argument><expr><name>pid_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>or_register</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid_snmpMIB</name></expr></argument>, <argument><expr><literal type="string">"The MIB module for SNMPv2 entities."</literal></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><literal type="string">"cannot register SNMPv2 MIB"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>or_register</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid_begemotSnmpd</name></expr></argument>, <argument><expr><literal type="string">"The MIB module for the Begemot SNMPd."</literal></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><literal type="string">"cannot register begemotSnmpd MIB"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><operator>(</operator><name>m</name> <operator>=</operator> <call><name>TAILQ_FIRST</name><argument_list>(<argument><expr><operator>&amp;</operator><name>modules_start</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>LM_ONSTARTLIST</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TAILQ_REMOVE</name><argument_list>(<argument><expr><operator>&amp;</operator><name>modules_start</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lm_start</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>

<expr_stmt><expr><call><name>snmp_send_trap</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oid_coldStart</name></expr></argument>, <argument><expr><operator>(</operator>struct <name>snmp_value</name> <operator>*</operator><operator>)</operator><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>USE_LIBBEGEMOT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>evEvent</name></type> <name>event</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name><name>struct</name> <name>lmodule</name></name> <modifier>*</modifier></type><name>mod</name></decl>;</decl_stmt>

<macro><name>TAILQ_FOREACH</name><argument_list>(<argument>mod</argument>, <argument>&amp;lmodules</argument>, <argument>link</argument>)</argument_list></macro>
<if_stmt><if>if <condition>(<expr><name><name>mod</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>idle</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call>(<modifier>*</modifier><name><name>mod</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>idle</name></name>)<argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>USE_LIBBEGEMOT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>evGetNext</name><argument_list>(<argument><expr><name>evctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>event</name></expr></argument>, <argument><expr><name>EV_WAIT</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>evDispatch</name><argument_list>(<argument><expr><name>evctx</name></expr></argument>, <argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><literal type="string">"evDispatch: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>EINTR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><literal type="string">"evGetNext: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>poll_dispatch</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>work</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>block_sigs</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>work</name> <operator>&amp;</operator> <name>WORK_DOINFO</name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_LIBBEGEMOT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>info_func</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if_stmt><if>if <condition>(<expr><call><name>evWaitFor</name><argument_list>(<argument><expr><name>evctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>work</name></expr></argument>, <argument><expr><name>info_func</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><literal type="string">"evWaitFor: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>work</name> <operator>&amp;</operator> <name>WORK_RECONFIG</name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_LIBBEGEMOT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>config_func</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if_stmt><if>if <condition>(<expr><call><name>evWaitFor</name><argument_list>(<argument><expr><name>evctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>work</name></expr></argument>, <argument><expr><name>config_func</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><literal type="string">"evWaitFor: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>work</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>unblock_sigs</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>USE_LIBBEGEMOT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>evDo</name><argument_list>(<argument><expr><name>evctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>work</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><literal type="string">"evDo: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>uint64_t</name></type>
<name>get_ticks</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>ret</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name><name>tv</name><operator>.</operator><name>tv_sec</name></name> <operator>*</operator> <literal type="number">100ULL</literal> <operator>+</operator> <name><name>tv</name><operator>.</operator><name>tv_usec</name></name> <operator>/</operator> <literal type="number">10000ULL</literal></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ret</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>








<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_LIBBEGEMOT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type>
<name>tfunc</name><argument_list>(<argument><expr><name>int</name> <name>tid</name> <name>__unused</name></expr></argument>, <argument><expr><name>void</name> <operator>*</operator><name>uap</name></expr></argument>)</argument_list>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
static <name>void</name>
<name>tfunc</name><argument_list>(<argument><expr><name>evContext</name> <name>ctx</name> <name>__unused</name></expr></argument>, <argument><expr><name>void</name> <operator>*</operator><name>uap</name></expr></argument>, <argument><expr>struct <name>timespec</name> <name>due</name> <name>__unused</name></expr></argument>,
<argument><expr>struct <name>timespec</name> <name>inter</name> <name>__unused</name></expr></argument>)</argument_list>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>timer</name></name> <modifier>*</modifier></type><name>tp</name> <init>= <expr><name>uap</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>LIST_REMOVE</name><argument_list>(<argument><expr><name>tp</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>tp</name><operator>-&gt;</operator><name>func</name></name><argument_list>(<argument><expr><name><name>tp</name><operator>-&gt;</operator><name>udata</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>




<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_LIBBEGEMOT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type>
<name>trfunc</name><argument_list>(<argument><expr><name>int</name> <name>tid</name> <name>__unused</name></expr></argument>, <argument><expr><name>void</name> <operator>*</operator><name>uap</name></expr></argument>)</argument_list>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
static <name>void</name>
<name>trfunc</name><argument_list>(<argument><expr><name>evContext</name> <name>ctx</name> <name>__unused</name></expr></argument>, <argument><expr><name>void</name> <operator>*</operator><name>uap</name></expr></argument>, <argument><expr>struct <name>timespec</name> <name>due</name> <name>__unused</name></expr></argument>,
<argument><expr>struct <name>timespec</name> <name>inter</name> <name>__unused</name></expr></argument>)</argument_list>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>timer</name></name> <modifier>*</modifier></type><name>tp</name> <init>= <expr><name>uap</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name><name>tp</name><operator>-&gt;</operator><name>func</name></name><argument_list>(<argument><expr><name><name>tp</name><operator>-&gt;</operator><name>udata</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>




<function><type><name>void</name> <modifier>*</modifier></type>
<name>timer_start</name><parameter_list>(<parameter><decl><type><name>u_int</name></type> <name>ticks</name></decl></parameter>, <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>udata</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>lmodule</name></name> <modifier>*</modifier></type><name>mod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>timer</name></name> <modifier>*</modifier></type><name>tp</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>USE_LIBBEGEMOT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name><name>struct</name> <name>timespec</name></name></type> <name>due</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>tp</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>timer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_CRIT</name></expr></argument>, <argument><expr><literal type="string">"out of memory for timer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>USE_LIBBEGEMOT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>due</name> <operator>=</operator> <call><name>evAddTime</name><argument_list>(<argument><expr><call><name>evNowTime</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>evConsTime</name><argument_list>(<argument><expr><name>ticks</name> <operator>/</operator> <literal type="number">100</literal></expr></argument>, <argument><expr><operator>(</operator><name>ticks</name> <operator>%</operator> <literal type="number">100</literal><operator>)</operator> <operator>*</operator> <literal type="number">10000</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name><name>tp</name><operator>-&gt;</operator><name>udata</name></name> <operator>=</operator> <name>udata</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tp</name><operator>-&gt;</operator><name>owner</name></name> <operator>=</operator> <name>mod</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tp</name><operator>-&gt;</operator><name>func</name></name> <operator>=</operator> <name>func</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>LIST_INSERT_HEAD</name><argument_list>(<argument><expr><operator>&amp;</operator><name>timer_list</name></expr></argument>, <argument><expr><name>tp</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_LIBBEGEMOT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>tp</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <call><name>poll_start_timer</name><argument_list>(<argument><expr><name>ticks</name> <operator>*</operator> <literal type="number">10</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>tfunc</name></expr></argument>, <argument><expr><name>tp</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><literal type="string">"cannot set timer: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if_stmt><if>if <condition>(<expr><call><name>evSetTimer</name><argument_list>(<argument><expr><name>evctx</name></expr></argument>, <argument><expr><name>tfunc</name></expr></argument>, <argument><expr><name>tp</name></expr></argument>, <argument><expr><name>due</name></expr></argument>, <argument><expr><call><name>evConsTime</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tp</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call>
<operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><literal type="string">"cannot set timer: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><operator>(</operator><name>tp</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>






<function><type><name>void</name> <modifier>*</modifier></type>
<name>timer_start_repeat</name><parameter_list>(<parameter><decl><type><name>u_int</name> <name>ticks</name></type> <name>__unused</name></decl></parameter>, <parameter><decl><type><name>u_int</name></type> <name>repeat_ticks</name></decl></parameter>,
<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>udata</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>lmodule</name></name> <modifier>*</modifier></type><name>mod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>timer</name></name> <modifier>*</modifier></type><name>tp</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>USE_LIBBEGEMOT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name><name>struct</name> <name>timespec</name></name></type> <name>due</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>timespec</name></name></type> <name>inter</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>tp</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>timer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_CRIT</name></expr></argument>, <argument><expr><literal type="string">"out of memory for timer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>USE_LIBBEGEMOT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>due</name> <operator>=</operator> <call><name>evAddTime</name><argument_list>(<argument><expr><call><name>evNowTime</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>evConsTime</name><argument_list>(<argument><expr><name>ticks</name> <operator>/</operator> <literal type="number">100</literal></expr></argument>, <argument><expr><operator>(</operator><name>ticks</name> <operator>%</operator> <literal type="number">100</literal><operator>)</operator> <operator>*</operator> <literal type="number">10000</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>inter</name> <operator>=</operator> <call><name>evConsTime</name><argument_list>(<argument><expr><name>repeat_ticks</name> <operator>/</operator> <literal type="number">100</literal></expr></argument>, <argument><expr><operator>(</operator><name>repeat_ticks</name> <operator>%</operator> <literal type="number">100</literal><operator>)</operator> <operator>*</operator> <literal type="number">10000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name><name>tp</name><operator>-&gt;</operator><name>udata</name></name> <operator>=</operator> <name>udata</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tp</name><operator>-&gt;</operator><name>owner</name></name> <operator>=</operator> <name>mod</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tp</name><operator>-&gt;</operator><name>func</name></name> <operator>=</operator> <name>func</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>LIST_INSERT_HEAD</name><argument_list>(<argument><expr><operator>&amp;</operator><name>timer_list</name></expr></argument>, <argument><expr><name>tp</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_LIBBEGEMOT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>tp</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <call><name>poll_start_timer</name><argument_list>(<argument><expr><name>repeat_ticks</name> <operator>*</operator> <literal type="number">10</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>trfunc</name></expr></argument>, <argument><expr><name>tp</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><literal type="string">"cannot set timer: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if_stmt><if>if <condition>(<expr><call><name>evSetTimer</name><argument_list>(<argument><expr><name>evctx</name></expr></argument>, <argument><expr><name>trfunc</name></expr></argument>, <argument><expr><name>tp</name></expr></argument>, <argument><expr><name>due</name></expr></argument>, <argument><expr><name>inter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tp</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><literal type="string">"cannot set timer: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><operator>(</operator><name>tp</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>




<function><type><name>void</name></type>
<name>timer_stop</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>timer</name></name> <modifier>*</modifier></type><name>tp</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>LIST_REMOVE</name><argument_list>(<argument><expr><name>tp</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_LIBBEGEMOT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>poll_stop_timer</name><argument_list>(<argument><expr><name><name>tp</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if_stmt><if>if <condition>(<expr><call><name>evClearTimer</name><argument_list>(<argument><expr><name>evctx</name></expr></argument>, <argument><expr><name><name>tp</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><literal type="string">"cannot stop timer: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>timer_flush</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>lmodule</name></name> <modifier>*</modifier></type><name>mod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>timer</name></name> <modifier>*</modifier></type><name>t</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>t1</name></decl>;</decl_stmt>

<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>LIST_FIRST</name><argument_list>(<argument><expr><operator>&amp;</operator><name>timer_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>t</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>t1</name> <operator>=</operator> <call><name>LIST_NEXT</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>owner</name></name> <operator>==</operator> <name>mod</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>timer_stop</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>t</name> <operator>=</operator> <name>t1</name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>snmp_printf_func</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>pend</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ret</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>new</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vasprintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ret</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>pend</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>new</name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><name>pend</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>pend</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator>
<operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>pend</name> <operator>=</operator> <name>new</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>pend</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>pend</name> <operator>=</operator> <name>ret</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<while>while <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>pend</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>ret</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>pend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>ret</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>pend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pend</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>pend</name></expr></argument>, <argument><expr><name>ret</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>snmp_error_func</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>err</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>errbuf</name><index>[<expr><literal type="number">1000</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>snmp_trace</name> <operator>&amp;</operator> <name>LOG_SNMP_ERRORS</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"SNMP: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vsnprintf</name><argument_list>(<argument><expr><name>errbuf</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>err</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>snmp_debug_func</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>err</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>errbuf</name><index>[<expr><literal type="number">1000</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"SNMP: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vsnprintf</name><argument_list>(<argument><expr><name>errbuf</name><operator>+</operator><call><name>strlen</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></sizeof><operator>-</operator><call><name>strlen</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>err</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_DEBUG</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>asn_error_func</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>asn_buf</name></name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>err</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>errbuf</name><index>[<expr><literal type="number">1000</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>u_int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>snmp_trace</name> <operator>&amp;</operator> <name>LOG_ASN1_ERRORS</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"ASN.1: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vsnprintf</name><argument_list>(<argument><expr><name>errbuf</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>err</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>b</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>errbuf</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">" at"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>b</name><operator>-&gt;</operator><name>asn_len</name></name> <operator>&gt;</operator> <name>i</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>errbuf</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><literal type="string">" %02x"</literal></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>asn_cptr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><name><name>struct</name> <name>community</name></name><modifier>*</modifier></type>
<name>comm_define_ordered</name><parameter_list>(<parameter><decl><type><name>u_int</name></type> <name>priv</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>descr</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>asn_oid</name></name> <modifier>*</modifier></type><name>idx</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>lmodule</name></name> <modifier>*</modifier></type><name>owner</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>community</name></name> <modifier>*</modifier></type><name>c</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>u_int</name></type> <name>ncomm</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ncomm</name> <operator>=</operator> <name><name>idx</name><operator>-&gt;</operator><name>subs</name><index>[<expr><name><name>idx</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>


<macro><name>TAILQ_FOREACH</name><argument_list>(<argument>c</argument>, <argument>&amp;community_list</argument>, <argument>link</argument>)</argument_list></macro>
<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>value</name></name> <operator>==</operator> <name>ncomm</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>c</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>community</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><literal type="string">"%s: %m"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>owner</name></name> <operator>=</operator> <name>owner</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name>ncomm</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>descr</name></name> <operator>=</operator> <name>descr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>string</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>private</name></name> <operator>=</operator> <name>priv</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>str</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>string</name></name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>string</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>



<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <operator>*</operator><name>idx</name></expr>;</expr_stmt>
<macro><name>TAILQ_FOREACH</name><argument_list>(<argument>p</argument>, <argument>&amp;community_list</argument>, <argument>link</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>asn_compare_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>TAILQ_INSERT_BEFORE</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>TAILQ_INSERT_TAIL</name><argument_list>(<argument><expr><operator>&amp;</operator><name>community_list</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><name>c</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>u_int</name></type>
<name>comm_define</name><parameter_list>(<parameter><decl><type><name>u_int</name></type> <name>priv</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>descr</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>lmodule</name></name> <modifier>*</modifier></type><name>owner</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>asn_oid</name></name></type> <name>idx</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>community</name></name> <modifier>*</modifier></type><name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>u_int</name></type> <name>ncomm</name></decl>;</decl_stmt>


<do>do <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ncomm</name> <operator>=</operator> <name>next_community_index</name><operator>++</operator><operator>)</operator> <operator>==</operator> <name>UINT_MAX</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>next_community_index</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<macro><name>TAILQ_FOREACH</name><argument_list>(<argument>c</argument>, <argument>&amp;community_list</argument>, <argument>link</argument>)</argument_list></macro>
<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>value</name></name> <operator>==</operator> <name>ncomm</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block> while <condition>(<expr><name>c</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>;</do>


<if_stmt><if>if <condition>(<expr><name>owner</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>&amp;</operator><name><name>owner</name><operator>-&gt;</operator><name>index</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>&amp;</operator><name>idx</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>subs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>subs</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>len</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>ncomm</name></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>comm_define_ordered</name><argument_list>(<argument><expr><name>priv</name></expr></argument>, <argument><expr><name>descr</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>owner</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>value</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>comm_string</name><parameter_list>(<parameter><decl><type><name>u_int</name></type> <name>ncomm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>community</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<macro><name>TAILQ_FOREACH</name><argument_list>(<argument>p</argument>, <argument>&amp;community_list</argument>, <argument>link</argument>)</argument_list></macro>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>value</name></name> <operator>==</operator> <name>ncomm</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>string</name></name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>comm_flush</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>lmodule</name></name> <modifier>*</modifier></type><name>mod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>community</name></name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p1</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>TAILQ_FIRST</name><argument_list>(<argument><expr><operator>&amp;</operator><name>community_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p1</name> <operator>=</operator> <call><name>TAILQ_NEXT</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>owner</name></name> <operator>==</operator> <name>mod</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TAILQ_REMOVE</name><argument_list>(<argument><expr><operator>&amp;</operator><name>community_list</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>p1</name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>






<function><type><name>u_int</name></type>
<name>reqid_allocate</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>lmodule</name></name> <modifier>*</modifier></type><name>mod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>u_int</name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>idrange</name></name> <modifier>*</modifier></type><name>r</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>r1</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>size</name> <operator>&gt;</operator> <name>INT32_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_CRIT</name></expr></argument>, <argument><expr><literal type="string">"%s: size out of range: %d"</literal></expr></argument>, <argument><expr><name>__func__</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<do>do <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>type</name> <operator>=</operator> <name>next_idrange</name><operator>++</operator><operator>)</operator> <operator>==</operator> <name>UINT_MAX</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>next_idrange</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<macro><name>TAILQ_FOREACH</name><argument_list>(<argument>r</argument>, <argument>&amp;idrange_list</argument>, <argument>link</argument>)</argument_list></macro>
<if_stmt><if>if <condition>(<expr><name><name>r</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>type</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block> while<condition>(<expr><name>r</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>;</do>


<if_stmt><if>if <condition>(<expr><call><name>TAILQ_EMPTY</name><argument_list>(<argument><expr><operator>&amp;</operator><name>idrange_list</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>TAILQ_FIRST</name><argument_list>(<argument><expr><operator>&amp;</operator><name>idrange_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>r</name><operator>-&gt;</operator><name>base</name></name> <operator>&lt;</operator> <name>size</name></expr>)</condition> <block>{<block_content>
<while>while<condition>(<expr><operator>(</operator><name>r1</name> <operator>=</operator> <call><name>TAILQ_NEXT</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>r1</name><operator>-&gt;</operator><name>base</name></name> <operator>-</operator> <operator>(</operator><name><name>r</name><operator>-&gt;</operator><name>base</name></name> <operator>+</operator> <name><name>r</name><operator>-&gt;</operator><name>size</name></name><operator>)</operator> <operator>&gt;=</operator> <name>size</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>r1</name></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>r1</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r1</name> <operator>=</operator> <call><name>TAILQ_LAST</name><argument_list>(<argument><expr><operator>&amp;</operator><name>idrange_list</name></expr></argument>, <argument><expr><name>idrange_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>INT32_MAX</name> <operator>-</operator> <name>size</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>r1</name><operator>-&gt;</operator><name>base</name></name> <operator>+</operator> <name><name>r1</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><literal type="string">"out of id ranges (%u)"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>(</operator><name>r1</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>idrange</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><literal type="string">"%s: %m"</literal></expr></argument>, <argument><expr><name>__FUNCTION__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>r1</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>r1</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>r1</name><operator>-&gt;</operator><name>owner</name></name> <operator>=</operator> <name>mod</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>TAILQ_EMPTY</name><argument_list>(<argument><expr><operator>&amp;</operator><name>idrange_list</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>r</name> <operator>==</operator> <call><name>TAILQ_FIRST</name><argument_list>(<argument><expr><operator>&amp;</operator><name>idrange_list</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>r1</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TAILQ_INSERT_HEAD</name><argument_list>(<argument><expr><operator>&amp;</operator><name>idrange_list</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>r</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>TAILQ_LAST</name><argument_list>(<argument><expr><operator>&amp;</operator><name>idrange_list</name></expr></argument>, <argument><expr><name>idrange_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>r1</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <name><name>r</name><operator>-&gt;</operator><name>base</name></name> <operator>+</operator> <name><name>r</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TAILQ_INSERT_TAIL</name><argument_list>(<argument><expr><operator>&amp;</operator><name>idrange_list</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>TAILQ_PREV</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>idrange_list</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>r1</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <name><name>r</name><operator>-&gt;</operator><name>base</name></name> <operator>+</operator> <name><name>r</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TAILQ_INSERT_AFTER</name><argument_list>(<argument><expr><operator>&amp;</operator><name>idrange_list</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>r1</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>r1</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>type</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type>
<name>reqid_next</name><parameter_list>(<parameter><decl><type><name>u_int</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>idrange</name></name> <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name></type> <name>id</name></decl>;</decl_stmt>

<macro><name>TAILQ_FOREACH</name><argument_list>(<argument>r</argument>, <argument>&amp;idrange_list</argument>, <argument>link</argument>)</argument_list></macro>
<if_stmt><if>if <condition>(<expr><name><name>r</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>type</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_CRIT</name></expr></argument>, <argument><expr><literal type="string">"wrong idrange type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>id</name> <operator>=</operator> <name><name>r</name><operator>-&gt;</operator><name>next</name></name><operator>++</operator><operator>)</operator> <operator>==</operator> <name><name>r</name><operator>-&gt;</operator><name>base</name></name> <operator>+</operator> <operator>(</operator><name><name>r</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>r</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><name>id</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type>
<name>reqid_base</name><parameter_list>(<parameter><decl><type><name>u_int</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>idrange</name></name> <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>

<macro><name>TAILQ_FOREACH</name><argument_list>(<argument>r</argument>, <argument>&amp;idrange_list</argument>, <argument>link</argument>)</argument_list></macro>
<if_stmt><if>if <condition>(<expr><name><name>r</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>type</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name><name>r</name><operator>-&gt;</operator><name>base</name></name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_CRIT</name></expr></argument>, <argument><expr><literal type="string">"wrong idrange type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>u_int</name></type>
<name>reqid_type</name><parameter_list>(<parameter><decl><type><name>int32_t</name></type> <name>reqid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>idrange</name></name> <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>

<macro><name>TAILQ_FOREACH</name><argument_list>(<argument>r</argument>, <argument>&amp;idrange_list</argument>, <argument>link</argument>)</argument_list></macro>
<if_stmt><if>if <condition>(<expr><name>reqid</name> <operator>&gt;=</operator> <name><name>r</name><operator>-&gt;</operator><name>base</name></name> <operator>&amp;&amp;</operator> <name>reqid</name> <operator>&lt;=</operator> <name><name>r</name><operator>-&gt;</operator><name>base</name></name> <operator>+</operator> <operator>(</operator><name><name>r</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name><name>r</name><operator>-&gt;</operator><name>type</name></name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>reqid_istype</name><parameter_list>(<parameter><decl><type><name>int32_t</name></type> <name>reqid</name></decl></parameter>, <parameter><decl><type><name>u_int</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><call><name>reqid_type</name><argument_list>(<argument><expr><name>reqid</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>type</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>reqid_flush</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>lmodule</name></name> <modifier>*</modifier></type><name>mod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>idrange</name></name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p1</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>TAILQ_FIRST</name><argument_list>(<argument><expr><operator>&amp;</operator><name>idrange_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p1</name> <operator>=</operator> <call><name>TAILQ_NEXT</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>owner</name></name> <operator>==</operator> <name>mod</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>TAILQ_REMOVE</name><argument_list>(<argument><expr><operator>&amp;</operator><name>idrange_list</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>p1</name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>int</name></type>
<name>compare_node</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>v1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>v2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>snmp_node</name></name> <modifier>*</modifier></type><name>n1</name> <init>= <expr><name>v1</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>snmp_node</name></name> <modifier>*</modifier></type><name>n2</name> <init>= <expr><name>v2</name></expr></init></decl>;</decl_stmt>

<return>return <expr><operator>(</operator><call><name>asn_compare_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>n1</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>n2</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>tree_merge</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>snmp_node</name></name> <modifier>*</modifier></type><name>ntree</name></decl></parameter>, <parameter><decl><type><name>u_int</name></type> <name>nsize</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>lmodule</name></name> <modifier>*</modifier></type><name>mod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>snmp_node</name></name> <modifier>*</modifier></type><name>xtree</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>u_int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>xtree</name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>tree</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>tree_size</name> <operator>+</operator> <name>nsize</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>xtree</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><literal type="string">"tree_merge: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>tree</name> <operator>=</operator> <name>xtree</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tree</name><index>[<expr><name>tree_size</name></expr>]</index></name></expr></argument>, <argument><expr><name>ntree</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>tree</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nsize</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>tree</name><index>[<expr><name>tree_size</name> <operator>+</operator> <name>i</name></expr>]</index></name><operator>.</operator><name>tree_data</name> <operator>=</operator> <name>mod</name></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><name>tree_size</name> <operator>+=</operator> <name>nsize</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>tree_size</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>tree</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>compare_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>tree_unmerge</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>lmodule</name></name> <modifier>*</modifier></type><name>mod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>u_int</name></type> <name>s</name></decl>, <decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>

<for>for<control>(<init><expr><name>s</name> <operator>=</operator> <name>d</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>s</name> <operator>&lt;</operator> <name>tree_size</name></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>tree</name><index>[<expr><name>s</name></expr>]</index></name><operator>.</operator><name>tree_data</name> <operator>!=</operator> <name>mod</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>s</name> <operator>!=</operator> <name>d</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>tree</name><index>[<expr><name>d</name></expr>]</index></name> <operator>=</operator> <name><name>tree</name><index>[<expr><name>s</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>d</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt></block_content></block></for>
<expr_stmt><expr><name>tree_size</name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><name><name>struct</name> <name>lmodule</name></name> <modifier>*</modifier></type>
<name>lm_load</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>section</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>lmodule</name></name> <modifier>*</modifier></type><name>m</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name><name>av</name><index>[<expr><name>MAX_MOD_ARGS</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ac</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>u_int</name></type> <name>u</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>m</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>m</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><literal type="string">"lm_load: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>handle</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>section</name></name></expr></argument>, <argument><expr><name>section</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>section</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>m</name><operator>-&gt;</operator><name>path</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><literal type="string">"lm_load: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>err</name>;</goto>
</block_content>}</block></if></if_stmt>




<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>index</name><operator>.</operator><name>subs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>section</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>index</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name><name>m</name><operator>-&gt;</operator><name>index</name><operator>.</operator><name>subs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>u</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>u</name> <operator>&lt;</operator> <name><name>m</name><operator>-&gt;</operator><name>index</name><operator>.</operator><name>subs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</condition> <incr><expr><name>u</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>index</name><operator>.</operator><name>subs</name><index>[<expr><name>u</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>section</name><index>[<expr><name>u</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>




<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>m</name><operator>-&gt;</operator><name>handle</name></name> <operator>=</operator> <call><name>dlopen</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name>RTLD_NOW</name><operator>|</operator><name>RTLD_GLOBAL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><literal type="string">"lm_load: open %s"</literal></expr></argument>, <argument><expr><call><name>dlerror</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>err</name>;</goto>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>m</name><operator>-&gt;</operator><name>config</name></name> <operator>=</operator> <call><name>dlsym</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>, <argument><expr><literal type="string">"config"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><literal type="string">"lm_load: no 'config' symbol %s"</literal></expr></argument>, <argument><expr><call><name>dlerror</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>err</name>;</goto>
</block_content>}</block></if></if_stmt>




<expr_stmt><expr><call><name>INSERT_OBJECT_OID</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lmodules</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>community</name> <operator>==</operator> <name>COMM_INITIALIZE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>m</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>LM_ONSTARTLIST</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TAILQ_INSERT_TAIL</name><argument_list>(<argument><expr><operator>&amp;</operator><name>modules_start</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>




<expr_stmt><expr><name>ac</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nprogargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>progargs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>section</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
<call><name>strncmp</name><argument_list>(<argument><expr><name><name>progargs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>section</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>section</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<name><name>progargs</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>section</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>ac</name> <operator>==</operator> <name>MAX_MOD_ARGS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_WARNING</name></expr></argument>, <argument><expr><literal type="string">"too many arguments for "</literal>
<literal type="string">"module '%s"</literal></expr></argument>, <argument><expr><name>section</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>progargs</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>section</name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>




<if_stmt><if>if <condition>(<expr><operator>(</operator><name>err</name> <operator>=</operator> <call>(<modifier>*</modifier><name><name>m</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>init</name></name>)<argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>ac</name></expr></argument>, <argument><expr><name>av</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><literal type="string">"lm_load: init failed: %d"</literal></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TAILQ_REMOVE</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lmodules</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>err</name>;</goto>
</block_content>}</block></if></if_stmt>

<return>return <expr><operator>(</operator><name>m</name><operator>)</operator></expr>;</return>

<label><name>err</name>:</label>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>m</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>LM_ONSTARTLIST</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>TAILQ_REMOVE</name><argument_list>(<argument><expr><operator>&amp;</operator><name>modules_start</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>m</name><operator>-&gt;</operator><name>handle</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dlclose</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>




<function><type><name>void</name></type>
<name>lm_start</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>lmodule</name></name> <modifier>*</modifier></type><name>mod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>lmodule</name></name> <modifier>*</modifier></type><name>m</name></decl>;</decl_stmt>




<if_stmt><if>if <condition>(<expr><call><name>tree_merge</name><argument_list>(<argument><expr><name><name>mod</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>tree</name></name></expr></argument>, <argument><expr><name><name>mod</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>tree_size</name></name></expr></argument>, <argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>lm_unload</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><call><name>read_config</name><argument_list>(<argument><expr><name>config_file</name></expr></argument>, <argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><literal type="string">"error in config file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lm_unload</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>mod</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>start</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call>(<modifier>*</modifier><name><name>mod</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>start</name></name>)<argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>mod</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>LM_STARTED</name></expr>;</expr_stmt>




<macro><name>TAILQ_FOREACH</name><argument_list>(<argument>m</argument>, <argument>&amp;lmodules</argument>, <argument>link</argument>)</argument_list></macro>
<if_stmt><if>if <condition>(<expr><name><name>m</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>loading</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call>(<modifier>*</modifier><name><name>m</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>loading</name></name>)<argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>





<function><type><name>void</name></type>
<name>lm_unload</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>lmodule</name></name> <modifier>*</modifier></type><name>m</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>lmodule</name></name> <modifier>*</modifier></type><name>mod</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>TAILQ_REMOVE</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lmodules</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>m</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>LM_ONSTARTLIST</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>TAILQ_REMOVE</name><argument_list>(<argument><expr><operator>&amp;</operator><name>modules_start</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>tree_unmerge</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>m</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>LM_STARTED</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>m</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>fini</name></name> <operator>&amp;&amp;</operator>
<operator>(</operator><name>err</name> <operator>=</operator> <call>(<modifier>*</modifier><name><name>m</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>fini</name></name>)<argument_list>()</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_WARNING</name></expr></argument>, <argument><expr><literal type="string">"lm_unload(%s): fini %d"</literal></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>section</name></name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>comm_flush</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>reqid_flush</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>timer_flush</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fd_flush</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>dlclose</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>m</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<macro><name>TAILQ_FOREACH</name><argument_list>(<argument>mod</argument>, <argument>&amp;lmodules</argument>, <argument>link</argument>)</argument_list></macro>
<if_stmt><if>if <condition>(<expr><name><name>mod</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>loading</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call>(<modifier>*</modifier><name><name>mod</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>loading</name></name>)<argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><name>u_int</name></type>
<name>or_register</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>asn_oid</name></name> <modifier>*</modifier></type><name>or</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>descr</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>lmodule</name></name> <modifier>*</modifier></type><name>mod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>objres</name></name> <modifier>*</modifier></type><name>objres</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>or1</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>u_int</name></type> <name>idx</name></decl>;</decl_stmt>


<expr_stmt><expr><name>idx</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>objres</name> <operator>=</operator> <call><name>TAILQ_FIRST</name><argument_list>(<argument><expr><operator>&amp;</operator><name>objres_list</name></expr></argument>)</argument_list></call></expr>;</init>
<condition><expr><name>objres</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
<incr><expr><name>objres</name> <operator>=</operator> <call><name>TAILQ_NEXT</name><argument_list>(<argument><expr><name>objres</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>or1</name> <operator>=</operator> <call><name>TAILQ_NEXT</name><argument_list>(<argument><expr><name>objres</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>||</operator>
<name><name>or1</name><operator>-&gt;</operator><name>index</name></name> <operator>&gt;</operator> <name><name>objres</name><operator>-&gt;</operator><name>index</name></name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>idx</name> <operator>=</operator> <name><name>objres</name><operator>-&gt;</operator><name>index</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>objres</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>objres</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>objres</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>objres</name><operator>-&gt;</operator><name>oid</name></name> <operator>=</operator> <operator>*</operator><name>or</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>objres</name><operator>-&gt;</operator><name>descr</name></name></expr></argument>, <argument><expr><name>descr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>objres</name><operator>-&gt;</operator><name>descr</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>objres</name><operator>-&gt;</operator><name>uptime</name></name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><call><name>get_ticks</name><argument_list>()</argument_list></call> <operator>-</operator> <name>start_tick</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>objres</name><operator>-&gt;</operator><name>module</name></name> <operator>=</operator> <name>mod</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>INSERT_OBJECT_INT</name><argument_list>(<argument><expr><name>objres</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>objres_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>systemg</name><operator>.</operator><name>or_last_change</name></name> <operator>=</operator> <name><name>objres</name><operator>-&gt;</operator><name>uptime</name></name></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>idx</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>or_unregister</name><parameter_list>(<parameter><decl><type><name>u_int</name></type> <name>idx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>objres</name></name> <modifier>*</modifier></type><name>objres</name></decl>;</decl_stmt>

<macro><name>TAILQ_FOREACH</name><argument_list>(<argument>objres</argument>, <argument>&amp;objres_list</argument>, <argument>link</argument>)</argument_list></macro>
<if_stmt><if>if <condition>(<expr><name><name>objres</name><operator>-&gt;</operator><name>index</name></name> <operator>==</operator> <name>idx</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>TAILQ_REMOVE</name><argument_list>(<argument><expr><operator>&amp;</operator><name>objres_list</name></expr></argument>, <argument><expr><name>objres</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>objres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>





<function><type><name><name>struct</name> <name>snmpd_usmstat</name></name> <modifier>*</modifier></type>
<name>bsnmpd_get_usm_stats</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><operator>&amp;</operator><name>snmpd_usmstats</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>bsnmpd_reset_usm_stats</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>snmpd_usmstats</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>snmpd_usmstats</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>usm_user</name></name> <modifier>*</modifier></type>
<name>usm_first_user</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><call><name>SLIST_FIRST</name><argument_list>(<argument><expr><operator>&amp;</operator><name>usm_userlist</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>usm_user</name></name> <modifier>*</modifier></type>
<name>usm_next_user</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>usm_user</name></name> <modifier>*</modifier></type><name>uuser</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>uuser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><call><name>SLIST_NEXT</name><argument_list>(<argument><expr><name>uuser</name></expr></argument>, <argument><expr><name>up</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>usm_user</name></name> <modifier>*</modifier></type>
<name>usm_find_user</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>engine</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>elen</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>uname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>usm_user</name></name> <modifier>*</modifier></type><name>uuser</name></decl>;</decl_stmt>

<macro><name>SLIST_FOREACH</name><argument_list>(<argument>uuser</argument>, <argument>&amp;usm_userlist</argument>, <argument>up</argument>)</argument_list></macro>
<if_stmt><if>if <condition>(<expr><name><name>uuser</name><operator>-&gt;</operator><name>user_engine_len</name></name> <operator>==</operator> <name>elen</name> <operator>&amp;&amp;</operator>
<call><name>memcmp</name><argument_list>(<argument><expr><name><name>uuser</name><operator>-&gt;</operator><name>user_engine_id</name></name></expr></argument>, <argument><expr><name>engine</name></expr></argument>, <argument><expr><name>elen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<call><name>strlen</name><argument_list>(<argument><expr><name><name>uuser</name><operator>-&gt;</operator><name>suser</name><operator>.</operator><name>sec_name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>uname</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<call><name>strcmp</name><argument_list>(<argument><expr><name><name>uuser</name><operator>-&gt;</operator><name>suser</name><operator>.</operator><name>sec_name</name></name></expr></argument>, <argument><expr><name>uname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><name>uuser</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>usm_compare_user</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>usm_user</name></name> <modifier>*</modifier></type><name>u1</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>usm_user</name></name> <modifier>*</modifier></type><name>u2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>u1</name><operator>-&gt;</operator><name>user_engine_len</name></name> <operator>&lt;</operator> <name><name>u2</name><operator>-&gt;</operator><name>user_engine_len</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>u1</name><operator>-&gt;</operator><name>user_engine_len</name></name> <operator>&gt;</operator> <name><name>u2</name><operator>-&gt;</operator><name>user_engine_len</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>u1</name><operator>-&gt;</operator><name>user_engine_len</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>u1</name><operator>-&gt;</operator><name>user_engine_id</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <name><name>u2</name><operator>-&gt;</operator><name>user_engine_id</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>u1</name><operator>-&gt;</operator><name>user_engine_id</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name><name>u2</name><operator>-&gt;</operator><name>user_engine_id</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>u1</name><operator>-&gt;</operator><name>suser</name><operator>.</operator><name>sec_name</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>u2</name><operator>-&gt;</operator><name>suser</name><operator>.</operator><name>sec_name</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>u1</name><operator>-&gt;</operator><name>suser</name><operator>.</operator><name>sec_name</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>u2</name><operator>-&gt;</operator><name>suser</name><operator>.</operator><name>sec_name</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>u1</name><operator>-&gt;</operator><name>suser</name><operator>.</operator><name>sec_name</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>u1</name><operator>-&gt;</operator><name>suser</name><operator>.</operator><name>sec_name</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <name><name>u2</name><operator>-&gt;</operator><name>suser</name><operator>.</operator><name>sec_name</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>u1</name><operator>-&gt;</operator><name>suser</name><operator>.</operator><name>sec_name</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name><name>u2</name><operator>-&gt;</operator><name>suser</name><operator>.</operator><name>sec_name</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>

<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>usm_user</name></name> <modifier>*</modifier></type>
<name>usm_new_user</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>eid</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>elen</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>uname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>cmp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>usm_user</name></name> <modifier>*</modifier></type><name>uuser</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>temp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>uuser</name> <operator>=</operator> <call><name>usm_first_user</name><argument_list>()</argument_list></call></expr>;</init> <condition><expr><name>uuser</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
<incr><expr><operator>(</operator><name>uuser</name> <operator>=</operator> <call><name>usm_next_user</name><argument_list>(<argument><expr><name>uuser</name></expr></argument>)</argument_list></call><operator>)</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>uuser</name><operator>-&gt;</operator><name>user_engine_len</name></name> <operator>==</operator> <name>elen</name> <operator>&amp;&amp;</operator>
<call><name>strlen</name><argument_list>(<argument><expr><name>uname</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>uuser</name><operator>-&gt;</operator><name>suser</name><operator>.</operator><name>sec_name</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<call><name>strcmp</name><argument_list>(<argument><expr><name>uname</name></expr></argument>, <argument><expr><name><name>uuser</name><operator>-&gt;</operator><name>suser</name><operator>.</operator><name>sec_name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<call><name>memcmp</name><argument_list>(<argument><expr><name>eid</name></expr></argument>, <argument><expr><name><name>uuser</name><operator>-&gt;</operator><name>user_engine_id</name></name></expr></argument>, <argument><expr><name>elen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>uuser</name> <operator>=</operator> <operator>(</operator>struct <name>usm_user</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>uuser</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>uuser</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>uuser</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>uuser</name><operator>-&gt;</operator><name>suser</name><operator>.</operator><name>sec_name</name></name></expr></argument>, <argument><expr><name>uname</name></expr></argument>, <argument><expr><name>SNMP_ADM_STR32_SIZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>uuser</name><operator>-&gt;</operator><name>user_engine_id</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>, <argument><expr><name>elen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>uuser</name><operator>-&gt;</operator><name>user_engine_len</name></name> <operator>=</operator> <name>elen</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>prev</name> <operator>=</operator> <call><name>SLIST_FIRST</name><argument_list>(<argument><expr><operator>&amp;</operator><name>usm_userlist</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>||</operator>
<call><name>usm_compare_user</name><argument_list>(<argument><expr><name>uuser</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>SLIST_INSERT_HEAD</name><argument_list>(<argument><expr><operator>&amp;</operator><name>usm_userlist</name></expr></argument>, <argument><expr><name>uuser</name></expr></argument>, <argument><expr><name>up</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>uuser</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<macro><name>SLIST_FOREACH</name><argument_list>(<argument>temp</argument>, <argument>&amp;usm_userlist</argument>, <argument>up</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>cmp</name> <operator>=</operator> <call><name>usm_compare_user</name><argument_list>(<argument><expr><name>uuser</name></expr></argument>, <argument><expr><name>temp</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>temp</name></expr>;</expr_stmt>
</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name>temp</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>cmp</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>SLIST_INSERT_AFTER</name><argument_list>(<argument><expr><name>prev</name></expr></argument>, <argument><expr><name>uuser</name></expr></argument>, <argument><expr><name>up</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>cmp</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>SLIST_INSERT_AFTER</name><argument_list>(<argument><expr><name>temp</name></expr></argument>, <argument><expr><name>uuser</name></expr></argument>, <argument><expr><name>up</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><literal type="string">"User %s exists"</literal></expr></argument>, <argument><expr><name><name>uuser</name><operator>-&gt;</operator><name>suser</name><operator>.</operator><name>sec_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>uuser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></else></if_stmt>

<return>return <expr><operator>(</operator><name>uuser</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>usm_delete_user</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>usm_user</name></name> <modifier>*</modifier></type><name>uuser</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>SLIST_REMOVE</name><argument_list>(<argument><expr><operator>&amp;</operator><name>usm_userlist</name></expr></argument>, <argument><expr><name>uuser</name></expr></argument>, <argument><expr><name>usm_user</name></expr></argument>, <argument><expr><name>up</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>uuser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>usm_flush_users</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>usm_user</name></name> <modifier>*</modifier></type><name>uuser</name></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>(</operator><name>uuser</name> <operator>=</operator> <call><name>SLIST_FIRST</name><argument_list>(<argument><expr><operator>&amp;</operator><name>usm_userlist</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>SLIST_REMOVE_HEAD</name><argument_list>(<argument><expr><operator>&amp;</operator><name>usm_userlist</name></expr></argument>, <argument><expr><name>up</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>uuser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>

<expr_stmt><expr><call><name>SLIST_INIT</name><argument_list>(<argument><expr><operator>&amp;</operator><name>usm_userlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><name><name>struct</name> <name>vacm_user</name></name> <modifier>*</modifier></type>
<name>vacm_first_user</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><call><name>SLIST_FIRST</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vacm_userlist</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>vacm_user</name></name> <modifier>*</modifier></type>
<name>vacm_next_user</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vacm_user</name></name> <modifier>*</modifier></type><name>vuser</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>vuser</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><call><name>SLIST_NEXT</name><argument_list>(<argument><expr><name>vuser</name></expr></argument>, <argument><expr><name>vvu</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>vacm_compare_user</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vacm_user</name></name> <modifier>*</modifier></type><name>v1</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>vacm_user</name></name> <modifier>*</modifier></type><name>v2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>v1</name><operator>-&gt;</operator><name>sec_model</name></name> <operator>&lt;</operator> <name><name>v2</name><operator>-&gt;</operator><name>sec_model</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>v1</name><operator>-&gt;</operator><name>sec_model</name></name> <operator>&gt;</operator> <name><name>v2</name><operator>-&gt;</operator><name>sec_model</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>v1</name><operator>-&gt;</operator><name>secname</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>v2</name><operator>-&gt;</operator><name>secname</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>v1</name><operator>-&gt;</operator><name>secname</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>v2</name><operator>-&gt;</operator><name>secname</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>v1</name><operator>-&gt;</operator><name>secname</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>v1</name><operator>-&gt;</operator><name>secname</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <name><name>v2</name><operator>-&gt;</operator><name>secname</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>v1</name><operator>-&gt;</operator><name>secname</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name><name>v2</name><operator>-&gt;</operator><name>secname</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>

<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>vacm_user</name></name> <modifier>*</modifier></type>
<name>vacm_new_user</name><parameter_list>(<parameter><decl><type><name>int32_t</name></type> <name>smodel</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>uname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>cmp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>vacm_user</name></name> <modifier>*</modifier></type><name>user</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>temp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>

<macro><name>SLIST_FOREACH</name><argument_list>(<argument>user</argument>, <argument>&amp;vacm_userlist</argument>, <argument>vvu</argument>)</argument_list></macro>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>uname</name></expr></argument>, <argument><expr><name><name>user</name><operator>-&gt;</operator><name>secname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<name>smodel</name> <operator>==</operator> <name><name>user</name><operator>-&gt;</operator><name>sec_model</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>user</name> <operator>=</operator> <operator>(</operator>struct <name>vacm_user</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>user</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>user</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>user</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>user</name><operator>-&gt;</operator><name>group</name></name> <operator>=</operator> <operator>&amp;</operator><name>vacm_default_group</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SLIST_INSERT_HEAD</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>vacm_default_group</name><operator>.</operator><name>group_users</name></name></expr></argument>, <argument><expr><name>user</name></expr></argument>, <argument><expr><name>vvg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>user</name><operator>-&gt;</operator><name>sec_model</name></name> <operator>=</operator> <name>smodel</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>user</name><operator>-&gt;</operator><name>secname</name></name></expr></argument>, <argument><expr><name>uname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>user</name><operator>-&gt;</operator><name>secname</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>prev</name> <operator>=</operator> <call><name>SLIST_FIRST</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vacm_userlist</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>||</operator>
<call><name>vacm_compare_user</name><argument_list>(<argument><expr><name>user</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>SLIST_INSERT_HEAD</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vacm_userlist</name></expr></argument>, <argument><expr><name>user</name></expr></argument>, <argument><expr><name>vvu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>user</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<macro><name>SLIST_FOREACH</name><argument_list>(<argument>temp</argument>, <argument>&amp;vacm_userlist</argument>, <argument>vvu</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>cmp</name> <operator>=</operator> <call><name>vacm_compare_user</name><argument_list>(<argument><expr><name>user</name></expr></argument>, <argument><expr><name>temp</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>temp</name></expr>;</expr_stmt>
</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name>temp</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>cmp</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>SLIST_INSERT_AFTER</name><argument_list>(<argument><expr><name>prev</name></expr></argument>, <argument><expr><name>user</name></expr></argument>, <argument><expr><name>vvu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>cmp</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>SLIST_INSERT_AFTER</name><argument_list>(<argument><expr><name>temp</name></expr></argument>, <argument><expr><name>user</name></expr></argument>, <argument><expr><name>vvu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><literal type="string">"User %s exists"</literal></expr></argument>, <argument><expr><name><name>user</name><operator>-&gt;</operator><name>secname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>user</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></else></if_stmt>

<return>return <expr><operator>(</operator><name>user</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>vacm_delete_user</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vacm_user</name></name> <modifier>*</modifier></type><name>user</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>user</name><operator>-&gt;</operator><name>group</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>user</name><operator>-&gt;</operator><name>group</name></name> <operator>!=</operator> <operator>&amp;</operator><name>vacm_default_group</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>SLIST_REMOVE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>user</name><operator>-&gt;</operator><name>group</name><operator>-&gt;</operator><name>group_users</name></name></expr></argument>, <argument><expr><name>user</name></expr></argument>, <argument><expr><name>vacm_user</name></expr></argument>, <argument><expr><name>vvg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>SLIST_EMPTY</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>user</name><operator>-&gt;</operator><name>group</name><operator>-&gt;</operator><name>group_users</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>SLIST_REMOVE</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vacm_grouplist</name></expr></argument>, <argument><expr><name><name>user</name><operator>-&gt;</operator><name>group</name></name></expr></argument>,
<argument><expr><name>vacm_group</name></expr></argument>, <argument><expr><name>vge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>user</name><operator>-&gt;</operator><name>group</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>SLIST_REMOVE</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vacm_userlist</name></expr></argument>, <argument><expr><name>user</name></expr></argument>, <argument><expr><name>vacm_user</name></expr></argument>, <argument><expr><name>vvu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>user</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>vacm_user_set_group</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vacm_user</name></name> <modifier>*</modifier></type><name>user</name></decl></parameter>, <parameter><decl><type><name>u_char</name> <modifier>*</modifier></type><name>octets</name></decl></parameter>, <parameter><decl><type><name>u_int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>vacm_group</name></name> <modifier>*</modifier></type><name>group</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <name>SNMP_ADM_STR32_SIZ</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<macro><name>SLIST_FOREACH</name><argument_list>(<argument>group</argument>, <argument>&amp;vacm_grouplist</argument>, <argument>vge</argument>)</argument_list></macro>
<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>groupname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>len</name> <operator>&amp;&amp;</operator>
<call><name>memcmp</name><argument_list>(<argument><expr><name>octets</name></expr></argument>, <argument><expr><name><name>group</name><operator>-&gt;</operator><name>groupname</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>group</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>group</name> <operator>=</operator> <operator>(</operator>struct <name>vacm_group</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>group</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>group</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>groupname</name></name></expr></argument>, <argument><expr><name>octets</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>groupname</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SLIST_INSERT_HEAD</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vacm_grouplist</name></expr></argument>, <argument><expr><name>group</name></expr></argument>, <argument><expr><name>vge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>SLIST_REMOVE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>user</name><operator>-&gt;</operator><name>group</name><operator>-&gt;</operator><name>group_users</name></name></expr></argument>, <argument><expr><name>user</name></expr></argument>, <argument><expr><name>vacm_user</name></expr></argument>, <argument><expr><name>vvg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SLIST_INSERT_HEAD</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>group</name><operator>-&gt;</operator><name>group_users</name></name></expr></argument>, <argument><expr><name>user</name></expr></argument>, <argument><expr><name>vvg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>user</name><operator>-&gt;</operator><name>group</name></name> <operator>=</operator> <name>group</name></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>vacm_groups_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>SLIST_INSERT_HEAD</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vacm_grouplist</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vacm_default_group</name></expr></argument>, <argument><expr><name>vge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>vacm_access</name></name> <modifier>*</modifier></type>
<name>vacm_first_access_rule</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><call><name>TAILQ_FIRST</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vacm_accesslist</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>vacm_access</name></name> <modifier>*</modifier></type>
<name>vacm_next_access_rule</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vacm_access</name></name> <modifier>*</modifier></type><name>acl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>acl</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><call><name>TAILQ_NEXT</name><argument_list>(<argument><expr><name>acl</name></expr></argument>, <argument><expr><name>vva</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>vacm_compare_access_rule</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vacm_access</name></name> <modifier>*</modifier></type><name>v1</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>vacm_access</name></name> <modifier>*</modifier></type><name>v2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>v1</name><operator>-&gt;</operator><name>group</name><operator>-&gt;</operator><name>groupname</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>v2</name><operator>-&gt;</operator><name>group</name><operator>-&gt;</operator><name>groupname</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>v1</name><operator>-&gt;</operator><name>group</name><operator>-&gt;</operator><name>groupname</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>v2</name><operator>-&gt;</operator><name>group</name><operator>-&gt;</operator><name>groupname</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>v1</name><operator>-&gt;</operator><name>group</name><operator>-&gt;</operator><name>groupname</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>v1</name><operator>-&gt;</operator><name>group</name><operator>-&gt;</operator><name>groupname</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <name><name>v2</name><operator>-&gt;</operator><name>group</name><operator>-&gt;</operator><name>groupname</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>v1</name><operator>-&gt;</operator><name>group</name><operator>-&gt;</operator><name>groupname</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name><name>v2</name><operator>-&gt;</operator><name>group</name><operator>-&gt;</operator><name>groupname</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>v1</name><operator>-&gt;</operator><name>ctx_prefix</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>v2</name><operator>-&gt;</operator><name>ctx_prefix</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>v1</name><operator>-&gt;</operator><name>ctx_prefix</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>v2</name><operator>-&gt;</operator><name>ctx_prefix</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>v1</name><operator>-&gt;</operator><name>ctx_prefix</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>v1</name><operator>-&gt;</operator><name>ctx_prefix</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <name><name>v2</name><operator>-&gt;</operator><name>ctx_prefix</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>v1</name><operator>-&gt;</operator><name>ctx_prefix</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name><name>v2</name><operator>-&gt;</operator><name>ctx_prefix</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>v1</name><operator>-&gt;</operator><name>sec_model</name></name> <operator>&lt;</operator> <name><name>v2</name><operator>-&gt;</operator><name>sec_model</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>v1</name><operator>-&gt;</operator><name>sec_model</name></name> <operator>&gt;</operator> <name><name>v2</name><operator>-&gt;</operator><name>sec_model</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>v1</name><operator>-&gt;</operator><name>sec_level</name></name> <operator>&lt;</operator> <name><name>v2</name><operator>-&gt;</operator><name>sec_level</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>v1</name><operator>-&gt;</operator><name>sec_level</name></name> <operator>&gt;</operator> <name><name>v2</name><operator>-&gt;</operator><name>sec_level</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>vacm_access</name></name> <modifier>*</modifier></type>
<name>vacm_new_access_rule</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>gname</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cprefix</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>smodel</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>slevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>vacm_group</name></name> <modifier>*</modifier></type><name>group</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>vacm_access</name></name> <modifier>*</modifier></type><name>acl</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>temp</name></decl>;</decl_stmt>

<macro><name>TAILQ_FOREACH</name><argument_list>(<argument>acl</argument>, <argument>&amp;vacm_accesslist</argument>, <argument>vva</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>acl</name><operator>-&gt;</operator><name>group</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>gname</name></expr></argument>, <argument><expr><name><name>acl</name><operator>-&gt;</operator><name>group</name><operator>-&gt;</operator><name>groupname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<call><name>strcmp</name><argument_list>(<argument><expr><name>cprefix</name></expr></argument>, <argument><expr><name><name>acl</name><operator>-&gt;</operator><name>ctx_prefix</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<name><name>acl</name><operator>-&gt;</operator><name>sec_model</name></name> <operator>==</operator> <name>smodel</name> <operator>&amp;&amp;</operator> <name><name>acl</name><operator>-&gt;</operator><name>sec_level</name></name> <operator>==</operator> <name>slevel</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block>


<macro><name>SLIST_FOREACH</name><argument_list>(<argument>group</argument>, <argument>&amp;vacm_grouplist</argument>, <argument>vge</argument>)</argument_list></macro>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>gname</name></expr></argument>, <argument><expr><name><name>group</name><operator>-&gt;</operator><name>groupname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>group</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>acl</name> <operator>=</operator> <operator>(</operator>struct <name>vacm_access</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>acl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>acl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>acl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>acl</name><operator>-&gt;</operator><name>group</name></name> <operator>=</operator> <name>group</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>acl</name><operator>-&gt;</operator><name>ctx_prefix</name></name></expr></argument>, <argument><expr><name>cprefix</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>acl</name><operator>-&gt;</operator><name>ctx_prefix</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>acl</name><operator>-&gt;</operator><name>sec_model</name></name> <operator>=</operator> <name>smodel</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>acl</name><operator>-&gt;</operator><name>sec_level</name></name> <operator>=</operator> <name>slevel</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>temp</name> <operator>=</operator> <call><name>TAILQ_FIRST</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vacm_accesslist</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>||</operator>
<call><name>vacm_compare_access_rule</name><argument_list>(<argument><expr><name>acl</name></expr></argument>, <argument><expr><name>temp</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>TAILQ_INSERT_HEAD</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vacm_accesslist</name></expr></argument>, <argument><expr><name>acl</name></expr></argument>, <argument><expr><name>vva</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>acl</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<macro><name>TAILQ_FOREACH</name><argument_list>(<argument>temp</argument>, <argument>&amp;vacm_accesslist</argument>, <argument>vva</argument>)</argument_list></macro>
<if_stmt><if>if <condition>(<expr><call><name>vacm_compare_access_rule</name><argument_list>(<argument><expr><name>acl</name></expr></argument>, <argument><expr><name>temp</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>TAILQ_INSERT_BEFORE</name><argument_list>(<argument><expr><name>temp</name></expr></argument>, <argument><expr><name>acl</name></expr></argument>, <argument><expr><name>vva</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>acl</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>TAILQ_INSERT_TAIL</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vacm_accesslist</name></expr></argument>, <argument><expr><name>acl</name></expr></argument>, <argument><expr><name>vva</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>acl</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>vacm_delete_access_rule</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vacm_access</name></name> <modifier>*</modifier></type><name>acl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>TAILQ_REMOVE</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vacm_accesslist</name></expr></argument>, <argument><expr><name>acl</name></expr></argument>, <argument><expr><name>vva</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>acl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>vacm_view</name></name> <modifier>*</modifier></type>
<name>vacm_first_view</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><call><name>SLIST_FIRST</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vacm_viewlist</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>vacm_view</name></name> <modifier>*</modifier></type>
<name>vacm_next_view</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vacm_view</name></name> <modifier>*</modifier></type><name>view</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>view</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><call><name>SLIST_NEXT</name><argument_list>(<argument><expr><name>view</name></expr></argument>, <argument><expr><name>vvl</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>vacm_compare_view</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vacm_view</name></name> <modifier>*</modifier></type><name>v1</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>vacm_view</name></name> <modifier>*</modifier></type><name>v2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>v1</name><operator>-&gt;</operator><name>viewname</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>v2</name><operator>-&gt;</operator><name>viewname</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>v1</name><operator>-&gt;</operator><name>viewname</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>v2</name><operator>-&gt;</operator><name>viewname</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>v1</name><operator>-&gt;</operator><name>viewname</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>v1</name><operator>-&gt;</operator><name>viewname</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <name><name>v2</name><operator>-&gt;</operator><name>viewname</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>v1</name><operator>-&gt;</operator><name>viewname</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name><name>v2</name><operator>-&gt;</operator><name>viewname</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>

<return>return <expr><operator>(</operator><call><name>asn_compare_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>v1</name><operator>-&gt;</operator><name>subtree</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>v2</name><operator>-&gt;</operator><name>subtree</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>vacm_view</name></name> <modifier>*</modifier></type>
<name>vacm_new_view</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>vname</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>asn_oid</name></name> <modifier>*</modifier></type><name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>cmp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>vacm_view</name></name> <modifier>*</modifier></type><name>view</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>temp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>

<macro><name>SLIST_FOREACH</name><argument_list>(<argument>view</argument>, <argument>&amp;vacm_viewlist</argument>, <argument>vvl</argument>)</argument_list></macro>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>vname</name></expr></argument>, <argument><expr><name><name>view</name><operator>-&gt;</operator><name>viewname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>view</name> <operator>=</operator> <operator>(</operator>struct <name>vacm_view</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>view</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>view</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>view</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>view</name><operator>-&gt;</operator><name>viewname</name></name></expr></argument>, <argument><expr><name>vname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>view</name><operator>-&gt;</operator><name>viewname</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>asn_append_oid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>view</name><operator>-&gt;</operator><name>subtree</name></name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>prev</name> <operator>=</operator> <call><name>SLIST_FIRST</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vacm_viewlist</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>||</operator>
<call><name>vacm_compare_view</name><argument_list>(<argument><expr><name>view</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>SLIST_INSERT_HEAD</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vacm_viewlist</name></expr></argument>, <argument><expr><name>view</name></expr></argument>, <argument><expr><name>vvl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>view</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<macro><name>SLIST_FOREACH</name><argument_list>(<argument>temp</argument>, <argument>&amp;vacm_viewlist</argument>, <argument>vvl</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>cmp</name> <operator>=</operator> <call><name>vacm_compare_view</name><argument_list>(<argument><expr><name>view</name></expr></argument>, <argument><expr><name>temp</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>temp</name></expr>;</expr_stmt>
</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name>temp</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>cmp</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>SLIST_INSERT_AFTER</name><argument_list>(<argument><expr><name>prev</name></expr></argument>, <argument><expr><name>view</name></expr></argument>, <argument><expr><name>vvl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>cmp</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>SLIST_INSERT_AFTER</name><argument_list>(<argument><expr><name>temp</name></expr></argument>, <argument><expr><name>view</name></expr></argument>, <argument><expr><name>vvl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><literal type="string">"View %s exists"</literal></expr></argument>, <argument><expr><name><name>view</name><operator>-&gt;</operator><name>viewname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>view</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></else></if_stmt>

<return>return <expr><operator>(</operator><name>view</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>vacm_delete_view</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vacm_view</name></name> <modifier>*</modifier></type><name>view</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>SLIST_REMOVE</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vacm_viewlist</name></expr></argument>, <argument><expr><name>view</name></expr></argument>, <argument><expr><name>vacm_view</name></expr></argument>, <argument><expr><name>vvl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>view</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>vacm_context</name></name> <modifier>*</modifier></type>
<name>vacm_first_context</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><call><name>SLIST_FIRST</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vacm_contextlist</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>vacm_context</name></name> <modifier>*</modifier></type>
<name>vacm_next_context</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vacm_context</name></name> <modifier>*</modifier></type><name>vacmctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>vacmctx</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><call><name>SLIST_NEXT</name><argument_list>(<argument><expr><name>vacmctx</name></expr></argument>, <argument><expr><name>vcl</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>vacm_context</name></name> <modifier>*</modifier></type>
<name>vacm_add_context</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>ctxname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>regid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>cmp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>vacm_context</name></name> <modifier>*</modifier></type><name>ctx</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>temp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>

<macro><name>SLIST_FOREACH</name><argument_list>(<argument>ctx</argument>, <argument>&amp;vacm_contextlist</argument>, <argument>vcl</argument>)</argument_list></macro>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>ctxname</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>ctxname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><literal type="string">"Context %s exists"</literal></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>ctxname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ctx</name> <operator>=</operator> <operator>(</operator>struct <name>vacm_context</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>ctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>ctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>ctxname</name></name></expr></argument>, <argument><expr><name>ctxname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>ctxname</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>regid</name></name> <operator>=</operator> <name>regid</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>prev</name> <operator>=</operator> <call><name>SLIST_FIRST</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vacm_contextlist</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>||</operator>
<call><name>strlen</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>ctxname</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>prev</name><operator>-&gt;</operator><name>ctxname</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>strcmp</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>ctxname</name></name></expr></argument>, <argument><expr><name><name>prev</name><operator>-&gt;</operator><name>ctxname</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>SLIST_INSERT_HEAD</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vacm_contextlist</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>vcl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ctx</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<macro><name>SLIST_FOREACH</name><argument_list>(<argument>temp</argument>, <argument>&amp;vacm_contextlist</argument>, <argument>vcl</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>ctxname</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>temp</name><operator>-&gt;</operator><name>ctxname</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>strcmp</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>ctxname</name></name></expr></argument>, <argument><expr><name><name>temp</name><operator>-&gt;</operator><name>ctxname</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cmp</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>temp</name></expr>;</expr_stmt>
</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name>temp</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>cmp</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>SLIST_INSERT_AFTER</name><argument_list>(<argument><expr><name>prev</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>vcl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>cmp</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>SLIST_INSERT_AFTER</name><argument_list>(<argument><expr><name>temp</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>vcl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><literal type="string">"Context %s exists"</literal></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>ctxname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></else></if_stmt>

<return>return <expr><operator>(</operator><name>ctx</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>vacm_flush_contexts</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>regid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>vacm_context</name></name> <modifier>*</modifier></type><name>ctx</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>temp</name></decl>;</decl_stmt>

<macro><name>SLIST_FOREACH_SAFE</name><argument_list>(<argument>ctx</argument>, <argument>&amp;vacm_contextlist</argument>, <argument>vcl</argument>, <argument>temp</argument>)</argument_list></macro>
<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>regid</name></name> <operator>==</operator> <name>regid</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>SLIST_REMOVE</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vacm_contextlist</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>vacm_context</name></expr></argument>, <argument><expr><name>vcl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
</unit>
