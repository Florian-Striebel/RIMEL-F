<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/arm-optimized-routines/math/math_config.h">






<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_MATH_CONFIG_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_MATH_CONFIG_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>WANT_ROUNDING</name></expr></argument>)</argument_list></call></expr></cpp:if>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WANT_ROUNDING</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>WANT_ERRNO</name></expr></argument>)</argument_list></call></expr></cpp:if>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WANT_ERRNO</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>WANT_ERRNO_UFLOW</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WANT_ERRNO_UFLOW</name></cpp:macro> <cpp:value>(WANT_ROUNDING &amp;&amp; WANT_ERRNO)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FAST_ROUND</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__aarch64__</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_FAST_ROUND</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_FAST_ROUND</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FAST_LROUND</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__aarch64__</name> <operator>&amp;&amp;</operator> <operator>(</operator><literal type="number">100</literal><operator>*</operator><name>__GNUC__</name> <operator>+</operator> <name>__GNUC_MINOR__</name><operator>)</operator> <operator>&gt;=</operator> <literal type="number">408</literal> <operator>&amp;&amp;</operator> <name>__NO_MATH_ERRNO__</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_FAST_LROUND</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_FAST_LROUND</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FAST_FMA</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>FP_FAST_FMA</name> <operator>||</operator> <name>__aarch64__</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_FAST_FMA</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_FAST_FMA</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>




<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>USE_GLIBC_ABI</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__GNUC__</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_GLIBC_ABI</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_GLIBC_ABI</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HIDDEN</name></cpp:macro> <cpp:value>__attribute__ ((__visibility__ ("hidden")))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NOINLINE</name></cpp:macro> <cpp:value>__attribute__ ((noinline))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNUSED</name></cpp:macro> <cpp:value>__attribute__ ((unused))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>likely</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>__builtin_expect (!!(x), 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>unlikely</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>__builtin_expect (x, 0)</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__GNUC__</name> <operator>&gt;=</operator> <literal type="number">9</literal></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>attribute_copy</name><parameter_list>(<parameter><type><name>f</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>__attribute__ ((copy (f)))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>attribute_copy</name><parameter_list>(<parameter><type><name>f</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>strong_alias</name><parameter_list>(<parameter><type><name>f</name></type></parameter>, <parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>extern __typeof (f) a __attribute__ ((alias (#f))) attribute_copy (f);</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>hidden_alias</name><parameter_list>(<parameter><type><name>f</name></type></parameter>, <parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>extern __typeof (f) a __attribute__ ((alias (#f), visibility ("hidden"))) attribute_copy (f);</cpp:value></cpp:define>


<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HIDDEN</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NOINLINE</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNUSED</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>likely</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(x)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>unlikely</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(x)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_FAST_ROUND</name></expr></cpp:if>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TOINT_INTRINSICS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>




<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>double_t</name></type>
<name>roundtoint</name> <parameter_list>(<parameter><decl><type><name>double_t</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>round</name> <argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int32_t</name></type>
<name>converttoint</name> <parameter_list>(<parameter><decl><type><name>double_t</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_FAST_LROUND</name></expr></cpp:if>
<return>return <expr><call><name>lround</name> <argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><operator>(</operator><name>long</name><operator>)</operator> <call><name>round</name> <argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>uint32_t</name></type>
<name>asuint</name> <parameter_list>(<parameter><decl><type><name>float</name></type> <name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<union>union
<block>{
<decl_stmt><decl><type><name>float</name></type> <name>f</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>
}</block> <decl><name>u</name> <init>= <expr><block>{<expr><name>f</name></expr>}</block></expr></init></decl>;</union>
<return>return <expr><name><name>u</name><operator>.</operator><name>i</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>float</name></type>
<name>asfloat</name> <parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>i</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<union>union
<block>{
<decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>f</name></decl>;</decl_stmt>
}</block> <decl><name>u</name> <init>= <expr><block>{<expr><name>i</name></expr>}</block></expr></init></decl>;</union>
<return>return <expr><name><name>u</name><operator>.</operator><name>f</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>uint64_t</name></type>
<name>asuint64</name> <parameter_list>(<parameter><decl><type><name>double</name></type> <name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<union>union
<block>{
<decl_stmt><decl><type><name>double</name></type> <name>f</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>i</name></decl>;</decl_stmt>
}</block> <decl><name>u</name> <init>= <expr><block>{<expr><name>f</name></expr>}</block></expr></init></decl>;</union>
<return>return <expr><name><name>u</name><operator>.</operator><name>i</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>double</name></type>
<name>asdouble</name> <parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>i</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<union>union
<block>{
<decl_stmt><decl><type><name>uint64_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>f</name></decl>;</decl_stmt>
}</block> <decl><name>u</name> <init>= <expr><block>{<expr><name>i</name></expr>}</block></expr></init></decl>;</union>
<return>return <expr><name><name>u</name><operator>.</operator><name>f</name></name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>IEEE_754_2008_SNAN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IEEE_754_2008_SNAN</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>
<name>issignalingf_inline</name> <parameter_list>(<parameter><decl><type><name>float</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>ix</name> <init>= <expr><call><name>asuint</name> <argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IEEE_754_2008_SNAN</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>ix</name> <operator>&amp;</operator> <literal type="number">0x7fc00000</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x7fc00000</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">2</literal> <operator>*</operator> <operator>(</operator><name>ix</name> <operator>^</operator> <literal type="number">0x00400000</literal><operator>)</operator> <operator>&gt;</operator> <literal type="number">2u</literal> <operator>*</operator> <literal type="number">0x7fc00000</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>
<name>issignaling_inline</name> <parameter_list>(<parameter><decl><type><name>double</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>ix</name> <init>= <expr><call><name>asuint64</name> <argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IEEE_754_2008_SNAN</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>ix</name> <operator>&amp;</operator> <literal type="number">0x7ff8000000000000</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x7ff8000000000000</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">2</literal> <operator>*</operator> <operator>(</operator><name>ix</name> <operator>^</operator> <literal type="number">0x0008000000000000</literal><operator>)</operator> <operator>&gt;</operator> <literal type="number">2</literal> <operator>*</operator> <literal type="number">0x7ff8000000000000ULL</literal></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__aarch64__</name> <operator>&amp;&amp;</operator> <name>__GNUC__</name></expr></cpp:if>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>float</name></type>
<name>opt_barrier_float</name> <parameter_list>(<parameter><decl><type><name>float</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<asm>__asm__ <specifier>__volatile__</specifier> ("" : "+w" (x));</asm>
<return>return <expr><name>x</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>double</name></type>
<name>opt_barrier_double</name> <parameter_list>(<parameter><decl><type><name>double</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<asm>__asm__ <specifier>__volatile__</specifier> ("" : "+w" (x));</asm>
<return>return <expr><name>x</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>force_eval_float</name> <parameter_list>(<parameter><decl><type><name>float</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<asm>__asm__ <specifier>__volatile__</specifier> ("" : "+w" (x));</asm>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>force_eval_double</name> <parameter_list>(<parameter><decl><type><name>double</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<asm>__asm__ <specifier>__volatile__</specifier> ("" : "+w" (x));</asm>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>float</name></type>
<name>opt_barrier_float</name> <parameter_list>(<parameter><decl><type><name>float</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>volatile</specifier> <name>float</name></type> <name>y</name> <init>= <expr><name>x</name></expr></init></decl>;</decl_stmt>
<return>return <expr><name>y</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>double</name></type>
<name>opt_barrier_double</name> <parameter_list>(<parameter><decl><type><name>double</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>volatile</specifier> <name>double</name></type> <name>y</name> <init>= <expr><name>x</name></expr></init></decl>;</decl_stmt>
<return>return <expr><name>y</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>force_eval_float</name> <parameter_list>(<parameter><decl><type><name>float</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>volatile</specifier> <name>float</name> <name>y</name></type> <name>UNUSED</name> <init>= <expr><name>x</name></expr></init></decl>;</decl_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>force_eval_double</name> <parameter_list>(<parameter><decl><type><name>double</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>volatile</specifier> <name>double</name> <name>y</name></type> <name>UNUSED</name> <init>= <expr><name>x</name></expr></init></decl>;</decl_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>





<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>float</name></type>
<name>eval_as_float</name> <parameter_list>(<parameter><decl><type><name>float</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name>x</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>double</name></type>
<name>eval_as_double</name> <parameter_list>(<parameter><decl><type><name>double</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name>x</name></expr>;</return>
</block_content>}</block></function>





<function_decl><type><name>HIDDEN</name> <name>float</name></type> <name>__math_oflowf</name> <parameter_list>(<parameter><decl><type><name>uint32_t</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>HIDDEN</name> <name>float</name></type> <name>__math_uflowf</name> <parameter_list>(<parameter><decl><type><name>uint32_t</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>HIDDEN</name> <name>float</name></type> <name>__math_may_uflowf</name> <parameter_list>(<parameter><decl><type><name>uint32_t</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>HIDDEN</name> <name>float</name></type> <name>__math_divzerof</name> <parameter_list>(<parameter><decl><type><name>uint32_t</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>HIDDEN</name> <name>double</name></type> <name>__math_oflow</name> <parameter_list>(<parameter><decl><type><name>uint32_t</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>HIDDEN</name> <name>double</name></type> <name>__math_uflow</name> <parameter_list>(<parameter><decl><type><name>uint32_t</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>HIDDEN</name> <name>double</name></type> <name>__math_may_uflow</name> <parameter_list>(<parameter><decl><type><name>uint32_t</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>HIDDEN</name> <name>double</name></type> <name>__math_divzero</name> <parameter_list>(<parameter><decl><type><name>uint32_t</name></type></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>HIDDEN</name> <name>float</name></type> <name>__math_invalidf</name> <parameter_list>(<parameter><decl><type><name>float</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>HIDDEN</name> <name>double</name></type> <name>__math_invalid</name> <parameter_list>(<parameter><decl><type><name>double</name></type></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>HIDDEN</name> <name>double</name></type> <name>__math_check_oflow</name> <parameter_list>(<parameter><decl><type><name>double</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>HIDDEN</name> <name>double</name></type> <name>__math_check_uflow</name> <parameter_list>(<parameter><decl><type><name>double</name></type></decl></parameter>)</parameter_list>;</function_decl>


<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>double</name></type>
<name>check_oflow</name> <parameter_list>(<parameter><decl><type><name>double</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><ternary><condition><expr><name>WANT_ERRNO</name></expr> ?</condition><then> <expr><call><name>__math_check_oflow</name> <argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>x</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>double</name></type>
<name>check_uflow</name> <parameter_list>(<parameter><decl><type><name>double</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><ternary><condition><expr><name>WANT_ERRNO</name></expr> ?</condition><then> <expr><call><name>__math_check_uflow</name> <argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>x</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>


<function_decl><type><name>HIDDEN</name> <name>float</name></type> <name>__math_check_oflowf</name> <parameter_list>(<parameter><decl><type><name>float</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>HIDDEN</name> <name>float</name></type> <name>__math_check_uflowf</name> <parameter_list>(<parameter><decl><type><name>float</name></type></decl></parameter>)</parameter_list>;</function_decl>


<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>float</name></type>
<name>check_oflowf</name> <parameter_list>(<parameter><decl><type><name>float</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><ternary><condition><expr><name>WANT_ERRNO</name></expr> ?</condition><then> <expr><call><name>__math_check_oflowf</name> <argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>x</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>float</name></type>
<name>check_uflowf</name> <parameter_list>(<parameter><decl><type><name>float</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><ternary><condition><expr><name>WANT_ERRNO</name></expr> ?</condition><then> <expr><call><name>__math_check_uflowf</name> <argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>x</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXP2F_TABLE_BITS</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXP2F_POLY_ORDER</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<struct><specifier>extern</specifier> <specifier>const</specifier> struct <name>exp2f_data</name>
<block>{
<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>tab</name><index>[<expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>EXP2F_TABLE_BITS</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>shift_scaled</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name><name>poly</name><index>[<expr><name>EXP2F_POLY_ORDER</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>shift</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>invln2_scaled</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name><name>poly_scaled</name><index>[<expr><name>EXP2F_POLY_ORDER</name></expr>]</index></name></decl>;</decl_stmt>
}</block> <decl><name>__exp2f_data</name> <name>HIDDEN</name></decl>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOGF_TABLE_BITS</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOGF_POLY_ORDER</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<struct><specifier>extern</specifier> <specifier>const</specifier> struct <name>logf_data</name>
<block>{
<struct>struct
<block>{
<decl_stmt><decl><type><name>double</name></type> <name>invc</name></decl>, <decl><type ref="prev"/><name>logc</name></decl>;</decl_stmt>
}</block> <decl><name><name>tab</name><index>[<expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>LOGF_TABLE_BITS</name></expr>]</index></name></decl>;</struct>
<decl_stmt><decl><type><name>double</name></type> <name>ln2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name><name>poly</name><index>[<expr><name>LOGF_POLY_ORDER</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
}</block> <decl><name>__logf_data</name> <name>HIDDEN</name></decl>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOG2F_TABLE_BITS</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOG2F_POLY_ORDER</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<struct><specifier>extern</specifier> <specifier>const</specifier> struct <name>log2f_data</name>
<block>{
<struct>struct
<block>{
<decl_stmt><decl><type><name>double</name></type> <name>invc</name></decl>, <decl><type ref="prev"/><name>logc</name></decl>;</decl_stmt>
}</block> <decl><name><name>tab</name><index>[<expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>LOG2F_TABLE_BITS</name></expr>]</index></name></decl>;</struct>
<decl_stmt><decl><type><name>double</name></type> <name><name>poly</name><index>[<expr><name>LOG2F_POLY_ORDER</name></expr>]</index></name></decl>;</decl_stmt>
}</block> <decl><name>__log2f_data</name> <name>HIDDEN</name></decl>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POWF_LOG2_TABLE_BITS</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POWF_LOG2_POLY_ORDER</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>TOINT_INTRINSICS</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POWF_SCALE_BITS</name></cpp:macro> <cpp:value>EXP2F_TABLE_BITS</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POWF_SCALE_BITS</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POWF_SCALE</name></cpp:macro> <cpp:value>((double) (1 &lt;&lt; POWF_SCALE_BITS))</cpp:value></cpp:define>
<struct><specifier>extern</specifier> <specifier>const</specifier> struct <name>powf_log2_data</name>
<block>{
<struct>struct
<block>{
<decl_stmt><decl><type><name>double</name></type> <name>invc</name></decl>, <decl><type ref="prev"/><name>logc</name></decl>;</decl_stmt>
}</block> <decl><name><name>tab</name><index>[<expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>POWF_LOG2_TABLE_BITS</name></expr>]</index></name></decl>;</struct>
<decl_stmt><decl><type><name>double</name></type> <name><name>poly</name><index>[<expr><name>POWF_LOG2_POLY_ORDER</name></expr>]</index></name></decl>;</decl_stmt>
}</block> <decl><name>__powf_log2_data</name> <name>HIDDEN</name></decl>;</struct>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXP_TABLE_BITS</name></cpp:macro> <cpp:value>7</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXP_POLY_ORDER</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXP_POLY_WIDE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXP_USE_TOINT_NARROW</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXP2_POLY_ORDER</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXP2_POLY_WIDE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<struct><specifier>extern</specifier> <specifier>const</specifier> struct <name>exp_data</name>
<block>{
<decl_stmt><decl><type><name>double</name></type> <name>invln2N</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>shift</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>negln2hiN</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>negln2loN</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name><name>poly</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>exp2_shift</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name><name>exp2_poly</name><index>[<expr><name>EXP2_POLY_ORDER</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>tab</name><index>[<expr><literal type="number">2</literal><operator>*</operator><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>EXP_TABLE_BITS</name><operator>)</operator></expr>]</index></name></decl>;</decl_stmt>
}</block> <decl><name>__exp_data</name> <name>HIDDEN</name></decl>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOG_TABLE_BITS</name></cpp:macro> <cpp:value>7</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOG_POLY_ORDER</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOG_POLY1_ORDER</name></cpp:macro> <cpp:value>12</cpp:value></cpp:define>
<struct><specifier>extern</specifier> <specifier>const</specifier> struct <name>log_data</name>
<block>{
<decl_stmt><decl><type><name>double</name></type> <name>ln2hi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>ln2lo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name><name>poly</name><index>[<expr><name>LOG_POLY_ORDER</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name><name>poly1</name><index>[<expr><name>LOG_POLY1_ORDER</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<struct>struct <block>{<decl_stmt><decl><type><name>double</name></type> <name>invc</name></decl>, <decl><type ref="prev"/><name>logc</name></decl>;</decl_stmt>}</block> <decl><name><name>tab</name><index>[<expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>LOG_TABLE_BITS</name></expr>]</index></name></decl>;</struct>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>HAVE_FAST_FMA</name></expr></cpp:if>
<struct>struct <block>{<decl_stmt><decl><type><name>double</name></type> <name>chi</name></decl>, <decl><type ref="prev"/><name>clo</name></decl>;</decl_stmt>}</block> <decl><name><name>tab2</name><index>[<expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>LOG_TABLE_BITS</name></expr>]</index></name></decl>;</struct>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block> <decl><name>__log_data</name> <name>HIDDEN</name></decl>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOG2_TABLE_BITS</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOG2_POLY_ORDER</name></cpp:macro> <cpp:value>7</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOG2_POLY1_ORDER</name></cpp:macro> <cpp:value>11</cpp:value></cpp:define>
<struct><specifier>extern</specifier> <specifier>const</specifier> struct <name>log2_data</name>
<block>{
<decl_stmt><decl><type><name>double</name></type> <name>invln2hi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>invln2lo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name><name>poly</name><index>[<expr><name>LOG2_POLY_ORDER</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name><name>poly1</name><index>[<expr><name>LOG2_POLY1_ORDER</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<struct>struct <block>{<decl_stmt><decl><type><name>double</name></type> <name>invc</name></decl>, <decl><type ref="prev"/><name>logc</name></decl>;</decl_stmt>}</block> <decl><name><name>tab</name><index>[<expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>LOG2_TABLE_BITS</name></expr>]</index></name></decl>;</struct>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><name>HAVE_FAST_FMA</name></expr></cpp:if>
<struct>struct <block>{<decl_stmt><decl><type><name>double</name></type> <name>chi</name></decl>, <decl><type ref="prev"/><name>clo</name></decl>;</decl_stmt>}</block> <decl><name><name>tab2</name><index>[<expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>LOG2_TABLE_BITS</name></expr>]</index></name></decl>;</struct>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block> <decl><name>__log2_data</name> <name>HIDDEN</name></decl>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POW_LOG_TABLE_BITS</name></cpp:macro> <cpp:value>7</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POW_LOG_POLY_ORDER</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>
<struct><specifier>extern</specifier> <specifier>const</specifier> struct <name>pow_log_data</name>
<block>{
<decl_stmt><decl><type><name>double</name></type> <name>ln2hi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>ln2lo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name><name>poly</name><index>[<expr><name>POW_LOG_POLY_ORDER</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

<struct>struct <block>{<decl_stmt><decl><type><name>double</name></type> <name>invc</name></decl>, <decl><type ref="prev"/><name>pad</name></decl>, <decl><type ref="prev"/><name>logc</name></decl>, <decl><type ref="prev"/><name>logctail</name></decl>;</decl_stmt>}</block> <decl><name><name>tab</name><index>[<expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>POW_LOG_TABLE_BITS</name></expr>]</index></name></decl>;</struct>
}</block> <decl><name>__pow_log_data</name> <name>HIDDEN</name></decl>;</struct>

<struct><specifier>extern</specifier> <specifier>const</specifier> struct <name>erff_data</name>
<block>{
<decl_stmt><decl><type><name>float</name></type> <name><name>erff_poly_A</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name><name>erff_poly_B</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></decl>;</decl_stmt>
}</block> <decl><name>__erff_data</name> <name>HIDDEN</name></decl>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERF_POLY_A_ORDER</name></cpp:macro> <cpp:value>19</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERF_POLY_A_NCOEFFS</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERFC_POLY_C_NCOEFFS</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERFC_POLY_D_NCOEFFS</name></cpp:macro> <cpp:value>18</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERFC_POLY_E_NCOEFFS</name></cpp:macro> <cpp:value>14</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERFC_POLY_F_NCOEFFS</name></cpp:macro> <cpp:value>17</cpp:value></cpp:define>
<struct><specifier>extern</specifier> <specifier>const</specifier> struct <name>erf_data</name>
<block>{
<decl_stmt><decl><type><name>double</name></type> <name><name>erf_poly_A</name><index>[<expr><name>ERF_POLY_A_NCOEFFS</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name><name>erf_ratio_N_A</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name><name>erf_ratio_D_A</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name><name>erf_ratio_N_B</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name><name>erf_ratio_D_B</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name><name>erfc_poly_C</name><index>[<expr><name>ERFC_POLY_C_NCOEFFS</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name><name>erfc_poly_D</name><index>[<expr><name>ERFC_POLY_D_NCOEFFS</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name><name>erfc_poly_E</name><index>[<expr><name>ERFC_POLY_E_NCOEFFS</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name><name>erfc_poly_F</name><index>[<expr><name>ERFC_POLY_F_NCOEFFS</name></expr>]</index></name></decl>;</decl_stmt>
}</block> <decl><name>__erf_data</name> <name>HIDDEN</name></decl>;</struct>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
