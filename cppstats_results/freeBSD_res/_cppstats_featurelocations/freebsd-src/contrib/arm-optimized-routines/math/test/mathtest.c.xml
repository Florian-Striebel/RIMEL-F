<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/arm-optimized-routines/math/test/mathtest.c">






<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;setjmp.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fenv.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mathlib.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>math_errhandling</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>math_errhandling</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXTERN_C</name></cpp:macro> <cpp:value>extern "C"</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXTERN_C</name></cpp:macro> <cpp:value>extern</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRUE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FALSE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IMPORT_SYMBOL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STR2</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>#x</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STR</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>STR2(x)</cpp:value></cpp:define>
<macro><name>_Pragma</name><argument_list>(<argument>STR(import IMPORT_SYMBOL)</argument>)</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>int</name></type> <name>dmsd</name></decl>, <decl><type ref="prev"/><name>dlsd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>quiet</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>doround</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>statusmask</name> <init>= <expr><name>FE_ALL_EXCEPT</name></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXTRABITS</name></cpp:macro> <cpp:value>(12)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ULPUNIT</name></cpp:macro> <cpp:value>(1&lt;&lt;EXTRABITS)</cpp:value></cpp:define>

<typedef>typedef <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>test</name>) <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl></typedef>




<typedef>typedef <type><struct>struct <block>{
<enum>enum <block>{
<decl><name>t_func</name></decl>, <decl><name>t_macro</name></decl>
}</block> <decl><name>type</name></decl>;</enum>
<enum>enum <block>{
<decl><name>at_d</name></decl>, <decl><name>at_s</name></decl>,
<decl><name>at_d2</name></decl>, <decl><name>at_s2</name></decl>,
<decl><name>at_di</name></decl>, <decl><name>at_si</name></decl>,
<decl><name>at_dip</name></decl>, <decl><name>at_sip</name></decl>,
<decl><name>at_ddp</name></decl>, <decl><name>at_ssp</name></decl>,
<decl><name>at_dc</name></decl>, <decl><name>at_sc</name></decl>,
<decl><name>at_dc2</name></decl>, <decl><name>at_sc2</name></decl>
}</block> <decl><name>argtype</name></decl>;</enum>
<enum>enum <block>{
<decl><name>rt_d</name></decl>, <decl><name>rt_s</name></decl>, <decl><name>rt_i</name></decl>,
<decl><name>rt_dc</name></decl>, <decl><name>rt_sc</name></decl>,
<decl><name>rt_d2</name></decl>, <decl><name>rt_s2</name></decl>
}</block> <decl><name>rettype</name></decl>;</enum>
<union>union <block>{
<decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>ptr</name></decl>;</decl_stmt>
<function_decl><type><name>double</name></type> (<modifier>*</modifier><name>d_d_ptr</name>)<parameter_list>(<parameter><decl><type><name>double</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>float</name></type> (<modifier>*</modifier><name>s_s_ptr</name>)<parameter_list>(<parameter><decl><type><name>float</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> (<modifier>*</modifier><name>d_i_ptr</name>)<parameter_list>(<parameter><decl><type><name>double</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> (<modifier>*</modifier><name>s_i_ptr</name>)<parameter_list>(<parameter><decl><type><name>float</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>double</name></type> (<modifier>*</modifier><name>d2_d_ptr</name>)<parameter_list>(<parameter><decl><type><name>double</name></type></decl></parameter>, <parameter><decl><type><name>double</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>float</name></type> (<modifier>*</modifier><name>s2_s_ptr</name>)<parameter_list>(<parameter><decl><type><name>float</name></type></decl></parameter>, <parameter><decl><type><name>float</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>double</name></type> (<modifier>*</modifier><name>di_d_ptr</name>)<parameter_list>(<parameter><decl><type><name>double</name></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>float</name></type> (<modifier>*</modifier><name>si_s_ptr</name>)<parameter_list>(<parameter><decl><type><name>float</name></type></decl></parameter>,<parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>double</name></type> (<modifier>*</modifier><name>dip_d_ptr</name>)<parameter_list>(<parameter><decl><type><name>double</name></type></decl></parameter>,<parameter><decl><type><name>int</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>float</name></type> (<modifier>*</modifier><name>sip_s_ptr</name>)<parameter_list>(<parameter><decl><type><name>float</name></type></decl></parameter>,<parameter><decl><type><name>int</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>double</name></type> (<modifier>*</modifier><name>ddp_d_ptr</name>)<parameter_list>(<parameter><decl><type><name>double</name></type></decl></parameter>,<parameter><decl><type><name>double</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>float</name></type> (<modifier>*</modifier><name>ssp_s_ptr</name>)<parameter_list>(<parameter><decl><type><name>float</name></type></decl></parameter>,<parameter><decl><type><name>float</name><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
}</block> <decl><name>func</name></decl>;</union>
<enum>enum <block>{
<decl><name>m_none</name></decl>,
<decl><name>m_isfinite</name></decl>, <decl><name>m_isfinitef</name></decl>,
<decl><name>m_isgreater</name></decl>, <decl><name>m_isgreaterequal</name></decl>,
<decl><name>m_isgreaterequalf</name></decl>, <decl><name>m_isgreaterf</name></decl>,
<decl><name>m_isinf</name></decl>, <decl><name>m_isinff</name></decl>,
<decl><name>m_isless</name></decl>, <decl><name>m_islessequal</name></decl>,
<decl><name>m_islessequalf</name></decl>, <decl><name>m_islessf</name></decl>,
<decl><name>m_islessgreater</name></decl>, <decl><name>m_islessgreaterf</name></decl>,
<decl><name>m_isnan</name></decl>, <decl><name>m_isnanf</name></decl>,
<decl><name>m_isnormal</name></decl>, <decl><name>m_isnormalf</name></decl>,
<decl><name>m_isunordered</name></decl>, <decl><name>m_isunorderedf</name></decl>,
<decl><name>m_fpclassify</name></decl>, <decl><name>m_fpclassifyf</name></decl>,
<decl><name>m_signbit</name></decl>, <decl><name>m_signbitf</name></decl>,

<decl><name>m_rred</name></decl>, <decl><name>m_rredf</name></decl>,
<decl><name>m_cadd</name></decl>, <decl><name>m_csub</name></decl>, <decl><name>m_cmul</name></decl>, <decl><name>m_cdiv</name></decl>,
<decl><name>m_caddf</name></decl>, <decl><name>m_csubf</name></decl>, <decl><name>m_cmulf</name></decl>, <decl><name>m_cdivf</name></decl>
}</block> <decl><name>macro_name</name></decl>;</enum>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>tolerance</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>name</name></decl>;</decl_stmt>
}</block></struct></type> <name>test_func</name>;</typedef>


<function><type><name>int</name></type> <name>compare_tfuncs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>test_func</name><operator>*</operator><operator>)</operator><name>a</name><operator>)</operator><operator>-&gt;</operator><name>name</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>test_func</name><operator>*</operator><operator>)</operator><name>b</name><operator>)</operator><operator>-&gt;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>is_double_argtype</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argtype</name></decl></parameter>)</parameter_list> <block>{<block_content>
<switch>switch<condition>(<expr><name>argtype</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>at_d</name></expr>:</case>
<case>case <expr><name>at_d2</name></expr>:</case>
<case>case <expr><name>at_dc</name></expr>:</case>
<case>case <expr><name>at_dc2</name></expr>:</case>
<return>return <expr><literal type="number">1</literal></expr>;</return>
<default>default:</default>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>is_single_argtype</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argtype</name></decl></parameter>)</parameter_list> <block>{<block_content>
<switch>switch<condition>(<expr><name>argtype</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>at_s</name></expr>:</case>
<case>case <expr><name>at_s2</name></expr>:</case>
<case>case <expr><name>at_sc</name></expr>:</case>
<case>case <expr><name>at_sc2</name></expr>:</case>
<return>return <expr><literal type="number">1</literal></expr>;</return>
<default>default:</default>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>is_double_rettype</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>rettype</name></decl></parameter>)</parameter_list> <block>{<block_content>
<switch>switch<condition>(<expr><name>rettype</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>rt_d</name></expr>:</case>
<case>case <expr><name>rt_dc</name></expr>:</case>
<case>case <expr><name>rt_d2</name></expr>:</case>
<return>return <expr><literal type="number">1</literal></expr>;</return>
<default>default:</default>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>is_single_rettype</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>rettype</name></decl></parameter>)</parameter_list> <block>{<block_content>
<switch>switch<condition>(<expr><name>rettype</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>rt_s</name></expr>:</case>
<case>case <expr><name>rt_sc</name></expr>:</case>
<case>case <expr><name>rt_s2</name></expr>:</case>
<return>return <expr><literal type="number">1</literal></expr>;</return>
<default>default:</default>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>is_complex_argtype</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argtype</name></decl></parameter>)</parameter_list> <block>{<block_content>
<switch>switch<condition>(<expr><name>argtype</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>at_dc</name></expr>:</case>
<case>case <expr><name>at_sc</name></expr>:</case>
<case>case <expr><name>at_dc2</name></expr>:</case>
<case>case <expr><name>at_sc2</name></expr>:</case>
<return>return <expr><literal type="number">1</literal></expr>;</return>
<default>default:</default>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>is_complex_rettype</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>rettype</name></decl></parameter>)</parameter_list> <block>{<block_content>
<switch>switch<condition>(<expr><name>rettype</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>rt_dc</name></expr>:</case>
<case>case <expr><name>rt_sc</name></expr>:</case>
<return>return <expr><literal type="number">1</literal></expr>;</return>
<default>default:</default>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>






<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ABSLOWERBOUND</name></cpp:macro> <cpp:value>0x4000000000000000LL</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PLUSMINUSPIO2</name></cpp:macro> <cpp:value>0x1000000000000000LL</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARM_PREFIX</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>x</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TFUNC</name><parameter_list>(<parameter><type><name>arg</name></type></parameter>,<parameter><type><name>ret</name></type></parameter>,<parameter><type><name>name</name></type></parameter>,<parameter><type><name>tolerance</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ t_func, arg, ret, (void*)&amp;name, m_none, tolerance, #name }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TFUNCARM</name><parameter_list>(<parameter><type><name>arg</name></type></parameter>,<parameter><type><name>ret</name></type></parameter>,<parameter><type><name>name</name></type></parameter>,<parameter><type><name>tolerance</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ t_func, arg, ret, (void*)&amp; ARM_PREFIX(name), m_none, tolerance, #name }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MFUNC</name><parameter_list>(<parameter><type><name>arg</name></type></parameter>,<parameter><type><name>ret</name></type></parameter>,<parameter><type><name>name</name></type></parameter>,<parameter><type><name>tolerance</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ t_macro, arg, ret, NULL, m_##name, tolerance, #name }</cpp:value></cpp:define>


<function><type><specifier>static</specifier> <name>float</name></type> <name>sincosf_sinf</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>x</name></decl></parameter>)</parameter_list> <block>{<block_content> <decl_stmt><decl><type><name>float</name></type> <name>s</name></decl>,<decl><type ref="prev"/><name>c</name></decl>;</decl_stmt> <expr_stmt><expr><call><name>sincosf</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>s</name></expr>;</return> </block_content>}</block></function>
<function><type><specifier>static</specifier> <name>float</name></type> <name>sincosf_cosf</name><parameter_list>(<parameter><decl><type><name>float</name></type> <name>x</name></decl></parameter>)</parameter_list> <block>{<block_content> <decl_stmt><decl><type><name>float</name></type> <name>s</name></decl>,<decl><type ref="prev"/><name>c</name></decl>;</decl_stmt> <expr_stmt><expr><call><name>sincosf</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><name>c</name></expr>;</return> </block_content>}</block></function>

<decl_stmt><decl><type><name>test_func</name></type> <name><name>tfuncs</name><index>[]</index></name> <init>= <expr><block>{

<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_d</name></expr></argument>,<argument><expr><name>rt_d</name></expr></argument>, <argument><expr><name>acos</name></expr></argument>, <argument><expr><literal type="number">4</literal><operator>*</operator><name>ULPUNIT</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_d</name></expr></argument>,<argument><expr><name>rt_d</name></expr></argument>, <argument><expr><name>asin</name></expr></argument>, <argument><expr><literal type="number">4</literal><operator>*</operator><name>ULPUNIT</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_d</name></expr></argument>,<argument><expr><name>rt_d</name></expr></argument>, <argument><expr><name>atan</name></expr></argument>, <argument><expr><literal type="number">4</literal><operator>*</operator><name>ULPUNIT</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_d2</name></expr></argument>,<argument><expr><name>rt_d</name></expr></argument>, <argument><expr><name>atan2</name></expr></argument>, <argument><expr><literal type="number">4</literal><operator>*</operator><name>ULPUNIT</name></expr></argument>)</argument_list></call></expr>,

<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_d</name></expr></argument>,<argument><expr><name>rt_d</name></expr></argument>, <argument><expr><name>tan</name></expr></argument>, <argument><expr><literal type="number">2</literal><operator>*</operator><name>ULPUNIT</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_d</name></expr></argument>,<argument><expr><name>rt_d</name></expr></argument>, <argument><expr><name>sin</name></expr></argument>, <argument><expr><literal type="number">2</literal><operator>*</operator><name>ULPUNIT</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_d</name></expr></argument>,<argument><expr><name>rt_d</name></expr></argument>, <argument><expr><name>cos</name></expr></argument>, <argument><expr><literal type="number">2</literal><operator>*</operator><name>ULPUNIT</name></expr></argument>)</argument_list></call></expr>,

<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_s</name></expr></argument>,<argument><expr><name>rt_s</name></expr></argument>, <argument><expr><name>acosf</name></expr></argument>, <argument><expr><literal type="number">4</literal><operator>*</operator><name>ULPUNIT</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_s</name></expr></argument>,<argument><expr><name>rt_s</name></expr></argument>, <argument><expr><name>asinf</name></expr></argument>, <argument><expr><literal type="number">4</literal><operator>*</operator><name>ULPUNIT</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_s</name></expr></argument>,<argument><expr><name>rt_s</name></expr></argument>, <argument><expr><name>atanf</name></expr></argument>, <argument><expr><literal type="number">4</literal><operator>*</operator><name>ULPUNIT</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_s2</name></expr></argument>,<argument><expr><name>rt_s</name></expr></argument>, <argument><expr><name>atan2f</name></expr></argument>, <argument><expr><literal type="number">4</literal><operator>*</operator><name>ULPUNIT</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNCARM</name><argument_list>(<argument><expr><name>at_s</name></expr></argument>,<argument><expr><name>rt_s</name></expr></argument>, <argument><expr><name>tanf</name></expr></argument>, <argument><expr><literal type="number">4</literal><operator>*</operator><name>ULPUNIT</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNCARM</name><argument_list>(<argument><expr><name>at_s</name></expr></argument>,<argument><expr><name>rt_s</name></expr></argument>, <argument><expr><name>sinf</name></expr></argument>, <argument><expr><literal type="number">3</literal><operator>*</operator><name>ULPUNIT</name><operator>/</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNCARM</name><argument_list>(<argument><expr><name>at_s</name></expr></argument>,<argument><expr><name>rt_s</name></expr></argument>, <argument><expr><name>cosf</name></expr></argument>, <argument><expr><literal type="number">3</literal><operator>*</operator><name>ULPUNIT</name><operator>/</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNCARM</name><argument_list>(<argument><expr><name>at_s</name></expr></argument>,<argument><expr><name>rt_s</name></expr></argument>, <argument><expr><name>sincosf_sinf</name></expr></argument>, <argument><expr><literal type="number">3</literal><operator>*</operator><name>ULPUNIT</name><operator>/</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNCARM</name><argument_list>(<argument><expr><name>at_s</name></expr></argument>,<argument><expr><name>rt_s</name></expr></argument>, <argument><expr><name>sincosf_cosf</name></expr></argument>, <argument><expr><literal type="number">3</literal><operator>*</operator><name>ULPUNIT</name><operator>/</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>,


<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_d</name></expr></argument>, <argument><expr><name>rt_d</name></expr></argument>, <argument><expr><name>atanh</name></expr></argument>, <argument><expr><literal type="number">4</literal><operator>*</operator><name>ULPUNIT</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_d</name></expr></argument>, <argument><expr><name>rt_d</name></expr></argument>, <argument><expr><name>asinh</name></expr></argument>, <argument><expr><literal type="number">4</literal><operator>*</operator><name>ULPUNIT</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_d</name></expr></argument>, <argument><expr><name>rt_d</name></expr></argument>, <argument><expr><name>acosh</name></expr></argument>, <argument><expr><literal type="number">4</literal><operator>*</operator><name>ULPUNIT</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_d</name></expr></argument>,<argument><expr><name>rt_d</name></expr></argument>, <argument><expr><name>tanh</name></expr></argument>, <argument><expr><literal type="number">4</literal><operator>*</operator><name>ULPUNIT</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_d</name></expr></argument>,<argument><expr><name>rt_d</name></expr></argument>, <argument><expr><name>sinh</name></expr></argument>, <argument><expr><literal type="number">4</literal><operator>*</operator><name>ULPUNIT</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_d</name></expr></argument>,<argument><expr><name>rt_d</name></expr></argument>, <argument><expr><name>cosh</name></expr></argument>, <argument><expr><literal type="number">4</literal><operator>*</operator><name>ULPUNIT</name></expr></argument>)</argument_list></call></expr>,

<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_s</name></expr></argument>, <argument><expr><name>rt_s</name></expr></argument>, <argument><expr><name>atanhf</name></expr></argument>, <argument><expr><literal type="number">4</literal><operator>*</operator><name>ULPUNIT</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_s</name></expr></argument>, <argument><expr><name>rt_s</name></expr></argument>, <argument><expr><name>asinhf</name></expr></argument>, <argument><expr><literal type="number">4</literal><operator>*</operator><name>ULPUNIT</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_s</name></expr></argument>, <argument><expr><name>rt_s</name></expr></argument>, <argument><expr><name>acoshf</name></expr></argument>, <argument><expr><literal type="number">4</literal><operator>*</operator><name>ULPUNIT</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_s</name></expr></argument>,<argument><expr><name>rt_s</name></expr></argument>, <argument><expr><name>tanhf</name></expr></argument>, <argument><expr><literal type="number">4</literal><operator>*</operator><name>ULPUNIT</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_s</name></expr></argument>,<argument><expr><name>rt_s</name></expr></argument>, <argument><expr><name>sinhf</name></expr></argument>, <argument><expr><literal type="number">4</literal><operator>*</operator><name>ULPUNIT</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_s</name></expr></argument>,<argument><expr><name>rt_s</name></expr></argument>, <argument><expr><name>coshf</name></expr></argument>, <argument><expr><literal type="number">4</literal><operator>*</operator><name>ULPUNIT</name></expr></argument>)</argument_list></call></expr>,


<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_d</name></expr></argument>,<argument><expr><name>rt_d</name></expr></argument>, <argument><expr><name>log</name></expr></argument>, <argument><expr><literal type="number">3</literal><operator>*</operator><name>ULPUNIT</name><operator>/</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_d</name></expr></argument>,<argument><expr><name>rt_d</name></expr></argument>, <argument><expr><name>log10</name></expr></argument>, <argument><expr><literal type="number">3</literal><operator>*</operator><name>ULPUNIT</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_d</name></expr></argument>,<argument><expr><name>rt_d</name></expr></argument>, <argument><expr><name>log2</name></expr></argument>, <argument><expr><literal type="number">3</literal><operator>*</operator><name>ULPUNIT</name><operator>/</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_d</name></expr></argument>,<argument><expr><name>rt_d</name></expr></argument>, <argument><expr><name>log1p</name></expr></argument>, <argument><expr><literal type="number">2</literal><operator>*</operator><name>ULPUNIT</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_d</name></expr></argument>,<argument><expr><name>rt_d</name></expr></argument>, <argument><expr><name>exp</name></expr></argument>, <argument><expr><literal type="number">3</literal><operator>*</operator><name>ULPUNIT</name><operator>/</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_d</name></expr></argument>,<argument><expr><name>rt_d</name></expr></argument>, <argument><expr><name>exp2</name></expr></argument>, <argument><expr><literal type="number">3</literal><operator>*</operator><name>ULPUNIT</name><operator>/</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_d</name></expr></argument>,<argument><expr><name>rt_d</name></expr></argument>, <argument><expr><name>expm1</name></expr></argument>, <argument><expr><name>ULPUNIT</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNCARM</name><argument_list>(<argument><expr><name>at_s</name></expr></argument>,<argument><expr><name>rt_s</name></expr></argument>, <argument><expr><name>logf</name></expr></argument>, <argument><expr><name>ULPUNIT</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_s</name></expr></argument>,<argument><expr><name>rt_s</name></expr></argument>, <argument><expr><name>log10f</name></expr></argument>, <argument><expr><literal type="number">3</literal><operator>*</operator><name>ULPUNIT</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNCARM</name><argument_list>(<argument><expr><name>at_s</name></expr></argument>,<argument><expr><name>rt_s</name></expr></argument>, <argument><expr><name>log2f</name></expr></argument>, <argument><expr><name>ULPUNIT</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_s</name></expr></argument>,<argument><expr><name>rt_s</name></expr></argument>, <argument><expr><name>log1pf</name></expr></argument>, <argument><expr><literal type="number">2</literal><operator>*</operator><name>ULPUNIT</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNCARM</name><argument_list>(<argument><expr><name>at_s</name></expr></argument>,<argument><expr><name>rt_s</name></expr></argument>, <argument><expr><name>expf</name></expr></argument>, <argument><expr><literal type="number">3</literal><operator>*</operator><name>ULPUNIT</name><operator>/</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNCARM</name><argument_list>(<argument><expr><name>at_s</name></expr></argument>,<argument><expr><name>rt_s</name></expr></argument>, <argument><expr><name>exp2f</name></expr></argument>, <argument><expr><literal type="number">3</literal><operator>*</operator><name>ULPUNIT</name><operator>/</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_s</name></expr></argument>,<argument><expr><name>rt_s</name></expr></argument>, <argument><expr><name>expm1f</name></expr></argument>, <argument><expr><name>ULPUNIT</name></expr></argument>)</argument_list></call></expr>,


<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_d2</name></expr></argument>,<argument><expr><name>rt_d</name></expr></argument>, <argument><expr><name>pow</name></expr></argument>, <argument><expr><literal type="number">3</literal><operator>*</operator><name>ULPUNIT</name><operator>/</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_d</name></expr></argument>,<argument><expr><name>rt_d</name></expr></argument>, <argument><expr><name>sqrt</name></expr></argument>, <argument><expr><name>ULPUNIT</name><operator>/</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_d</name></expr></argument>,<argument><expr><name>rt_d</name></expr></argument>, <argument><expr><name>cbrt</name></expr></argument>, <argument><expr><literal type="number">2</literal><operator>*</operator><name>ULPUNIT</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_d2</name></expr></argument>, <argument><expr><name>rt_d</name></expr></argument>, <argument><expr><name>hypot</name></expr></argument>, <argument><expr><literal type="number">4</literal><operator>*</operator><name>ULPUNIT</name></expr></argument>)</argument_list></call></expr>,

<expr><call><name>TFUNCARM</name><argument_list>(<argument><expr><name>at_s2</name></expr></argument>,<argument><expr><name>rt_s</name></expr></argument>, <argument><expr><name>powf</name></expr></argument>, <argument><expr><name>ULPUNIT</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_s</name></expr></argument>,<argument><expr><name>rt_s</name></expr></argument>, <argument><expr><name>sqrtf</name></expr></argument>, <argument><expr><name>ULPUNIT</name><operator>/</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_s</name></expr></argument>,<argument><expr><name>rt_s</name></expr></argument>, <argument><expr><name>cbrtf</name></expr></argument>, <argument><expr><literal type="number">2</literal><operator>*</operator><name>ULPUNIT</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_s2</name></expr></argument>, <argument><expr><name>rt_s</name></expr></argument>, <argument><expr><name>hypotf</name></expr></argument>, <argument><expr><literal type="number">4</literal><operator>*</operator><name>ULPUNIT</name></expr></argument>)</argument_list></call></expr>,


<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_d</name></expr></argument>,<argument><expr><name>rt_d</name></expr></argument>, <argument><expr><name>erf</name></expr></argument>, <argument><expr><literal type="number">16</literal><operator>*</operator><name>ULPUNIT</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_s</name></expr></argument>,<argument><expr><name>rt_s</name></expr></argument>, <argument><expr><name>erff</name></expr></argument>, <argument><expr><literal type="number">16</literal><operator>*</operator><name>ULPUNIT</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_d</name></expr></argument>,<argument><expr><name>rt_d</name></expr></argument>, <argument><expr><name>erfc</name></expr></argument>, <argument><expr><literal type="number">16</literal><operator>*</operator><name>ULPUNIT</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_s</name></expr></argument>,<argument><expr><name>rt_s</name></expr></argument>, <argument><expr><name>erfcf</name></expr></argument>, <argument><expr><literal type="number">16</literal><operator>*</operator><name>ULPUNIT</name></expr></argument>)</argument_list></call></expr>,


<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_d</name></expr></argument>,<argument><expr><name>rt_d</name></expr></argument>, <argument><expr><name>tgamma</name></expr></argument>, <argument><expr><literal type="number">16</literal><operator>*</operator><name>ULPUNIT</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_s</name></expr></argument>,<argument><expr><name>rt_s</name></expr></argument>, <argument><expr><name>tgammaf</name></expr></argument>, <argument><expr><literal type="number">16</literal><operator>*</operator><name>ULPUNIT</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_d</name></expr></argument>,<argument><expr><name>rt_d</name></expr></argument>, <argument><expr><name>lgamma</name></expr></argument>, <argument><expr><literal type="number">16</literal><operator>*</operator><name>ULPUNIT</name> <operator>|</operator> <name>ABSLOWERBOUND</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_s</name></expr></argument>,<argument><expr><name>rt_s</name></expr></argument>, <argument><expr><name>lgammaf</name></expr></argument>, <argument><expr><literal type="number">16</literal><operator>*</operator><name>ULPUNIT</name> <operator>|</operator> <name>ABSLOWERBOUND</name></expr></argument>)</argument_list></call></expr>,

<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_d</name></expr></argument>,<argument><expr><name>rt_d</name></expr></argument>, <argument><expr><name>ceil</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_s</name></expr></argument>,<argument><expr><name>rt_s</name></expr></argument>, <argument><expr><name>ceilf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_d2</name></expr></argument>,<argument><expr><name>rt_d</name></expr></argument>, <argument><expr><name>copysign</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_s2</name></expr></argument>,<argument><expr><name>rt_s</name></expr></argument>, <argument><expr><name>copysignf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_d</name></expr></argument>,<argument><expr><name>rt_d</name></expr></argument>, <argument><expr><name>floor</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_s</name></expr></argument>,<argument><expr><name>rt_s</name></expr></argument>, <argument><expr><name>floorf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_d2</name></expr></argument>,<argument><expr><name>rt_d</name></expr></argument>, <argument><expr><name>fmax</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_s2</name></expr></argument>,<argument><expr><name>rt_s</name></expr></argument>, <argument><expr><name>fmaxf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_d2</name></expr></argument>,<argument><expr><name>rt_d</name></expr></argument>, <argument><expr><name>fmin</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_s2</name></expr></argument>,<argument><expr><name>rt_s</name></expr></argument>, <argument><expr><name>fminf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_d2</name></expr></argument>,<argument><expr><name>rt_d</name></expr></argument>, <argument><expr><name>fmod</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_s2</name></expr></argument>,<argument><expr><name>rt_s</name></expr></argument>, <argument><expr><name>fmodf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>MFUNC</name><argument_list>(<argument><expr><name>at_d</name></expr></argument>, <argument><expr><name>rt_i</name></expr></argument>, <argument><expr><name>fpclassify</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>MFUNC</name><argument_list>(<argument><expr><name>at_s</name></expr></argument>, <argument><expr><name>rt_i</name></expr></argument>, <argument><expr><name>fpclassifyf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_dip</name></expr></argument>,<argument><expr><name>rt_d</name></expr></argument>, <argument><expr><name>frexp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_sip</name></expr></argument>,<argument><expr><name>rt_s</name></expr></argument>, <argument><expr><name>frexpf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>MFUNC</name><argument_list>(<argument><expr><name>at_d</name></expr></argument>, <argument><expr><name>rt_i</name></expr></argument>, <argument><expr><name>isfinite</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>MFUNC</name><argument_list>(<argument><expr><name>at_s</name></expr></argument>, <argument><expr><name>rt_i</name></expr></argument>, <argument><expr><name>isfinitef</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>MFUNC</name><argument_list>(<argument><expr><name>at_d</name></expr></argument>, <argument><expr><name>rt_i</name></expr></argument>, <argument><expr><name>isgreater</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>MFUNC</name><argument_list>(<argument><expr><name>at_d</name></expr></argument>, <argument><expr><name>rt_i</name></expr></argument>, <argument><expr><name>isgreaterequal</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>MFUNC</name><argument_list>(<argument><expr><name>at_s</name></expr></argument>, <argument><expr><name>rt_i</name></expr></argument>, <argument><expr><name>isgreaterequalf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>MFUNC</name><argument_list>(<argument><expr><name>at_s</name></expr></argument>, <argument><expr><name>rt_i</name></expr></argument>, <argument><expr><name>isgreaterf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>MFUNC</name><argument_list>(<argument><expr><name>at_d</name></expr></argument>, <argument><expr><name>rt_i</name></expr></argument>, <argument><expr><name>isinf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>MFUNC</name><argument_list>(<argument><expr><name>at_s</name></expr></argument>, <argument><expr><name>rt_i</name></expr></argument>, <argument><expr><name>isinff</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>MFUNC</name><argument_list>(<argument><expr><name>at_d</name></expr></argument>, <argument><expr><name>rt_i</name></expr></argument>, <argument><expr><name>isless</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>MFUNC</name><argument_list>(<argument><expr><name>at_d</name></expr></argument>, <argument><expr><name>rt_i</name></expr></argument>, <argument><expr><name>islessequal</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>MFUNC</name><argument_list>(<argument><expr><name>at_s</name></expr></argument>, <argument><expr><name>rt_i</name></expr></argument>, <argument><expr><name>islessequalf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>MFUNC</name><argument_list>(<argument><expr><name>at_s</name></expr></argument>, <argument><expr><name>rt_i</name></expr></argument>, <argument><expr><name>islessf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>MFUNC</name><argument_list>(<argument><expr><name>at_d</name></expr></argument>, <argument><expr><name>rt_i</name></expr></argument>, <argument><expr><name>islessgreater</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>MFUNC</name><argument_list>(<argument><expr><name>at_s</name></expr></argument>, <argument><expr><name>rt_i</name></expr></argument>, <argument><expr><name>islessgreaterf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>MFUNC</name><argument_list>(<argument><expr><name>at_d</name></expr></argument>, <argument><expr><name>rt_i</name></expr></argument>, <argument><expr><name>isnan</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>MFUNC</name><argument_list>(<argument><expr><name>at_s</name></expr></argument>, <argument><expr><name>rt_i</name></expr></argument>, <argument><expr><name>isnanf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>MFUNC</name><argument_list>(<argument><expr><name>at_d</name></expr></argument>, <argument><expr><name>rt_i</name></expr></argument>, <argument><expr><name>isnormal</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>MFUNC</name><argument_list>(<argument><expr><name>at_s</name></expr></argument>, <argument><expr><name>rt_i</name></expr></argument>, <argument><expr><name>isnormalf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>MFUNC</name><argument_list>(<argument><expr><name>at_d</name></expr></argument>, <argument><expr><name>rt_i</name></expr></argument>, <argument><expr><name>isunordered</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>MFUNC</name><argument_list>(<argument><expr><name>at_s</name></expr></argument>, <argument><expr><name>rt_i</name></expr></argument>, <argument><expr><name>isunorderedf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_di</name></expr></argument>,<argument><expr><name>rt_d</name></expr></argument>, <argument><expr><name>ldexp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_si</name></expr></argument>,<argument><expr><name>rt_s</name></expr></argument>, <argument><expr><name>ldexpf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_ddp</name></expr></argument>,<argument><expr><name>rt_d2</name></expr></argument>, <argument><expr><name>modf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TFUNC</name><argument_list>(<argument><expr><name>at_ssp</name></expr></argument>,<argument><expr><name>rt_s2</name></expr></argument>, <argument><expr><name>modff</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>BIGRANGERED</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><call><name>MFUNC</name><argument_list>(<argument><expr><name>at_d</name></expr></argument>, <argument><expr><name>rt_d</name></expr></argument>, <argument><expr><name>rred</name></expr></argument>, <argument><expr><literal type="number">2</literal><operator>*</operator><name>ULPUNIT</name></expr></argument>)</argument_list></call></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr><call><name>MFUNC</name><argument_list>(<argument><expr><name>at_d</name></expr></argument>, <argument><expr><name>rt_d</name></expr></argument>, <argument><expr><name>m_rred</name></expr></argument>, <argument><expr><name>ULPUNIT</name></expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><call><name>MFUNC</name><argument_list>(<argument><expr><name>at_d</name></expr></argument>, <argument><expr><name>rt_i</name></expr></argument>, <argument><expr><name>signbit</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>MFUNC</name><argument_list>(<argument><expr><name>at_s</name></expr></argument>, <argument><expr><name>rt_i</name></expr></argument>, <argument><expr><name>signbitf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>,
}</block></expr></init></decl>;</decl_stmt>







<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>test_func</name> <modifier>*</modifier></type><name>func</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name><name>op1r</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name><name>op1i</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name><name>op2r</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name><name>op2i</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name><name>resultr</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name><name>resulti</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
<enum>enum <block>{
<decl><name>rc_none</name></decl>, <decl><name>rc_zero</name></decl>, <decl><name>rc_infinity</name></decl>, <decl><name>rc_nan</name></decl>, <decl><name>rc_finite</name></decl>
}</block> <decl><name>resultc</name></decl>;</enum>
<decl_stmt><decl><type><name>unsigned</name></type> <name><name>res2</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>status</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>maybestatus</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nresult</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>in_err</name></decl>, <name>in_err_limit</name>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>maybeerr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>valid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>comment</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>random</name></decl>;</decl_stmt>
}</block></struct></type> <name>testdetail</name>;</typedef>

<enum>enum <block>{
<decl><name>k_errno</name></decl>, <decl><name>k_errno_in</name></decl>, <decl><name>k_error</name></decl>, <decl><name>k_func</name></decl>, <decl><name>k_maybeerror</name></decl>, <decl><name>k_maybestatus</name></decl>, <decl><name>k_op1</name></decl>, <decl><name>k_op1i</name></decl>, <decl><name>k_op1r</name></decl>, <decl><name>k_op2</name></decl>, <decl><name>k_op2i</name></decl>, <decl><name>k_op2r</name></decl>,
<decl><name>k_random</name></decl>, <decl><name>k_res2</name></decl>, <decl><name>k_result</name></decl>, <decl><name>k_resultc</name></decl>, <decl><name>k_resulti</name></decl>, <decl><name>k_resultr</name></decl>, <decl><name>k_status</name></decl>,
<decl><name>k_wrongres2</name></decl>, <decl><name>k_wrongresult</name></decl>, <decl><name>k_wrongstatus</name></decl>, <decl><name>k_wrongerrno</name></decl>
}</block>;</enum>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name><name>keywords</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"errno"</literal></expr>, <expr><literal type="string">"errno_in"</literal></expr>, <expr><literal type="string">"error"</literal></expr>, <expr><literal type="string">"func"</literal></expr>, <expr><literal type="string">"maybeerror"</literal></expr>, <expr><literal type="string">"maybestatus"</literal></expr>, <expr><literal type="string">"op1"</literal></expr>, <expr><literal type="string">"op1i"</literal></expr>, <expr><literal type="string">"op1r"</literal></expr>, <expr><literal type="string">"op2"</literal></expr>, <expr><literal type="string">"op2i"</literal></expr>, <expr><literal type="string">"op2r"</literal></expr>,
<expr><literal type="string">"random"</literal></expr>, <expr><literal type="string">"res2"</literal></expr>, <expr><literal type="string">"result"</literal></expr>, <expr><literal type="string">"resultc"</literal></expr>, <expr><literal type="string">"resulti"</literal></expr>, <expr><literal type="string">"resultr"</literal></expr>, <expr><literal type="string">"status"</literal></expr>,
<expr><literal type="string">"wrongres2"</literal></expr>, <expr><literal type="string">"wrongresult"</literal></expr>, <expr><literal type="string">"wrongstatus"</literal></expr>, <expr><literal type="string">"wrongerrno"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<enum>enum <block>{
<decl><name>e_0</name></decl>, <decl><name>e_EDOM</name></decl>, <decl><name>e_ERANGE</name></decl>,





<decl><name>e_number_of_errnos</name></decl>
}</block>;</enum>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name><name>errnos</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"0"</literal></expr>, <expr><literal type="string">"EDOM"</literal></expr>, <expr><literal type="string">"ERANGE"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<enum>enum <block>{
<decl><name>e_none</name></decl>, <decl><name>e_divbyzero</name></decl>, <decl><name>e_domain</name></decl>, <decl><name>e_overflow</name></decl>, <decl><name>e_underflow</name></decl>
}</block>;</enum>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name><name>errors</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"0"</literal></expr>, <expr><literal type="string">"divbyzero"</literal></expr>, <expr><literal type="string">"domain"</literal></expr>, <expr><literal type="string">"overflow"</literal></expr>, <expr><literal type="string">"underflow"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>verbose</name></decl>, <decl><type ref="prev"/><name>fo</name></decl>, <decl><type ref="prev"/><name>strict</name></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>randomstate</name></decl>;</decl_stmt>



<function><type><name>void</name></type> <name>canon_dNaN</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x7FF00000</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0x7FF00000</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xFFFFF</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;=</operator> <literal type="number">0x7FF80000</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x00000001</literal></expr>;</expr_stmt>
</block_content>}</block></function>



<function><type><name>void</name></type> <name>canon_sNaN</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x7F800000</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0x7F800000</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x7FFFFF</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;=</operator> <literal type="number">0x7FC00000</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>|=</operator> <literal type="number">0x00000001</literal></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><name>int</name></type> <name>is_dhard</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x7FF00000</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x7FF00000</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x7FF00000</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<operator>(</operator><operator>(</operator><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x7FFFFFFF</literal><operator>)</operator> <operator>|</operator> <name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>FALSE</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>is_shard</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x7F800000</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x7F800000</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x7F800000</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x7FFFFFFF</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>FALSE</name></expr>;</return>
</block_content>}</block></function>




<function><type><name>void</name></type> <name>dnormzero</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0x80000000</literal> <operator>&amp;&amp;</operator> <name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>snormzero</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0x80000000</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>find</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>word</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>array</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>asize</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<expr_stmt><expr><name>asize</name> <operator>/=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt> <expr_stmt><expr><name>j</name> <operator>=</operator> <name>asize</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>j</name><operator>-</operator><name>i</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>k</name> <init>= <expr><operator>(</operator><name>i</name><operator>+</operator><name>j</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name><name>array</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>i</name> <operator>=</operator> <name>k</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>c</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>j</name> <operator>=</operator> <name>k</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>k</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></while>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>test_func</name><modifier>*</modifier></type> <name>find_testfunc</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>word</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>asize</name></decl>;</decl_stmt>

<expr_stmt><expr><name>asize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>tfuncs</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name>test_func</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt> <expr_stmt><expr><name>j</name> <operator>=</operator> <name>asize</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>j</name><operator>-</operator><name>i</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>k</name> <init>= <expr><operator>(</operator><name>i</name><operator>+</operator><name>j</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name><name>tfuncs</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>i</name> <operator>=</operator> <name>k</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>c</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>j</name> <operator>=</operator> <name>k</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>tfuncs</name> <operator>+</operator> <name>k</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></while>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>long</name> <name>long</name></type> <name>calc_error</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name><name>b</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>shift</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rettype</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>r0</name></decl>, <decl><type ref="prev"/><name>r1</name></decl>, <decl><type ref="prev"/><name>r2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sign</name></decl>, <decl><type ref="prev"/><name>carry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>result</name></decl>;</decl_stmt>






<if_stmt><if>if <condition>(<expr><call><name>is_double_rettype</name><argument_list>(<argument><expr><name>rettype</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x7FF00000</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x7FF00000</literal> <operator>||</operator>
<operator>(</operator><name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x7FF00000</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x7FF00000</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x800FFFFF</literal><operator>)</operator> <operator>||</operator> <name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><operator>(</operator><name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x800FFFFF</literal><operator>)</operator> <operator>||</operator> <name><name>b</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x7FF00000</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x7FF00000</literal> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x7FF00000</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x7FF00000</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xFFFFF</literal><operator>)</operator> <operator>||</operator> <name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>!</operator><operator>(</operator><operator>(</operator><name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xFFFFF</literal><operator>)</operator> <operator>||</operator> <name><name>b</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator> <operator>&amp;&amp;</operator>
<name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>LLONG_MAX</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x7F800000</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x7F800000</literal> <operator>||</operator>
<operator>(</operator><name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x7F800000</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x7F800000</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x807FFFFF</literal><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x807FFFFF</literal><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x7F800000</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x7F800000</literal> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x7F800000</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x7F800000</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x7FFFFF</literal><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>!</operator><operator>(</operator><name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x7FFFFF</literal><operator>)</operator> <operator>&amp;&amp;</operator>
<name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>LLONG_MAX</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>




<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>^</operator> <name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x80000000</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>LLONG_MAX</name></expr>;</return></block_content></block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><call><name>is_double_rettype</name><argument_list>(<argument><expr><name>rettype</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r2</name> <operator>=</operator> <operator>-</operator><name><name>b</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt> <expr_stmt><expr><name>carry</name> <operator>=</operator> <operator>(</operator><name>r2</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>r1</name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <operator>~</operator><name><name>b</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name>carry</name></expr>;</expr_stmt> <expr_stmt><expr><name>carry</name> <operator>=</operator> <operator>(</operator><name>r1</name> <operator>&lt;</operator> <name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>||</operator> <operator>(</operator><name>carry</name> <operator>&amp;&amp;</operator> <name>r1</name> <operator>==</operator> <name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>r0</name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <operator>~</operator><name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name>carry</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>r2</name> <operator>=</operator> <operator>-</operator><name><name>b</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt> <expr_stmt><expr><name>carry</name> <operator>=</operator> <operator>(</operator><name>r2</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>r1</name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <operator>~</operator><name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name>carry</name></expr>;</expr_stmt> <expr_stmt><expr><name>carry</name> <operator>=</operator> <operator>(</operator><name>r1</name> <operator>&lt;</operator> <name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator> <operator>(</operator><name>carry</name> <operator>&amp;&amp;</operator> <name>r1</name> <operator>==</operator> <name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>r0</name> <operator>=</operator> <operator>~</operator><literal type="number">0</literal> <operator>+</operator> <name>carry</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>




<if_stmt><if>if <condition>(<expr><name>shift</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>shift</name> <operator>&gt;</operator> <literal type="number">32</literal><operator>*</operator><literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<while>while <condition>(<expr><name>shift</name> <operator>&gt;=</operator> <literal type="number">32</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r2</name> <operator>=</operator> <name>r1</name></expr>;</expr_stmt>
<expr_stmt><expr><name>r1</name> <operator>=</operator> <name>r0</name></expr>;</expr_stmt>
<expr_stmt><expr><name>r0</name> <operator>=</operator> <operator>-</operator><operator>(</operator><name>r0</name> <operator>&gt;&gt;</operator> <literal type="number">31</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>shift</name> <operator>-=</operator> <literal type="number">32</literal></expr>;</expr_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>shift</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r2</name> <operator>=</operator> <operator>(</operator><name>r2</name> <operator>&gt;&gt;</operator> <name>shift</name><operator>)</operator> <operator>|</operator> <operator>(</operator><name>r1</name> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">32</literal><operator>-</operator><name>shift</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>r1</name> <operator>=</operator> <operator>(</operator><name>r1</name> <operator>&gt;&gt;</operator> <name>shift</name><operator>)</operator> <operator>|</operator> <operator>(</operator><name>r0</name> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">32</literal><operator>-</operator><name>shift</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>r0</name> <operator>=</operator> <operator>(</operator><name>r0</name> <operator>&gt;&gt;</operator> <name>shift</name><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>(</operator><operator>-</operator><operator>(</operator><name>r0</name> <operator>&gt;&gt;</operator> <literal type="number">31</literal><operator>)</operator><operator>)</operator> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">32</literal><operator>-</operator><name>shift</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>r0</name> <operator>&amp;</operator> <literal type="number">0x80000000</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>sign</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>r2</name> <operator>=</operator> <operator>~</operator><name>r2</name></expr>;</expr_stmt> <expr_stmt><expr><name>carry</name> <operator>=</operator> <operator>(</operator><name>r2</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>r1</name> <operator>=</operator> <literal type="number">0</literal> <operator>+</operator> <operator>~</operator><name>r1</name> <operator>+</operator> <name>carry</name></expr>;</expr_stmt> <expr_stmt><expr><name>carry</name> <operator>=</operator> <operator>(</operator><name>carry</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>r2</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>r0</name> <operator>=</operator> <literal type="number">0</literal> <operator>+</operator> <operator>~</operator><name>r0</name> <operator>+</operator> <name>carry</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>sign</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>r0</name> <operator>&gt;=</operator> <operator>(</operator><literal type="number">1LL</literal><operator>&lt;&lt;</operator><operator>(</operator><literal type="number">31</literal><operator>-</operator><name>EXTRABITS</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>LLONG_MAX</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>r2</name> <operator>&gt;&gt;</operator> <operator>(</operator><literal type="number">32</literal><operator>-</operator><name>EXTRABITS</name><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>ULPUNIT</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>|=</operator> <name>r1</name> <operator>&lt;&lt;</operator> <name>EXTRABITS</name></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>|=</operator> <operator>(</operator><name>long</name> <name>long</name><operator>)</operator><name>r0</name> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">32</literal><operator>+</operator><name>EXTRABITS</name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>sign</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>-</operator><name>result</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>



<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>unsigned</name></type> <name>op1</name></decl>, <name>op2</name>;</decl_stmt>
<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>name</name></decl>;</decl_stmt>
}</block></struct></type> <name>special_op</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>special_op</name></type> <name><name>special_ops_double</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr><literal type="number">0x00000000</literal></expr>,<expr><literal type="number">0x00000000</literal></expr>,<expr><literal type="string">"0"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">0x3FF00000</literal></expr>,<expr><literal type="number">0x00000000</literal></expr>,<expr><literal type="string">"1"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">0x7FF00000</literal></expr>,<expr><literal type="number">0x00000000</literal></expr>,<expr><literal type="string">"inf"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">0x7FF80000</literal></expr>,<expr><literal type="number">0x00000001</literal></expr>,<expr><literal type="string">"qnan"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">0x7FF00000</literal></expr>,<expr><literal type="number">0x00000001</literal></expr>,<expr><literal type="string">"snan"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">0x3ff921fb</literal></expr>,<expr><literal type="number">0x54442d18</literal></expr>,<expr><literal type="string">"pi2"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">0x400921fb</literal></expr>,<expr><literal type="number">0x54442d18</literal></expr>,<expr><literal type="string">"pi"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">0x3fe921fb</literal></expr>,<expr><literal type="number">0x54442d18</literal></expr>,<expr><literal type="string">"pi4"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">0x4002d97c</literal></expr>,<expr><literal type="number">0x7f3321d2</literal></expr>,<expr><literal type="string">"3pi4"</literal></expr>}</block></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>special_op</name></type> <name><name>special_ops_float</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr><literal type="number">0x00000000</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="string">"0"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">0x3f800000</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="string">"1"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">0x7f800000</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="string">"inf"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">0x7fc00000</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="string">"qnan"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">0x7f800001</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="string">"snan"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">0x3fc90fdb</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="string">"pi2"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">0x40490fdb</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="string">"pi"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">0x3f490fdb</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="string">"pi4"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">0x4016cbe4</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="string">"3pi4"</literal></expr>}</block></expr>,
}</block></expr></init></decl>;</decl_stmt>





<decl_stmt><decl><type><specifier>static</specifier> <name>special_op</name></type> <name>tmp_op</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<function><type><name>special_op</name><modifier>*</modifier></type> <name>find_special_op_from_op</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>op1</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>op2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_double</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>special_op</name><modifier>*</modifier></type> <name>sop</name></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>is_double</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>sop</name> <operator>=</operator> <name>special_ops_double</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>sop</name> <operator>=</operator> <name>special_ops_float</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>special_ops_double</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name>special_op</name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>sop</name><operator>-&gt;</operator><name>op1</name></name> <operator>==</operator> <operator>(</operator><name>op1</name><operator>&amp;</operator><literal type="number">0x7fffffff</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>sop</name><operator>-&gt;</operator><name>op2</name></name> <operator>==</operator> <name>op2</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>tmp_op</name><operator>.</operator><name>name</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>tmp_op</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>tmp_op</name><operator>.</operator><name>name</name></name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>sop</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>op1</name><operator>&gt;&gt;</operator><literal type="number">31</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>tmp_op</name><operator>.</operator><name>name</name></name></expr></argument>,<argument><expr><literal type="string">"-%s"</literal></expr></argument>,<argument><expr><name><name>sop</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>tmp_op</name><operator>.</operator><name>name</name></name></expr></argument>,<argument><expr><name><name>sop</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><operator>&amp;</operator><name>tmp_op</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>sop</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>special_op</name><modifier>*</modifier></type> <name>find_special_op_from_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_double</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>neg</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>special_op</name><modifier>*</modifier></type> <name>sop</name></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>is_double</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>sop</name> <operator>=</operator> <name>special_ops_double</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>sop</name> <operator>=</operator> <name>special_ops_float</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if<condition>(<expr><operator>*</operator><name>name</name><operator>==</operator><literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>neg</name><operator>=</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>name</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><operator>*</operator><name>name</name><operator>==</operator><literal type="char">'+'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>name</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>special_ops_double</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name>special_op</name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if<condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>,<argument><expr><name><name>sop</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>tmp_op</name><operator>.</operator><name>op1</name></name> <operator>=</operator> <name><name>sop</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>neg</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>tmp_op</name><operator>.</operator><name>op1</name></name> <operator>|=</operator> <literal type="number">0x80000000</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>tmp_op</name><operator>.</operator><name>op2</name></name> <operator>=</operator> <name><name>sop</name><operator>-&gt;</operator><name>op2</name></name></expr>;</expr_stmt>
<return>return <expr><operator>&amp;</operator><name>tmp_op</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>sop</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>





<function><type><name>int</name></type> <name>do_op</name><parameter_list>(<parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>q</name></decl></parameter>, <parameter><decl><type><name>unsigned</name><modifier>*</modifier></type> <name>op</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>num</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sop_type</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name><init>=<expr><name>num</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>special_op</name><modifier>*</modifier></type> <name>sop</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>op</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if<condition>(<expr><name>sop_type</name><operator>&lt;</operator><literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>sop</name> <operator>=</operator> <call><name>find_special_op_from_name</name><argument_list>(<argument><expr><name>q</name></expr></argument>,<argument><expr><name>sop_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><name>sop</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>op</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>sop</name><operator>-&gt;</operator><name>op1</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>op</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>sop</name><operator>-&gt;</operator><name>op2</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<switch>switch<condition>(<expr><name>num</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">1</literal></expr>:</case> <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>sscanf</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"%x"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>op</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">2</literal></expr>:</case> <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>sscanf</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"%x.%x"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>op</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>op</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">3</literal></expr>:</case> <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>sscanf</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"%x.%x.%x"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>op</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>op</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>op</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<default>default:</default> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s="</literal></expr></argument>,<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>i</name> <operator>&lt;</operator> <name>n</name><operator>)</operator></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%x."</literal></expr></argument>, <argument><expr><name><name>op</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" (n=%d)\n"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>testdetail</name></type> <name>parsetest</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>testbuf</name></decl></parameter>, <parameter><decl><type><name>testdetail</name></type> <name>oldtest</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>q</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>testdetail</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>argtype</name><init>=<expr><literal type="number">2</literal></expr></init></decl>, <decl><type ref="prev"/><name>rettype</name><init>=<expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ret</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Parsing line: %s\n"</literal></expr></argument>, <argument><expr><name>testbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<while>while <condition>(<expr><operator>*</operator><name>testbuf</name> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><operator>*</operator><name>testbuf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>testbuf</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<if_stmt><if>if <condition>(<expr><name><name>testbuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">';'</literal> <operator>||</operator> <name><name>testbuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'#'</literal> <operator>||</operator> <name><name>testbuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'!'</literal> <operator>||</operator>
<name><name>testbuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'&gt;'</literal> <operator>||</operator> <name><name>testbuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>comment</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Line is a comment\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>comment</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>testbuf</name> <operator>==</operator> <literal type="char">'+'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>oldtest</name><operator>.</operator><name>valid</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>oldtest</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"copy from invalid: ignored\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>testbuf</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>random</name></name> <operator>=</operator> <name>randomstate</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>in_err</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>in_err_limit</name></name> <operator>=</operator> <name>e_number_of_errnos</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strtok</name><argument_list>(<argument><expr><name>testbuf</name></expr></argument>, <argument><expr><literal type="string">" \t"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>q</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>balderdash</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>q</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>find</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>keywords</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>keywords</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>k</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>k_random</name></expr>:</case>
<expr_stmt><expr><name>randomstate</name> <operator>=</operator> <operator>(</operator><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="string">"on"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>comment</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
<case>case <expr><name>k_func</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"func=%s "</literal></expr></argument>, <argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>func</name></name> <operator>=</operator> <call><name>find_testfunc</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ret</name><operator>.</operator><name>func</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"(id=unknown)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<goto>goto <name>balderdash</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><call><name>is_single_argtype</name><argument_list>(<argument><expr><name><name>ret</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>argtype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>argtype</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if<condition>(<expr><call><name>is_double_argtype</name><argument_list>(<argument><expr><name><name>ret</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>argtype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>argtype</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><call><name>is_single_rettype</name><argument_list>(<argument><expr><name><name>ret</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>rettype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>rettype</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if<condition>(<expr><call><name>is_double_rettype</name><argument_list>(<argument><expr><name><name>ret</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>rettype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>rettype</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"(name=%s) (size=%d)\n"</literal></expr></argument>, <argument><expr><name><name>ret</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>ret</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>argtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>k_op1</name></expr>:</case>
<case>case <expr><name>k_op1r</name></expr>:</case>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>do_op</name><argument_list>(<argument><expr><name>q</name></expr></argument>,<argument><expr><name><name>ret</name><operator>.</operator><name>op1r</name></name></expr></argument>,<argument><expr><literal type="string">"op1r"</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>,<argument><expr><name>argtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>balderdash</name>;</goto></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>k_op1i</name></expr>:</case>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>do_op</name><argument_list>(<argument><expr><name>q</name></expr></argument>,<argument><expr><name><name>ret</name><operator>.</operator><name>op1i</name></name></expr></argument>,<argument><expr><literal type="string">"op1i"</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>,<argument><expr><name>argtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>balderdash</name>;</goto></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>k_op2</name></expr>:</case>
<case>case <expr><name>k_op2r</name></expr>:</case>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>do_op</name><argument_list>(<argument><expr><name>q</name></expr></argument>,<argument><expr><name><name>ret</name><operator>.</operator><name>op2r</name></name></expr></argument>,<argument><expr><literal type="string">"op2r"</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>,<argument><expr><name>argtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>balderdash</name>;</goto></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>k_op2i</name></expr>:</case>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>do_op</name><argument_list>(<argument><expr><name>q</name></expr></argument>,<argument><expr><name><name>ret</name><operator>.</operator><name>op2i</name></name></expr></argument>,<argument><expr><literal type="string">"op2i"</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>,<argument><expr><name>argtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>balderdash</name>;</goto></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>k_resultc</name></expr>:</case>
<expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>q</name></expr></argument>,<argument><expr><literal type="string">"inf"</literal></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>resultc</name></name> <operator>=</operator> <name>rc_infinity</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>q</name></expr></argument>,<argument><expr><literal type="string">"zero"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>resultc</name></name> <operator>=</operator> <name>rc_zero</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>q</name></expr></argument>,<argument><expr><literal type="string">"nan"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>resultc</name></name> <operator>=</operator> <name>rc_nan</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if<condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>q</name></expr></argument>,<argument><expr><literal type="string">"finite"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>resultc</name></name> <operator>=</operator> <name>rc_finite</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<goto>goto <name>balderdash</name>;</goto>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<case>case <expr><name>k_result</name></expr>:</case>
<case>case <expr><name>k_resultr</name></expr>:</case>
<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>do_op</name><operator>)</operator><operator>(</operator><name>q</name><operator>,</operator><name><name>ret</name><operator>.</operator><name>resultr</name></name><operator>,</operator><literal type="string">"resultr"</literal><operator>,</operator><literal type="number">3</literal><operator>,</operator><name>rettype</name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>balderdash</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>nresult</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>k_resulti</name></expr>:</case>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>do_op</name><argument_list>(<argument><expr><name>q</name></expr></argument>,<argument><expr><name><name>ret</name><operator>.</operator><name>resulti</name></name></expr></argument>,<argument><expr><literal type="string">"resulti"</literal></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>,<argument><expr><name>rettype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>balderdash</name>;</goto></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>k_res2</name></expr>:</case>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>do_op</name><argument_list>(<argument><expr><name>q</name></expr></argument>,<argument><expr><name><name>ret</name><operator>.</operator><name>res2</name></name></expr></argument>,<argument><expr><literal type="string">"res2"</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>,<argument><expr><name>rettype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>balderdash</name>;</goto></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>k_status</name></expr>:</case>
<while>while <condition>(<expr><operator>*</operator><name>q</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>q</name> <operator>==</operator> <literal type="char">'i'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>ret</name><operator>.</operator><name>status</name></name> <operator>|=</operator> <name>FE_INVALID</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>q</name> <operator>==</operator> <literal type="char">'z'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>ret</name><operator>.</operator><name>status</name></name> <operator>|=</operator> <name>FE_DIVBYZERO</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>q</name> <operator>==</operator> <literal type="char">'o'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>ret</name><operator>.</operator><name>status</name></name> <operator>|=</operator> <name>FE_OVERFLOW</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>q</name> <operator>==</operator> <literal type="char">'u'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>ret</name><operator>.</operator><name>status</name></name> <operator>|=</operator> <name>FE_UNDERFLOW</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>q</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<break>break;</break>
<case>case <expr><name>k_maybeerror</name></expr>:</case>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>find</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errors</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>balderdash</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><name>math_errhandling</name><operator>&amp;</operator><name>MATH_ERREXCEPT</name></expr>)</condition> <block>{<block_content>
<switch>switch<condition>(<expr><name>n</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>e_domain</name></expr>:</case> <expr_stmt><expr><name><name>ret</name><operator>.</operator><name>maybestatus</name></name> <operator>|=</operator> <name>FE_INVALID</name></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>e_divbyzero</name></expr>:</case> <expr_stmt><expr><name><name>ret</name><operator>.</operator><name>maybestatus</name></name> <operator>|=</operator> <name>FE_DIVBYZERO</name></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>e_overflow</name></expr>:</case> <expr_stmt><expr><name><name>ret</name><operator>.</operator><name>maybestatus</name></name> <operator>|=</operator> <name>FE_OVERFLOW</name></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>e_underflow</name></expr>:</case> <expr_stmt><expr><name><name>ret</name><operator>.</operator><name>maybestatus</name></name> <operator>|=</operator> <name>FE_UNDERFLOW</name></expr>;</expr_stmt> <break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></if></if_stmt>
<block>{<block_content>
<switch>switch<condition>(<expr><name>n</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>e_domain</name></expr>:</case>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>maybeerr</name></name> <operator>=</operator> <name>e_EDOM</name></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>e_divbyzero</name></expr>:</case>
<case>case <expr><name>e_overflow</name></expr>:</case>
<case>case <expr><name>e_underflow</name></expr>:</case>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>maybeerr</name></name> <operator>=</operator> <name>e_ERANGE</name></expr>;</expr_stmt> <break>break;</break>
</block_content>}</block></switch>
</block_content>}</block>
<case>case <expr><name>k_maybestatus</name></expr>:</case>
<while>while <condition>(<expr><operator>*</operator><name>q</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>q</name> <operator>==</operator> <literal type="char">'i'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>ret</name><operator>.</operator><name>maybestatus</name></name> <operator>|=</operator> <name>FE_INVALID</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>q</name> <operator>==</operator> <literal type="char">'z'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>ret</name><operator>.</operator><name>maybestatus</name></name> <operator>|=</operator> <name>FE_DIVBYZERO</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>q</name> <operator>==</operator> <literal type="char">'o'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>ret</name><operator>.</operator><name>maybestatus</name></name> <operator>|=</operator> <name>FE_OVERFLOW</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>q</name> <operator>==</operator> <literal type="char">'u'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>ret</name><operator>.</operator><name>maybestatus</name></name> <operator>|=</operator> <name>FE_UNDERFLOW</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>q</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<break>break;</break>
<case>case <expr><name>k_error</name></expr>:</case>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>find</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errors</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>balderdash</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><name>math_errhandling</name><operator>&amp;</operator><name>MATH_ERREXCEPT</name></expr>)</condition> <block>{<block_content>
<switch>switch<condition>(<expr><name>n</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>e_domain</name></expr>:</case> <expr_stmt><expr><name><name>ret</name><operator>.</operator><name>status</name></name> <operator>|=</operator> <name>FE_INVALID</name></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>e_divbyzero</name></expr>:</case> <expr_stmt><expr><name><name>ret</name><operator>.</operator><name>status</name></name> <operator>|=</operator> <name>FE_DIVBYZERO</name></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>e_overflow</name></expr>:</case> <expr_stmt><expr><name><name>ret</name><operator>.</operator><name>status</name></name> <operator>|=</operator> <name>FE_OVERFLOW</name></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>e_underflow</name></expr>:</case> <expr_stmt><expr><name><name>ret</name><operator>.</operator><name>status</name></name> <operator>|=</operator> <name>FE_UNDERFLOW</name></expr>;</expr_stmt> <break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><name>math_errhandling</name><operator>&amp;</operator><name>MATH_ERRNO</name></expr>)</condition> <block>{<block_content>
<switch>switch<condition>(<expr><name>n</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>e_domain</name></expr>:</case>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>err</name></name> <operator>=</operator> <name>e_EDOM</name></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>e_divbyzero</name></expr>:</case>
<case>case <expr><name>e_overflow</name></expr>:</case>
<case>case <expr><name>e_underflow</name></expr>:</case>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>err</name></name> <operator>=</operator> <name>e_ERANGE</name></expr>;</expr_stmt> <break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><operator>(</operator><name>math_errhandling</name><operator>&amp;</operator><name>MATH_ERRNO</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<switch>switch<condition>(<expr><name>n</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>e_domain</name></expr>:</case>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>maybeerr</name></name> <operator>=</operator> <name>e_EDOM</name></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>e_divbyzero</name></expr>:</case>
<case>case <expr><name>e_overflow</name></expr>:</case>
<case>case <expr><name>e_underflow</name></expr>:</case>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>maybeerr</name></name> <operator>=</operator> <name>e_ERANGE</name></expr>;</expr_stmt> <break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>k_errno</name></expr>:</case>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>err</name></name> <operator>=</operator> <call><name>find</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>errnos</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errnos</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ret</name><operator>.</operator><name>err</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>balderdash</name>;</goto></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>k_errno_in</name></expr>:</case>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>in_err</name></name> <operator>=</operator> <call><name>find</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>errnos</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errnos</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ret</name><operator>.</operator><name>err</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>balderdash</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>in_err_limit</name></name> <operator>=</operator> <name><name>ret</name><operator>.</operator><name>in_err</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>k_wrongresult</name></expr>:</case>
<case>case <expr><name>k_wrongstatus</name></expr>:</case>
<case>case <expr><name>k_wrongres2</name></expr>:</case>
<case>case <expr><name>k_wrongerrno</name></expr>:</case>

<break>break;</break>
<default>default:</default>
<goto>goto <name>balderdash</name>;</goto>
</block_content>}</block></switch>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strtok</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">" \t"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>valid</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>


<label><name>balderdash</name>:</label>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>valid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><enum>enum <block>{
<decl><name>test_comment</name></decl>,
<decl><name>test_invalid</name></decl>,
<decl><name>test_decline</name></decl>,
<decl><name>test_fail</name></decl>,
<decl><name>test_pass</name></decl>
}</block></enum></type> <name>testresult</name>;</typedef>

<decl_stmt><decl><type><name>char</name></type> <name><name>failtext</name><index>[<expr><literal type="number">512</literal></expr>]</index></name></decl>;</decl_stmt>

<typedef>typedef <type><union>union <block>{
<decl_stmt><decl><type><name>unsigned</name></type> <name><name>i</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>f</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name><name>da</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
}</block></union></type> <name>dbl</name>;</typedef>

<typedef>typedef <type><union>union <block>{
<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>f</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name><name>da</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
}</block></union></type> <name>sgl</name>;</typedef>


<function><type><name>void</name></type> <name>print_error</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>rettype</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>text</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier><modifier>*</modifier></type> <name>failp</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>special_op</name> <modifier>*</modifier></type><name>sop</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><name>result</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>failp</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><operator>*</operator><name>failp</name></expr></argument>,<argument><expr><literal type="string">" %s="</literal></expr></argument>,<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sop</name> <operator>=</operator> <call><name>find_special_op_from_op</name><argument_list>(<argument><expr><name><name>result</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>result</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><call><name>is_double_rettype</name><argument_list>(<argument><expr><name>rettype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>sop</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>failp</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><operator>*</operator><name>failp</name></expr></argument>,<argument><expr><literal type="string">"%s"</literal></expr></argument>,<argument><expr><name><name>sop</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if<condition>(<expr><call><name>is_double_rettype</name><argument_list>(<argument><expr><name>rettype</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>str</name><operator>=</operator><literal type="string">"%08x.%08x"</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>str</name><operator>=</operator><literal type="string">"%08x"</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><operator>*</operator><name>failp</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><operator>*</operator><name>failp</name></expr></argument>,<argument><expr><name>str</name></expr></argument>,<argument><expr><name><name>result</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>result</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>print_ulps_helper</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>long</name> <name>long</name></type> <name>ulps</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier><modifier>*</modifier></type> <name>failp</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if<condition>(<expr><name>ulps</name> <operator>==</operator> <name>LLONG_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>failp</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><operator>*</operator><name>failp</name></expr></argument>, <argument><expr><literal type="string">" %s=HUGE"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>failp</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><operator>*</operator><name>failp</name></expr></argument>, <argument><expr><literal type="string">" %s=%.3f"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>(</operator><name>double</name><operator>)</operator><name>ulps</name> <operator>/</operator> <name>ULPUNIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>print_ulps</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>rettype</name></decl></parameter>, <parameter><decl><type><name>long</name> <name>long</name></type> <name>ulpsr</name></decl></parameter>, <parameter><decl><type><name>long</name> <name>long</name></type> <name>ulpsi</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier><modifier>*</modifier></type> <name>failp</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if<condition>(<expr><call><name>is_complex_rettype</name><argument_list>(<argument><expr><name>rettype</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>ulpsr</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>print_ulps_helper</name><argument_list>(<argument><expr><literal type="string">"ulpsr"</literal></expr></argument>,<argument><expr><name>ulpsr</name></expr></argument>,<argument><expr><name>failp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ulpsi</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>print_ulps_helper</name><argument_list>(<argument><expr><literal type="string">"ulpsi"</literal></expr></argument>,<argument><expr><name>ulpsi</name></expr></argument>,<argument><expr><name>failp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>ulpsr</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>print_ulps_helper</name><argument_list>(<argument><expr><literal type="string">"ulps"</literal></expr></argument>,<argument><expr><name>ulpsr</name></expr></argument>,<argument><expr><name>failp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>runtest</name><parameter_list>(<parameter><decl><type><name>testdetail</name></type> <name>t</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>, <decl><type ref="prev"/><name>status</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>dbl</name></type> <name>d_arg1</name></decl>, <decl><type ref="prev"/><name>d_arg2</name></decl>, <decl><type ref="prev"/><name>d_res</name></decl>, <decl><type ref="prev"/><name>d_res2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sgl</name></type> <name>s_arg1</name></decl>, <decl><type ref="prev"/><name>s_arg2</name></decl>, <decl><type ref="prev"/><name>s_res</name></decl>, <decl><type ref="prev"/><name>s_res2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>deferred_decline</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>failp</name> <init>= <expr><name>failtext</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>intres</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>res2_adjust</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>t</name><operator>.</operator><name>comment</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>test_comment</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>t</name><operator>.</operator><name>valid</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>test_invalid</name></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>feclearexcept</name><argument_list>(<argument><expr><name>FE_ALL_EXCEPT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DO_DOP</name><parameter_list>(<parameter><type><name>arg</name></type></parameter>,<parameter><type><name>op</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>arg.i[dmsd] = t.op[0]; arg.i[dlsd] = t.op[1]</cpp:value></cpp:define>
<expr_stmt><expr><call><name>DO_DOP</name><argument_list>(<argument><expr><name>d_arg1</name></expr></argument>,<argument><expr><name>op1r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DO_DOP</name><argument_list>(<argument><expr><name>d_arg2</name></expr></argument>,<argument><expr><name>op2r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s_arg1</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name><name>t</name><operator>.</operator><name>op1r</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt> <expr_stmt><expr><name><name>s_arg2</name><operator>.</operator><name>i</name></name> <operator>=</operator> <name><name>t</name><operator>.</operator><name>op2r</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>










<if_stmt><if>if <condition>(<expr><name>fo</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>is_double_argtype</name><argument_list>(<argument><expr><name><name>t</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>argtype</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>is_dhard</name><argument_list>(<argument><expr><name><name>t</name><operator>.</operator><name>op1r</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>deferred_decline</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>t</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>argtype</name></name><operator>==</operator><name>at_d2</name> <operator>&amp;&amp;</operator> <call><name>is_dhard</name><argument_list>(<argument><expr><name><name>t</name><operator>.</operator><name>op2r</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>deferred_decline</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>is_single_argtype</name><argument_list>(<argument><expr><name><name>t</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>argtype</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>is_shard</name><argument_list>(<argument><expr><name><name>t</name><operator>.</operator><name>op1r</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>deferred_decline</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>t</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>argtype</name></name><operator>==</operator><name>at_s2</name> <operator>&amp;&amp;</operator> <call><name>is_shard</name><argument_list>(<argument><expr><name><name>t</name><operator>.</operator><name>op2r</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>deferred_decline</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>is_double_rettype</name><argument_list>(<argument><expr><name><name>t</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>rettype</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>is_dhard</name><argument_list>(<argument><expr><name><name>t</name><operator>.</operator><name>resultr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>deferred_decline</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>t</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>rettype</name></name><operator>==</operator><name>rt_d2</name> <operator>&amp;&amp;</operator> <call><name>is_dhard</name><argument_list>(<argument><expr><name><name>t</name><operator>.</operator><name>res2</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>deferred_decline</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>is_single_argtype</name><argument_list>(<argument><expr><name><name>t</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>rettype</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>is_shard</name><argument_list>(<argument><expr><name><name>t</name><operator>.</operator><name>resultr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>deferred_decline</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>t</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>rettype</name></name><operator>==</operator><name>rt_s2</name> <operator>&amp;&amp;</operator> <call><name>is_shard</name><argument_list>(<argument><expr><name><name>t</name><operator>.</operator><name>res2</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>deferred_decline</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>t</name><operator>.</operator><name>err</name></name> <operator>==</operator> <name>e_ERANGE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>deferred_decline</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>





<expr_stmt><expr><name>errno</name> <operator>=</operator> <ternary><condition><expr><name><name>t</name><operator>.</operator><name>in_err</name></name> <operator>==</operator> <name>e_EDOM</name></expr> ?</condition><then> <expr><name>EDOM</name></expr> </then><else>: <expr><ternary><condition><expr><name><name>t</name><operator>.</operator><name>in_err</name></name> <operator>==</operator> <name>e_ERANGE</name></expr> ?</condition><then> <expr><name>ERANGE</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>t</name><operator>.</operator><name>err</name></name> <operator>==</operator> <name>e_0</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>t</name><operator>.</operator><name>err</name></name> <operator>=</operator> <name><name>t</name><operator>.</operator><name>in_err</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>t</name><operator>.</operator><name>maybeerr</name></name> <operator>==</operator> <name>e_0</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>t</name><operator>.</operator><name>maybeerr</name></name> <operator>=</operator> <name><name>t</name><operator>.</operator><name>in_err</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name><name>t</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>t_func</name></expr>)</condition> <block>{<block_content>
<switch>switch<condition>(<expr><name><name>t</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>argtype</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>at_d</name></expr>:</case> <expr_stmt><expr><name><name>d_res</name><operator>.</operator><name>f</name></name> <operator>=</operator> <call><name><name>t</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>func</name><operator>.</operator><name>d_d_ptr</name></name><argument_list>(<argument><expr><name><name>d_arg1</name><operator>.</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>at_s</name></expr>:</case> <expr_stmt><expr><name><name>s_res</name><operator>.</operator><name>f</name></name> <operator>=</operator> <call><name><name>t</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>func</name><operator>.</operator><name>s_s_ptr</name></name><argument_list>(<argument><expr><name><name>s_arg1</name><operator>.</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>at_d2</name></expr>:</case> <expr_stmt><expr><name><name>d_res</name><operator>.</operator><name>f</name></name> <operator>=</operator> <call><name><name>t</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>func</name><operator>.</operator><name>d2_d_ptr</name></name><argument_list>(<argument><expr><name><name>d_arg1</name><operator>.</operator><name>f</name></name></expr></argument>, <argument><expr><name><name>d_arg2</name><operator>.</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>at_s2</name></expr>:</case> <expr_stmt><expr><name><name>s_res</name><operator>.</operator><name>f</name></name> <operator>=</operator> <call><name><name>t</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>func</name><operator>.</operator><name>s2_s_ptr</name></name><argument_list>(<argument><expr><name><name>s_arg1</name><operator>.</operator><name>f</name></name></expr></argument>, <argument><expr><name><name>s_arg2</name><operator>.</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>at_di</name></expr>:</case> <expr_stmt><expr><name><name>d_res</name><operator>.</operator><name>f</name></name> <operator>=</operator> <call><name><name>t</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>func</name><operator>.</operator><name>di_d_ptr</name></name><argument_list>(<argument><expr><name><name>d_arg1</name><operator>.</operator><name>f</name></name></expr></argument>, <argument><expr><name><name>d_arg2</name><operator>.</operator><name>i</name><index>[<expr><name>dmsd</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>at_si</name></expr>:</case> <expr_stmt><expr><name><name>s_res</name><operator>.</operator><name>f</name></name> <operator>=</operator> <call><name><name>t</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>func</name><operator>.</operator><name>si_s_ptr</name></name><argument_list>(<argument><expr><name><name>s_arg1</name><operator>.</operator><name>f</name></name></expr></argument>, <argument><expr><name><name>s_arg2</name><operator>.</operator><name>i</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>at_dip</name></expr>:</case> <expr_stmt><expr><name><name>d_res</name><operator>.</operator><name>f</name></name> <operator>=</operator> <call><name><name>t</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>func</name><operator>.</operator><name>dip_d_ptr</name></name><argument_list>(<argument><expr><name><name>d_arg1</name><operator>.</operator><name>f</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>intres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>at_sip</name></expr>:</case> <expr_stmt><expr><name><name>s_res</name><operator>.</operator><name>f</name></name> <operator>=</operator> <call><name><name>t</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>func</name><operator>.</operator><name>sip_s_ptr</name></name><argument_list>(<argument><expr><name><name>s_arg1</name><operator>.</operator><name>f</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>intres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>at_ddp</name></expr>:</case> <expr_stmt><expr><name><name>d_res</name><operator>.</operator><name>f</name></name> <operator>=</operator> <call><name><name>t</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>func</name><operator>.</operator><name>ddp_d_ptr</name></name><argument_list>(<argument><expr><name><name>d_arg1</name><operator>.</operator><name>f</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>d_res2</name><operator>.</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>at_ssp</name></expr>:</case> <expr_stmt><expr><name><name>s_res</name><operator>.</operator><name>f</name></name> <operator>=</operator> <call><name><name>t</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>func</name><operator>.</operator><name>ssp_s_ptr</name></name><argument_list>(<argument><expr><name><name>s_arg1</name><operator>.</operator><name>f</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s_res2</name><operator>.</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"unhandled function: %s\n"</literal></expr></argument>,<argument><expr><name><name>t</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>test_fail</name></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></if> <else>else <block>{<block_content>

<switch>switch<condition>(<expr><name><name>t</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>macro_name</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>m_isfinite</name></expr>:</case> <expr_stmt><expr><name>intres</name> <operator>=</operator> <call><name>isfinite</name><argument_list>(<argument><expr><name><name>d_arg1</name><operator>.</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>m_isinf</name></expr>:</case> <expr_stmt><expr><name>intres</name> <operator>=</operator> <call><name>isinf</name><argument_list>(<argument><expr><name><name>d_arg1</name><operator>.</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>m_isnan</name></expr>:</case> <expr_stmt><expr><name>intres</name> <operator>=</operator> <call><name>isnan</name><argument_list>(<argument><expr><name><name>d_arg1</name><operator>.</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>m_isnormal</name></expr>:</case> <expr_stmt><expr><name>intres</name> <operator>=</operator> <call><name>isnormal</name><argument_list>(<argument><expr><name><name>d_arg1</name><operator>.</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>m_signbit</name></expr>:</case> <expr_stmt><expr><name>intres</name> <operator>=</operator> <call><name>signbit</name><argument_list>(<argument><expr><name><name>d_arg1</name><operator>.</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>m_fpclassify</name></expr>:</case> <expr_stmt><expr><name>intres</name> <operator>=</operator> <call><name>fpclassify</name><argument_list>(<argument><expr><name><name>d_arg1</name><operator>.</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>m_isgreater</name></expr>:</case> <expr_stmt><expr><name>intres</name> <operator>=</operator> <call><name>isgreater</name><argument_list>(<argument><expr><name><name>d_arg1</name><operator>.</operator><name>f</name></name></expr></argument>, <argument><expr><name><name>d_arg2</name><operator>.</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>m_isgreaterequal</name></expr>:</case> <expr_stmt><expr><name>intres</name> <operator>=</operator> <call><name>isgreaterequal</name><argument_list>(<argument><expr><name><name>d_arg1</name><operator>.</operator><name>f</name></name></expr></argument>, <argument><expr><name><name>d_arg2</name><operator>.</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>m_isless</name></expr>:</case> <expr_stmt><expr><name>intres</name> <operator>=</operator> <call><name>isless</name><argument_list>(<argument><expr><name><name>d_arg1</name><operator>.</operator><name>f</name></name></expr></argument>, <argument><expr><name><name>d_arg2</name><operator>.</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>m_islessequal</name></expr>:</case> <expr_stmt><expr><name>intres</name> <operator>=</operator> <call><name>islessequal</name><argument_list>(<argument><expr><name><name>d_arg1</name><operator>.</operator><name>f</name></name></expr></argument>, <argument><expr><name><name>d_arg2</name><operator>.</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>m_islessgreater</name></expr>:</case> <expr_stmt><expr><name>intres</name> <operator>=</operator> <call><name>islessgreater</name><argument_list>(<argument><expr><name><name>d_arg1</name><operator>.</operator><name>f</name></name></expr></argument>, <argument><expr><name><name>d_arg2</name><operator>.</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>m_isunordered</name></expr>:</case> <expr_stmt><expr><name>intres</name> <operator>=</operator> <call><name>isunordered</name><argument_list>(<argument><expr><name><name>d_arg1</name><operator>.</operator><name>f</name></name></expr></argument>, <argument><expr><name><name>d_arg2</name><operator>.</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>m_isfinitef</name></expr>:</case> <expr_stmt><expr><name>intres</name> <operator>=</operator> <call><name>isfinite</name><argument_list>(<argument><expr><name><name>s_arg1</name><operator>.</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>m_isinff</name></expr>:</case> <expr_stmt><expr><name>intres</name> <operator>=</operator> <call><name>isinf</name><argument_list>(<argument><expr><name><name>s_arg1</name><operator>.</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>m_isnanf</name></expr>:</case> <expr_stmt><expr><name>intres</name> <operator>=</operator> <call><name>isnan</name><argument_list>(<argument><expr><name><name>s_arg1</name><operator>.</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>m_isnormalf</name></expr>:</case> <expr_stmt><expr><name>intres</name> <operator>=</operator> <call><name>isnormal</name><argument_list>(<argument><expr><name><name>s_arg1</name><operator>.</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>m_signbitf</name></expr>:</case> <expr_stmt><expr><name>intres</name> <operator>=</operator> <call><name>signbit</name><argument_list>(<argument><expr><name><name>s_arg1</name><operator>.</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>m_fpclassifyf</name></expr>:</case> <expr_stmt><expr><name>intres</name> <operator>=</operator> <call><name>fpclassify</name><argument_list>(<argument><expr><name><name>s_arg1</name><operator>.</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>m_isgreaterf</name></expr>:</case> <expr_stmt><expr><name>intres</name> <operator>=</operator> <call><name>isgreater</name><argument_list>(<argument><expr><name><name>s_arg1</name><operator>.</operator><name>f</name></name></expr></argument>, <argument><expr><name><name>s_arg2</name><operator>.</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>m_isgreaterequalf</name></expr>:</case> <expr_stmt><expr><name>intres</name> <operator>=</operator> <call><name>isgreaterequal</name><argument_list>(<argument><expr><name><name>s_arg1</name><operator>.</operator><name>f</name></name></expr></argument>, <argument><expr><name><name>s_arg2</name><operator>.</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>m_islessf</name></expr>:</case> <expr_stmt><expr><name>intres</name> <operator>=</operator> <call><name>isless</name><argument_list>(<argument><expr><name><name>s_arg1</name><operator>.</operator><name>f</name></name></expr></argument>, <argument><expr><name><name>s_arg2</name><operator>.</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>m_islessequalf</name></expr>:</case> <expr_stmt><expr><name>intres</name> <operator>=</operator> <call><name>islessequal</name><argument_list>(<argument><expr><name><name>s_arg1</name><operator>.</operator><name>f</name></name></expr></argument>, <argument><expr><name><name>s_arg2</name><operator>.</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>m_islessgreaterf</name></expr>:</case> <expr_stmt><expr><name>intres</name> <operator>=</operator> <call><name>islessgreater</name><argument_list>(<argument><expr><name><name>s_arg1</name><operator>.</operator><name>f</name></name></expr></argument>, <argument><expr><name><name>s_arg2</name><operator>.</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>m_isunorderedf</name></expr>:</case> <expr_stmt><expr><name>intres</name> <operator>=</operator> <call><name>isunordered</name><argument_list>(<argument><expr><name><name>s_arg1</name><operator>.</operator><name>f</name></name></expr></argument>, <argument><expr><name><name>s_arg2</name><operator>.</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

<default>default:</default>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"unhandled macro: %s\n"</literal></expr></argument>,<argument><expr><name><name>t</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>test_fail</name></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></else></if_stmt>




<if_stmt><if>if <condition>(<expr><name>deferred_decline</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>test_decline</name></expr>;</return></block_content></block></if></if_stmt>




<expr_stmt><expr><name><name>failp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>





<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>is_complex_argtype</name><argument_list>(<argument><expr><name><name>t</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>argtype</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>is_complex_rettype</name><argument_list>(<argument><expr><name><name>t</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>rettype</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>fetestexcept</name><argument_list>(<argument><expr><name>FE_INVALID</name><operator>|</operator><name>FE_DIVBYZERO</name><operator>|</operator><name>FE_OVERFLOW</name><operator>|</operator><name>FE_UNDERFLOW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>status</name><operator>|</operator><name><name>t</name><operator>.</operator><name>maybestatus</name></name><operator>|</operator><operator>~</operator><name>statusmask</name><operator>)</operator> <operator>!=</operator> <operator>(</operator><name><name>t</name><operator>.</operator><name>status</name></name><operator>|</operator><name><name>t</name><operator>.</operator><name>maybestatus</name></name><operator>|</operator><operator>~</operator><name>statusmask</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>quiet</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>failtext</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>=</operator><literal type="char">'x'</literal></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>failp</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>failp</name></expr></argument>,
<argument><expr><literal type="string">" wrongstatus=%s%s%s%s%s"</literal></expr></argument>,
<argument><expr><operator>(</operator><ternary><condition><expr><name>status</name> <operator>&amp;</operator> <name>FE_INVALID</name></expr> ?</condition><then> <expr><literal type="string">"i"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>,
<argument><expr><operator>(</operator><ternary><condition><expr><name>status</name> <operator>&amp;</operator> <name>FE_DIVBYZERO</name></expr> ?</condition><then> <expr><literal type="string">"z"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>,
<argument><expr><operator>(</operator><ternary><condition><expr><name>status</name> <operator>&amp;</operator> <name>FE_OVERFLOW</name></expr> ?</condition><then> <expr><literal type="string">"o"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>,
<argument><expr><operator>(</operator><ternary><condition><expr><name>status</name> <operator>&amp;</operator> <name>FE_UNDERFLOW</name></expr> ?</condition><then> <expr><literal type="string">"u"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>,
<argument><expr><operator>(</operator><ternary><condition><expr><name>status</name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"OK"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name><name>resultr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>resulti</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name><name>tresultr</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>tresulti</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name>wres</name></decl>;</decl_stmt>

<switch>switch<condition>(<expr><name><name>t</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>rettype</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>rt_d</name></expr>:</case>
<case>case <expr><name>rt_d2</name></expr>:</case>
<expr_stmt><expr><name><name>tresultr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>t</name><operator>.</operator><name>resultr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tresultr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>t</name><operator>.</operator><name>resultr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>resultr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>d_res</name><operator>.</operator><name>i</name><index>[<expr><name>dmsd</name></expr>]</index></name></expr>;</expr_stmt> <expr_stmt><expr><name><name>resultr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>d_res</name><operator>.</operator><name>i</name><index>[<expr><name>dlsd</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>wres</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>rt_i</name></expr>:</case>
<expr_stmt><expr><name><name>tresultr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>t</name><operator>.</operator><name>resultr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>resultr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>intres</name></expr>;</expr_stmt>
<expr_stmt><expr><name>wres</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>rt_s</name></expr>:</case>
<case>case <expr><name>rt_s2</name></expr>:</case>
<expr_stmt><expr><name><name>tresultr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>t</name><operator>.</operator><name>resultr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>resultr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>s_res</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>wres</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><literal type="string">"unhandled rettype in runtest"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>wres</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></switch>
<if_stmt><if>if<condition>(<expr><name><name>t</name><operator>.</operator><name>resultc</name></name> <operator>!=</operator> <name>rc_none</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<switch>switch<condition>(<expr><name><name>t</name><operator>.</operator><name>resultc</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>rc_zero</name></expr>:</case>
<if_stmt><if>if<condition>(<expr><name><name>resultr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>resulti</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
<operator>(</operator><name>wres</name><operator>==</operator><literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>resultr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>resulti</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>err</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>rc_infinity</name></expr>:</case>
<if_stmt><if>if<condition>(<expr><name>wres</name><operator>==</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if<condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><name><name>resultr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x7fffffff</literal><operator>)</operator><operator>==</operator><literal type="number">0x7f800000</literal> <operator>||</operator>
<operator>(</operator><name><name>resulti</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x7fffffff</literal><operator>)</operator><operator>==</operator><literal type="number">0x7f800000</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>err</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if<condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><operator>(</operator><name><name>resultr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x7fffffff</literal><operator>)</operator><operator>==</operator><literal type="number">0x7ff00000</literal> <operator>&amp;&amp;</operator> <name><name>resultr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal><operator>)</operator> <operator>||</operator>
<operator>(</operator><operator>(</operator><name><name>resulti</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x7fffffff</literal><operator>)</operator><operator>==</operator><literal type="number">0x7ff00000</literal> <operator>&amp;&amp;</operator> <name><name>resulti</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>err</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<case>case <expr><name>rc_nan</name></expr>:</case>
<if_stmt><if>if<condition>(<expr><name>wres</name><operator>==</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if<condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><name><name>resultr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x7fffffff</literal><operator>)</operator><operator>&gt;</operator><literal type="number">0x7f800000</literal> <operator>||</operator>
<operator>(</operator><name><name>resulti</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x7fffffff</literal><operator>)</operator><operator>&gt;</operator><literal type="number">0x7f800000</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>err</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>canon_dNaN</name><argument_list>(<argument><expr><name>resultr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>canon_dNaN</name><argument_list>(<argument><expr><name>resulti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><operator>(</operator><name><name>resultr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x7fffffff</literal><operator>)</operator><operator>&gt;</operator><literal type="number">0x7ff00000</literal> <operator>&amp;&amp;</operator> <name><name>resultr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="number">1</literal><operator>)</operator> <operator>||</operator>
<operator>(</operator><operator>(</operator><name><name>resulti</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x7fffffff</literal><operator>)</operator><operator>&gt;</operator><literal type="number">0x7ff00000</literal> <operator>&amp;&amp;</operator> <name><name>resulti</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>err</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<case>case <expr><name>rc_finite</name></expr>:</case>
<if_stmt><if>if<condition>(<expr><name>wres</name><operator>==</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if<condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><name><name>resultr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x7fffffff</literal><operator>)</operator><operator>&lt;</operator><literal type="number">0x7f800000</literal> <operator>||</operator>
<operator>(</operator><name><name>resulti</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x7fffffff</literal><operator>)</operator><operator>&lt;</operator><literal type="number">0x7f800000</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>err</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if<condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><name><name>resultr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x7fffffff</literal><operator>)</operator><operator>&lt;</operator><literal type="number">0x7ff00000</literal> <operator>||</operator>
<operator>(</operator><name><name>resulti</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x7fffffff</literal><operator>)</operator><operator>&lt;</operator><literal type="number">0x7ff00000</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>err</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
<if_stmt><if>if<condition>(<expr><name>err</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>print_error</name><argument_list>(<argument><expr><name><name>t</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>rettype</name></name></expr></argument>,<argument><expr><name>resultr</name></expr></argument>,<argument><expr><literal type="string">"wrongresultr"</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>failp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>print_error</name><argument_list>(<argument><expr><name><name>t</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>rettype</name></name></expr></argument>,<argument><expr><name>resulti</name></expr></argument>,<argument><expr><literal type="string">"wrongresulti"</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>failp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>t</name><operator>.</operator><name>nresult</name></name> <operator>&gt;</operator> <name>wres</name></expr>)</condition> <block>{<block_content>






<decl_stmt><decl><type><name>int</name></type> <name>rshift</name></decl>, <decl><type ref="prev"/><name>ishift</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>ulpsr</name></decl>, <decl><type ref="prev"/><name>ulpsi</name></decl>, <decl><type ref="prev"/><name>ulptolerance</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>tresultr</name><index>[<expr><name>wres</name></expr>]</index></name> <operator>=</operator> <name><name>t</name><operator>.</operator><name>resultr</name><index>[<expr><name>wres</name></expr>]</index></name> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">32</literal><operator>-</operator><name>EXTRABITS</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tresulti</name><index>[<expr><name>wres</name></expr>]</index></name> <operator>=</operator> <name><name>t</name><operator>.</operator><name>resulti</name><index>[<expr><name>wres</name></expr>]</index></name> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">32</literal><operator>-</operator><name>EXTRABITS</name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>strict</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ulptolerance</name> <operator>=</operator> <literal type="number">4096</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ulptolerance</name> <operator>=</operator> <name><name>t</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>tolerance</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>rshift</name> <operator>=</operator> <name>ishift</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ulptolerance</name> <operator>&amp;</operator> <name>ABSLOWERBOUND</name></expr>)</condition> <block>{<block_content>



























<expr_stmt><expr><name>ulptolerance</name> <operator>&amp;=</operator> <operator>~</operator><name>ABSLOWERBOUND</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>t</name><operator>.</operator><name>op1r</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x80000000</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>t</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>rettype</name></name> <operator>==</operator> <name>rt_d</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>rshift</name> <operator>=</operator> <literal type="number">0x400</literal> <operator>-</operator> <operator>(</operator><operator>(</operator><name><name>tresultr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">20</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x7ff</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>t</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>rettype</name></name> <operator>==</operator> <name>rt_s</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>rshift</name> <operator>=</operator> <literal type="number">0x80</literal> <operator>-</operator> <operator>(</operator><operator>(</operator><name><name>tresultr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">23</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>rshift</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>rshift</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ulptolerance</name> <operator>&amp;</operator> <name>PLUSMINUSPIO2</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ulptolerance</name> <operator>&amp;=</operator> <operator>~</operator><name>PLUSMINUSPIO2</name></expr>;</expr_stmt>














<if_stmt><if>if <condition>(<expr><name>wres</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>resultr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x7FFFFFFF</literal><operator>)</operator> <operator>&lt;=</operator> <literal type="number">0x3f494b02</literal> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>resultr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x7FFFFFFF</literal><operator>)</operator> <operator>&gt;</operator> <literal type="number">0x3f490fda</literal> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>resultr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x80000000</literal><operator>)</operator> <operator>!=</operator> <operator>(</operator><name><name>tresultr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x80000000</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>val</name></decl>;</decl_stmt>
<expr_stmt><expr><name>val</name> <operator>=</operator> <name><name>tresultr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>val</name> <operator>=</operator> <operator>(</operator><name>val</name> <operator>&lt;&lt;</operator> <literal type="number">32</literal><operator>)</operator> <operator>|</operator> <name><name>tresultr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>









<expr_stmt><expr><name>val</name> <operator>=</operator> <literal type="number">0xfe921fb54442d184ULL</literal> <operator>-</operator> <name>val</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tresultr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>val</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tresultr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>val</name> <operator>&gt;&gt;</operator> <operator>(</operator><literal type="number">32</literal><operator>-</operator><name>EXTRABITS</name><operator>)</operator><operator>)</operator> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">32</literal><operator>-</operator><name>EXTRABITS</name><operator>)</operator></expr>;</expr_stmt>







<if_stmt><if>if <condition>(<expr><name><name>resultr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x80000000</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>res2_adjust</name> <operator>=</operator> <operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>res2_adjust</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ulpsr</name> <operator>=</operator> <call><name>calc_error</name><argument_list>(<argument><expr><name>resultr</name></expr></argument>, <argument><expr><name>tresultr</name></expr></argument>, <argument><expr><name>rshift</name></expr></argument>, <argument><expr><name><name>t</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>rettype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><call><name>is_complex_rettype</name><argument_list>(<argument><expr><name><name>t</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>rettype</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ulpsi</name> <operator>=</operator> <call><name>calc_error</name><argument_list>(<argument><expr><name>resulti</name></expr></argument>, <argument><expr><name>tresulti</name></expr></argument>, <argument><expr><name>ishift</name></expr></argument>, <argument><expr><name><name>t</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>rettype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ulpsi</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<decl_stmt><decl><type><name>unsigned</name> <modifier>*</modifier></type><name>rr</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>ulpsr</name> <operator>&gt;</operator> <name>ulptolerance</name> <operator>||</operator> <name>ulpsr</name> <operator>&lt;</operator> <operator>-</operator><name>ulptolerance</name><operator>)</operator></expr> ?</condition><then> <expr><name>resultr</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <modifier>*</modifier></type><name>ri</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>ulpsi</name> <operator>&gt;</operator> <name>ulptolerance</name> <operator>||</operator> <name>ulpsi</name> <operator>&lt;</operator> <operator>-</operator><name>ulptolerance</name><operator>)</operator></expr> ?</condition><then> <expr><name>resulti</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>rr</name> <operator>||</operator> <name>ri</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>quiet</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>failtext</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>=</operator><literal type="char">'x'</literal></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>print_error</name><argument_list>(<argument><expr><name><name>t</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>rettype</name></name></expr></argument>,<argument><expr><name>rr</name></expr></argument>,<argument><expr><literal type="string">"wrongresultr"</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>failp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>print_error</name><argument_list>(<argument><expr><name><name>t</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>rettype</name></name></expr></argument>,<argument><expr><name>ri</name></expr></argument>,<argument><expr><literal type="string">"wrongresulti"</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>failp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>print_ulps</name><argument_list>(<argument><expr><name><name>t</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>rettype</name></name></expr></argument>,<argument><expr><ternary><condition><expr><name>rr</name></expr> ?</condition><then> <expr><name>ulpsr</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>, <argument><expr><ternary><condition><expr><name>ri</name></expr> ?</condition><then> <expr><name>ulpsi</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>,<argument><expr><operator>&amp;</operator><name>failp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if<condition>(<expr><call><name>is_complex_rettype</name><argument_list>(<argument><expr><name><name>t</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>rettype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>




<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>





<switch>switch<condition>(<expr><name><name>t</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>rettype</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>rt_dc</name></expr>:</case>
<expr_stmt><expr><call><name>canon_dNaN</name><argument_list>(<argument><expr><name>tresulti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>canon_dNaN</name><argument_list>(<argument><expr><name>resulti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fo</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnormzero</name><argument_list>(<argument><expr><name>tresulti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dnormzero</name><argument_list>(<argument><expr><name>resulti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<case>case <expr><name>rt_d</name></expr>:</case>
<expr_stmt><expr><call><name>canon_dNaN</name><argument_list>(<argument><expr><name>tresultr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>canon_dNaN</name><argument_list>(<argument><expr><name>resultr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fo</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnormzero</name><argument_list>(<argument><expr><name>tresultr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dnormzero</name><argument_list>(<argument><expr><name>resultr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>rt_sc</name></expr>:</case>
<expr_stmt><expr><call><name>canon_sNaN</name><argument_list>(<argument><expr><name>tresulti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>canon_sNaN</name><argument_list>(<argument><expr><name>resulti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fo</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>snormzero</name><argument_list>(<argument><expr><name>tresulti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>snormzero</name><argument_list>(<argument><expr><name>resulti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<case>case <expr><name>rt_s</name></expr>:</case>
<expr_stmt><expr><call><name>canon_sNaN</name><argument_list>(<argument><expr><name>tresultr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>canon_sNaN</name><argument_list>(<argument><expr><name>resultr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fo</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>snormzero</name><argument_list>(<argument><expr><name>tresultr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>snormzero</name><argument_list>(<argument><expr><name>resultr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
<if_stmt><if>if<condition>(<expr><call><name>is_complex_rettype</name><argument_list>(<argument><expr><name><name>t</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>rettype</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <modifier>*</modifier></type><name>rr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ri</name></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name><name>resultr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name><name>tresultr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator>
<operator>(</operator><name>wres</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>resultr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name><name>tresultr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>rr</name> <operator>=</operator> <name>resultr</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>rr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if<condition>(<expr><name><name>resulti</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name><name>tresulti</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator>
<operator>(</operator><name>wres</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>resulti</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name><name>tresulti</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ri</name> <operator>=</operator> <name>resulti</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ri</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if<condition>(<expr><name>rr</name> <operator>||</operator> <name>ri</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>quiet</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>failtext</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>=</operator><literal type="char">'x'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>print_error</name><argument_list>(<argument><expr><name><name>t</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>rettype</name></name></expr></argument>,<argument><expr><name>rr</name></expr></argument>,<argument><expr><literal type="string">"wrongresultr"</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>failp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>print_error</name><argument_list>(<argument><expr><name><name>t</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>rettype</name></name></expr></argument>,<argument><expr><name>ri</name></expr></argument>,<argument><expr><literal type="string">"wrongresulti"</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>failp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>resultr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name><name>tresultr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator>
<operator>(</operator><name>wres</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>resultr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name><name>tresultr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>quiet</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>failtext</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>=</operator><literal type="char">'x'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>print_error</name><argument_list>(<argument><expr><name><name>t</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>rettype</name></name></expr></argument>,<argument><expr><name>resultr</name></expr></argument>,<argument><expr><literal type="string">"wrongresult"</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>failp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>




<if_stmt><if>if <condition>(<expr><name><name>t</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>func</name><operator>.</operator><name>ptr</name></name> <operator>==</operator> <operator>&amp;</operator><name>frexp</name> <operator>||</operator> <name><name>t</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>func</name><operator>.</operator><name>ptr</name></name> <operator>==</operator> <operator>&amp;</operator><name>frexpf</name> <operator>||</operator>
<name><name>t</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>macro_name</name></name> <operator>==</operator> <name>m_rred</name> <operator>||</operator> <name><name>t</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>macro_name</name></name> <operator>==</operator> <name>m_rredf</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>tres2</name> <init>= <expr><name><name>t</name><operator>.</operator><name>res2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>res2_adjust</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>tres2</name> <operator>=</operator> <operator>(</operator><name>tres2</name> <operator>+</operator> <name>res2_adjust</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">3</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>tres2</name> <operator>!=</operator> <name>intres</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>quiet</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>failtext</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>=</operator><literal type="char">'x'</literal></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>failp</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>failp</name></expr></argument>,
<argument><expr><literal type="string">" wrongres2=%08x"</literal></expr></argument>, <argument><expr><name>intres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>t</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>func</name><operator>.</operator><name>ptr</name></name> <operator>==</operator> <operator>&amp;</operator><name>modf</name> <operator>||</operator> <name><name>t</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>func</name><operator>.</operator><name>ptr</name></name> <operator>==</operator> <operator>&amp;</operator><name>modff</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>tresultr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>t</name><operator>.</operator><name>res2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tresultr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>t</name><operator>.</operator><name>res2</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>is_double_rettype</name><argument_list>(<argument><expr><name><name>t</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>rettype</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>canon_dNaN</name><argument_list>(<argument><expr><name>tresultr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>resultr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>d_res2</name><operator>.</operator><name>i</name><index>[<expr><name>dmsd</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>resultr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>d_res2</name><operator>.</operator><name>i</name><index>[<expr><name>dlsd</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>canon_dNaN</name><argument_list>(<argument><expr><name>resultr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fo</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnormzero</name><argument_list>(<argument><expr><name>tresultr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dnormzero</name><argument_list>(<argument><expr><name>resultr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>canon_sNaN</name><argument_list>(<argument><expr><name>tresultr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>resultr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>s_res2</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>resultr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>s_res2</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>canon_sNaN</name><argument_list>(<argument><expr><name>resultr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fo</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>snormzero</name><argument_list>(<argument><expr><name>tresultr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>snormzero</name><argument_list>(<argument><expr><name>resultr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>resultr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name><name>tresultr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator>
<operator>(</operator><name>wres</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>resultr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name><name>tresultr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>quiet</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>failtext</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>=</operator><literal type="char">'x'</literal></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>is_double_rettype</name><argument_list>(<argument><expr><name><name>t</name><operator>.</operator><name>func</name><operator>-&gt;</operator><name>rettype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>failp</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>failp</name></expr></argument>, <argument><expr><literal type="string">" wrongres2=%08x.%08x"</literal></expr></argument>,
<argument><expr><name><name>resultr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>resultr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>failp</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>failp</name></expr></argument>, <argument><expr><literal type="string">" wrongres2=%08x"</literal></expr></argument>,
<argument><expr><name><name>resultr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>


<expr_stmt><expr><name>err</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>errno</name> <operator>==</operator> <name>EDOM</name></expr> ?</condition><then> <expr><name>e_EDOM</name></expr> </then><else>: <expr><ternary><condition><expr><name>errno</name> <operator>==</operator> <name>ERANGE</name></expr> ?</condition><then> <expr><name>e_ERANGE</name></expr> </then><else>: <expr><name>e_0</name></expr></else></ternary></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <name><name>t</name><operator>.</operator><name>err</name></name> <operator>&amp;&amp;</operator> <name>err</name> <operator>!=</operator> <name><name>t</name><operator>.</operator><name>maybeerr</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>quiet</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>failtext</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>=</operator><literal type="char">'x'</literal></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>failp</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>failp</name></expr></argument>, <argument><expr><literal type="string">" wrongerrno=%s expecterrno=%s "</literal></expr></argument>, <argument><expr><name><name>errnos</name><index>[<expr><name>err</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>errnos</name><index>[<expr><name><name>t</name><operator>.</operator><name>err</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><ternary><condition><expr><operator>*</operator><name>failtext</name></expr> ?</condition><then> <expr><name>test_fail</name></expr> </then><else>: <expr><name>test_pass</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><name>int</name></type> <name>passed</name></decl>, <decl><type ref="prev"/><name>failed</name></decl>, <decl><type ref="prev"/><name>declined</name></decl>;</decl_stmt>

<function><type><name>void</name></type> <name>runtests</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>testbuf</name><index>[<expr><literal type="number">512</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>linebuf</name><index>[<expr><literal type="number">512</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lineno</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>testdetail</name></type> <name>test</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>test</name><operator>.</operator><name>valid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"runtests: %s\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<while>while <condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><name>testbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>testbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>, <decl><type ref="prev"/><name>print_errno</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>testbuf</name><index>[<expr><call><name>strcspn</name><argument_list>(<argument><expr><name>testbuf</name></expr></argument>, <argument><expr><literal type="string">"\r\n"</literal></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>linebuf</name></expr></argument>, <argument><expr><name>testbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>test</name> <operator>=</operator> <call><name>parsetest</name><argument_list>(<argument><expr><name>testbuf</name></expr></argument>, <argument><expr><name>test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>print_errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name><name>test</name><operator>.</operator><name>in_err</name></name> <operator>&lt;</operator> <name><name>test</name><operator>.</operator><name>in_err_limit</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>runtest</name><argument_list>(<argument><expr><name>test</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>test_pass</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s:%d: pass\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>++</operator><name>passed</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>res</name> <operator>==</operator> <name>test_decline</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s:%d: declined\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>++</operator><name>declined</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>res</name> <operator>==</operator> <name>test_fail</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>quiet</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s:%d: FAIL%s: %s%s%s%s\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>,
<argument><expr><ternary><condition><expr><name><name>test</name><operator>.</operator><name>random</name></name></expr> ?</condition><then> <expr><literal type="string">" (random)"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
<argument><expr><name>linebuf</name></expr></argument>,
<argument><expr><ternary><condition><expr><name>print_errno</name></expr> ?</condition><then> <expr><literal type="string">" errno_in="</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
<argument><expr><ternary><condition><expr><name>print_errno</name></expr> ?</condition><then> <expr><name><name>errnos</name><index>[<expr><name><name>test</name><operator>.</operator><name>in_err</name></name></expr>]</index></name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
<argument><expr><name>failtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>++</operator><name>failed</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>res</name> <operator>==</operator> <name>test_invalid</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s:%d: malformed: %s\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>linebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>failed</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>test</name><operator>.</operator><name>in_err</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>print_errno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name>lineno</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>ac</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>av</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>files</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>nfiles</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dbl</name></type> <name>d</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MICROLIB</name></expr></argument>)</argument_list></call></expr></cpp:if>



<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>args</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name><name>sargs</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ac</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sargs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>=</operator><operator>(</operator><name>int</name><operator>)</operator><name>args</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sargs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>=</operator><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>__semihost</name><argument_list>(<argument><expr><literal type="number">0x15</literal></expr></argument>, <argument><expr><name>sargs</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>args</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>args</name></expr>;</expr_stmt>
<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">' '</literal> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\t'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>argv</name><index>[<expr><name>ac</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">' '</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\t'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></while>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>av</name> <operator>=</operator> <name>argv</name></expr>;</expr_stmt>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>tfuncs</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tfuncs</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name>test_func</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>test_func</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>compare_tfuncs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><name>dmsd</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>d</name><operator>.</operator><name>f</name></name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>.</operator><name>i</name><index>[<expr><name>dmsd</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>dmsd</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>




<expr_stmt><expr><name><name>d</name><operator>.</operator><name>i</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>d</name><operator>.</operator><name>i</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x11111111</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>d</name><operator>.</operator><name>f</name></name> <operator>/=</operator> <name><name>d</name><operator>.</operator><name>f</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>.</operator><name>i</name><index>[<expr><name>dmsd</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"YIKES! Compiler and runtime disagree on endianness"</literal>
<literal type="string">" of `double'. Bailing out\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>dlsd</name> <operator>=</operator> <operator>!</operator><name>dmsd</name></expr>;</expr_stmt>


<expr_stmt><expr><name>verbose</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>fo</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>strict</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>files</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><operator>(</operator><name>ac</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>files</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"initial malloc failed!\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NOCMDLINE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>files</name><index>[<expr><name>nfiles</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="string">"testfile"</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<while>while <condition>(<expr><operator>--</operator><name>ac</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><operator>++</operator><name>av</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name><name>options</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"-fo"</literal></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
"-noinexact",
"-noround",
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><literal type="string">"-nostatus"</literal></expr>,
<expr><literal type="string">"-quiet"</literal></expr>,
<expr><literal type="string">"-strict"</literal></expr>,
<expr><literal type="string">"-v"</literal></expr>,
<expr><literal type="string">"-verbose"</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>
<enum>enum <block>{
<decl><name>op_fo</name></decl>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
op_noinexact,
op_noround,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl><name>op_nostatus</name></decl>,
<decl><name>op_quiet</name></decl>,
<decl><name>op_strict</name></decl>,
<decl><name>op_v</name></decl>,
<decl><name>op_verbose</name></decl>,
}</block>;</enum>
<switch>switch <condition>(<expr><call><name>find</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>op_quiet</name></expr>:</case>
<expr_stmt><expr><name>quiet</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
case op_noinexact:
statusmask &amp;= 0x0F;
break;
case op_noround:
doround = 0;
break;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<case>case <expr><name>op_nostatus</name></expr>:</case>
<expr_stmt><expr><name>statusmask</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>doround</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>op_v</name></expr>:</case>
<case>case <expr><name>op_verbose</name></expr>:</case>
<expr_stmt><expr><name>verbose</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>op_fo</name></expr>:</case>
<expr_stmt><expr><name>fo</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>op_strict</name></expr>:</case>
<expr_stmt><expr><name>strict</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"unrecognised option: %s\n"</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>files</name><index>[<expr><name>nfiles</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>

<expr_stmt><expr><name>passed</name> <operator>=</operator> <name>failed</name> <operator>=</operator> <name>declined</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>nfiles</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nfiles</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name> <init>= <expr><call><name>fopen</name><argument_list>(<argument><expr><name><name>files</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fp</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Couldn't open %s\n"</literal></expr></argument>, <argument><expr><name><name>files</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>runtests</name><argument_list>(<argument><expr><name><name>files</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>runtests</name><argument_list>(<argument><expr><literal type="string">"(stdin)"</literal></expr></argument>, <argument><expr><name>stdin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Completed. Passed %d, failed %d (total %d"</literal></expr></argument>,
<argument><expr><name>passed</name></expr></argument>, <argument><expr><name>failed</name></expr></argument>, <argument><expr><name>passed</name><operator>+</operator><name>failed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>declined</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" plus %d declined"</literal></expr></argument>, <argument><expr><name>declined</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">")\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>failed</name> <operator>||</operator> <name>passed</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"** TEST PASSED OK **\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>undef_func</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>failed</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><literal type="string">"ERROR: undefined function called"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
