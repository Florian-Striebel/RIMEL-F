


















#include "openbsd-compat.h"

#if !defined(HAVE_RECALLOCARRAY)

#include <errno.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#if defined(HAVE_UNISTD_H)
#include <unistd.h>
#endif





#define MUL_NO_OVERFLOW ((size_t)1 << (sizeof(size_t) * 4))

void *
recallocarray(void *ptr, size_t oldnmemb, size_t newnmemb, size_t size)
{
size_t oldsize, newsize;
void *newptr;

if (ptr == NULL)
return calloc(newnmemb, size);

if ((newnmemb >= MUL_NO_OVERFLOW || size >= MUL_NO_OVERFLOW) &&
newnmemb > 0 && SIZE_MAX / newnmemb < size) {
errno = ENOMEM;
return NULL;
}
newsize = newnmemb * size;

if ((oldnmemb >= MUL_NO_OVERFLOW || size >= MUL_NO_OVERFLOW) &&
oldnmemb > 0 && SIZE_MAX / oldnmemb < size) {
errno = EINVAL;
return NULL;
}
oldsize = oldnmemb * size;





if (newsize <= oldsize) {
size_t d = oldsize - newsize;

if (d < oldsize / 2 && d < (size_t)getpagesize()) {
memset((char *)ptr + newsize, 0, d);
return ptr;
}
}

newptr = malloc(newsize);
if (newptr == NULL)
return NULL;

if (newsize > oldsize) {
memcpy(newptr, ptr, oldsize);
memset((char *)newptr + oldsize, 0, newsize - oldsize);
} else
memcpy(newptr, ptr, newsize);

explicit_bzero(ptr, oldsize);
free(ptr);

return newptr;
}


#endif
