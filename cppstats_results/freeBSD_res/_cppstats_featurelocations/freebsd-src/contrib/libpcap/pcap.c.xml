<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/libpcap/pcap.c">
































<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_CONFIG_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;config.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pcap-types.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/param.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MSDOS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/file.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/ioctl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/socket.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_SOCKIO_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/sockio.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<struct_decl>struct <name>mbuf</name>;</struct_decl>
<struct_decl>struct <name>rtentry</name>;</struct_decl>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;net/if.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netinet/in.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__BORLANDC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__MINGW32__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LIMITS_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INT_MAX</name></cpp:macro> <cpp:value>2147483647</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_OS_PROTO_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"os-proto.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MSDOS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pcap-dos.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pcap-int.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimize.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DAG_API</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pcap-dag.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SEPTEL_API</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pcap-septel.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SNF_API</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pcap-snf.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_TC_API</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pcap-tc.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PCAP_SUPPORT_USB</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pcap-usb-linux.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PCAP_SUPPORT_BT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pcap-bt-linux.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PCAP_SUPPORT_BT_MONITOR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pcap-bt-monitor-linux.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PCAP_SUPPORT_NETFILTER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pcap-netfilter-linux.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PCAP_SUPPORT_NETMAP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pcap-netmap.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PCAP_SUPPORT_DBUS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pcap-dbus.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PCAP_SUPPORT_RDMASNIFF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pcap-rdmasniff.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>



<function><type><name>BOOL</name> <name>WINAPI</name></type> <name>DllMain</name><parameter_list>(
<parameter><decl><type><name>HANDLE</name></type> <name>hinstDLL</name></decl></parameter>,
<parameter><decl><type><name>DWORD</name></type> <name>dwReason</name></decl></parameter>,
<parameter><decl><type><name>LPVOID</name></type> <name>lpvReserved</name></decl></parameter>
)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><name>TRUE</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>






<function><type><name>int</name></type>
<name>wsockinit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>WORD</name></type> <name>wVersionRequested</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WSADATA</name></type> <name>wsaData</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>err</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>done</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>done</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>err</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>wVersionRequested</name> <operator>=</operator> <call><name>MAKEWORD</name><argument_list>( <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>WSAStartup</name><argument_list>( <argument><expr><name>wVersionRequested</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>wsaData</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>atexit</name> <argument_list>(<argument><expr><operator>(</operator><call><call><name>void</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call><operator>)</operator><name>WSACleanup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>done</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>( <expr><name>err</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>err</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><name>err</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>




<function><type><name>int</name></type>
<name>pcap_wsockinit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><call><name>wsockinit</name><argument_list>()</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>











<decl_stmt><decl><type><name>PCAP_API</name> <name>char</name></type> <name><name>pcap_version</name><index>[]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCAP_API_DEF</name> <name>char</name></type> <name><name>pcap_version</name><index>[]</index></name> <init>= <expr><name>PACKAGE_VERSION</name></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>pcap_set_not_initialized_message</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>pcap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>pcap</name><operator>-&gt;</operator><name>activated</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name><name>pcap</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pcap</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><literal type="string">"This operation isn't properly handled by that device"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name><name>pcap</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pcap</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><literal type="string">"This handle hasn't been activated yet"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pcap_read_not_initialized</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>pcap</name></decl></parameter>, <parameter><decl><type><name>int</name> <name>cnt</name></type> <name>_U_</name></decl></parameter>, <parameter><decl><type><name>pcap_handler</name> <name>callback</name></type> <name>_U_</name></decl></parameter>,
<parameter><decl><type><name>u_char</name> <modifier>*</modifier><name>user</name></type> <name>_U_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>pcap_set_not_initialized_message</name><argument_list>(<argument><expr><name>pcap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>PCAP_ERROR_NOT_ACTIVATED</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pcap_inject_not_initialized</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>pcap</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier> <name>buf</name></type> <name>_U_</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <name>size</name></type> <name>_U_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>pcap_set_not_initialized_message</name><argument_list>(<argument><expr><name>pcap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>PCAP_ERROR_NOT_ACTIVATED</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pcap_setfilter_not_initialized</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>pcap</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>bpf_program</name></name> <modifier>*</modifier><name>fp</name></type> <name>_U_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>pcap_set_not_initialized_message</name><argument_list>(<argument><expr><name>pcap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>PCAP_ERROR_NOT_ACTIVATED</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pcap_setdirection_not_initialized</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>pcap</name></decl></parameter>, <parameter><decl><type><name>pcap_direction_t</name> <name>d</name></type> <name>_U_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>pcap_set_not_initialized_message</name><argument_list>(<argument><expr><name>pcap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>PCAP_ERROR_NOT_ACTIVATED</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pcap_set_datalink_not_initialized</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>pcap</name></decl></parameter>, <parameter><decl><type><name>int</name> <name>dlt</name></type> <name>_U_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>pcap_set_not_initialized_message</name><argument_list>(<argument><expr><name>pcap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>PCAP_ERROR_NOT_ACTIVATED</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pcap_getnonblock_not_initialized</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>pcap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>pcap_set_not_initialized_message</name><argument_list>(<argument><expr><name>pcap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>PCAP_ERROR_NOT_ACTIVATED</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pcap_stats_not_initialized</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>pcap</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>pcap_stat</name></name> <modifier>*</modifier><name>ps</name></type> <name>_U_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>pcap_set_not_initialized_message</name><argument_list>(<argument><expr><name>pcap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>PCAP_ERROR_NOT_ACTIVATED</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name><name>struct</name> <name>pcap_stat</name></name> <modifier>*</modifier></type>
<name>pcap_stats_ex_not_initialized</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>pcap</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier><name>pcap_stat_size</name></type> <name>_U_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>pcap_set_not_initialized_message</name><argument_list>(<argument><expr><name>pcap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pcap_setbuff_not_initialized</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>pcap</name></decl></parameter>, <parameter><decl><type><name>int</name> <name>dim</name></type> <name>_U_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>pcap_set_not_initialized_message</name><argument_list>(<argument><expr><name>pcap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>PCAP_ERROR_NOT_ACTIVATED</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pcap_setmode_not_initialized</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>pcap</name></decl></parameter>, <parameter><decl><type><name>int</name> <name>mode</name></type> <name>_U_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>pcap_set_not_initialized_message</name><argument_list>(<argument><expr><name>pcap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>PCAP_ERROR_NOT_ACTIVATED</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pcap_setmintocopy_not_initialized</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>pcap</name></decl></parameter>, <parameter><decl><type><name>int</name> <name>size</name></type> <name>_U_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>pcap_set_not_initialized_message</name><argument_list>(<argument><expr><name>pcap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>PCAP_ERROR_NOT_ACTIVATED</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>HANDLE</name></type>
<name>pcap_getevent_not_initialized</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>pcap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>pcap_set_not_initialized_message</name><argument_list>(<argument><expr><name>pcap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>INVALID_HANDLE_VALUE</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pcap_oid_get_request_not_initialized</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>pcap</name></decl></parameter>, <parameter><decl><type><name>bpf_u_int32</name> <name>oid</name></type> <name>_U_</name></decl></parameter>,
<parameter><decl><type><name>void</name> <modifier>*</modifier><name>data</name></type> <name>_U_</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier><name>lenp</name></type> <name>_U_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>pcap_set_not_initialized_message</name><argument_list>(<argument><expr><name>pcap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>PCAP_ERROR_NOT_ACTIVATED</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pcap_oid_set_request_not_initialized</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>pcap</name></decl></parameter>, <parameter><decl><type><name>bpf_u_int32</name> <name>oid</name></type> <name>_U_</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier><name>data</name></type> <name>_U_</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier><name>lenp</name></type> <name>_U_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>pcap_set_not_initialized_message</name><argument_list>(<argument><expr><name>pcap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>PCAP_ERROR_NOT_ACTIVATED</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>u_int</name></type>
<name>pcap_sendqueue_transmit_not_initialized</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>pcap</name></decl></parameter>, <parameter><decl><type><name>pcap_send_queue</name><modifier>*</modifier></type> <name>queue</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sync</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>pcap_set_not_initialized_message</name><argument_list>(<argument><expr><name>pcap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pcap_setuserbuffer_not_initialized</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>pcap</name></decl></parameter>, <parameter><decl><type><name>int</name> <name>size</name></type> <name>_U_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>pcap_set_not_initialized_message</name><argument_list>(<argument><expr><name>pcap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>PCAP_ERROR_NOT_ACTIVATED</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pcap_live_dump_not_initialized</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>pcap</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><name>filename</name></type> <name>_U_</name></decl></parameter>, <parameter><decl><type><name>int</name> <name>maxsize</name></type> <name>_U_</name></decl></parameter>,
<parameter><decl><type><name>int</name> <name>maxpacks</name></type> <name>_U_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>pcap_set_not_initialized_message</name><argument_list>(<argument><expr><name>pcap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>PCAP_ERROR_NOT_ACTIVATED</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pcap_live_dump_ended_not_initialized</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>pcap</name></decl></parameter>, <parameter><decl><type><name>int</name> <name>sync</name></type> <name>_U_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>pcap_set_not_initialized_message</name><argument_list>(<argument><expr><name>pcap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>PCAP_ERROR_NOT_ACTIVATED</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PAirpcapHandle</name></type>
<name>pcap_get_airpcap_handle_not_initialized</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>pcap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>pcap_set_not_initialized_message</name><argument_list>(<argument><expr><name>pcap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>





<function><type><name>int</name></type>
<name>pcap_can_set_rfmon</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><call><name><name>p</name><operator>-&gt;</operator><name>can_set_rfmon_op</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>int</name></type>
<name>pcap_cant_set_rfmon</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier><name>p</name></type> <name>_U_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>












<function><type><name>int</name></type>
<name>pcap_list_tstamp_types</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier><modifier>*</modifier></type><name>tstamp_typesp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>tstamp_type_count</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>





<expr_stmt><expr><operator>*</operator><name>tstamp_typesp</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><operator>*</operator><name>tstamp_typesp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>tstamp_typesp</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pcap_fmt_errmsg_for_errno</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><name>errno</name></expr></argument>, <argument><expr><literal type="string">"malloc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>PCAP_ERROR</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><operator>*</operator><name>tstamp_typesp</name> <operator>=</operator> <name>PCAP_TSTAMP_HOST</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>tstamp_typesp</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><call><name>calloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><operator>*</operator><name>tstamp_typesp</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><name><name>p</name><operator>-&gt;</operator><name>tstamp_type_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>tstamp_typesp</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pcap_fmt_errmsg_for_errno</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><name>errno</name></expr></argument>, <argument><expr><literal type="string">"malloc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>PCAP_ERROR</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>memcpy</name><argument_list>(<argument><expr><operator>*</operator><name>tstamp_typesp</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>tstamp_type_list</name></name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><operator>*</operator><name>tstamp_typesp</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>p</name><operator>-&gt;</operator><name>tstamp_type_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>tstamp_type_count</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>












<function><type><name>void</name></type>
<name>pcap_free_tstamp_types</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>tstamp_type_list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tstamp_type_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>






<function><type><name>void</name></type>
<name>pcap_oneshot</name><parameter_list>(<parameter><decl><type><name>u_char</name> <modifier>*</modifier></type><name>user</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>pcap_pkthdr</name></name> <modifier>*</modifier></type><name>h</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>u_char</name> <modifier>*</modifier></type><name>pkt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>oneshot_userdata</name></name> <modifier>*</modifier></type><name>sp</name> <init>= <expr><operator>(</operator>struct <name>oneshot_userdata</name> <operator>*</operator><operator>)</operator><name>user</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name><name>sp</name><operator>-&gt;</operator><name>hdr</name></name> <operator>=</operator> <operator>*</operator><name>h</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name><name>sp</name><operator>-&gt;</operator><name>pkt</name></name> <operator>=</operator> <name>pkt</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>u_char</name> <modifier>*</modifier></type>
<name>pcap_next</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>pcap_pkthdr</name></name> <modifier>*</modifier></type><name>h</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>oneshot_userdata</name></name></type> <name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>u_char</name> <modifier>*</modifier></type><name>pkt</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>s</name><operator>.</operator><name>hdr</name></name> <operator>=</operator> <name>h</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>.</operator><name>pkt</name></name> <operator>=</operator> <operator>&amp;</operator><name>pkt</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>.</operator><name>pd</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>pcap_dispatch</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>oneshot_callback</name></name></expr></argument>, <argument><expr><operator>(</operator><name>u_char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><name>pkt</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pcap_next_ex</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>pcap_pkthdr</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>pkt_header</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>u_char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pkt_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>oneshot_userdata</name></name></type> <name>s</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>s</name><operator>.</operator><name>hdr</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>pcap_header</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>.</operator><name>pkt</name></name> <operator>=</operator> <name>pkt_data</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>.</operator><name>pd</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>


<expr_stmt><expr><operator>*</operator><name>pkt_header</name><operator>=</operator> <operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>pcap_header</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>rfile</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>


<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>pcap_offline_read</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>oneshot_callback</name></name></expr></argument>,
<argument><expr><operator>(</operator><name>u_char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>













<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">2</literal><operator>)</operator></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>status</name><operator>)</operator></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>










<return>return <expr><operator>(</operator><call><name><name>p</name><operator>-&gt;</operator><name>read_op</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>oneshot_callback</name></name></expr></argument>, <argument><expr><operator>(</operator><name>u_char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>




<struct>struct <name>pcap_if_list</name> <block>{
<decl_stmt><decl><type><name>pcap_if_t</name> <modifier>*</modifier></type><name>beginning</name></decl>;</decl_stmt>
}</block>;</struct>

<struct><specifier>static</specifier> struct <name>capture_source_type</name> <block>{
<function_decl><type><name>int</name></type> (<modifier>*</modifier><name>findalldevs_op</name>)<parameter_list>(<parameter><decl><type><name>pcap_if_list_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>pcap_t</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>create_op</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
}</block> <decl><name><name>capture_source_types</name><index>[]</index></name> <init>= <expr><block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DAG_API</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{ <expr><name>dag_findalldevs</name></expr>, <expr><name>dag_create</name></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SEPTEL_API</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{ <expr><name>septel_findalldevs</name></expr>, <expr><name>septel_create</name></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SNF_API</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{ <expr><name>snf_findalldevs</name></expr>, <expr><name>snf_create</name></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_TC_API</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{ <expr><name>TcFindAllDevs</name></expr>, <expr><name>TcCreate</name></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PCAP_SUPPORT_BT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{ <expr><name>bt_findalldevs</name></expr>, <expr><name>bt_create</name></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PCAP_SUPPORT_BT_MONITOR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{ <expr><name>bt_monitor_findalldevs</name></expr>, <expr><name>bt_monitor_create</name></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PCAP_SUPPORT_USB</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{ <expr><name>usb_findalldevs</name></expr>, <expr><name>usb_create</name></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PCAP_SUPPORT_NETFILTER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{ <expr><name>netfilter_findalldevs</name></expr>, <expr><name>netfilter_create</name></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PCAP_SUPPORT_NETMAP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{ <expr><name>pcap_netmap_findalldevs</name></expr>, <expr><name>pcap_netmap_create</name></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PCAP_SUPPORT_DBUS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{ <expr><name>dbus_findalldevs</name></expr>, <expr><name>dbus_create</name></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PCAP_SUPPORT_RDMASNIFF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{ <expr><name>rdmasniff_findalldevs</name></expr>, <expr><name>rdmasniff_create</name></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><block>{ <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr> }</block></expr>
}</block></expr></init></decl>;</struct>







<function><type><name>int</name></type>
<name>pcap_findalldevs</name><parameter_list>(<parameter><decl><type><name>pcap_if_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>alldevsp</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>errbuf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>pcap_if_list_t</name></type> <name>devlist</name></decl>;</decl_stmt>





<expr_stmt><expr><name><name>devlist</name><operator>.</operator><name>beginning</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>pcap_platform_finddevs</name><argument_list>(<argument><expr><operator>&amp;</operator><name>devlist</name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>




<if_stmt><if>if <condition>(<expr><name><name>devlist</name><operator>.</operator><name>beginning</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>pcap_freealldevs</name><argument_list>(<argument><expr><name><name>devlist</name><operator>.</operator><name>beginning</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>alldevsp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>





<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>capture_source_types</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>findalldevs_op</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>capture_source_types</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>findalldevs_op</name><argument_list>(<argument><expr><operator>&amp;</operator><name>devlist</name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>




<if_stmt><if>if <condition>(<expr><name><name>devlist</name><operator>.</operator><name>beginning</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>pcap_freealldevs</name><argument_list>(<argument><expr><name><name>devlist</name><operator>.</operator><name>beginning</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>alldevsp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>




<expr_stmt><expr><operator>*</operator><name>alldevsp</name> <operator>=</operator> <name><name>devlist</name><operator>.</operator><name>beginning</name></name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>sockaddr</name></name> <modifier>*</modifier></type>
<name>dup_sockaddr</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sockaddr</name></name> <modifier>*</modifier></type><name>sa</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>sa_length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>sockaddr</name></name> <modifier>*</modifier></type><name>newsa</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>newsa</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>sa_length</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><call><name>memcpy</name><argument_list>(<argument><expr><name>newsa</name></expr></argument>, <argument><expr><name>sa</name></expr></argument>, <argument><expr><name>sa_length</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>



















<function><type><specifier>static</specifier> <name>u_int</name></type>
<name>get_figure_of_merit</name><parameter_list>(<parameter><decl><type><name>pcap_if_t</name> <modifier>*</modifier></type><name>dev</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>u_int</name></type> <name>n</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>dev</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"any"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>





<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0x1FFFFFFF</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>







<expr_stmt><expr><name>cp</name> <operator>=</operator> <name><name>dev</name><operator>-&gt;</operator><name>name</name></name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>dev</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name>cp</name><operator>-</operator><literal type="number">1</literal> <operator>&gt;=</operator> <name><name>dev</name><operator>-&gt;</operator><name>name</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>cp</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>cp</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>cp</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>cp</name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>dev</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PCAP_IF_RUNNING</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>n</name> <operator>|=</operator> <literal type="number">0x80000000</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>dev</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PCAP_IF_UP</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>n</name> <operator>|=</operator> <literal type="number">0x40000000</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>











<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>dev</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PCAP_IF_WIRELESS</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>dev</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PCAP_IF_CONNECTION_STATUS</name><operator>)</operator> <operator>==</operator> <name>PCAP_IF_CONNECTION_STATUS_DISCONNECTED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>n</name> <operator>|=</operator> <literal type="number">0x20000000</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>





<if_stmt><if>if <condition>(<expr><name><name>dev</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PCAP_IF_LOOPBACK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>n</name> <operator>|=</operator> <literal type="number">0x10000000</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><name>n</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>

















































<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIOCGIFDESCR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<name>get_if_description</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>description</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>ifreq</name></name></type> <name>ifrdesc</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>IFDESCRSIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>size_t</name></type> <name>descrlen</name> <init>= <expr><literal type="number">64</literal></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>size_t</name></type> <name>descrlen</name> <init>= <expr><name>IFDESCRSIZE</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>




<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ifrdesc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof <name>ifrdesc</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pcap_strlcpy</name><argument_list>(<argument><expr><name><name>ifrdesc</name><operator>.</operator><name>ifr_name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><sizeof>sizeof <name><name>ifrdesc</name><operator>.</operator><name>ifr_name</name></name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>socket</name><argument_list>(<argument><expr><name>AF_INET</name></expr></argument>, <argument><expr><name>SOCK_DGRAM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>s</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__FreeBSD__</name></expr></argument>)</argument_list></call></expr></cpp:if>






<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>description</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>description</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>descrlen</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ifrdesc</name><operator>.</operator><name>ifr_buffer</name><operator>.</operator><name>buffer</name></name> <operator>=</operator> <name>description</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ifrdesc</name><operator>.</operator><name>ifr_buffer</name><operator>.</operator><name>length</name></name> <operator>=</operator> <name>descrlen</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ioctl</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>SIOCGIFDESCR</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ifrdesc</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ifrdesc</name><operator>.</operator><name>ifr_buffer</name><operator>.</operator><name>buffer</name></name> <operator>==</operator>
<name>description</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>descrlen</name> <operator>=</operator> <name><name>ifrdesc</name><operator>.</operator><name>ifr_buffer</name><operator>.</operator><name>length</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>



<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>description</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>description</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<break>break;</break></block_content></block></else></if_stmt>
</block_content>}</block></for>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>






<if_stmt><if>if <condition>(<expr><operator>(</operator><name>description</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>descrlen</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ifrdesc</name><operator>.</operator><name>ifr_data</name></name> <operator>=</operator> <operator>(</operator><name>caddr_t</name><operator>)</operator><name>description</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ioctl</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>SIOCGIFDESCR</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ifrdesc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>description</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>description</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>description</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>description</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>description</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>description</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__FreeBSD__</name></expr></argument>)</argument_list></call></expr></cpp:if>





<if_stmt><if>if <condition>(<expr><name>description</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"usbus"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>



<decl_stmt><decl><type><name>long</name></type> <name>busnum</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>busnum</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>name</name> <operator>+</operator> <literal type="number">5</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>p</name> <operator>!=</operator> <name>name</name> <operator>+</operator> <literal type="number">5</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator>
<name>busnum</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>busnum</name> <operator>&lt;=</operator> <name>INT_MAX</name></expr>)</condition> <block>{<block_content>







<if_stmt><if>if <condition>(<expr><call><name>pcap_asprintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>description</name></expr></argument>,
<argument><expr><literal type="string">"USB bus number %ld"</literal></expr></argument>, <argument><expr><name>busnum</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>description</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><operator>(</operator><name>description</name><operator>)</operator></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<macro><name>get_if_description</name><argument_list>(<argument>const char *name _U_</argument>)</argument_list></macro>
<block>{<block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block>










<function><type><name>pcap_if_t</name> <modifier>*</modifier></type>
<name>find_or_add_if</name><parameter_list>(<parameter><decl><type><name>pcap_if_list_t</name> <modifier>*</modifier></type><name>devlistp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
<parameter><decl><type><name>bpf_u_int32</name></type> <name>if_flags</name></decl></parameter>, <parameter><decl><type><name>get_if_flags_func</name></type> <name>get_flags_func</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>errbuf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>bpf_u_int32</name></type> <name>pcap_flags</name></decl>;</decl_stmt>




<expr_stmt><expr><name>pcap_flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IFF_LOOPBACK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>if_flags</name> <operator>&amp;</operator> <name>IFF_LOOPBACK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>pcap_flags</name> <operator>|=</operator> <name>PCAP_IF_LOOPBACK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>




<if_stmt><if>if <condition>(<decl_stmt><expr><name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'l'</literal> <operator>&amp;&amp;</operator> <name><name>name</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'o'</literal> <operator>&amp;&amp;</operator>
<operator>(</operator><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>(</operator><name><name>name</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>name</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal><operator>)</operator>
<name>pcap_flags</name> <operator>|=</operator> <name>PCAP_IF_LOOPBACK</name></expr>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IFF_UP</name></expr></argument>)</argument_list></call></expr></cpp:if>
if <expr><operator>(</operator><name>if_flags</name> <operator>&amp;</operator> <name>IFF_UP</name><operator>)</operator>
<name>pcap_flags</name> <operator>|=</operator> <name>PCAP_IF_UP</name></expr></condition><empty_stmt>;</empty_stmt></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IFF_RUNNING</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>if_flags</name> <operator>&amp;</operator> <name>IFF_RUNNING</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>pcap_flags</name> <operator>|=</operator> <name>PCAP_IF_RUNNING</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>





<return>return <expr><operator>(</operator><call><name>find_or_add_dev</name><argument_list>(<argument><expr><name>devlistp</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>pcap_flags</name></expr></argument>,
<argument><expr><name>get_flags_func</name></expr></argument>, <argument><expr><call><name>get_if_description</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>



















<function><type><name>int</name></type>
<name>add_addr_to_if</name><parameter_list>(<parameter><decl><type><name>pcap_if_list_t</name> <modifier>*</modifier></type><name>devlistp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
<parameter><decl><type><name>bpf_u_int32</name></type> <name>if_flags</name></decl></parameter>, <parameter><decl><type><name>get_if_flags_func</name></type> <name>get_flags_func</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>sockaddr</name></name> <modifier>*</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>addr_size</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>sockaddr</name></name> <modifier>*</modifier></type><name>netmask</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>netmask_size</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>sockaddr</name></name> <modifier>*</modifier></type><name>broadaddr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>broadaddr_size</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>sockaddr</name></name> <modifier>*</modifier></type><name>dstaddr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstaddr_size</name></decl></parameter>,
<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>errbuf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>pcap_if_t</name> <modifier>*</modifier></type><name>curdev</name></decl>;</decl_stmt>




<expr_stmt><expr><name>curdev</name> <operator>=</operator> <call><name>find_or_add_if</name><argument_list>(<argument><expr><name>devlistp</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>if_flags</name></expr></argument>, <argument><expr><name>get_flags_func</name></expr></argument>,
<argument><expr><name>errbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>curdev</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>



<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>




<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>






<return>return <expr><operator>(</operator><call><name>add_addr_to_dev</name><argument_list>(<argument><expr><name>curdev</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>addr_size</name></expr></argument>, <argument><expr><name>netmask</name></expr></argument>,
<argument><expr><name>netmask_size</name></expr></argument>, <argument><expr><name>broadaddr</name></expr></argument>, <argument><expr><name>broadaddr_size</name></expr></argument>, <argument><expr><name>dstaddr</name></expr></argument>,
<argument><expr><name>dstaddr_size</name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>





<function><type><name>int</name></type>
<name>add_addr_to_dev</name><parameter_list>(<parameter><decl><type><name>pcap_if_t</name> <modifier>*</modifier></type><name>curdev</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>sockaddr</name></name> <modifier>*</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>addr_size</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>sockaddr</name></name> <modifier>*</modifier></type><name>netmask</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>netmask_size</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>sockaddr</name></name> <modifier>*</modifier></type><name>broadaddr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>broadaddr_size</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>sockaddr</name></name> <modifier>*</modifier></type><name>dstaddr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>dstaddr_size</name></decl></parameter>,
<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>errbuf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>pcap_addr_t</name> <modifier>*</modifier></type><name>curaddr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>prevaddr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>nextaddr</name></decl>;</decl_stmt>




<expr_stmt><expr><name>curaddr</name> <operator>=</operator> <operator>(</operator><name>pcap_addr_t</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pcap_addr_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>curaddr</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pcap_fmt_errmsg_for_errno</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><name>errno</name></expr></argument>, <argument><expr><literal type="string">"malloc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>curaddr</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>addr_size</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>curaddr</name><operator>-&gt;</operator><name>addr</name></name> <operator>=</operator> <operator>(</operator>struct <name>sockaddr</name> <operator>*</operator><operator>)</operator><call><name>dup_sockaddr</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>addr_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>curaddr</name><operator>-&gt;</operator><name>addr</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pcap_fmt_errmsg_for_errno</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><name>errno</name></expr></argument>, <argument><expr><literal type="string">"malloc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>curaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>curaddr</name><operator>-&gt;</operator><name>addr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>netmask</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>netmask_size</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>curaddr</name><operator>-&gt;</operator><name>netmask</name></name> <operator>=</operator> <operator>(</operator>struct <name>sockaddr</name> <operator>*</operator><operator>)</operator><call><name>dup_sockaddr</name><argument_list>(<argument><expr><name>netmask</name></expr></argument>, <argument><expr><name>netmask_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>curaddr</name><operator>-&gt;</operator><name>netmask</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pcap_fmt_errmsg_for_errno</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><name>errno</name></expr></argument>, <argument><expr><literal type="string">"malloc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>curaddr</name><operator>-&gt;</operator><name>addr</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>curaddr</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>curaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>curaddr</name><operator>-&gt;</operator><name>netmask</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>broadaddr</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>broadaddr_size</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>curaddr</name><operator>-&gt;</operator><name>broadaddr</name></name> <operator>=</operator> <operator>(</operator>struct <name>sockaddr</name> <operator>*</operator><operator>)</operator><call><name>dup_sockaddr</name><argument_list>(<argument><expr><name>broadaddr</name></expr></argument>, <argument><expr><name>broadaddr_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>curaddr</name><operator>-&gt;</operator><name>broadaddr</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pcap_fmt_errmsg_for_errno</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><name>errno</name></expr></argument>, <argument><expr><literal type="string">"malloc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>curaddr</name><operator>-&gt;</operator><name>netmask</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>curaddr</name><operator>-&gt;</operator><name>netmask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>curaddr</name><operator>-&gt;</operator><name>addr</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>curaddr</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>curaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>curaddr</name><operator>-&gt;</operator><name>broadaddr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>dstaddr</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>dstaddr_size</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>curaddr</name><operator>-&gt;</operator><name>dstaddr</name></name> <operator>=</operator> <operator>(</operator>struct <name>sockaddr</name> <operator>*</operator><operator>)</operator><call><name>dup_sockaddr</name><argument_list>(<argument><expr><name>dstaddr</name></expr></argument>, <argument><expr><name>dstaddr_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>curaddr</name><operator>-&gt;</operator><name>dstaddr</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pcap_fmt_errmsg_for_errno</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><name>errno</name></expr></argument>, <argument><expr><literal type="string">"malloc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>curaddr</name><operator>-&gt;</operator><name>broadaddr</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>curaddr</name><operator>-&gt;</operator><name>broadaddr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>curaddr</name><operator>-&gt;</operator><name>netmask</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>curaddr</name><operator>-&gt;</operator><name>netmask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>curaddr</name><operator>-&gt;</operator><name>addr</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>curaddr</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>curaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>curaddr</name><operator>-&gt;</operator><name>dstaddr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>




<for>for <control>(<init><expr><name>prevaddr</name> <operator>=</operator> <name><name>curdev</name><operator>-&gt;</operator><name>addresses</name></name></expr>;</init> <condition><expr><name>prevaddr</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>prevaddr</name> <operator>=</operator> <name>nextaddr</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>nextaddr</name> <operator>=</operator> <name><name>prevaddr</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nextaddr</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>



<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>prevaddr</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><name><name>curdev</name><operator>-&gt;</operator><name>addresses</name></name> <operator>=</operator> <name>curaddr</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>




<expr_stmt><expr><name><name>prevaddr</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>curaddr</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>










<function><type><name>pcap_if_t</name> <modifier>*</modifier></type>
<name>find_or_add_dev</name><parameter_list>(<parameter><decl><type><name>pcap_if_list_t</name> <modifier>*</modifier></type><name>devlistp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>bpf_u_int32</name></type> <name>flags</name></decl></parameter>,
<parameter><decl><type><name>get_if_flags_func</name></type> <name>get_flags_func</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>description</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>errbuf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>pcap_if_t</name> <modifier>*</modifier></type><name>curdev</name></decl>;</decl_stmt>




<expr_stmt><expr><name>curdev</name> <operator>=</operator> <call><name>find_dev</name><argument_list>(<argument><expr><name>devlistp</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>curdev</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>



<return>return <expr><operator>(</operator><name>curdev</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>








<if_stmt><if>if <condition>(<expr><call>(<modifier>*</modifier><name>get_flags_func</name>)<argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flags</name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>



<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>




<return>return <expr><operator>(</operator><call><name>add_dev</name><argument_list>(<argument><expr><name>devlistp</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>description</name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>





<function><type><name>pcap_if_t</name> <modifier>*</modifier></type>
<name>find_dev</name><parameter_list>(<parameter><decl><type><name>pcap_if_list_t</name> <modifier>*</modifier></type><name>devlistp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>pcap_if_t</name> <modifier>*</modifier></type><name>curdev</name></decl>;</decl_stmt>




<for>for <control>(<init><expr><name>curdev</name> <operator>=</operator> <name><name>devlistp</name><operator>-&gt;</operator><name>beginning</name></name></expr>;</init> <condition><expr><name>curdev</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
<incr><expr><name>curdev</name> <operator>=</operator> <name><name>curdev</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>curdev</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>





<return>return <expr><operator>(</operator><name>curdev</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>




<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>









<function><type><name>pcap_if_t</name> <modifier>*</modifier></type>
<name>add_dev</name><parameter_list>(<parameter><decl><type><name>pcap_if_list_t</name> <modifier>*</modifier></type><name>devlistp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>bpf_u_int32</name></type> <name>flags</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>description</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>errbuf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>pcap_if_t</name> <modifier>*</modifier></type><name>curdev</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>prevdev</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>nextdev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>u_int</name></type> <name>this_figure_of_merit</name></decl>, <decl><type ref="prev"/><name>nextdev_figure_of_merit</name></decl>;</decl_stmt>

<expr_stmt><expr><name>curdev</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pcap_if_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>curdev</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pcap_fmt_errmsg_for_errno</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><name>errno</name></expr></argument>, <argument><expr><literal type="string">"malloc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>




<expr_stmt><expr><name><name>curdev</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>curdev</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>curdev</name><operator>-&gt;</operator><name>name</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pcap_fmt_errmsg_for_errno</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><name>errno</name></expr></argument>, <argument><expr><literal type="string">"malloc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>curdev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>description</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><name><name>curdev</name><operator>-&gt;</operator><name>description</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>



<expr_stmt><expr><name><name>curdev</name><operator>-&gt;</operator><name>description</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>description</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>curdev</name><operator>-&gt;</operator><name>description</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pcap_fmt_errmsg_for_errno</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><name>errno</name></expr></argument>, <argument><expr><literal type="string">"malloc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>curdev</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>curdev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>curdev</name><operator>-&gt;</operator><name>addresses</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>curdev</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>





<expr_stmt><expr><name>this_figure_of_merit</name> <operator>=</operator> <call><name>get_figure_of_merit</name><argument_list>(<argument><expr><name>curdev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>








<expr_stmt><expr><name>prevdev</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>



<if_stmt><if>if <condition>(<expr><name>prevdev</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><name>nextdev</name> <operator>=</operator> <name><name>devlistp</name><operator>-&gt;</operator><name>beginning</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>nextdev</name> <operator>=</operator> <name><name>prevdev</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>




<if_stmt><if>if <condition>(<expr><name>nextdev</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>



<break>break;</break>
</block_content>}</block></if></if_stmt>







<expr_stmt><expr><name>nextdev_figure_of_merit</name> <operator>=</operator> <call><name>get_figure_of_merit</name><argument_list>(<argument><expr><name>nextdev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>this_figure_of_merit</name> <operator>&lt;</operator> <name>nextdev_figure_of_merit</name></expr>)</condition> <block>{<block_content>




<break>break;</break>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>prevdev</name> <operator>=</operator> <name>nextdev</name></expr>;</expr_stmt>
</block_content>}</block></for>




<expr_stmt><expr><name><name>curdev</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>nextdev</name></expr>;</expr_stmt>





<if_stmt><if>if <condition>(<expr><name>prevdev</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>




<expr_stmt><expr><name><name>devlistp</name><operator>-&gt;</operator><name>beginning</name></name> <operator>=</operator> <name>curdev</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>prevdev</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>curdev</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return <expr><operator>(</operator><name>curdev</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>




<function><type><name>void</name></type>
<name>pcap_freealldevs</name><parameter_list>(<parameter><decl><type><name>pcap_if_t</name> <modifier>*</modifier></type><name>alldevs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>pcap_if_t</name> <modifier>*</modifier></type><name>curdev</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>nextdev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>pcap_addr_t</name> <modifier>*</modifier></type><name>curaddr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>nextaddr</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>curdev</name> <operator>=</operator> <name>alldevs</name></expr>;</init> <condition><expr><name>curdev</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>curdev</name> <operator>=</operator> <name>nextdev</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>nextdev</name> <operator>=</operator> <name><name>curdev</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>




<for>for <control>(<init><expr><name>curaddr</name> <operator>=</operator> <name><name>curdev</name><operator>-&gt;</operator><name>addresses</name></name></expr>;</init> <condition><expr><name>curaddr</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>curaddr</name> <operator>=</operator> <name>nextaddr</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>nextaddr</name> <operator>=</operator> <name><name>curaddr</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>curaddr</name><operator>-&gt;</operator><name>addr</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>curaddr</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>curaddr</name><operator>-&gt;</operator><name>netmask</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>curaddr</name><operator>-&gt;</operator><name>netmask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>curaddr</name><operator>-&gt;</operator><name>broadaddr</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>curaddr</name><operator>-&gt;</operator><name>broadaddr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>curaddr</name><operator>-&gt;</operator><name>dstaddr</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>curaddr</name><operator>-&gt;</operator><name>dstaddr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>curaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>




<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>curdev</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<if_stmt><if>if <condition>(<expr><name><name>curdev</name><operator>-&gt;</operator><name>description</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>curdev</name><operator>-&gt;</operator><name>description</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>




<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>curdev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>












<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_PACKET32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MSDOS</name></expr></argument>)</argument_list></call></expr></cpp:if>





<function><type><name>char</name> <modifier>*</modifier></type>
<name>pcap_lookupdev</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>errbuf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>pcap_if_t</name> <modifier>*</modifier></type><name>alldevs</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IF_NAMESIZE</name></cpp:macro> <cpp:value>8192</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>






<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>IF_NAMESIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IF_NAMESIZE</name></cpp:macro> <cpp:value>IFNAMSIZ</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>device</name><index>[<expr><name>IF_NAMESIZE</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>pcap_findalldevs</name><argument_list>(<argument><expr><operator>&amp;</operator><name>alldevs</name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>alldevs</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>(</operator><name><name>alldevs</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PCAP_IF_LOOPBACK</name><operator>)</operator></expr>)</condition> <block>{<block_content>











<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>pcap_strlcpy</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><literal type="string">"no suitable device found"</literal></expr></argument>,
<argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>



<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>pcap_strlcpy</name><argument_list>(<argument><expr><name>device</name></expr></argument>, <argument><expr><name><name>alldevs</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>device</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>device</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>pcap_freealldevs</name><argument_list>(<argument><expr><name>alldevs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ret</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MSDOS</name></expr></argument>)</argument_list></call></expr></cpp:if>








<function><type><name>int</name></type>
<name>pcap_lookupnet</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>device</name></decl></parameter>, <parameter><decl><type><name>bpf_u_int32</name> <modifier>*</modifier></type><name>netp</name></decl></parameter>, <parameter><decl><type><name>bpf_u_int32</name> <modifier>*</modifier></type><name>maskp</name></decl></parameter>,
<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>errbuf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type> <name>fd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>register</specifier> <name><name>struct</name> <name>sockaddr_in</name></name> <modifier>*</modifier></type><name>sin4</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>ifreq</name></name></type> <name>ifr</name></decl>;</decl_stmt>






<if_stmt><if>if <condition>(<expr><operator>!</operator><name>device</name> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>device</name></expr></argument>, <argument><expr><literal type="string">"any"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DAG_API</name></expr></argument>)</argument_list></call></expr></cpp:if>
<operator>||</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>device</name></expr></argument>, <argument><expr><literal type="string">"dag"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SEPTEL_API</name></expr></argument>)</argument_list></call></expr></cpp:if>
<operator>||</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>device</name></expr></argument>, <argument><expr><literal type="string">"septel"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PCAP_SUPPORT_BT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<operator>||</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>device</name></expr></argument>, <argument><expr><literal type="string">"bluetooth"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PCAP_SUPPORT_USB</name></expr></argument>)</argument_list></call></expr></cpp:if>
<operator>||</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>device</name></expr></argument>, <argument><expr><literal type="string">"usbmon"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SNF_API</name></expr></argument>)</argument_list></call></expr></cpp:if>
<operator>||</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>device</name></expr></argument>, <argument><expr><literal type="string">"snf"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PCAP_SUPPORT_NETMAP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<operator>||</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name>device</name></expr></argument>, <argument><expr><literal type="string">"netmap:"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>
<operator>||</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name>device</name></expr></argument>, <argument><expr><literal type="string">"vale"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>netp</name> <operator>=</operator> <operator>*</operator><name>maskp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>socket</name><argument_list>(<argument><expr><name>AF_INET</name></expr></argument>, <argument><expr><name>SOCK_DGRAM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pcap_fmt_errmsg_for_errno</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><name>errno</name></expr></argument>, <argument><expr><literal type="string">"socket"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ifr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ifr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>linux</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr_stmt><expr><name><name>ifr</name><operator>.</operator><name>ifr_addr</name><operator>.</operator><name>sa_family</name></name> <operator>=</operator> <name>AF_INET</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>pcap_strlcpy</name><argument_list>(<argument><expr><name><name>ifr</name><operator>.</operator><name>ifr_name</name></name></expr></argument>, <argument><expr><name>device</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>ifr</name><operator>.</operator><name>ifr_name</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ioctl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>SIOCGIFADDR</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>ifr</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EADDRNOTAVAIL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"%s: no IPv4 address assigned"</literal></expr></argument>, <argument><expr><name>device</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>pcap_fmt_errmsg_for_errno</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><name>errno</name></expr></argument>, <argument><expr><literal type="string">"SIOCGIFADDR: %s"</literal></expr></argument>, <argument><expr><name>device</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>sin4</name> <operator>=</operator> <operator>(</operator>struct <name>sockaddr_in</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>ifr</name><operator>.</operator><name>ifr_addr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>netp</name> <operator>=</operator> <name><name>sin4</name><operator>-&gt;</operator><name>sin_addr</name><operator>.</operator><name>s_addr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ifr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ifr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>linux</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr_stmt><expr><name><name>ifr</name><operator>.</operator><name>ifr_addr</name><operator>.</operator><name>sa_family</name></name> <operator>=</operator> <name>AF_INET</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>pcap_strlcpy</name><argument_list>(<argument><expr><name><name>ifr</name><operator>.</operator><name>ifr_name</name></name></expr></argument>, <argument><expr><name>device</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>ifr</name><operator>.</operator><name>ifr_name</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ioctl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>SIOCGIFNETMASK</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>ifr</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pcap_fmt_errmsg_for_errno</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><name>errno</name></expr></argument>, <argument><expr><literal type="string">"SIOCGIFNETMASK: %s"</literal></expr></argument>, <argument><expr><name>device</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>maskp</name> <operator>=</operator> <name><name>sin4</name><operator>-&gt;</operator><name>sin_addr</name><operator>.</operator><name>s_addr</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>maskp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>IN_CLASSA</name><argument_list>(<argument><expr><operator>*</operator><name>netp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>maskp</name> <operator>=</operator> <name>IN_CLASSA_NET</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>IN_CLASSB</name><argument_list>(<argument><expr><operator>*</operator><name>netp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>maskp</name> <operator>=</operator> <name>IN_CLASSB_NET</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>IN_CLASSC</name><argument_list>(<argument><expr><operator>*</operator><name>netp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>maskp</name> <operator>=</operator> <name>IN_CLASSC_NET</name></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"inet class for 0x%x unknown"</literal></expr></argument>, <argument><expr><operator>*</operator><name>netp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>netp</name> <operator>&amp;=</operator> <operator>*</operator><name>maskp</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_REMOTE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pcap-rpcap.h"</cpp:file></cpp:include>




<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_substring</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>ebuf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>token</name></decl>;</decl_stmt>

<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>token</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pcap_fmt_errmsg_for_errno</name><argument_list>(<argument><expr><name>ebuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><name>errno</name></expr></argument>, <argument><expr><literal type="string">"malloc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>token</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>token</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>




































<function><type><specifier>static</specifier> <name>int</name></type>
<name>pcap_parse_source</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>source</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>schemep</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>userinfop</name></decl></parameter>,
<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>hostp</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>portp</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pathp</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>ebuf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>colonp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>scheme_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>scheme</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>endp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>authority_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>authority</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>parsep</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>atsignp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>bracketp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>userinfo</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>host</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>port</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>




<expr_stmt><expr><operator>*</operator><name>schemep</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>userinfop</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>hostp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>portp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>pathp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>





















<expr_stmt><expr><name>colonp</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>colonp</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>





<expr_stmt><expr><operator>*</operator><name>pathp</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>pathp</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pcap_fmt_errmsg_for_errno</name><argument_list>(<argument><expr><name>ebuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><name>errno</name></expr></argument>, <argument><expr><literal type="string">"malloc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>











<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>colonp</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"//"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>





<expr_stmt><expr><operator>*</operator><name>pathp</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>pathp</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pcap_fmt_errmsg_for_errno</name><argument_list>(<argument><expr><name>ebuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><name>errno</name></expr></argument>, <argument><expr><literal type="string">"malloc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>









<expr_stmt><expr><name>scheme_len</name> <operator>=</operator> <name>colonp</name> <operator>-</operator> <name>source</name></expr>;</expr_stmt>
<expr_stmt><expr><name>scheme</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>scheme_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>scheme</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pcap_fmt_errmsg_for_errno</name><argument_list>(<argument><expr><name>ebuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><name>errno</name></expr></argument>, <argument><expr><literal type="string">"malloc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>scheme</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>scheme_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>scheme</name><index>[<expr><name>scheme_len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>





<if_stmt><if>if <condition>(<expr><call><name>pcap_strcasecmp</name><argument_list>(<argument><expr><name>scheme</name></expr></argument>, <argument><expr><literal type="string">"file"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>pathp</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>colonp</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>pathp</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pcap_fmt_errmsg_for_errno</name><argument_list>(<argument><expr><name>ebuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><name>errno</name></expr></argument>, <argument><expr><literal type="string">"malloc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>scheme</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>schemep</name> <operator>=</operator> <name>scheme</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>









<if_stmt><if>if <condition>(<expr><call><name>pcap_strcasecmp</name><argument_list>(<argument><expr><name>scheme</name></expr></argument>, <argument><expr><literal type="string">"rpcap"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<call><name>strchr</name><argument_list>(<argument><expr><name>colonp</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>






<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>scheme</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>pathp</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>colonp</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>pathp</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pcap_fmt_errmsg_for_errno</name><argument_list>(<argument><expr><name>ebuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><name>errno</name></expr></argument>, <argument><expr><literal type="string">"malloc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>






<expr_stmt><expr><name>authority_len</name> <operator>=</operator> <call><name>strcspn</name><argument_list>(<argument><expr><name>colonp</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"/"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>authority</name> <operator>=</operator> <call><name>get_substring</name><argument_list>(<argument><expr><name>colonp</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><name>authority_len</name></expr></argument>, <argument><expr><name>ebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>authority</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>scheme</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>endp</name> <operator>=</operator> <name>colonp</name> <operator>+</operator> <literal type="number">3</literal> <operator>+</operator> <name>authority_len</name></expr>;</expr_stmt>




<expr_stmt><expr><name>parsep</name> <operator>=</operator> <name>authority</name></expr>;</expr_stmt>




<expr_stmt><expr><name>atsignp</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>parsep</name></expr></argument>, <argument><expr><literal type="char">'@'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>atsignp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>



<decl_stmt><decl><type><name>size_t</name></type> <name>userinfo_len</name></decl>;</decl_stmt>

<expr_stmt><expr><name>userinfo_len</name> <operator>=</operator> <name>atsignp</name> <operator>-</operator> <name>parsep</name></expr>;</expr_stmt>
<expr_stmt><expr><name>userinfo</name> <operator>=</operator> <call><name>get_substring</name><argument_list>(<argument><expr><name>parsep</name></expr></argument>, <argument><expr><name>userinfo_len</name></expr></argument>, <argument><expr><name>ebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>userinfo</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>authority</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>scheme</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>parsep</name> <operator>=</operator> <name>atsignp</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>



<expr_stmt><expr><name>userinfo</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>




<if_stmt><if>if <condition>(<expr><operator>*</operator><name>parsep</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><name>host</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>port</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>



<decl_stmt><decl><type><name>size_t</name></type> <name>host_len</name></decl>;</decl_stmt>




<if_stmt><if>if <condition>(<expr><operator>*</operator><name>parsep</name> <operator>==</operator> <literal type="char">'['</literal></expr>)</condition> <block>{<block_content>












<expr_stmt><expr><name>bracketp</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>parsep</name></expr></argument>, <argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bracketp</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name>ebuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"IP-literal in URL doesn't end with ]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>userinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>authority</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>scheme</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><name>bracketp</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator>
<operator>*</operator><operator>(</operator><name>bracketp</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>!=</operator> <literal type="char">':'</literal></expr>)</condition> <block>{<block_content>




<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name>ebuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"Extra text after IP-literal in URL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>userinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>authority</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>scheme</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>host_len</name> <operator>=</operator> <operator>(</operator><name>bracketp</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>-</operator> <name>parsep</name></expr>;</expr_stmt>
<expr_stmt><expr><name>host</name> <operator>=</operator> <call><name>get_substring</name><argument_list>(<argument><expr><name>parsep</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>host_len</name></expr></argument>, <argument><expr><name>ebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>host</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>userinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>authority</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>scheme</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>parsep</name> <operator>=</operator> <name>bracketp</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>





<expr_stmt><expr><name>host_len</name> <operator>=</operator> <call><name>strcspn</name><argument_list>(<argument><expr><name>parsep</name></expr></argument>, <argument><expr><literal type="string">":"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>host</name> <operator>=</operator> <call><name>get_substring</name><argument_list>(<argument><expr><name>parsep</name></expr></argument>, <argument><expr><name>host_len</name></expr></argument>, <argument><expr><name>ebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>host</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>userinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>authority</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>scheme</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>parsep</name> <operator>=</operator> <name>parsep</name> <operator>+</operator> <name>host_len</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>




<if_stmt><if>if <condition>(<expr><operator>*</operator><name>parsep</name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition> <block>{<block_content>



<decl_stmt><decl><type><name>size_t</name></type> <name>port_len</name></decl>;</decl_stmt>

<expr_stmt><expr><name>parsep</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>port_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>parsep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>port</name> <operator>=</operator> <call><name>get_substring</name><argument_list>(<argument><expr><name>parsep</name></expr></argument>, <argument><expr><name>port_len</name></expr></argument>, <argument><expr><name>ebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>port</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>host</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>userinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>authority</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>scheme</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>



<expr_stmt><expr><name>port</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>authority</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<if_stmt><if>if <condition>(<expr><operator>*</operator><name>endp</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>endp</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>path</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pcap_fmt_errmsg_for_errno</name><argument_list>(<argument><expr><name>ebuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><name>errno</name></expr></argument>, <argument><expr><literal type="string">"malloc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>host</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>userinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>scheme</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>schemep</name> <operator>=</operator> <name>scheme</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>userinfop</name> <operator>=</operator> <name>userinfo</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>hostp</name> <operator>=</operator> <name>host</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>portp</name> <operator>=</operator> <name>port</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>pathp</name> <operator>=</operator> <name>path</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pcap_createsrcstr</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>source</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>host</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>port</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>errbuf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>PCAP_SRC_FILE</name></expr>:</case>
<expr_stmt><expr><call><name>pcap_strlcpy</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>PCAP_SRC_FILE_STRING</name></expr></argument>, <argument><expr><name>PCAP_BUF_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>name</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>name</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pcap_strlcat</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>PCAP_BUF_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"The file name cannot be NULL."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></else></if_stmt>

<case>case <expr><name>PCAP_SRC_IFREMOTE</name></expr>:</case>
<expr_stmt><expr><call><name>pcap_strlcpy</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>PCAP_SRC_IF_STRING</name></expr></argument>, <argument><expr><name>PCAP_BUF_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>host</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>host</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>host</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>





<expr_stmt><expr><call><name>pcap_strlcat</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><literal type="string">"["</literal></expr></argument>, <argument><expr><name>PCAP_BUF_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pcap_strlcat</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>host</name></expr></argument>, <argument><expr><name>PCAP_BUF_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pcap_strlcat</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><literal type="string">"]"</literal></expr></argument>, <argument><expr><name>PCAP_BUF_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>pcap_strlcat</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>host</name></expr></argument>, <argument><expr><name>PCAP_BUF_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>port</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>port</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pcap_strlcat</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><literal type="string">":"</literal></expr></argument>, <argument><expr><name>PCAP_BUF_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pcap_strlcat</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><name>PCAP_BUF_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>pcap_strlcat</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><literal type="string">"/"</literal></expr></argument>, <argument><expr><name>PCAP_BUF_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"The host name cannot be NULL."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>name</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>name</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>pcap_strlcat</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>PCAP_BUF_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>

<case>case <expr><name>PCAP_SRC_IFLOCAL</name></expr>:</case>
<expr_stmt><expr><call><name>pcap_strlcpy</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>PCAP_SRC_IF_STRING</name></expr></argument>, <argument><expr><name>PCAP_BUF_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>name</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>name</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>pcap_strlcat</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>PCAP_BUF_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>

<default>default:</default>
<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"The interface type is not valid."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pcap_parsesrcstr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>source</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>host</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>port</name></decl></parameter>,
<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>errbuf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>scheme</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tmpuserinfo</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tmphost</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tmpport</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tmppath</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name>host</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>host</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>port</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>port</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>name</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>pcap_parse_source</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scheme</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmpuserinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmphost</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>tmpport</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmppath</name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>



<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>scheme</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>



<if_stmt><if>if <condition>(<expr><name>name</name> <operator>&amp;&amp;</operator> <name>tmppath</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>pcap_strlcpy</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>tmppath</name></expr></argument>, <argument><expr><name>PCAP_BUF_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>type</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>type</name> <operator>=</operator> <name>PCAP_SRC_IFLOCAL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tmppath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tmpport</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tmphost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tmpuserinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>scheme</name></expr></argument>, <argument><expr><literal type="string">"rpcap"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>






<if_stmt><if>if <condition>(<expr><name>host</name> <operator>&amp;&amp;</operator> <name>tmphost</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>tmpuserinfo</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name>host</name></expr></argument>, <argument><expr><name>PCAP_BUF_SIZE</name></expr></argument>, <argument><expr><literal type="string">"%s@%s"</literal></expr></argument>,
<argument><expr><name>tmpuserinfo</name></expr></argument>, <argument><expr><name>tmphost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>pcap_strlcpy</name><argument_list>(<argument><expr><name>host</name></expr></argument>, <argument><expr><name>tmphost</name></expr></argument>, <argument><expr><name>PCAP_BUF_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>port</name> <operator>&amp;&amp;</operator> <name>tmpport</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>pcap_strlcpy</name><argument_list>(<argument><expr><name>port</name></expr></argument>, <argument><expr><name>tmpport</name></expr></argument>, <argument><expr><name>PCAP_BUF_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>name</name> <operator>&amp;&amp;</operator> <name>tmppath</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>pcap_strlcpy</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>tmppath</name></expr></argument>, <argument><expr><name>PCAP_BUF_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>type</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>type</name> <operator>=</operator> <name>PCAP_SRC_IFREMOTE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tmppath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tmpport</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tmphost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tmpuserinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>scheme</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>scheme</name></expr></argument>, <argument><expr><literal type="string">"file"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>



<if_stmt><if>if <condition>(<expr><name>name</name> <operator>&amp;&amp;</operator> <name>tmppath</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>pcap_strlcpy</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>tmppath</name></expr></argument>, <argument><expr><name>PCAP_BUF_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>type</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>type</name> <operator>=</operator> <name>PCAP_SRC_FILE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tmppath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tmpport</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tmphost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tmpuserinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>scheme</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>





<if_stmt><if>if <condition>(<expr><name>name</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>pcap_strlcpy</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>PCAP_BUF_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>type</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>type</name> <operator>=</operator> <name>PCAP_SRC_IFLOCAL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tmppath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tmpport</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tmphost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tmpuserinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>scheme</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>pcap_t</name> <modifier>*</modifier></type>
<name>pcap_create</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>device</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>errbuf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>is_theirs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>device_str</name></decl>;</decl_stmt>








<if_stmt><if>if <condition>(<expr><name>device</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>device_str</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><literal type="string">"any"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
























<if_stmt><if>if <condition>(<expr><name><name>device</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <name><name>device</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>length</name></decl>;</decl_stmt>

<expr_stmt><expr><name>length</name> <operator>=</operator> <call><name>wcslen</name><argument_list>(<argument><expr><operator>(</operator><name>wchar_t</name> <operator>*</operator><operator>)</operator><name>device</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>device_str</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><name>length</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>device_str</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pcap_fmt_errmsg_for_errno</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>,
<argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>,
<argument><expr><literal type="string">"malloc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name>device_str</name></expr></argument>, <argument><expr><name>length</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"%ws"</literal></expr></argument>,
<argument><expr><operator>(</operator><specifier>const</specifier> <name>wchar_t</name> <operator>*</operator><operator>)</operator><name>device</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>device_str</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>device</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>device_str</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pcap_fmt_errmsg_for_errno</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><name>errno</name></expr></argument>, <argument><expr><literal type="string">"malloc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>






<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>capture_source_types</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>create_op</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>is_theirs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>capture_source_types</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>create_op</name><argument_list>(<argument><expr><name>device_str</name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>is_theirs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>is_theirs</name></expr>)</condition> <block>{<block_content>









<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>device_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>device</name></name> <operator>=</operator> <name>device_str</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>p</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>




<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>pcap_create_interface</name><argument_list>(<argument><expr><name>device_str</name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>device_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>device</name></name> <operator>=</operator> <name>device_str</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>p</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>int</name></type>
<name>pcap_setnonblock_unactivated</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nonblock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>nonblock</name></name> <operator>=</operator> <name>nonblock</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>initialize_ops</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>





<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>read_op</name></name> <operator>=</operator> <name>pcap_read_not_initialized</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>inject_op</name></name> <operator>=</operator> <name>pcap_inject_not_initialized</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>setfilter_op</name></name> <operator>=</operator> <name>pcap_setfilter_not_initialized</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>setdirection_op</name></name> <operator>=</operator> <name>pcap_setdirection_not_initialized</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>set_datalink_op</name></name> <operator>=</operator> <name>pcap_set_datalink_not_initialized</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>getnonblock_op</name></name> <operator>=</operator> <name>pcap_getnonblock_not_initialized</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>stats_op</name></name> <operator>=</operator> <name>pcap_stats_not_initialized</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>stats_ex_op</name></name> <operator>=</operator> <name>pcap_stats_ex_not_initialized</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>setbuff_op</name></name> <operator>=</operator> <name>pcap_setbuff_not_initialized</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>setmode_op</name></name> <operator>=</operator> <name>pcap_setmode_not_initialized</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>setmintocopy_op</name></name> <operator>=</operator> <name>pcap_setmintocopy_not_initialized</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>getevent_op</name></name> <operator>=</operator> <name>pcap_getevent_not_initialized</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>oid_get_request_op</name></name> <operator>=</operator> <name>pcap_oid_get_request_not_initialized</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>oid_set_request_op</name></name> <operator>=</operator> <name>pcap_oid_set_request_not_initialized</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>sendqueue_transmit_op</name></name> <operator>=</operator> <name>pcap_sendqueue_transmit_not_initialized</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>setuserbuffer_op</name></name> <operator>=</operator> <name>pcap_setuserbuffer_not_initialized</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>live_dump_op</name></name> <operator>=</operator> <name>pcap_live_dump_not_initialized</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>live_dump_ended_op</name></name> <operator>=</operator> <name>pcap_live_dump_ended_not_initialized</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>get_airpcap_handle_op</name></name> <operator>=</operator> <name>pcap_get_airpcap_handle_not_initialized</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>






<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cleanup_op</name></name> <operator>=</operator> <name>pcap_cleanup_live_common</name></expr>;</expr_stmt>





<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>oneshot_callback</name></name> <operator>=</operator> <name>pcap_oneshot</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>pcap_t</name> <modifier>*</modifier></type>
<name>pcap_alloc_pcap_t</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>ebuf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>chunk</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>















<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCAP_T_ALIGNED_SIZE</name></cpp:macro> <cpp:value>((sizeof(pcap_t) + 7U) &amp; ~0x7U)</cpp:value></cpp:define>
<expr_stmt><expr><name>chunk</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>PCAP_T_ALIGNED_SIZE</name> <operator>+</operator> <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>chunk</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pcap_fmt_errmsg_for_errno</name><argument_list>(<argument><expr><name>ebuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><name>errno</name></expr></argument>, <argument><expr><literal type="string">"malloc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>PCAP_T_ALIGNED_SIZE</name> <operator>+</operator> <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>pcap_t</name> <operator>*</operator><operator>)</operator><name>chunk</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>handle</name></name> <operator>=</operator> <name>INVALID_HANDLE_VALUE</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>fd</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MSDOS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>selectable_fd</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>required_select_timeout</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>priv</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>




<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>priv</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>chunk</name> <operator>+</operator> <name>PCAP_T_ALIGNED_SIZE</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><operator>(</operator><name>p</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>pcap_t</name> <modifier>*</modifier></type>
<name>pcap_create_common</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>ebuf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>pcap_alloc_pcap_t</name><argument_list>(<argument><expr><name>ebuf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>







<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>can_set_rfmon_op</name></name> <operator>=</operator> <name>pcap_cant_set_rfmon</name></expr>;</expr_stmt>






<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>setnonblock_op</name></name> <operator>=</operator> <name>pcap_setnonblock_unactivated</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>initialize_ops</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>snapshot</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>timeout</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>buffer_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>promisc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>rfmon</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>immediate</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>tstamp_type</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>tstamp_precision</name></name> <operator>=</operator> <name>PCAP_TSTAMP_PRECISION_MICRO</name></expr>;</expr_stmt>



<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__linux__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>protocol</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>nocapture_local</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>




<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bpf_codegen_flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>p</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pcap_check_activated</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>activated</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>, <argument><expr><literal type="string">"can't perform "</literal>
<literal type="string">" operation on activated capture"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pcap_set_snaplen</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>snaplen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>pcap_check_activated</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>PCAP_ERROR_ACTIVATED</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>snapshot</name></name> <operator>=</operator> <name>snaplen</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pcap_set_promisc</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>promisc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>pcap_check_activated</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>PCAP_ERROR_ACTIVATED</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>promisc</name></name> <operator>=</operator> <name>promisc</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pcap_set_rfmon</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rfmon</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>pcap_check_activated</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>PCAP_ERROR_ACTIVATED</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>rfmon</name></name> <operator>=</operator> <name>rfmon</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pcap_set_timeout</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>timeout_ms</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>pcap_check_activated</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>PCAP_ERROR_ACTIVATED</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>timeout</name></name> <operator>=</operator> <name>timeout_ms</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pcap_set_tstamp_type</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tstamp_type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>pcap_check_activated</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>PCAP_ERROR_ACTIVATED</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>





<if_stmt><if>if <condition>(<expr><name>tstamp_type</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>PCAP_WARNING_TSTAMP_TYPE_NOTSUP</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>





<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>tstamp_type_count</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>tstamp_type</name> <operator>==</operator> <name>PCAP_TSTAMP_HOST</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>tstamp_type</name></name> <operator>=</operator> <name>tstamp_type</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>



<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>p</name><operator>-&gt;</operator><name>tstamp_type_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>tstamp_type_list</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <operator>(</operator><name>u_int</name><operator>)</operator><name>tstamp_type</name></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>tstamp_type</name></name> <operator>=</operator> <name>tstamp_type</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>




<return>return <expr><operator>(</operator><name>PCAP_WARNING_TSTAMP_TYPE_NOTSUP</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pcap_set_immediate_mode</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>immediate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>pcap_check_activated</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>PCAP_ERROR_ACTIVATED</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>immediate</name></name> <operator>=</operator> <name>immediate</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pcap_set_buffer_size</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>buffer_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>pcap_check_activated</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>PCAP_ERROR_ACTIVATED</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>buffer_size</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>



<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>buffer_size</name></name> <operator>=</operator> <name>buffer_size</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pcap_set_tstamp_precision</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tstamp_precision</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>pcap_check_activated</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>PCAP_ERROR_ACTIVATED</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>





<if_stmt><if>if <condition>(<expr><name>tstamp_precision</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>PCAP_ERROR_TSTAMP_PRECISION_NOTSUP</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>








<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>tstamp_precision_count</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>tstamp_precision</name> <operator>==</operator> <name>PCAP_TSTAMP_PRECISION_MICRO</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>tstamp_precision</name></name> <operator>=</operator> <name>tstamp_precision</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>




<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>p</name><operator>-&gt;</operator><name>tstamp_precision_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>tstamp_precision_list</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <operator>(</operator><name>u_int</name><operator>)</operator><name>tstamp_precision</name></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>tstamp_precision</name></name> <operator>=</operator> <name>tstamp_precision</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>




<return>return <expr><operator>(</operator><name>PCAP_ERROR_TSTAMP_PRECISION_NOTSUP</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pcap_get_tstamp_precision</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>tstamp_precision</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pcap_activate</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>








<if_stmt><if>if <condition>(<expr><call><name>pcap_check_activated</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>PCAP_ERROR_ACTIVATED</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name><name>p</name><operator>-&gt;</operator><name>activate_op</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>status</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>




<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>nonblock</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name><name>p</name><operator>-&gt;</operator><name>setnonblock_op</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>status</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>




<expr_stmt><expr><call><name><name>p</name><operator>-&gt;</operator><name>cleanup_op</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>initialize_ops</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>status</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>activated</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>






<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>,
<argument><expr><call><name>pcap_statustostr</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>





<expr_stmt><expr><call><name>initialize_ops</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><operator>(</operator><name>status</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>pcap_t</name> <modifier>*</modifier></type>
<name>pcap_open_live</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>device</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>snaplen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>promisc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>to_ms</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>errbuf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_REMOTE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>char</name></type> <name><name>host</name><index>[<expr><name>PCAP_BUF_SIZE</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>port</name><index>[<expr><name>PCAP_BUF_SIZE</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>name</name><index>[<expr><name>PCAP_BUF_SIZE</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>srctype</name></decl>;</decl_stmt>








<if_stmt><if>if <condition>(<expr><name>device</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>device</name> <operator>=</operator> <literal type="string">"any"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>










<if_stmt><if>if <condition>(<expr><call><name>pcap_parsesrcstr</name><argument_list>(<argument><expr><name>device</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>srctype</name></expr></argument>, <argument><expr><name>host</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>srctype</name> <operator>==</operator> <name>PCAP_SRC_IFREMOTE</name></expr>)</condition> <block>{<block_content>






<return>return <expr><operator>(</operator><call><name>pcap_open_rpcap</name><argument_list>(<argument><expr><name>device</name></expr></argument>, <argument><expr><name>snaplen</name></expr></argument>,
<argument><expr><ternary><condition><expr><name>promisc</name></expr> ?</condition><then> <expr><name>PCAP_OPENFLAG_PROMISCUOUS</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>, <argument><expr><name>to_ms</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>srctype</name> <operator>==</operator> <name>PCAP_SRC_FILE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>, <argument><expr><literal type="string">"unknown URL scheme \"file\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>srctype</name> <operator>==</operator> <name>PCAP_SRC_IFLOCAL</name></expr>)</condition> <block>{<block_content>





<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>device</name></expr></argument>, <argument><expr><name>PCAP_SRC_IF_STRING</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>PCAP_SRC_IF_STRING</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>device</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>PCAP_SRC_IF_STRING</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>device</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>PCAP_SRC_IF_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>pcap_create</name><argument_list>(<argument><expr><name>device</name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>pcap_set_snaplen</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>snaplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>status</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>pcap_set_promisc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>promisc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>status</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>pcap_set_timeout</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>to_ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>status</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>










<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>oldstyle</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>pcap_activate</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>status</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><name>p</name><operator>)</operator></expr>;</return>
<label><name>fail</name>:</label>
<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>PCAP_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>, <argument><expr><literal type="string">"%s: %.*s"</literal></expr></argument>, <argument><expr><name>device</name></expr></argument>,
<argument><expr><name>PCAP_ERRBUF_SIZE</name> <operator>-</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>status</name> <operator>==</operator> <name>PCAP_ERROR_NO_SUCH_DEVICE</name> <operator>||</operator>
<name>status</name> <operator>==</operator> <name>PCAP_ERROR_PERM_DENIED</name> <operator>||</operator>
<name>status</name> <operator>==</operator> <name>PCAP_ERROR_PROMISC_PERM_DENIED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>, <argument><expr><literal type="string">"%s: %s (%.*s)"</literal></expr></argument>, <argument><expr><name>device</name></expr></argument>,
<argument><expr><call><name>pcap_statustostr</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name> <operator>-</operator> <literal type="number">6</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>, <argument><expr><literal type="string">"%s: %s"</literal></expr></argument>, <argument><expr><name>device</name></expr></argument>,
<argument><expr><call><name>pcap_statustostr</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>pcap_close</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>pcap_t</name> <modifier>*</modifier></type>
<name>pcap_open_offline_common</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>ebuf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>pcap_alloc_pcap_t</name><argument_list>(<argument><expr><name>ebuf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>tstamp_precision</name></name> <operator>=</operator> <name>PCAP_TSTAMP_PRECISION_MICRO</name></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>p</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pcap_dispatch</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cnt</name></decl></parameter>, <parameter><decl><type><name>pcap_handler</name></type> <name>callback</name></decl></parameter>, <parameter><decl><type><name>u_char</name> <modifier>*</modifier></type><name>user</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><call><name><name>p</name><operator>-&gt;</operator><name>read_op</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>cnt</name></expr></argument>, <argument><expr><name>callback</name></expr></argument>, <argument><expr><name>user</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pcap_loop</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cnt</name></decl></parameter>, <parameter><decl><type><name>pcap_handler</name></type> <name>callback</name></decl></parameter>, <parameter><decl><type><name>u_char</name> <modifier>*</modifier></type><name>user</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type> <name>n</name></decl>;</decl_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>rfile</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>pcap_offline_read</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>cnt</name></expr></argument>, <argument><expr><name>callback</name></expr></argument>, <argument><expr><name>user</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>




<do>do <block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name><name>p</name><operator>-&gt;</operator><name>read_op</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>cnt</name></expr></argument>, <argument><expr><name>callback</name></expr></argument>, <argument><expr><name>user</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>;</do>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>n</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PACKET_COUNT_IS_UNLIMITED</name><argument_list>(<argument><expr><name>cnt</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cnt</name> <operator>-=</operator> <name>n</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cnt</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>




<function><type><name>void</name></type>
<name>pcap_breakloop</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>break_loop</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pcap_datalink</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>activated</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>PCAP_ERROR_NOT_ACTIVATED</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>linktype</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pcap_datalink_ext</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>activated</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>PCAP_ERROR_NOT_ACTIVATED</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>linktype_ext</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pcap_list_datalinks</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier><modifier>*</modifier></type><name>dlt_buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>activated</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>PCAP_ERROR_NOT_ACTIVATED</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>dlt_count</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>






<expr_stmt><expr><operator>*</operator><name>dlt_buffer</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><operator>*</operator><name>dlt_buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>dlt_buffer</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pcap_fmt_errmsg_for_errno</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><name>errno</name></expr></argument>, <argument><expr><literal type="string">"malloc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>PCAP_ERROR</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><operator>*</operator><name>dlt_buffer</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>linktype</name></name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>dlt_buffer</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><call><name>calloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><operator>*</operator><name>dlt_buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dlt_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>dlt_buffer</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pcap_fmt_errmsg_for_errno</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><name>errno</name></expr></argument>, <argument><expr><literal type="string">"malloc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>PCAP_ERROR</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>memcpy</name><argument_list>(<argument><expr><operator>*</operator><name>dlt_buffer</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>dlt_list</name></name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><operator>*</operator><name>dlt_buffer</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>p</name><operator>-&gt;</operator><name>dlt_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>dlt_count</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>












<function><type><name>void</name></type>
<name>pcap_free_datalinks</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>dlt_list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>dlt_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pcap_set_datalink</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dlt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dlt_name</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>dlt</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>unsupported</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>dlt_count</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>set_datalink_op</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>







<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>linktype</name></name> <operator>!=</operator> <name>dlt</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>unsupported</name>;</goto></block_content></block></if></if_stmt>




<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>p</name><operator>-&gt;</operator><name>dlt_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>dlt_list</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <operator>(</operator><name>u_int</name><operator>)</operator><name>dlt</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name><name>p</name><operator>-&gt;</operator><name>dlt_count</name></name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>unsupported</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>dlt_count</name></name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>dlt_list</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>DLT_EN10MB</name> <operator>&amp;&amp;</operator>
<name>dlt</name> <operator>==</operator> <name>DLT_DOCSIS</name></expr>)</condition> <block>{<block_content>











<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>linktype</name></name> <operator>=</operator> <name>dlt</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>p</name><operator>-&gt;</operator><name>set_datalink_op</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>dlt</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>linktype</name></name> <operator>=</operator> <name>dlt</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>

<label><name>unsupported</name>:</label>
<expr_stmt><expr><name>dlt_name</name> <operator>=</operator> <call><name>pcap_datalink_val_to_name</name><argument_list>(<argument><expr><name>dlt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>dlt_name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pcap_snprintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><literal type="string">"%s is not one of the DLTs supported by this device"</literal></expr></argument>,
<argument><expr><name>dlt_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pcap_snprintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><literal type="string">"DLT %d is not one of the DLTs supported by this device"</literal></expr></argument>,
<argument><expr><name>dlt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>






<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>u_char</name></type> <name><name>charmap</name><index>[]</index></name> <init>= <expr><block>{
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\000'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\001'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\002'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\003'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\004'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\005'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\006'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\007'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\010'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\011'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\012'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\013'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\014'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\015'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\016'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\017'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\020'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\021'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\022'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\023'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\024'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\025'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\026'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\027'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\030'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\031'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\032'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\033'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\034'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\035'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\036'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\037'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\040'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\041'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\042'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\043'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\044'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\045'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\046'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\047'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\050'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\051'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\052'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\053'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\054'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\055'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\056'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\057'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\060'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\061'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\062'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\063'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\064'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\065'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\066'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\067'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\070'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\071'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\072'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\073'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\074'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\075'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\076'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\077'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\100'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\141'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\142'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\143'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\144'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\145'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\146'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\147'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\150'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\151'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\152'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\153'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\154'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\155'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\156'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\157'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\160'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\161'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\162'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\163'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\164'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\165'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\166'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\167'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\170'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\171'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\172'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\133'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\134'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\135'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\136'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\137'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\140'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\141'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\142'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\143'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\144'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\145'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\146'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\147'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\150'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\151'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\152'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\153'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\154'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\155'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\156'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\157'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\160'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\161'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\162'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\163'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\164'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\165'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\166'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\167'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\170'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\171'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\172'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\173'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\174'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\175'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\176'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\177'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\200'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\201'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\202'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\203'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\204'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\205'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\206'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\207'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\210'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\211'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\212'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\213'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\214'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\215'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\216'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\217'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\220'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\221'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\222'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\223'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\224'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\225'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\226'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\227'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\230'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\231'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\232'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\233'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\234'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\235'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\236'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\237'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\240'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\241'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\242'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\243'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\244'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\245'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\246'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\247'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\250'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\251'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\252'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\253'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\254'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\255'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\256'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\257'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\260'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\261'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\262'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\263'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\264'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\265'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\266'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\267'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\270'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\271'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\272'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\273'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\274'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\275'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\276'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\277'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\300'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\341'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\342'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\343'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\344'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\345'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\346'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\347'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\350'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\351'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\352'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\353'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\354'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\355'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\356'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\357'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\360'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\361'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\362'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\363'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\364'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\365'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\366'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\367'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\370'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\371'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\372'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\333'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\334'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\335'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\336'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\337'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\340'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\341'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\342'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\343'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\344'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\345'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\346'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\347'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\350'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\351'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\352'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\353'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\354'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\355'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\356'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\357'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\360'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\361'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\362'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\363'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\364'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\365'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\366'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\367'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\370'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\371'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\372'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\373'</literal></expr>,
<expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\374'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\375'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\376'</literal></expr>, <expr><operator>(</operator><name>u_char</name><operator>)</operator><literal type="char">'\377'</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>int</name></type>
<name>pcap_strcasecmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>register</specifier> <specifier>const</specifier> <name>u_char</name> <modifier>*</modifier></type><name>cm</name> <init>= <expr><name>charmap</name></expr></init></decl>,
<decl><type ref="prev"><modifier>*</modifier></type><name>us1</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>u_char</name> <operator>*</operator><operator>)</operator><name>s1</name></expr></init></decl>,
<decl><type ref="prev"><modifier>*</modifier></type><name>us2</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>u_char</name> <operator>*</operator><operator>)</operator><name>s2</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name><name>cm</name><index>[<expr><operator>*</operator><name>us1</name></expr>]</index></name> <operator>==</operator> <name><name>cm</name><index>[<expr><operator>*</operator><name>us2</name><operator>++</operator></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>us1</name><operator>++</operator> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return<expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt></block_content></block></while>
<return>return <expr><operator>(</operator><name><name>cm</name><index>[<expr><operator>*</operator><name>us1</name></expr>]</index></name> <operator>-</operator> <name><name>cm</name><index>[<expr><operator>*</operator><operator>--</operator><name>us2</name></expr>]</index></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<struct>struct <name>dlt_choice</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>description</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>dlt</name></decl>;</decl_stmt>
}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DLT_CHOICE</name><parameter_list>(<parameter><type><name>code</name></type></parameter>, <parameter><type><name>description</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ #code, description, DLT_ ##code }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DLT_CHOICE_SENTINEL</name></cpp:macro> <cpp:value>{ NULL, NULL, 0 }</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>dlt_choice</name></name></type> <name><name>dlt_choices</name><index>[]</index></name> <init>= <expr><block>{
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"BSD loopback"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>EN10MB</name></expr></argument>, <argument><expr><literal type="string">"Ethernet"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>IEEE802</name></expr></argument>, <argument><expr><literal type="string">"Token ring"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>ARCNET</name></expr></argument>, <argument><expr><literal type="string">"BSD ARCNET"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>SLIP</name></expr></argument>, <argument><expr><literal type="string">"SLIP"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>PPP</name></expr></argument>, <argument><expr><literal type="string">"PPP"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>FDDI</name></expr></argument>, <argument><expr><literal type="string">"FDDI"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>ATM_RFC1483</name></expr></argument>, <argument><expr><literal type="string">"RFC 1483 LLC-encapsulated ATM"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>RAW</name></expr></argument>, <argument><expr><literal type="string">"Raw IP"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>SLIP_BSDOS</name></expr></argument>, <argument><expr><literal type="string">"BSD/OS SLIP"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>PPP_BSDOS</name></expr></argument>, <argument><expr><literal type="string">"BSD/OS PPP"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>ATM_CLIP</name></expr></argument>, <argument><expr><literal type="string">"Linux Classical IP-over-ATM"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>PPP_SERIAL</name></expr></argument>, <argument><expr><literal type="string">"PPP over serial"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>PPP_ETHER</name></expr></argument>, <argument><expr><literal type="string">"PPPoE"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>SYMANTEC_FIREWALL</name></expr></argument>, <argument><expr><literal type="string">"Symantec Firewall"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>C_HDLC</name></expr></argument>, <argument><expr><literal type="string">"Cisco HDLC"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>IEEE802_11</name></expr></argument>, <argument><expr><literal type="string">"802.11"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>FRELAY</name></expr></argument>, <argument><expr><literal type="string">"Frame Relay"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>LOOP</name></expr></argument>, <argument><expr><literal type="string">"OpenBSD loopback"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>ENC</name></expr></argument>, <argument><expr><literal type="string">"OpenBSD encapsulated IP"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>LINUX_SLL</name></expr></argument>, <argument><expr><literal type="string">"Linux cooked v1"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>LTALK</name></expr></argument>, <argument><expr><literal type="string">"Localtalk"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>PFLOG</name></expr></argument>, <argument><expr><literal type="string">"OpenBSD pflog file"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>PFSYNC</name></expr></argument>, <argument><expr><literal type="string">"Packet filter state syncing"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>PRISM_HEADER</name></expr></argument>, <argument><expr><literal type="string">"802.11 plus Prism header"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>IP_OVER_FC</name></expr></argument>, <argument><expr><literal type="string">"RFC 2625 IP-over-Fibre Channel"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>SUNATM</name></expr></argument>, <argument><expr><literal type="string">"Sun raw ATM"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>IEEE802_11_RADIO</name></expr></argument>, <argument><expr><literal type="string">"802.11 plus radiotap header"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>ARCNET_LINUX</name></expr></argument>, <argument><expr><literal type="string">"Linux ARCNET"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>JUNIPER_MLPPP</name></expr></argument>, <argument><expr><literal type="string">"Juniper Multi-Link PPP"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>JUNIPER_MLFR</name></expr></argument>, <argument><expr><literal type="string">"Juniper Multi-Link Frame Relay"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>JUNIPER_ES</name></expr></argument>, <argument><expr><literal type="string">"Juniper Encryption Services PIC"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>JUNIPER_GGSN</name></expr></argument>, <argument><expr><literal type="string">"Juniper GGSN PIC"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>JUNIPER_MFR</name></expr></argument>, <argument><expr><literal type="string">"Juniper FRF.16 Frame Relay"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>JUNIPER_ATM2</name></expr></argument>, <argument><expr><literal type="string">"Juniper ATM2 PIC"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>JUNIPER_SERVICES</name></expr></argument>, <argument><expr><literal type="string">"Juniper Advanced Services PIC"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>JUNIPER_ATM1</name></expr></argument>, <argument><expr><literal type="string">"Juniper ATM1 PIC"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>APPLE_IP_OVER_IEEE1394</name></expr></argument>, <argument><expr><literal type="string">"Apple IP-over-IEEE 1394"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>MTP2_WITH_PHDR</name></expr></argument>, <argument><expr><literal type="string">"SS7 MTP2 with Pseudo-header"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>MTP2</name></expr></argument>, <argument><expr><literal type="string">"SS7 MTP2"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>MTP3</name></expr></argument>, <argument><expr><literal type="string">"SS7 MTP3"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>SCCP</name></expr></argument>, <argument><expr><literal type="string">"SS7 SCCP"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>DOCSIS</name></expr></argument>, <argument><expr><literal type="string">"DOCSIS"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>LINUX_IRDA</name></expr></argument>, <argument><expr><literal type="string">"Linux IrDA"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>IEEE802_11_RADIO_AVS</name></expr></argument>, <argument><expr><literal type="string">"802.11 plus AVS radio information header"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>JUNIPER_MONITOR</name></expr></argument>, <argument><expr><literal type="string">"Juniper Passive Monitor PIC"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>BACNET_MS_TP</name></expr></argument>, <argument><expr><literal type="string">"BACnet MS/TP"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>PPP_PPPD</name></expr></argument>, <argument><expr><literal type="string">"PPP for pppd, with direction flag"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>JUNIPER_PPPOE</name></expr></argument>, <argument><expr><literal type="string">"Juniper PPPoE"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>JUNIPER_PPPOE_ATM</name></expr></argument>, <argument><expr><literal type="string">"Juniper PPPoE/ATM"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>GPRS_LLC</name></expr></argument>, <argument><expr><literal type="string">"GPRS LLC"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>GPF_T</name></expr></argument>, <argument><expr><literal type="string">"GPF-T"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>GPF_F</name></expr></argument>, <argument><expr><literal type="string">"GPF-F"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>JUNIPER_PIC_PEER</name></expr></argument>, <argument><expr><literal type="string">"Juniper PIC Peer"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>ERF_ETH</name></expr></argument>, <argument><expr><literal type="string">"Ethernet with Endace ERF header"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>ERF_POS</name></expr></argument>, <argument><expr><literal type="string">"Packet-over-SONET with Endace ERF header"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>LINUX_LAPD</name></expr></argument>, <argument><expr><literal type="string">"Linux vISDN LAPD"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>JUNIPER_ETHER</name></expr></argument>, <argument><expr><literal type="string">"Juniper Ethernet"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>JUNIPER_PPP</name></expr></argument>, <argument><expr><literal type="string">"Juniper PPP"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>JUNIPER_FRELAY</name></expr></argument>, <argument><expr><literal type="string">"Juniper Frame Relay"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>JUNIPER_CHDLC</name></expr></argument>, <argument><expr><literal type="string">"Juniper C-HDLC"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>MFR</name></expr></argument>, <argument><expr><literal type="string">"FRF.16 Frame Relay"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>JUNIPER_VP</name></expr></argument>, <argument><expr><literal type="string">"Juniper Voice PIC"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>A429</name></expr></argument>, <argument><expr><literal type="string">"Arinc 429"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>A653_ICM</name></expr></argument>, <argument><expr><literal type="string">"Arinc 653 Interpartition Communication"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>USB_FREEBSD</name></expr></argument>, <argument><expr><literal type="string">"USB with FreeBSD header"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>BLUETOOTH_HCI_H4</name></expr></argument>, <argument><expr><literal type="string">"Bluetooth HCI UART transport layer"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>IEEE802_16_MAC_CPS</name></expr></argument>, <argument><expr><literal type="string">"IEEE 802.16 MAC Common Part Sublayer"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>USB_LINUX</name></expr></argument>, <argument><expr><literal type="string">"USB with Linux header"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>CAN20B</name></expr></argument>, <argument><expr><literal type="string">"Controller Area Network (CAN) v. 2.0B"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>IEEE802_15_4_LINUX</name></expr></argument>, <argument><expr><literal type="string">"IEEE 802.15.4 with Linux padding"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>PPI</name></expr></argument>, <argument><expr><literal type="string">"Per-Packet Information"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>IEEE802_16_MAC_CPS_RADIO</name></expr></argument>, <argument><expr><literal type="string">"IEEE 802.16 MAC Common Part Sublayer plus radiotap header"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>JUNIPER_ISM</name></expr></argument>, <argument><expr><literal type="string">"Juniper Integrated Service Module"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>IEEE802_15_4</name></expr></argument>, <argument><expr><literal type="string">"IEEE 802.15.4 with FCS"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>SITA</name></expr></argument>, <argument><expr><literal type="string">"SITA pseudo-header"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>ERF</name></expr></argument>, <argument><expr><literal type="string">"Endace ERF header"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>RAIF1</name></expr></argument>, <argument><expr><literal type="string">"Ethernet with u10 Networks pseudo-header"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>IPMB_KONTRON</name></expr></argument>, <argument><expr><literal type="string">"IPMB with Kontron pseudo-header"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>JUNIPER_ST</name></expr></argument>, <argument><expr><literal type="string">"Juniper Secure Tunnel"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>BLUETOOTH_HCI_H4_WITH_PHDR</name></expr></argument>, <argument><expr><literal type="string">"Bluetooth HCI UART transport layer plus pseudo-header"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>AX25_KISS</name></expr></argument>, <argument><expr><literal type="string">"AX.25 with KISS header"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>IPMB_LINUX</name></expr></argument>, <argument><expr><literal type="string">"IPMB with Linux/Pigeon Point pseudo-header"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>IEEE802_15_4_NONASK_PHY</name></expr></argument>, <argument><expr><literal type="string">"IEEE 802.15.4 with non-ASK PHY data"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>MPLS</name></expr></argument>, <argument><expr><literal type="string">"MPLS with label as link-layer header"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>LINUX_EVDEV</name></expr></argument>, <argument><expr><literal type="string">"Linux evdev events"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>USB_LINUX_MMAPPED</name></expr></argument>, <argument><expr><literal type="string">"USB with padded Linux header"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>DECT</name></expr></argument>, <argument><expr><literal type="string">"DECT"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>AOS</name></expr></argument>, <argument><expr><literal type="string">"AOS Space Data Link protocol"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>WIHART</name></expr></argument>, <argument><expr><literal type="string">"Wireless HART"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>FC_2</name></expr></argument>, <argument><expr><literal type="string">"Fibre Channel FC-2"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>FC_2_WITH_FRAME_DELIMS</name></expr></argument>, <argument><expr><literal type="string">"Fibre Channel FC-2 with frame delimiters"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>IPNET</name></expr></argument>, <argument><expr><literal type="string">"Solaris ipnet"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>CAN_SOCKETCAN</name></expr></argument>, <argument><expr><literal type="string">"CAN-bus with SocketCAN headers"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>IPV4</name></expr></argument>, <argument><expr><literal type="string">"Raw IPv4"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>IPV6</name></expr></argument>, <argument><expr><literal type="string">"Raw IPv6"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>IEEE802_15_4_NOFCS</name></expr></argument>, <argument><expr><literal type="string">"IEEE 802.15.4 without FCS"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>DBUS</name></expr></argument>, <argument><expr><literal type="string">"D-Bus"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>JUNIPER_VS</name></expr></argument>, <argument><expr><literal type="string">"Juniper Virtual Server"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>JUNIPER_SRX_E2E</name></expr></argument>, <argument><expr><literal type="string">"Juniper SRX E2E"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>JUNIPER_FIBRECHANNEL</name></expr></argument>, <argument><expr><literal type="string">"Juniper Fibre Channel"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>DVB_CI</name></expr></argument>, <argument><expr><literal type="string">"DVB-CI"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>MUX27010</name></expr></argument>, <argument><expr><literal type="string">"MUX27010"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>STANAG_5066_D_PDU</name></expr></argument>, <argument><expr><literal type="string">"STANAG 5066 D_PDUs"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>JUNIPER_ATM_CEMIC</name></expr></argument>, <argument><expr><literal type="string">"Juniper ATM CEMIC"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>NFLOG</name></expr></argument>, <argument><expr><literal type="string">"Linux netfilter log messages"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>NETANALYZER</name></expr></argument>, <argument><expr><literal type="string">"Ethernet with Hilscher netANALYZER pseudo-header"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>NETANALYZER_TRANSPARENT</name></expr></argument>, <argument><expr><literal type="string">"Ethernet with Hilscher netANALYZER pseudo-header and with preamble and SFD"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>IPOIB</name></expr></argument>, <argument><expr><literal type="string">"RFC 4391 IP-over-Infiniband"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>MPEG_2_TS</name></expr></argument>, <argument><expr><literal type="string">"MPEG-2 transport stream"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>NG40</name></expr></argument>, <argument><expr><literal type="string">"ng40 protocol tester Iub/Iur"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>NFC_LLCP</name></expr></argument>, <argument><expr><literal type="string">"NFC LLCP PDUs with pseudo-header"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>INFINIBAND</name></expr></argument>, <argument><expr><literal type="string">"InfiniBand"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>SCTP</name></expr></argument>, <argument><expr><literal type="string">"SCTP"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>USBPCAP</name></expr></argument>, <argument><expr><literal type="string">"USB with USBPcap header"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>RTAC_SERIAL</name></expr></argument>, <argument><expr><literal type="string">"Schweitzer Engineering Laboratories RTAC packets"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>BLUETOOTH_LE_LL</name></expr></argument>, <argument><expr><literal type="string">"Bluetooth Low Energy air interface"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>NETLINK</name></expr></argument>, <argument><expr><literal type="string">"Linux netlink"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>BLUETOOTH_LINUX_MONITOR</name></expr></argument>, <argument><expr><literal type="string">"Bluetooth Linux Monitor"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>BLUETOOTH_BREDR_BB</name></expr></argument>, <argument><expr><literal type="string">"Bluetooth Basic Rate/Enhanced Data Rate baseband packets"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>BLUETOOTH_LE_LL_WITH_PHDR</name></expr></argument>, <argument><expr><literal type="string">"Bluetooth Low Energy air interface with pseudo-header"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>PROFIBUS_DL</name></expr></argument>, <argument><expr><literal type="string">"PROFIBUS data link layer"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>PKTAP</name></expr></argument>, <argument><expr><literal type="string">"Apple DLT_PKTAP"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>EPON</name></expr></argument>, <argument><expr><literal type="string">"Ethernet with 802.3 Clause 65 EPON preamble"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>IPMI_HPM_2</name></expr></argument>, <argument><expr><literal type="string">"IPMI trace packets"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>ZWAVE_R1_R2</name></expr></argument>, <argument><expr><literal type="string">"Z-Wave RF profile R1 and R2 packets"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>ZWAVE_R3</name></expr></argument>, <argument><expr><literal type="string">"Z-Wave RF profile R3 packets"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>WATTSTOPPER_DLM</name></expr></argument>, <argument><expr><literal type="string">"WattStopper Digital Lighting Management (DLM) and Legrand Nitoo Open protocol"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>ISO_14443</name></expr></argument>, <argument><expr><literal type="string">"ISO 14443 messages"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>RDS</name></expr></argument>, <argument><expr><literal type="string">"IEC 62106 Radio Data System groups"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>USB_DARWIN</name></expr></argument>, <argument><expr><literal type="string">"USB with Darwin header"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>OPENFLOW</name></expr></argument>, <argument><expr><literal type="string">"OpenBSD DLT_OPENFLOW"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>SDLC</name></expr></argument>, <argument><expr><literal type="string">"IBM SDLC frames"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>TI_LLN_SNIFFER</name></expr></argument>, <argument><expr><literal type="string">"TI LLN sniffer frames"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>VSOCK</name></expr></argument>, <argument><expr><literal type="string">"Linux vsock"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>NORDIC_BLE</name></expr></argument>, <argument><expr><literal type="string">"Nordic Semiconductor Bluetooth LE sniffer frames"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>DOCSIS31_XRA31</name></expr></argument>, <argument><expr><literal type="string">"Excentis XRA-31 DOCSIS 3.1 RF sniffer frames"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>ETHERNET_MPACKET</name></expr></argument>, <argument><expr><literal type="string">"802.3br mPackets"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>DISPLAYPORT_AUX</name></expr></argument>, <argument><expr><literal type="string">"DisplayPort AUX channel monitoring data"</literal></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DLT_CHOICE</name><argument_list>(<argument><expr><name>LINUX_SLL2</name></expr></argument>, <argument><expr><literal type="string">"Linux cooked v2"</literal></expr></argument>)</argument_list></call></expr>,
<expr><name>DLT_CHOICE_SENTINEL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>int</name></type>
<name>pcap_datalink_name_to_val</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>dlt_choices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>pcap_strcasecmp</name><argument_list>(<argument><expr><name><name>dlt_choices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name><name>dlt_choices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dlt</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>pcap_datalink_val_to_name</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>dlt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>dlt_choices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>dlt_choices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dlt</name> <operator>==</operator> <name>dlt</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name><name>dlt_choices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>pcap_datalink_val_to_description</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>dlt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>dlt_choices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>dlt_choices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dlt</name> <operator>==</operator> <name>dlt</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name><name>dlt_choices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>description</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>pcap_datalink_val_to_description_or_dlt</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>dlt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>unkbuf</name><index>[<expr><literal type="number">40</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>description</name></decl>;</decl_stmt>

<expr_stmt><expr><name>description</name> <operator>=</operator> <call><name>pcap_datalink_val_to_description</name><argument_list>(<argument><expr><name>dlt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>description</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>description</name></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name>unkbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>unkbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"DLT %u"</literal></expr></argument>, <argument><expr><name>dlt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>unkbuf</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<struct>struct <name>tstamp_type_choice</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>description</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>;</decl_stmt>
}</block>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>tstamp_type_choice</name></name></type> <name><name>tstamp_type_choices</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><literal type="string">"host"</literal></expr>, <expr><literal type="string">"Host"</literal></expr>, <expr><name>PCAP_TSTAMP_HOST</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"host_lowprec"</literal></expr>, <expr><literal type="string">"Host, low precision"</literal></expr>, <expr><name>PCAP_TSTAMP_HOST_LOWPREC</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"host_hiprec"</literal></expr>, <expr><literal type="string">"Host, high precision"</literal></expr>, <expr><name>PCAP_TSTAMP_HOST_HIPREC</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"adapter"</literal></expr>, <expr><literal type="string">"Adapter"</literal></expr>, <expr><name>PCAP_TSTAMP_ADAPTER</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"adapter_unsynced"</literal></expr>, <expr><literal type="string">"Adapter, not synced with system time"</literal></expr>, <expr><name>PCAP_TSTAMP_ADAPTER_UNSYNCED</name></expr> }</block></expr>,
<expr><block>{ <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>int</name></type>
<name>pcap_tstamp_type_name_to_val</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>tstamp_type_choices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>pcap_strcasecmp</name><argument_list>(<argument><expr><name><name>tstamp_type_choices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name><name>tstamp_type_choices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><operator>(</operator><name>PCAP_ERROR</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>pcap_tstamp_type_val_to_name</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>tstamp_type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>tstamp_type_choices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>tstamp_type_choices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>==</operator> <name>tstamp_type</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name><name>tstamp_type_choices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>pcap_tstamp_type_val_to_description</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>tstamp_type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>tstamp_type_choices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>tstamp_type_choices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>==</operator> <name>tstamp_type</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name><name>tstamp_type_choices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>description</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pcap_snapshot</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>activated</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>PCAP_ERROR_NOT_ACTIVATED</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>snapshot</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pcap_is_swapped</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>activated</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>PCAP_ERROR_NOT_ACTIVATED</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>swapped</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pcap_major_version</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>activated</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>PCAP_ERROR_NOT_ACTIVATED</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>version_major</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pcap_minor_version</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>activated</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>PCAP_ERROR_NOT_ACTIVATED</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>version_minor</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pcap_bufsize</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>activated</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>PCAP_ERROR_NOT_ACTIVATED</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>bufsize</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>FILE</name> <modifier>*</modifier></type>
<name>pcap_file</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>rfile</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pcap_fileno</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>fd</name></name><operator>)</operator></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>handle</name></name> <operator>!=</operator> <name>INVALID_HANDLE_VALUE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>DWORD</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>handle</name></name><operator>)</operator></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>PCAP_ERROR</name><operator>)</operator></expr>;</return></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MSDOS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>int</name></type>
<name>pcap_get_selectable_fd</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>selectable_fd</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>timeval</name></name> <modifier>*</modifier></type>
<name>pcap_get_required_select_timeout</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>required_select_timeout</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type>
<name>pcap_perror</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: %s\n"</literal></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>pcap_geterr</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pcap_getnonblock</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>errbuf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name><name>p</name><operator>-&gt;</operator><name>getnonblock_op</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>









<expr_stmt><expr><call><name>pcap_strlcpy</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name>ret</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>





<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MSDOS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>int</name></type>
<name>pcap_getnonblock_fd</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>fdflags</name></decl>;</decl_stmt>

<expr_stmt><expr><name>fdflags</name> <operator>=</operator> <call><name>fcntl</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>F_GETFL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fdflags</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pcap_fmt_errmsg_for_errno</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><name>errno</name></expr></argument>, <argument><expr><literal type="string">"F_GETFL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>fdflags</name> <operator>&amp;</operator> <name>O_NONBLOCK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>int</name></type>
<name>pcap_setnonblock</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nonblock</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>errbuf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name><name>p</name><operator>-&gt;</operator><name>setnonblock_op</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>nonblock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>









<expr_stmt><expr><call><name>pcap_strlcpy</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name>ret</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MSDOS</name></expr></argument>)</argument_list></call></expr></cpp:if>






<function><type><name>int</name></type>
<name>pcap_setnonblock_fd</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nonblock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>fdflags</name></decl>;</decl_stmt>

<expr_stmt><expr><name>fdflags</name> <operator>=</operator> <call><name>fcntl</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>F_GETFL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fdflags</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pcap_fmt_errmsg_for_errno</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><name>errno</name></expr></argument>, <argument><expr><literal type="string">"F_GETFL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>nonblock</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>fdflags</name> <operator>|=</operator> <name>O_NONBLOCK</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>fdflags</name> <operator>&amp;=</operator> <operator>~</operator><name>O_NONBLOCK</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>fcntl</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>F_SETFL</name></expr></argument>, <argument><expr><name>fdflags</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pcap_fmt_errmsg_for_errno</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><name>errno</name></expr></argument>, <argument><expr><literal type="string">"F_SETFL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>




<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>pcap_statustostr</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>errnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>ebuf</name><index>[<expr><literal type="number">15</literal><operator>+</operator><literal type="number">10</literal><operator>+</operator><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>errnum</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>PCAP_WARNING</name></expr>:</case>
<return>return<expr><operator>(</operator><literal type="string">"Generic warning"</literal><operator>)</operator></expr>;</return>

<case>case <expr><name>PCAP_WARNING_TSTAMP_TYPE_NOTSUP</name></expr>:</case>
<return>return <expr><operator>(</operator><literal type="string">"That type of time stamp is not supported by that device"</literal><operator>)</operator></expr>;</return>

<case>case <expr><name>PCAP_WARNING_PROMISC_NOTSUP</name></expr>:</case>
<return>return <expr><operator>(</operator><literal type="string">"That device doesn't support promiscuous mode"</literal><operator>)</operator></expr>;</return>

<case>case <expr><name>PCAP_ERROR</name></expr>:</case>
<return>return<expr><operator>(</operator><literal type="string">"Generic error"</literal><operator>)</operator></expr>;</return>

<case>case <expr><name>PCAP_ERROR_BREAK</name></expr>:</case>
<return>return<expr><operator>(</operator><literal type="string">"Loop terminated by pcap_breakloop"</literal><operator>)</operator></expr>;</return>

<case>case <expr><name>PCAP_ERROR_NOT_ACTIVATED</name></expr>:</case>
<return>return<expr><operator>(</operator><literal type="string">"The pcap_t has not been activated"</literal><operator>)</operator></expr>;</return>

<case>case <expr><name>PCAP_ERROR_ACTIVATED</name></expr>:</case>
<return>return <expr><operator>(</operator><literal type="string">"The setting can't be changed after the pcap_t is activated"</literal><operator>)</operator></expr>;</return>

<case>case <expr><name>PCAP_ERROR_NO_SUCH_DEVICE</name></expr>:</case>
<return>return <expr><operator>(</operator><literal type="string">"No such device exists"</literal><operator>)</operator></expr>;</return>

<case>case <expr><name>PCAP_ERROR_RFMON_NOTSUP</name></expr>:</case>
<return>return <expr><operator>(</operator><literal type="string">"That device doesn't support monitor mode"</literal><operator>)</operator></expr>;</return>

<case>case <expr><name>PCAP_ERROR_NOT_RFMON</name></expr>:</case>
<return>return <expr><operator>(</operator><literal type="string">"That operation is supported only in monitor mode"</literal><operator>)</operator></expr>;</return>

<case>case <expr><name>PCAP_ERROR_PERM_DENIED</name></expr>:</case>
<return>return <expr><operator>(</operator><literal type="string">"You don't have permission to capture on that device"</literal><operator>)</operator></expr>;</return>

<case>case <expr><name>PCAP_ERROR_IFACE_NOT_UP</name></expr>:</case>
<return>return <expr><operator>(</operator><literal type="string">"That device is not up"</literal><operator>)</operator></expr>;</return>

<case>case <expr><name>PCAP_ERROR_CANTSET_TSTAMP_TYPE</name></expr>:</case>
<return>return <expr><operator>(</operator><literal type="string">"That device doesn't support setting the time stamp type"</literal><operator>)</operator></expr>;</return>

<case>case <expr><name>PCAP_ERROR_PROMISC_PERM_DENIED</name></expr>:</case>
<return>return <expr><operator>(</operator><literal type="string">"You don't have permission to capture in promiscuous mode on that device"</literal><operator>)</operator></expr>;</return>

<case>case <expr><name>PCAP_ERROR_TSTAMP_PRECISION_NOTSUP</name></expr>:</case>
<return>return <expr><operator>(</operator><literal type="string">"That device doesn't support that time stamp precision"</literal><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name>ebuf</name></expr></argument>, <argument><expr><sizeof>sizeof <name>ebuf</name></sizeof></expr></argument>, <argument><expr><literal type="string">"Unknown error: %d"</literal></expr></argument>, <argument><expr><name>errnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return<expr><operator>(</operator><name>ebuf</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>pcap_strerror</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>errnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRERROR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>errbuf</name><index>[<expr><name>PCAP_ERRBUF_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>errno_t</name></type> <name>err</name> <init>= <expr><call><name>strerror_s</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>, <argument><expr><name>errnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>pcap_strlcpy</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><literal type="string">"strerror_s() error"</literal></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><name>errbuf</name><operator>)</operator></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><operator>(</operator><call><name>strerror</name><argument_list>(<argument><expr><name>errnum</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>sys_nerr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>sys_errlist</name><index>[]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>errbuf</name><index>[<expr><name>PCAP_ERRBUF_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>errnum</name> <operator>&lt;</operator> <name>sys_nerr</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>sys_errlist</name><index>[<expr><name>errnum</name></expr>]</index></name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><sizeof>sizeof <name>errbuf</name></sizeof></expr></argument>, <argument><expr><literal type="string">"Unknown error: %d"</literal></expr></argument>, <argument><expr><name>errnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>errbuf</name><operator>)</operator></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pcap_setfilter</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>bpf_program</name></name> <modifier>*</modifier></type><name>fp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><call><name><name>p</name><operator>-&gt;</operator><name>setfilter_op</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>







<function><type><name>int</name></type>
<name>pcap_setdirection</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>pcap_direction_t</name></type> <name>d</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>setdirection_op</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"Setting direction is not implemented on this platform"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name><name>p</name><operator>-&gt;</operator><name>setdirection_op</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pcap_stats</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>pcap_stat</name></name> <modifier>*</modifier></type><name>ps</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><call><name><name>p</name><operator>-&gt;</operator><name>stats_op</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>ps</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name><name>struct</name> <name>pcap_stat</name></name> <modifier>*</modifier></type>
<name>pcap_stats_ex</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pcap_stat_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><call><name><name>p</name><operator>-&gt;</operator><name>stats_ex_op</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pcap_stat_size</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pcap_setbuff</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><call><name><name>p</name><operator>-&gt;</operator><name>setbuff_op</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pcap_setmode</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><call><name><name>p</name><operator>-&gt;</operator><name>setmode_op</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pcap_setmintocopy</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><call><name><name>p</name><operator>-&gt;</operator><name>setmintocopy_op</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>HANDLE</name></type>
<name>pcap_getevent</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><call><name><name>p</name><operator>-&gt;</operator><name>getevent_op</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pcap_oid_get_request</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>bpf_u_int32</name></type> <name>oid</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>lenp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><call><name><name>p</name><operator>-&gt;</operator><name>oid_get_request_op</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>lenp</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pcap_oid_set_request</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>bpf_u_int32</name></type> <name>oid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>lenp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><call><name><name>p</name><operator>-&gt;</operator><name>oid_set_request_op</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>lenp</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>pcap_send_queue</name> <modifier>*</modifier></type>
<name>pcap_sendqueue_alloc</name><parameter_list>(<parameter><decl><type><name>u_int</name></type> <name>memsize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>pcap_send_queue</name> <modifier>*</modifier></type><name>tqueue</name></decl>;</decl_stmt>


<expr_stmt><expr><name>tqueue</name> <operator>=</operator> <operator>(</operator><name>pcap_send_queue</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pcap_send_queue</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tqueue</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block>{<block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name><name>tqueue</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><name>memsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>tqueue</name><operator>-&gt;</operator><name>buffer</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tqueue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>tqueue</name><operator>-&gt;</operator><name>maxlen</name></name> <operator>=</operator> <name>memsize</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tqueue</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>tqueue</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>pcap_sendqueue_destroy</name><parameter_list>(<parameter><decl><type><name>pcap_send_queue</name> <modifier>*</modifier></type><name>queue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>queue</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>queue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pcap_sendqueue_queue</name><parameter_list>(<parameter><decl><type><name>pcap_send_queue</name> <modifier>*</modifier></type><name>queue</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>pcap_pkthdr</name></name> <modifier>*</modifier></type><name>pkt_header</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>u_char</name> <modifier>*</modifier></type><name>pkt_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>queue</name><operator>-&gt;</operator><name>len</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>pcap_pkthdr</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>pkt_header</name><operator>-&gt;</operator><name>caplen</name></name> <operator>&gt;</operator> <name><name>queue</name><operator>-&gt;</operator><name>maxlen</name></name></expr>)</condition><block>{<block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>queue</name><operator>-&gt;</operator><name>buffer</name></name> <operator>+</operator> <name><name>queue</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name>pkt_header</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>pcap_pkthdr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>queue</name><operator>-&gt;</operator><name>len</name></name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>pcap_pkthdr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>


<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>queue</name><operator>-&gt;</operator><name>buffer</name></name> <operator>+</operator> <name><name>queue</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name>pkt_data</name></expr></argument>, <argument><expr><name><name>pkt_header</name><operator>-&gt;</operator><name>caplen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>queue</name><operator>-&gt;</operator><name>len</name></name> <operator>+=</operator> <name><name>pkt_header</name><operator>-&gt;</operator><name>caplen</name></name></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>u_int</name></type>
<name>pcap_sendqueue_transmit</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>pcap_send_queue</name> <modifier>*</modifier></type><name>queue</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sync</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><call><name><name>p</name><operator>-&gt;</operator><name>sendqueue_transmit_op</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>queue</name></expr></argument>, <argument><expr><name>sync</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pcap_setuserbuffer</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><call><name><name>p</name><operator>-&gt;</operator><name>setuserbuffer_op</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pcap_live_dump</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxsize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxpacks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><call><name><name>p</name><operator>-&gt;</operator><name>live_dump_op</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>maxsize</name></expr></argument>, <argument><expr><name>maxpacks</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pcap_live_dump_ended</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sync</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><call><name><name>p</name><operator>-&gt;</operator><name>live_dump_ended_op</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>sync</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>PAirpcapHandle</name></type>
<name>pcap_get_airpcap_handle</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>PAirpcapHandle</name></type> <name>handle</name></decl>;</decl_stmt>

<expr_stmt><expr><name>handle</name> <operator>=</operator> <call><name><name>p</name><operator>-&gt;</operator><name>get_airpcap_handle_op</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>handle</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><literal type="string">"This isn't an AirPcap device"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name>handle</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


















<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>pcap</name></name> <modifier>*</modifier></type><name>pcaps_to_close</name></decl>;</decl_stmt>





<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>did_atexit</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>pcap_close_all</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>pcap</name></name> <modifier>*</modifier></type><name>handle</name></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>(</operator><name>handle</name> <operator>=</operator> <name>pcaps_to_close</name><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>pcap_close</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pcap_do_addexit</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>




<if_stmt><if>if <condition>(<expr><operator>!</operator><name>did_atexit</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>atexit</name><argument_list>(<argument><expr><name>pcap_close_all</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><call><name>pcap_strlcpy</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><literal type="string">"atexit failed"</literal></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>did_atexit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>pcap_add_to_pcaps_to_close</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>pcaps_to_close</name></expr>;</expr_stmt>
<expr_stmt><expr><name>pcaps_to_close</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>pcap_remove_from_pcaps_to_close</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>pc</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>prevpc</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>pc</name> <operator>=</operator> <name>pcaps_to_close</name></expr><operator>,</operator> <expr><name>prevpc</name> <operator>=</operator> <name>NULL</name></expr>;</init> <condition><expr><name>pc</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
<incr><expr><name>prevpc</name> <operator>=</operator> <name>pc</name></expr><operator>,</operator> <expr><name>pc</name> <operator>=</operator> <name><name>pc</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>pc</name> <operator>==</operator> <name>p</name></expr>)</condition> <block>{<block_content>



<if_stmt><if>if <condition>(<expr><name>prevpc</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><name>pcaps_to_close</name> <operator>=</operator> <name><name>pc</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>



<expr_stmt><expr><name><name>prevpc</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>pc</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>pcap_cleanup_live_common</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>buffer</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>dlt_list</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>dlt_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>dlt_list</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>dlt_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>tstamp_type_list</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>tstamp_type_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>tstamp_type_list</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>tstamp_type_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>tstamp_precision_list</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>tstamp_precision_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>tstamp_precision_list</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>tstamp_precision_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>pcap_freecode</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>fcode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MSDOS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>fd</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>fd</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>selectable_fd</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>







<function><type><name>int</name></type>
<name>pcap_sendpacket</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>u_char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>p</name><operator>-&gt;</operator><name>inject_op</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>





<function><type><name>int</name></type>
<name>pcap_inject</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><call><name><name>p</name><operator>-&gt;</operator><name>inject_op</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>pcap_close</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>device</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>device</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>p</name><operator>-&gt;</operator><name>cleanup_op</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>







<function><type><name>int</name></type>
<name>pcap_offline_filter</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>bpf_program</name></name> <modifier>*</modifier></type><name>fp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>pcap_pkthdr</name></name> <modifier>*</modifier></type><name>h</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>u_char</name> <modifier>*</modifier></type><name>pkt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>bpf_insn</name></name> <modifier>*</modifier></type><name>fcode</name> <init>= <expr><name><name>fp</name><operator>-&gt;</operator><name>bf_insns</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fcode</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name>bpf_filter</name><argument_list>(<argument><expr><name>fcode</name></expr></argument>, <argument><expr><name>pkt</name></expr></argument>, <argument><expr><name><name>h</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name><name>h</name><operator>-&gt;</operator><name>caplen</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pcap_can_set_rfmon_dead</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"Rfmon mode doesn't apply on a pcap_open_dead pcap_t"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>PCAP_ERROR</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pcap_read_dead</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name> <name>cnt</name></type> <name>_U_</name></decl></parameter>, <parameter><decl><type><name>pcap_handler</name> <name>callback</name></type> <name>_U_</name></decl></parameter>,
<parameter><decl><type><name>u_char</name> <modifier>*</modifier><name>user</name></type> <name>_U_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"Packets aren't available from a pcap_open_dead pcap_t"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pcap_inject_dead</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier><name>buf</name></type> <name>_U_</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <name>size</name></type> <name>_U_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"Packets can't be sent on a pcap_open_dead pcap_t"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pcap_setfilter_dead</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>bpf_program</name></name> <modifier>*</modifier><name>fp</name></type> <name>_U_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"A filter cannot be set on a pcap_open_dead pcap_t"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pcap_setdirection_dead</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>pcap_direction_t</name> <name>d</name></type> <name>_U_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"The packet direction cannot be set on a pcap_open_dead pcap_t"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pcap_set_datalink_dead</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name> <name>dlt</name></type> <name>_U_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"The link-layer header type cannot be set on a pcap_open_dead pcap_t"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pcap_getnonblock_dead</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"A pcap_open_dead pcap_t does not have a non-blocking mode setting"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pcap_setnonblock_dead</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name> <name>nonblock</name></type> <name>_U_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"A pcap_open_dead pcap_t does not have a non-blocking mode setting"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pcap_stats_dead</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>pcap_stat</name></name> <modifier>*</modifier><name>ps</name></type> <name>_U_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"Statistics aren't available from a pcap_open_dead pcap_t"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name><name>struct</name> <name>pcap_stat</name></name> <modifier>*</modifier></type>
<name>pcap_stats_ex_dead</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier><name>pcap_stat_size</name></type> <name>_U_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"Statistics aren't available from a pcap_open_dead pcap_t"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pcap_setbuff_dead</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"The kernel buffer size cannot be set on a pcap_open_dead pcap_t"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pcap_setmode_dead</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"impossible to set mode on a pcap_open_dead pcap_t"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pcap_setmintocopy_dead</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"The mintocopy parameter cannot be set on a pcap_open_dead pcap_t"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>HANDLE</name></type>
<name>pcap_getevent_dead</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"A pcap_open_dead pcap_t has no event handle"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>INVALID_HANDLE_VALUE</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pcap_oid_get_request_dead</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>bpf_u_int32</name> <name>oid</name></type> <name>_U_</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><name>data</name></type> <name>_U_</name></decl></parameter>,
<parameter><decl><type><name>size_t</name> <modifier>*</modifier><name>lenp</name></type> <name>_U_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"An OID get request cannot be performed on a pcap_open_dead pcap_t"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>PCAP_ERROR</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pcap_oid_set_request_dead</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>bpf_u_int32</name> <name>oid</name></type> <name>_U_</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier><name>data</name></type> <name>_U_</name></decl></parameter>,
<parameter><decl><type><name>size_t</name> <modifier>*</modifier><name>lenp</name></type> <name>_U_</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"An OID set request cannot be performed on a pcap_open_dead pcap_t"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>PCAP_ERROR</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>u_int</name></type>
<name>pcap_sendqueue_transmit_dead</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>pcap_send_queue</name> <modifier>*</modifier></type><name>queue</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sync</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"Packets cannot be transmitted on a pcap_open_dead pcap_t"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pcap_setuserbuffer_dead</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"The user buffer cannot be set on a pcap_open_dead pcap_t"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pcap_live_dump_dead</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxsize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxpacks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"Live packet dumping cannot be performed on a pcap_open_dead pcap_t"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pcap_live_dump_ended_dead</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sync</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"Live packet dumping cannot be performed on a pcap_open_dead pcap_t"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PAirpcapHandle</name></type>
<name>pcap_get_airpcap_handle_dead</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>pcap_cleanup_dead</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier><name>p</name></type> <name>_U_</name></decl></parameter>)</parameter_list>
<block>{<block_content>

</block_content>}</block></function>

<function><type><name>pcap_t</name> <modifier>*</modifier></type>
<name>pcap_open_dead_with_tstamp_precision</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>linktype</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>snaplen</name></decl></parameter>, <parameter><decl><type><name>u_int</name></type> <name>precision</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>precision</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>PCAP_TSTAMP_PRECISION_MICRO</name></expr>:</case>
<case>case <expr><name>PCAP_TSTAMP_PRECISION_NANO</name></expr>:</case>
<break>break;</break>

<default>default:</default>






<expr_stmt><expr><name>precision</name> <operator>=</operator> <name>PCAP_TSTAMP_PRECISION_MICRO</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>memset</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>snapshot</name></name> <operator>=</operator> <name>snaplen</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>linktype</name></name> <operator>=</operator> <name>linktype</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>tstamp_precision</name></name> <operator>=</operator> <name>precision</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>can_set_rfmon_op</name></name> <operator>=</operator> <name>pcap_can_set_rfmon_dead</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>read_op</name></name> <operator>=</operator> <name>pcap_read_dead</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>inject_op</name></name> <operator>=</operator> <name>pcap_inject_dead</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>setfilter_op</name></name> <operator>=</operator> <name>pcap_setfilter_dead</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>setdirection_op</name></name> <operator>=</operator> <name>pcap_setdirection_dead</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>set_datalink_op</name></name> <operator>=</operator> <name>pcap_set_datalink_dead</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>getnonblock_op</name></name> <operator>=</operator> <name>pcap_getnonblock_dead</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>setnonblock_op</name></name> <operator>=</operator> <name>pcap_setnonblock_dead</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>stats_op</name></name> <operator>=</operator> <name>pcap_stats_dead</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>stats_ex_op</name></name> <operator>=</operator> <name>pcap_stats_ex_dead</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>setbuff_op</name></name> <operator>=</operator> <name>pcap_setbuff_dead</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>setmode_op</name></name> <operator>=</operator> <name>pcap_setmode_dead</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>setmintocopy_op</name></name> <operator>=</operator> <name>pcap_setmintocopy_dead</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>getevent_op</name></name> <operator>=</operator> <name>pcap_getevent_dead</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>oid_get_request_op</name></name> <operator>=</operator> <name>pcap_oid_get_request_dead</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>oid_set_request_op</name></name> <operator>=</operator> <name>pcap_oid_set_request_dead</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>sendqueue_transmit_op</name></name> <operator>=</operator> <name>pcap_sendqueue_transmit_dead</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>setuserbuffer_op</name></name> <operator>=</operator> <name>pcap_setuserbuffer_dead</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>live_dump_op</name></name> <operator>=</operator> <name>pcap_live_dump_dead</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>live_dump_ended_op</name></name> <operator>=</operator> <name>pcap_live_dump_ended_dead</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>get_airpcap_handle_op</name></name> <operator>=</operator> <name>pcap_get_airpcap_handle_dead</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cleanup_op</name></name> <operator>=</operator> <name>pcap_cleanup_dead</name></expr>;</expr_stmt>




<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bpf_codegen_flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>activated</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>p</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>pcap_t</name> <modifier>*</modifier></type>
<name>pcap_open_dead</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>linktype</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>snaplen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><call><name>pcap_open_dead_with_tstamp_precision</name><argument_list>(<argument><expr><name>linktype</name></expr></argument>, <argument><expr><name>snaplen</name></expr></argument>,
<argument><expr><name>PCAP_TSTAMP_PRECISION_MICRO</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYDEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>












<decl_stmt><decl><type><name>PCAP_API</name> <name>void</name></type> <name>pcap_set_parser_debug</name><argument_list>(<argument><expr><name>int</name> <name>value</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function><type><name>PCAP_API_DEF</name> <name>void</name></type>
<name>pcap_set_parser_debug</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>pcap_debug</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
</block_content>}</block></function></block_content></block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
