<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/libpcap/nametoaddr.c">























<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_CONFIG_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;config.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DECNETLIB</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netdnet/dnetdb.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;winsock2.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ws2tcpip.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>INET6</name></expr></argument>)</argument_list></call></expr></cpp:if>





















<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;wspiapi.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/param.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/socket.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netinet/in.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_ETHER_HOSTTON</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NET_ETHERNET_H_DECLARES_ETHER_HOSTTON</name></expr></argument>)</argument_list></call></expr></cpp:if>



<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;net/ethernet.h&gt;</cpp:file></cpp:include>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NETINET_ETHER_H_DECLARES_ETHER_HOSTTON</name></expr></argument>)</argument_list></call></expr></cpp:elif>



<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netinet/ether.h&gt;</cpp:file></cpp:include>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SYS_ETHERNET_H_DECLARES_ETHER_HOSTTON</name></expr></argument>)</argument_list></call></expr></cpp:elif>



<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/ethernet.h&gt;</cpp:file></cpp:include>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ARPA_INET_H_DECLARES_ETHER_HOSTTON</name></expr></argument>)</argument_list></call></expr></cpp:elif>



<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;arpa/inet.h&gt;</cpp:file></cpp:include>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NETINET_IF_ETHER_H_DECLARES_ETHER_HOSTTON</name></expr></argument>)</argument_list></call></expr></cpp:elif>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEED_NETINET_IF_ETHER_H</name></cpp:macro></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>





<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRUCT_ETHER_ADDR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEED_NETINET_IF_ETHER_H</name></cpp:macro></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<struct>struct <name>ether_addr</name> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>ether_addr_octet</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NEED_NETINET_IF_ETHER_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;net/if.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netinet/in.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netinet/if_ether.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DECL_ETHER_HOSTTON</name></expr></argument>)</argument_list></call></expr></cpp:if>



<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>ether_hostton</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ether_addr</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;arpa/inet.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netdb.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pcap-int.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gencode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pcap/namedb.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nametoaddr.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_OS_PROTO_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"os-proto.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NTOHL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NTOHL</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(x) = ntohl(x)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NTOHS</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(x) = ntohs(x)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>






<function><type><name>bpf_u_int32</name> <modifier>*</modifier><modifier>*</modifier></type>
<name>pcap_nametoaddr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>h_addr</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>bpf_u_int32</name> <modifier>*</modifier></type><name><name>hlist</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>bpf_u_int32</name> <modifier>*</modifier><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>hostent</name></name> <modifier>*</modifier></type><name>hp</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>hp</name> <operator>=</operator> <call><name>gethostbyname</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>h_addr</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>hlist</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>bpf_u_int32</name> <operator>*</operator><operator>)</operator><name><name>hp</name><operator>-&gt;</operator><name>h_addr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NTOHL</name><argument_list>(<argument><expr><name><name>hp</name><operator>-&gt;</operator><name>h_addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>hlist</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>bpf_u_int32</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>hp</name><operator>-&gt;</operator><name>h_addr_list</name></name></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><operator>++</operator><name>p</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>NTOHL</name><argument_list>(<argument><expr><operator>*</operator><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<return>return <expr><operator>(</operator><name>bpf_u_int32</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>hp</name><operator>-&gt;</operator><name>h_addr_list</name></name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>addrinfo</name></name> <modifier>*</modifier></type>
<name>pcap_nametoaddrinfo</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>addrinfo</name></name></type> <name>hints</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>error</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hints</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hints</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_family</name></name> <operator>=</operator> <name>PF_UNSPEC</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_socktype</name></name> <operator>=</operator> <name>SOCK_STREAM</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_protocol</name></name> <operator>=</operator> <name>IPPROTO_TCP</name></expr>;</expr_stmt>
<expr_stmt><expr><name>error</name> <operator>=</operator> <call><name>getaddrinfo</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hints</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>error</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>res</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>







<function><type><name>bpf_u_int32</name></type>
<name>pcap_nametonetaddr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>












<return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>



<decl_stmt><decl><type><name><name>struct</name> <name>netent</name></name> <modifier>*</modifier></type><name>np</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LINUX_GETNETBYNAME_R</name></expr></argument>)</argument_list></call></expr></cpp:if>



<decl_stmt><decl><type><name><name>struct</name> <name>netent</name></name></type> <name>result_buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>h_errnoval</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>















<expr_stmt><expr><name>np</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>getnetbyname_r</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result_buf</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <name>buf</name></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>np</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>h_errnoval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>




<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SOLARIS_IRIX_GETNETBYNAME_R</name></expr></argument>)</argument_list></call></expr></cpp:elif>



<decl_stmt><decl><type><name><name>struct</name> <name>netent</name></name></type> <name>result_buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name>np</name> <operator>=</operator> <call><name>getnetbyname_r</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result_buf</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof <name>buf</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_AIX_GETNETBYNAME_R</name></expr></argument>)</argument_list></call></expr></cpp:elif>



<decl_stmt><decl><type><name><name>struct</name> <name>netent</name></name></type> <name>result_buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>netent_data</name></name></type> <name>net_data</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>getnetbyname_r</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result_buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>net_data</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>np</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>np</name> <operator>=</operator> <operator>&amp;</operator><name>result_buf</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>










<expr_stmt><expr><name>np</name> <operator>=</operator> <call><name>getnetbyname</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><name>np</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>np</name><operator>-&gt;</operator><name>n_net</name></name></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>






<function><type><name>int</name></type>
<name>pcap_nametoport</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>port</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>proto</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>addrinfo</name></name></type> <name>hints</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>res</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ai</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>error</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sockaddr_in</name></name> <modifier>*</modifier></type><name>in4</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>INET6</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name><name>struct</name> <name>sockaddr_in6</name></name> <modifier>*</modifier></type><name>in6</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>int</name></type> <name>tcp_port</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>udp_port</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>





<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hints</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hints</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_family</name></name> <operator>=</operator> <name>PF_UNSPEC</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_socktype</name></name> <operator>=</operator> <name>SOCK_STREAM</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_protocol</name></name> <operator>=</operator> <name>IPPROTO_TCP</name></expr>;</expr_stmt>
<expr_stmt><expr><name>error</name> <operator>=</operator> <call><name>getaddrinfo</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hints</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>error</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>error</name> <operator>!=</operator> <name>EAI_NONAME</name> <operator>&amp;&amp;</operator>
<name>error</name> <operator>!=</operator> <name>EAI_SERVICE</name></expr>)</condition> <block>{<block_content>





<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>



<for>for <control>(<init><expr><name>ai</name> <operator>=</operator> <name>res</name></expr>;</init> <condition><expr><name>ai</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ai</name> <operator>=</operator> <name><name>ai</name><operator>-&gt;</operator><name>ai_next</name></name></expr></incr>)</control> <block>{<block_content>



<if_stmt><if>if <condition>(<expr><name><name>ai</name><operator>-&gt;</operator><name>ai_addr</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>



<if_stmt><if>if <condition>(<expr><name><name>ai</name><operator>-&gt;</operator><name>ai_addr</name><operator>-&gt;</operator><name>sa_family</name></name> <operator>==</operator> <name>AF_INET</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>in4</name> <operator>=</operator> <operator>(</operator>struct <name>sockaddr_in</name> <operator>*</operator><operator>)</operator><name><name>ai</name><operator>-&gt;</operator><name>ai_addr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>tcp_port</name> <operator>=</operator> <call><name>ntohs</name><argument_list>(<argument><expr><name><name>in4</name><operator>-&gt;</operator><name>sin_port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>INET6</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>ai</name><operator>-&gt;</operator><name>ai_addr</name><operator>-&gt;</operator><name>sa_family</name></name> <operator>==</operator> <name>AF_INET6</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>in6</name> <operator>=</operator> <operator>(</operator>struct <name>sockaddr_in6</name> <operator>*</operator><operator>)</operator><name><name>ai</name><operator>-&gt;</operator><name>ai_addr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>tcp_port</name> <operator>=</operator> <call><name>ntohs</name><argument_list>(<argument><expr><name><name>in6</name><operator>-&gt;</operator><name>sin6_port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>freeaddrinfo</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hints</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hints</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_family</name></name> <operator>=</operator> <name>PF_UNSPEC</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_socktype</name></name> <operator>=</operator> <name>SOCK_DGRAM</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_protocol</name></name> <operator>=</operator> <name>IPPROTO_UDP</name></expr>;</expr_stmt>
<expr_stmt><expr><name>error</name> <operator>=</operator> <call><name>getaddrinfo</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hints</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>error</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>error</name> <operator>!=</operator> <name>EAI_NONAME</name> <operator>&amp;&amp;</operator>
<name>error</name> <operator>!=</operator> <name>EAI_SERVICE</name></expr>)</condition> <block>{<block_content>





<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>



<for>for <control>(<init><expr><name>ai</name> <operator>=</operator> <name>res</name></expr>;</init> <condition><expr><name>ai</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ai</name> <operator>=</operator> <name><name>ai</name><operator>-&gt;</operator><name>ai_next</name></name></expr></incr>)</control> <block>{<block_content>



<if_stmt><if>if <condition>(<expr><name><name>ai</name><operator>-&gt;</operator><name>ai_addr</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>



<if_stmt><if>if <condition>(<expr><name><name>ai</name><operator>-&gt;</operator><name>ai_addr</name><operator>-&gt;</operator><name>sa_family</name></name> <operator>==</operator> <name>AF_INET</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>in4</name> <operator>=</operator> <operator>(</operator>struct <name>sockaddr_in</name> <operator>*</operator><operator>)</operator><name><name>ai</name><operator>-&gt;</operator><name>ai_addr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>udp_port</name> <operator>=</operator> <call><name>ntohs</name><argument_list>(<argument><expr><name><name>in4</name><operator>-&gt;</operator><name>sin_port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>INET6</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>ai</name><operator>-&gt;</operator><name>ai_addr</name><operator>-&gt;</operator><name>sa_family</name></name> <operator>==</operator> <name>AF_INET6</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>in6</name> <operator>=</operator> <operator>(</operator>struct <name>sockaddr_in6</name> <operator>*</operator><operator>)</operator><name><name>ai</name><operator>-&gt;</operator><name>ai_addr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>udp_port</name> <operator>=</operator> <call><name>ntohs</name><argument_list>(<argument><expr><name><name>in6</name><operator>-&gt;</operator><name>sin6_port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>freeaddrinfo</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>







<if_stmt><if>if <condition>(<expr><name>tcp_port</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>port</name> <operator>=</operator> <name>tcp_port</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>proto</name> <operator>=</operator> <name>IPPROTO_TCP</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>udp_port</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>udp_port</name> <operator>==</operator> <name>tcp_port</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>proto</name> <operator>=</operator> <name>PROTO_UNDEF</name></expr>;</expr_stmt></block_content></block></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>notdef</name></expr></argument>)</argument_list></call></expr></cpp:if>
<else>else<block type="pseudo"><block_content>


<expr_stmt><expr><call><name>warning</name><argument_list>(<argument><expr><literal type="string">"ambiguous port %s in /etc/services"</literal></expr></argument>,
<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>udp_port</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>port</name> <operator>=</operator> <name>udp_port</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>proto</name> <operator>=</operator> <name>IPPROTO_UDP</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ultrix</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__osf__</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"nfs"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>port</name> <operator>=</operator> <literal type="number">2049</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>proto</name> <operator>=</operator> <name>PROTO_UNDEF</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>






<function><type><name>int</name></type>
<name>pcap_nametoportrange</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>port1</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>port2</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>proto</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>u_int</name></type> <name>p1</name></decl>, <decl><type ref="prev"/><name>p2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>off</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>cpy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>save_proto</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"%d-%d"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>p1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p2</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>cpy</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>off</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>cpy</name></expr></argument>, <argument><expr><literal type="char">'-'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>cpy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>off</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>pcap_nametoport</name><argument_list>(<argument><expr><name>cpy</name></expr></argument>, <argument><expr><name>port1</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>cpy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>save_proto</name> <operator>=</operator> <operator>*</operator><name>proto</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>pcap_nametoport</name><argument_list>(<argument><expr><name>off</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>port2</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>cpy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>cpy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>proto</name> <operator>!=</operator> <name>save_proto</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>proto</name> <operator>=</operator> <name>PROTO_UNDEF</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>port1</name> <operator>=</operator> <name>p1</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>port2</name> <operator>=</operator> <name>p2</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>proto</name> <operator>=</operator> <name>PROTO_UNDEF</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>





<function><type><name>int</name></type>
<name>pcap_nametoproto</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>protoent</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LINUX_GETNETBYNAME_R</name></expr></argument>)</argument_list></call></expr></cpp:if>



<decl_stmt><decl><type><name><name>struct</name> <name>protoent</name></name></type> <name>result_buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>

<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>getprotobyname_r</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result_buf</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <name>buf</name></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>




<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SOLARIS_IRIX_GETNETBYNAME_R</name></expr></argument>)</argument_list></call></expr></cpp:elif>



<decl_stmt><decl><type><name><name>struct</name> <name>protoent</name></name></type> <name>result_buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>getprotobyname_r</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result_buf</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof <name>buf</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_AIX_GETNETBYNAME_R</name></expr></argument>)</argument_list></call></expr></cpp:elif>



<decl_stmt><decl><type><name><name>struct</name> <name>protoent</name></name></type> <name>result_buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>protoent_data</name></name></type> <name>proto_data</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>getprotobyname_r</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result_buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>proto_data</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>&amp;</operator><name>result_buf</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>










<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>getprotobyname</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>p</name><operator>-&gt;</operator><name>p_proto</name></name></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>PROTO_UNDEF</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ethertype.h"</cpp:file></cpp:include>

<struct>struct <name>eproto</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>u_short</name></type> <name>p</name></decl>;</decl_stmt>
}</block>;</struct>












<decl_stmt><decl><type><name>PCAP_API</name> <name><name>struct</name> <name>eproto</name></name></type> <name><name>eproto_db</name><index>[]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCAP_API_DEF</name> <name><name>struct</name> <name>eproto</name></name></type> <name><name>eproto_db</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><literal type="string">"pup"</literal></expr>, <expr><name>ETHERTYPE_PUP</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"xns"</literal></expr>, <expr><name>ETHERTYPE_NS</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"ip"</literal></expr>, <expr><name>ETHERTYPE_IP</name></expr> }</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>INET6</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{ <expr><literal type="string">"ip6"</literal></expr>, <expr><name>ETHERTYPE_IPV6</name></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><block>{ <expr><literal type="string">"arp"</literal></expr>, <expr><name>ETHERTYPE_ARP</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"rarp"</literal></expr>, <expr><name>ETHERTYPE_REVARP</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"sprite"</literal></expr>, <expr><name>ETHERTYPE_SPRITE</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"mopdl"</literal></expr>, <expr><name>ETHERTYPE_MOPDL</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"moprc"</literal></expr>, <expr><name>ETHERTYPE_MOPRC</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"decnet"</literal></expr>, <expr><name>ETHERTYPE_DN</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"lat"</literal></expr>, <expr><name>ETHERTYPE_LAT</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"sca"</literal></expr>, <expr><name>ETHERTYPE_SCA</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"lanbridge"</literal></expr>, <expr><name>ETHERTYPE_LANBRIDGE</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"vexp"</literal></expr>, <expr><name>ETHERTYPE_VEXP</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"vprod"</literal></expr>, <expr><name>ETHERTYPE_VPROD</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"atalk"</literal></expr>, <expr><name>ETHERTYPE_ATALK</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"atalkarp"</literal></expr>, <expr><name>ETHERTYPE_AARP</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"loopback"</literal></expr>, <expr><name>ETHERTYPE_LOOPBACK</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"decdts"</literal></expr>, <expr><name>ETHERTYPE_DECDTS</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"decdns"</literal></expr>, <expr><name>ETHERTYPE_DECDNS</name></expr> }</block></expr>,
<expr><block>{ <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>int</name></type>
<name>pcap_nametoeproto</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>eproto</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>eproto_db</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>s</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>s</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>p</name><operator>-&gt;</operator><name>p</name></name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><name>PROTO_UNDEF</name></expr>;</return>
</block_content>}</block></function>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llc.h"</cpp:file></cpp:include>


<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>eproto</name></name></type> <name><name>llc_db</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><literal type="string">"iso"</literal></expr>, <expr><name>LLCSAP_ISONS</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"stp"</literal></expr>, <expr><name>LLCSAP_8021D</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"ipx"</literal></expr>, <expr><name>LLCSAP_IPX</name></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"netbeui"</literal></expr>, <expr><name>LLCSAP_NETBEUI</name></expr> }</block></expr>,
<expr><block>{ <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>int</name></type>
<name>pcap_nametollc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>eproto</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>llc_db</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>s</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>s</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>p</name><operator>-&gt;</operator><name>p</name></name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><name>PROTO_UNDEF</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>u_char</name></type>
<name>xdtoi</name><parameter_list>(<parameter><decl><type><name>u_char</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>u_char</name><operator>)</operator><operator>(</operator><name>c</name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>islower</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>u_char</name><operator>)</operator><operator>(</operator><name>c</name> <operator>-</operator> <literal type="char">'a'</literal> <operator>+</operator> <literal type="number">10</literal><operator>)</operator></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>u_char</name><operator>)</operator><operator>(</operator><name>c</name> <operator>-</operator> <literal type="char">'A'</literal> <operator>+</operator> <literal type="number">10</literal><operator>)</operator></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>__pcap_atoin</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>bpf_u_int32</name> <modifier>*</modifier></type><name>addr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>u_int</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>addr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>s</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>!=</operator> <literal type="char">'.'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">25</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <name>n</name> <operator>*</operator> <literal type="number">10</literal> <operator>+</operator> <operator>*</operator><name>s</name><operator>++</operator> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">255</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>addr</name> <operator>&lt;&lt;=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>addr</name> <operator>|=</operator> <name>n</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>len</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>++</operator><name>s</name></expr>;</expr_stmt>
</block_content>}</block></for>

</block_content>}</block></function>

<function><type><name>int</name></type>
<name>__pcap_atodn</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>bpf_u_int32</name> <modifier>*</modifier></type><name>addr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AREASHIFT</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AREAMASK</name></cpp:macro> <cpp:value>0176000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NODEMASK</name></cpp:macro> <cpp:value>01777</cpp:value></cpp:define>

<decl_stmt><decl><type><name>u_int</name></type> <name>node</name></decl>, <decl><type ref="prev"/><name>area</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"%d.%d"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>area</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>node</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return<expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>addr</name> <operator>=</operator> <operator>(</operator><name>area</name> <operator>&lt;&lt;</operator> <name>AREASHIFT</name><operator>)</operator> <operator>&amp;</operator> <name>AREAMASK</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>addr</name> <operator>|=</operator> <operator>(</operator><name>node</name> <operator>&amp;</operator> <name>NODEMASK</name><operator>)</operator></expr>;</expr_stmt>

<return>return<expr><operator>(</operator><literal type="number">32</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>













<function><type><name>u_char</name> <modifier>*</modifier></type>
<name>pcap_ether_aton</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>register</specifier> <name>u_char</name> <modifier>*</modifier></type><name>ep</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>register</specifier> <name>u_char</name></type> <name>d</name></decl>;</decl_stmt>

<expr_stmt><expr><name>e</name> <operator>=</operator> <name>ep</name> <operator>=</operator> <operator>(</operator><name>u_char</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>e</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<while>while <condition>(<expr><operator>*</operator><name>s</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">':'</literal> <operator>||</operator> <operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'.'</literal> <operator>||</operator> <operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>s</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>xdtoi</name><argument_list>(<argument><expr><operator>*</operator><name>s</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>isxdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>d</name> <operator>&lt;&lt;=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>d</name> <operator>|=</operator> <call><name>xdtoi</name><argument_list>(<argument><expr><operator>*</operator><name>s</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>ep</name><operator>++</operator> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
</block_content>}</block></while>

<return>return <expr><operator>(</operator><name>e</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_ETHER_HOSTTON</name></expr></argument>)</argument_list></call></expr></cpp:if>





<function><type><name>u_char</name> <modifier>*</modifier></type>
<name>pcap_ether_hostton</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>register</specifier> <name><name>struct</name> <name>pcap_etherent</name></name> <modifier>*</modifier></type><name>ep</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>register</specifier> <name>u_char</name> <modifier>*</modifier></type><name>ap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>FILE</name> <modifier>*</modifier></type><name>fp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>init</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>init</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>PCAP_ETHERS_FILE</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>init</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>fp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rewind</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<while>while <condition>(<expr><operator>(</operator><name>ep</name> <operator>=</operator> <call><name>pcap_next_etherent</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>ep</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ap</name> <operator>=</operator> <operator>(</operator><name>u_char</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ap</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name><name>ep</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ap</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>




<function><type><name>u_char</name> <modifier>*</modifier></type>
<name>pcap_ether_hostton</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>register</specifier> <name>u_char</name> <modifier>*</modifier></type><name>ap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>u_char</name></type> <name><name>a</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name>ap</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ether_hostton</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>(</operator>struct <name>ether_addr</name> <operator>*</operator><operator>)</operator><name>a</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ap</name> <operator>=</operator> <operator>(</operator><name>u_char</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ap</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>ap</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>a</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name>ap</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>




<function><type><name>int</name></type>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DECNETLIB</name></expr></argument>)</argument_list></call></expr></cpp:if>
<name>__pcap_nametodnaddr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>u_short</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<function_decl><type><name><name>struct</name> <name>nodeent</name></name> <modifier>*</modifier></type><name>getnodebyname</name><parameter_list>()</parameter_list>;</function_decl>
<decl_stmt><decl><type><name><name>struct</name> <name>nodeent</name></name> <modifier>*</modifier></type><name>nep</name></decl>;</decl_stmt>

<expr_stmt><expr><name>nep</name> <operator>=</operator> <call><name>getnodebyname</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nep</name> <operator>==</operator> <operator>(</operator><operator>(</operator>struct <name>nodeent</name> <operator>*</operator><operator>)</operator><literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return<expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>res</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>nep</name><operator>-&gt;</operator><name>n_addr</name></name></expr></argument>, <argument><expr>sizeof<operator>(</operator><name>unsigned</name> <name>short</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return<expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<macro><name>__pcap_nametodnaddr</name><argument_list>(<argument>const char *name _U_</argument>, <argument>u_short *res _U_</argument>)</argument_list></macro>
<block>{<block_content>
<return>return<expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></block_content></block></function>
</unit>
