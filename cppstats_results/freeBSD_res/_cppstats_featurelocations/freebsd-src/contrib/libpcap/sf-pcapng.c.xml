<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/libpcap/sf-pcapng.c">






















<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_CONFIG_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;config.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pcap/pcap-inttypes.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;memory.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pcap-int.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pcap-common.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_OS_PROTO_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"os-proto.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sf-pcapng.h"</cpp:file></cpp:include>








<struct>struct <name>block_header</name> <block>{
<decl_stmt><decl><type><name>bpf_u_int32</name></type> <name>block_type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bpf_u_int32</name></type> <name>total_length</name></decl>;</decl_stmt>
}</block>;</struct>




<struct>struct <name>block_trailer</name> <block>{
<decl_stmt><decl><type><name>bpf_u_int32</name></type> <name>total_length</name></decl>;</decl_stmt>
}</block>;</struct>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPT_ENDOFOPT</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPT_COMMENT</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>




<struct>struct <name>option_header</name> <block>{
<decl_stmt><decl><type><name>u_short</name></type> <name>option_code</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>u_short</name></type> <name>option_length</name></decl>;</decl_stmt>
}</block>;</struct>









<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BT_SHB</name></cpp:macro> <cpp:value>0x0A0D0D0A</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BT_SHB_INSANE_MAX</name></cpp:macro> <cpp:value>1024U*1024U*1U</cpp:value></cpp:define>
<struct>struct <name>section_header_block</name> <block>{
<decl_stmt><decl><type><name>bpf_u_int32</name></type> <name>byte_order_magic</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>u_short</name></type> <name>major_version</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>u_short</name></type> <name>minor_version</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>section_length</name></decl>;</decl_stmt>

}</block>;</struct>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BYTE_ORDER_MAGIC</name></cpp:macro> <cpp:value>0x1A2B3C4D</cpp:value></cpp:define>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCAP_NG_VERSION_MAJOR</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCAP_NG_VERSION_MINOR</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BT_IDB</name></cpp:macro> <cpp:value>0x00000001</cpp:value></cpp:define>

<struct>struct <name>interface_description_block</name> <block>{
<decl_stmt><decl><type><name>u_short</name></type> <name>linktype</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>u_short</name></type> <name>reserved</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bpf_u_int32</name></type> <name>snaplen</name></decl>;</decl_stmt>

}</block>;</struct>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IF_NAME</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IF_DESCRIPTION</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IF_IPV4ADDR</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IF_IPV6ADDR</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IF_MACADDR</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IF_EUIADDR</name></cpp:macro> <cpp:value>7</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IF_SPEED</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IF_TSRESOL</name></cpp:macro> <cpp:value>9</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IF_TZONE</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IF_FILTER</name></cpp:macro> <cpp:value>11</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IF_OS</name></cpp:macro> <cpp:value>12</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IF_FCSLEN</name></cpp:macro> <cpp:value>13</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IF_TSOFFSET</name></cpp:macro> <cpp:value>14</cpp:value></cpp:define>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BT_EPB</name></cpp:macro> <cpp:value>0x00000006</cpp:value></cpp:define>

<struct>struct <name>enhanced_packet_block</name> <block>{
<decl_stmt><decl><type><name>bpf_u_int32</name></type> <name>interface_id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bpf_u_int32</name></type> <name>timestamp_high</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bpf_u_int32</name></type> <name>timestamp_low</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bpf_u_int32</name></type> <name>caplen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bpf_u_int32</name></type> <name>len</name></decl>;</decl_stmt>

}</block>;</struct>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BT_SPB</name></cpp:macro> <cpp:value>0x00000003</cpp:value></cpp:define>

<struct>struct <name>simple_packet_block</name> <block>{
<decl_stmt><decl><type><name>bpf_u_int32</name></type> <name>len</name></decl>;</decl_stmt>

}</block>;</struct>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BT_PB</name></cpp:macro> <cpp:value>0x00000002</cpp:value></cpp:define>

<struct>struct <name>packet_block</name> <block>{
<decl_stmt><decl><type><name>u_short</name></type> <name>interface_id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>u_short</name></type> <name>drops_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bpf_u_int32</name></type> <name>timestamp_high</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bpf_u_int32</name></type> <name>timestamp_low</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bpf_u_int32</name></type> <name>caplen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bpf_u_int32</name></type> <name>len</name></decl>;</decl_stmt>

}</block>;</struct>






<struct>struct <name>block_cursor</name> <block>{
<decl_stmt><decl><type><name>u_char</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>data_remaining</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bpf_u_int32</name></type> <name>block_type</name></decl>;</decl_stmt>
}</block>;</struct>

<typedef>typedef <type><enum>enum <block>{
<decl><name>PASS_THROUGH</name></decl>,
<decl><name>SCALE_UP_DEC</name></decl>,
<decl><name>SCALE_DOWN_DEC</name></decl>,
<decl><name>SCALE_UP_BIN</name></decl>,
<decl><name>SCALE_DOWN_BIN</name></decl>
}</block></enum></type> <name>tstamp_scale_type_t</name>;</typedef>




<struct>struct <name>pcap_ng_if</name> <block>{
<decl_stmt><decl><type><name>uint64_t</name></type> <name>tsresol</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>tstamp_scale_type_t</name></type> <name>scale_type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>scale_factor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>tsoffset</name></decl>;</decl_stmt>
}</block>;</struct>




















<struct>struct <name>pcap_ng_sf</name> <block>{
<decl_stmt><decl><type><name>uint64_t</name></type> <name>user_tsresol</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>u_int</name></type> <name>max_blocksize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bpf_u_int32</name></type> <name>ifcount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bpf_u_int32</name></type> <name>ifaces_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>pcap_ng_if</name></name> <modifier>*</modifier></type><name>ifaces</name></decl>;</decl_stmt>
}</block>;</struct>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INITIAL_MAX_BLOCKSIZE</name></cpp:macro> <cpp:value>(16*1024*1024)</cpp:value></cpp:define>






<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_BLOCKSIZE_FOR_SNAPLEN</name><parameter_list>(<parameter><type><name>max_snaplen</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(sizeof (struct block_header) + sizeof (struct enhanced_packet_block) + (max_snaplen) + 131072 + sizeof (struct block_trailer))</cpp:value></cpp:define>





<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pcap_ng_cleanup</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>pcap_ng_next_packet</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>pcap_pkthdr</name></name> <modifier>*</modifier></type><name>hdr</name></decl></parameter>,
<parameter><decl><type><name>u_char</name> <modifier>*</modifier><modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>read_bytes</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>bytes_to_read</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fail_on_eof</name></decl></parameter>,
<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>errbuf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>amt_read</name></decl>;</decl_stmt>

<expr_stmt><expr><name>amt_read</name> <operator>=</operator> <call><name>fread</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>bytes_to_read</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>amt_read</name> <operator>!=</operator> <name>bytes_to_read</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pcap_fmt_errmsg_for_errno</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><name>errno</name></expr></argument>, <argument><expr><literal type="string">"error reading dump file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>amt_read</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>fail_on_eof</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"truncated pcapng dump file; tried to read %"</literal> <name>PRIsize</name> <literal type="string">" bytes, only got %"</literal> <name>PRIsize</name></expr></argument>,
<argument><expr><name>bytes_to_read</name></expr></argument>, <argument><expr><name>amt_read</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>read_block</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>, <parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>block_cursor</name></name> <modifier>*</modifier></type><name>cursor</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>errbuf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>pcap_ng_sf</name></name> <modifier>*</modifier></type><name>ps</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>block_header</name></name></type> <name>bhdr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>block_trailer</name></name> <modifier>*</modifier></type><name>btrlr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>u_char</name> <modifier>*</modifier></type><name>bdata</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>data_remaining</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ps</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>priv</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>read_bytes</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bhdr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bhdr</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>status</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>status</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>swapped</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>bhdr</name><operator>.</operator><name>block_type</name></name> <operator>=</operator> <call><name>SWAPLONG</name><argument_list>(<argument><expr><name><name>bhdr</name><operator>.</operator><name>block_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bhdr</name><operator>.</operator><name>total_length</name></name> <operator>=</operator> <call><name>SWAPLONG</name><argument_list>(<argument><expr><name><name>bhdr</name><operator>.</operator><name>total_length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>





<if_stmt><if>if <condition>(<expr><name><name>bhdr</name><operator>.</operator><name>total_length</name></name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>block_header</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
<sizeof>sizeof<argument_list>(<argument><expr>struct <name>block_trailer</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"block in pcapng dump file has a length of %u &lt; %"</literal> <name>PRIsize</name></expr></argument>,
<argument><expr><name><name>bhdr</name><operator>.</operator><name>total_length</name></name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>block_header</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>block_trailer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>bhdr</name><operator>.</operator><name>total_length</name></name> <operator>%</operator> <literal type="number">4</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"block in pcapng dump file has a length of %u that is not a multiple of 4"</literal> <name>PRIsize</name></expr></argument>,
<argument><expr><name><name>bhdr</name><operator>.</operator><name>total_length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>bufsize</name></name> <operator>&lt;</operator> <name><name>bhdr</name><operator>.</operator><name>total_length</name></name></expr>)</condition> <block>{<block_content>




<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>bigger_buffer</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bhdr</name><operator>.</operator><name>total_length</name></name> <operator>&gt;</operator> <name><name>ps</name><operator>-&gt;</operator><name>max_blocksize</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>, <argument><expr><literal type="string">"pcapng block size %u &gt; maximum %u"</literal></expr></argument>, <argument><expr><name><name>bhdr</name><operator>.</operator><name>total_length</name></name></expr></argument>,
<argument><expr><name><name>ps</name><operator>-&gt;</operator><name>max_blocksize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>bigger_buffer</name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name><name>bhdr</name><operator>.</operator><name>total_length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bigger_buffer</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>, <argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <name>bigger_buffer</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>





<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bhdr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bhdr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bdata</name> <operator>=</operator> <operator>(</operator><name>u_char</name> <operator>*</operator><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>buffer</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bhdr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name>data_remaining</name> <operator>=</operator> <name><name>bhdr</name><operator>.</operator><name>total_length</name></name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bhdr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>read_bytes</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>bdata</name></expr></argument>, <argument><expr><name>data_remaining</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>




<expr_stmt><expr><name>btrlr</name> <operator>=</operator> <operator>(</operator>struct <name>block_trailer</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>bdata</name> <operator>+</operator> <name>data_remaining</name> <operator>-</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>block_trailer</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>swapped</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>btrlr</name><operator>-&gt;</operator><name>total_length</name></name> <operator>=</operator> <call><name>SWAPLONG</name><argument_list>(<argument><expr><name><name>btrlr</name><operator>-&gt;</operator><name>total_length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>





<if_stmt><if>if <condition>(<expr><name><name>bhdr</name><operator>.</operator><name>total_length</name></name> <operator>!=</operator> <name><name>btrlr</name><operator>-&gt;</operator><name>total_length</name></name></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"block total length in header and trailer don't match"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>




<expr_stmt><expr><name><name>cursor</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name>bdata</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cursor</name><operator>-&gt;</operator><name>data_remaining</name></name> <operator>=</operator> <name>data_remaining</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>block_trailer</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cursor</name><operator>-&gt;</operator><name>block_type</name></name> <operator>=</operator> <name><name>bhdr</name><operator>.</operator><name>block_type</name></name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>get_from_block_data</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>block_cursor</name></name> <modifier>*</modifier></type><name>cursor</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>chunk_size</name></decl></parameter>,
<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>errbuf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><name><name>cursor</name><operator>-&gt;</operator><name>data_remaining</name></name> <operator>&lt;</operator> <name>chunk_size</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"block of type %u in pcapng dump file is too short"</literal></expr></argument>,
<argument><expr><name><name>cursor</name><operator>-&gt;</operator><name>block_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>




<expr_stmt><expr><name>data</name> <operator>=</operator> <name><name>cursor</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cursor</name><operator>-&gt;</operator><name>data</name></name> <operator>+=</operator> <name>chunk_size</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cursor</name><operator>-&gt;</operator><name>data_remaining</name></name> <operator>-=</operator> <name>chunk_size</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>data</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>option_header</name></name> <modifier>*</modifier></type>
<name>get_opthdr_from_block_data</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>block_cursor</name></name> <modifier>*</modifier></type><name>cursor</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>errbuf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>option_header</name></name> <modifier>*</modifier></type><name>opthdr</name></decl>;</decl_stmt>

<expr_stmt><expr><name>opthdr</name> <operator>=</operator> <call><name>get_from_block_data</name><argument_list>(<argument><expr><name>cursor</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>opthdr</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>opthdr</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>



<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>swapped</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>opthdr</name><operator>-&gt;</operator><name>option_code</name></name> <operator>=</operator> <call><name>SWAPSHORT</name><argument_list>(<argument><expr><name><name>opthdr</name><operator>-&gt;</operator><name>option_code</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>opthdr</name><operator>-&gt;</operator><name>option_length</name></name> <operator>=</operator> <call><name>SWAPSHORT</name><argument_list>(<argument><expr><name><name>opthdr</name><operator>-&gt;</operator><name>option_length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><operator>(</operator><name>opthdr</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>get_optvalue_from_block_data</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>block_cursor</name></name> <modifier>*</modifier></type><name>cursor</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>option_header</name></name> <modifier>*</modifier></type><name>opthdr</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>errbuf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>padded_option_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>optvalue</name></decl>;</decl_stmt>


<expr_stmt><expr><name>padded_option_len</name> <operator>=</operator> <name><name>opthdr</name><operator>-&gt;</operator><name>option_length</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>padded_option_len</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>padded_option_len</name> <operator>+</operator> <literal type="number">3</literal><operator>)</operator><operator>/</operator><literal type="number">4</literal><operator>)</operator><operator>*</operator><literal type="number">4</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>optvalue</name> <operator>=</operator> <call><name>get_from_block_data</name><argument_list>(<argument><expr><name>cursor</name></expr></argument>, <argument><expr><name>padded_option_len</name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>optvalue</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>



<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><operator>(</operator><name>optvalue</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>process_idb_options</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>block_cursor</name></name> <modifier>*</modifier></type><name>cursor</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>tsresol</name></decl></parameter>,
<parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>tsoffset</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>is_binary</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>errbuf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>option_header</name></name> <modifier>*</modifier></type><name>opthdr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>optvalue</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>saw_tsresol</name></decl>, <decl><type ref="prev"/><name>saw_tsoffset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>tsresol_opt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>u_int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>saw_tsresol</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>saw_tsoffset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name><name>cursor</name><operator>-&gt;</operator><name>data_remaining</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><name>opthdr</name> <operator>=</operator> <call><name>get_opthdr_from_block_data</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>cursor</name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>opthdr</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>



<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>




<expr_stmt><expr><name>optvalue</name> <operator>=</operator> <call><name>get_optvalue_from_block_data</name><argument_list>(<argument><expr><name>cursor</name></expr></argument>, <argument><expr><name>opthdr</name></expr></argument>,
<argument><expr><name>errbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>optvalue</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>



<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>opthdr</name><operator>-&gt;</operator><name>option_code</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>OPT_ENDOFOPT</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>opthdr</name><operator>-&gt;</operator><name>option_length</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"Interface Description Block has opt_endofopt option with length %u != 0"</literal></expr></argument>,
<argument><expr><name><name>opthdr</name><operator>-&gt;</operator><name>option_length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<goto>goto <name>done</name>;</goto>

<case>case <expr><name>IF_TSRESOL</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>opthdr</name><operator>-&gt;</operator><name>option_length</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"Interface Description Block has if_tsresol option with length %u != 1"</literal></expr></argument>,
<argument><expr><name><name>opthdr</name><operator>-&gt;</operator><name>option_length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>saw_tsresol</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"Interface Description Block has more than one if_tsresol option"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>saw_tsresol</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tsresol_opt</name></expr></argument>, <argument><expr><name>optvalue</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tsresol_opt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tsresol_opt</name> <operator>&amp;</operator> <literal type="number">0x80</literal></expr>)</condition> <block>{<block_content>



<decl_stmt><decl><type><name>uint8_t</name></type> <name>tsresol_shift</name> <init>= <expr><operator>(</operator><name>tsresol_opt</name> <operator>&amp;</operator> <literal type="number">0x7F</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>tsresol_shift</name> <operator>&gt;</operator> <literal type="number">63</literal></expr>)</condition> <block>{<block_content>




<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"Interface Description Block if_tsresol option resolution 2^-%u is too high"</literal></expr></argument>,
<argument><expr><name>tsresol_shift</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>is_binary</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>tsresol</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>tsresol_shift</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>



<if_stmt><if>if <condition>(<expr><name>tsresol_opt</name> <operator>&gt;</operator> <literal type="number">19</literal></expr>)</condition> <block>{<block_content>








<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"Interface Description Block if_tsresol option resolution 10^-%u is too high"</literal></expr></argument>,
<argument><expr><name>tsresol_opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>is_binary</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>tsresol</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>tsresol_opt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>tsresol</name> <operator>*=</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></else></if_stmt>
<break>break;</break>

<case>case <expr><name>IF_TSOFFSET</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>opthdr</name><operator>-&gt;</operator><name>option_length</name></name> <operator>!=</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"Interface Description Block has if_tsoffset option with length %u != 8"</literal></expr></argument>,
<argument><expr><name><name>opthdr</name><operator>-&gt;</operator><name>option_length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>saw_tsoffset</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"Interface Description Block has more than one if_tsoffset option"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>saw_tsoffset</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>tsoffset</name></expr></argument>, <argument><expr><name>optvalue</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>tsoffset</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>swapped</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>tsoffset</name> <operator>=</operator> <call><name>SWAPLL</name><argument_list>(<argument><expr><operator>*</operator><name>tsoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>

<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></while>

<label><name>done</name>:</label>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>add_interface</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>block_cursor</name></name> <modifier>*</modifier></type><name>cursor</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>errbuf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>pcap_ng_sf</name></name> <modifier>*</modifier></type><name>ps</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>tsresol</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>tsoffset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>is_binary</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ps</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>priv</name></name></expr>;</expr_stmt>




<expr_stmt><expr><name><name>ps</name><operator>-&gt;</operator><name>ifcount</name></name><operator>++</operator></expr>;</expr_stmt>




<if_stmt><if>if <condition>(<expr><name><name>ps</name><operator>-&gt;</operator><name>ifcount</name></name> <operator>&gt;</operator> <name><name>ps</name><operator>-&gt;</operator><name>ifaces_size</name></name></expr>)</condition> <block>{<block_content>



<decl_stmt><decl><type><name>bpf_u_int32</name></type> <name>new_ifaces_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>pcap_ng_if</name></name> <modifier>*</modifier></type><name>new_ifaces</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ps</name><operator>-&gt;</operator><name>ifaces_size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
















<expr_stmt><expr><name>new_ifaces_size</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>new_ifaces</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>pcap_ng_if</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>






<if_stmt><if>if <condition>(<expr><name><name>ps</name><operator>-&gt;</operator><name>ifaces_size</name></name> <operator>*</operator> <literal type="number">2</literal> <operator>&lt;</operator> <name><name>ps</name><operator>-&gt;</operator><name>ifaces_size</name></name></expr>)</condition> <block>{<block_content>






<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"more than %u interfaces in the file"</literal></expr></argument>,
<argument><expr><literal type="number">0x80000000U</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>





<expr_stmt><expr><name>new_ifaces_size</name> <operator>=</operator> <name><name>ps</name><operator>-&gt;</operator><name>ifaces_size</name></name> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>










<if_stmt><if>if <condition>(<expr><name>new_ifaces_size</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>pcap_ng_if</name></expr></argument>)</argument_list></sizeof> <operator>&lt;</operator> <name>new_ifaces_size</name></expr>)</condition> <block>{<block_content>









<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"more than %u interfaces in the file"</literal></expr></argument>,
<argument><expr><literal type="number">0xFFFFFFFFU</literal> <operator>/</operator> <operator>(</operator><operator>(</operator><name>u_int</name><operator>)</operator><sizeof>sizeof <argument_list>(<argument><expr>struct <name>pcap_ng_if</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>new_ifaces</name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><name><name>ps</name><operator>-&gt;</operator><name>ifaces</name></name></expr></argument>, <argument><expr><name>new_ifaces_size</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>pcap_ng_if</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>new_ifaces</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>




<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"out of memory for per-interface information (%u interfaces)"</literal></expr></argument>,
<argument><expr><name><name>ps</name><operator>-&gt;</operator><name>ifcount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>ps</name><operator>-&gt;</operator><name>ifaces_size</name></name> <operator>=</operator> <name>new_ifaces_size</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ps</name><operator>-&gt;</operator><name>ifaces</name></name> <operator>=</operator> <name>new_ifaces</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>




<expr_stmt><expr><name>tsresol</name> <operator>=</operator> <literal type="number">1000000</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>is_binary</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>tsoffset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>





<if_stmt><if>if <condition>(<expr><call><name>process_idb_options</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>cursor</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tsresol</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tsoffset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_binary</name></expr></argument>,
<argument><expr><name>errbuf</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>ps</name><operator>-&gt;</operator><name>ifaces</name><index>[<expr><name><name>ps</name><operator>-&gt;</operator><name>ifcount</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>tsresol</name> <operator>=</operator> <name>tsresol</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ps</name><operator>-&gt;</operator><name>ifaces</name><index>[<expr><name><name>ps</name><operator>-&gt;</operator><name>ifcount</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>tsoffset</name> <operator>=</operator> <name>tsoffset</name></expr>;</expr_stmt>





<if_stmt><if>if <condition>(<expr><name>tsresol</name> <operator>==</operator> <name><name>ps</name><operator>-&gt;</operator><name>user_tsresol</name></name></expr>)</condition> <block>{<block_content>




<expr_stmt><expr><name><name>ps</name><operator>-&gt;</operator><name>ifaces</name><index>[<expr><name><name>ps</name><operator>-&gt;</operator><name>ifcount</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>scale_type</name> <operator>=</operator> <name>PASS_THROUGH</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>tsresol</name> <operator>&gt;</operator> <name><name>ps</name><operator>-&gt;</operator><name>user_tsresol</name></name></expr>)</condition> <block>{<block_content>




<if_stmt><if>if <condition>(<expr><name>is_binary</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ps</name><operator>-&gt;</operator><name>ifaces</name><index>[<expr><name><name>ps</name><operator>-&gt;</operator><name>ifcount</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>scale_type</name> <operator>=</operator> <name>SCALE_DOWN_BIN</name></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>



<expr_stmt><expr><name><name>ps</name><operator>-&gt;</operator><name>ifaces</name><index>[<expr><name><name>ps</name><operator>-&gt;</operator><name>ifcount</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>scale_factor</name> <operator>=</operator> <name>tsresol</name><operator>/</operator><name><name>ps</name><operator>-&gt;</operator><name>user_tsresol</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ps</name><operator>-&gt;</operator><name>ifaces</name><index>[<expr><name><name>ps</name><operator>-&gt;</operator><name>ifcount</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>scale_type</name> <operator>=</operator> <name>SCALE_DOWN_DEC</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>




<if_stmt><if>if <condition>(<expr><name>is_binary</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ps</name><operator>-&gt;</operator><name>ifaces</name><index>[<expr><name><name>ps</name><operator>-&gt;</operator><name>ifcount</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>scale_type</name> <operator>=</operator> <name>SCALE_UP_BIN</name></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>



<expr_stmt><expr><name><name>ps</name><operator>-&gt;</operator><name>ifaces</name><index>[<expr><name><name>ps</name><operator>-&gt;</operator><name>ifcount</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>scale_factor</name> <operator>=</operator> <name><name>ps</name><operator>-&gt;</operator><name>user_tsresol</name></name><operator>/</operator><name>tsresol</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ps</name><operator>-&gt;</operator><name>ifaces</name><index>[<expr><name><name>ps</name><operator>-&gt;</operator><name>ifcount</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>scale_type</name> <operator>=</operator> <name>SCALE_UP_DEC</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>





<function><type><name>pcap_t</name> <modifier>*</modifier></type>
<name>pcap_ng_check_header</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>magic</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>, <parameter><decl><type><name>u_int</name></type> <name>precision</name></decl></parameter>,
<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>errbuf</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>bpf_u_int32</name></type> <name>magic_int</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>amt_read</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bpf_u_int32</name></type> <name>total_length</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bpf_u_int32</name></type> <name>byte_order_magic</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>block_header</name></name> <modifier>*</modifier></type><name>bhdrp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>section_header_block</name></name> <modifier>*</modifier></type><name>shbp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>swapped</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>pcap_ng_sf</name></name> <modifier>*</modifier></type><name>ps</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>block_cursor</name></name></type> <name>cursor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>interface_description_block</name></name> <modifier>*</modifier></type><name>idbp</name></decl>;</decl_stmt>




<expr_stmt><expr><operator>*</operator><name>err</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>





<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>magic_int</name></expr></argument>, <argument><expr><name>magic</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>magic_int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>magic_int</name> <operator>!=</operator> <name>BT_SHB</name></expr>)</condition> <block>{<block_content>









<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>












<expr_stmt><expr><name>amt_read</name> <operator>=</operator> <call><name>fread</name><argument_list>(<argument><expr><operator>&amp;</operator><name>total_length</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>total_length</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>amt_read</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>total_length</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pcap_fmt_errmsg_for_errno</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><name>errno</name></expr></argument>, <argument><expr><literal type="string">"error reading dump file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>err</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>





<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>amt_read</name> <operator>=</operator> <call><name>fread</name><argument_list>(<argument><expr><operator>&amp;</operator><name>byte_order_magic</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>byte_order_magic</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>amt_read</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>byte_order_magic</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pcap_fmt_errmsg_for_errno</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><name>errno</name></expr></argument>, <argument><expr><literal type="string">"error reading dump file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>err</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>





<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>byte_order_magic</name> <operator>!=</operator> <name>BYTE_ORDER_MAGIC</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>byte_order_magic</name> <operator>=</operator> <call><name>SWAPLONG</name><argument_list>(<argument><expr><name>byte_order_magic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>byte_order_magic</name> <operator>!=</operator> <name>BYTE_ORDER_MAGIC</name></expr>)</condition> <block>{<block_content>



<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>swapped</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>total_length</name> <operator>=</operator> <call><name>SWAPLONG</name><argument_list>(<argument><expr><name>total_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><name>total_length</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>bhdrp</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>shbp</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>block_trailer</name></expr></argument>)</argument_list></sizeof> <operator>||</operator>
<operator>(</operator><name>total_length</name> <operator>&gt;</operator> <name>BT_SHB_INSANE_MAX</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"Section Header Block in pcapng dump file has invalid length %"</literal> <name>PRIsize</name> <literal type="string">" &lt; _%u_ &lt; %u (BT_SHB_INSANE_MAX)"</literal></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>bhdrp</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>shbp</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>block_trailer</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><name>total_length</name></expr></argument>,
<argument><expr><name>BT_SHB_INSANE_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>err</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>





<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>pcap_open_offline_common</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>pcap_ng_sf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>err</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>swapped</name></name> <operator>=</operator> <name>swapped</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ps</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>priv</name></name></expr>;</expr_stmt>




<switch>switch <condition>(<expr><name>precision</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>PCAP_TSTAMP_PRECISION_MICRO</name></expr>:</case>
<expr_stmt><expr><name><name>ps</name><operator>-&gt;</operator><name>user_tsresol</name></name> <operator>=</operator> <literal type="number">1000000</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>PCAP_TSTAMP_PRECISION_NANO</name></expr>:</case>
<expr_stmt><expr><name><name>ps</name><operator>-&gt;</operator><name>user_tsresol</name></name> <operator>=</operator> <literal type="number">1000000000</literal></expr>;</expr_stmt>
<break>break;</break>

<default>default:</default>
<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"unknown time stamp resolution %u"</literal></expr></argument>, <argument><expr><name>precision</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>err</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>tstamp_precision</name></name> <operator>=</operator> <name>precision</name></expr>;</expr_stmt>

















<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bufsize</name></name> <operator>=</operator> <literal type="number">2048</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>bufsize</name></name> <operator>&lt;</operator> <name>total_length</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bufsize</name></name> <operator>=</operator> <name>total_length</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>bufsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>buffer</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>, <argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>err</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>ps</name><operator>-&gt;</operator><name>max_blocksize</name></name> <operator>=</operator> <name>INITIAL_MAX_BLOCKSIZE</name></expr>;</expr_stmt>





<expr_stmt><expr><name>bhdrp</name> <operator>=</operator> <operator>(</operator>struct <name>block_header</name> <operator>*</operator><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>buffer</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>shbp</name> <operator>=</operator> <operator>(</operator>struct <name>section_header_block</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>u_char</name> <operator>*</operator><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>buffer</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>block_header</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bhdrp</name><operator>-&gt;</operator><name>block_type</name></name> <operator>=</operator> <name>magic_int</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bhdrp</name><operator>-&gt;</operator><name>total_length</name></name> <operator>=</operator> <name>total_length</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shbp</name><operator>-&gt;</operator><name>byte_order_magic</name></name> <operator>=</operator> <name>byte_order_magic</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>read_bytes</name><argument_list>(<argument><expr><name>fp</name></expr></argument>,
<argument><expr><operator>(</operator><name>u_char</name> <operator>*</operator><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>buffer</name></name> <operator>+</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>magic_int</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>total_length</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>byte_order_magic</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>,
<argument><expr><name>total_length</name> <operator>-</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>magic_int</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>total_length</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>byte_order_magic</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>,
<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>swapped</name></name></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><name><name>shbp</name><operator>-&gt;</operator><name>major_version</name></name> <operator>=</operator> <call><name>SWAPSHORT</name><argument_list>(<argument><expr><name><name>shbp</name><operator>-&gt;</operator><name>major_version</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shbp</name><operator>-&gt;</operator><name>minor_version</name></name> <operator>=</operator> <call><name>SWAPSHORT</name><argument_list>(<argument><expr><name><name>shbp</name><operator>-&gt;</operator><name>minor_version</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator> <operator>(</operator><name><name>shbp</name><operator>-&gt;</operator><name>major_version</name></name> <operator>==</operator> <name>PCAP_NG_VERSION_MAJOR</name> <operator>&amp;&amp;</operator>
<name><name>shbp</name><operator>-&gt;</operator><name>minor_version</name></name> <operator>==</operator> <name>PCAP_NG_VERSION_MINOR</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"unsupported pcapng savefile version %u.%u"</literal></expr></argument>,
<argument><expr><name><name>shbp</name><operator>-&gt;</operator><name>major_version</name></name></expr></argument>, <argument><expr><name><name>shbp</name><operator>-&gt;</operator><name>minor_version</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>version_major</name></name> <operator>=</operator> <name><name>shbp</name><operator>-&gt;</operator><name>major_version</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>version_minor</name></name> <operator>=</operator> <name><name>shbp</name><operator>-&gt;</operator><name>minor_version</name></name></expr>;</expr_stmt>




<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>opt</name><operator>.</operator><name>tstamp_precision</name></name> <operator>=</operator> <name>precision</name></expr>;</expr_stmt>




<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>



<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>read_block</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cursor</name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"the capture file has no Interface Description Blocks"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
<switch>switch <condition>(<expr><name><name>cursor</name><operator>.</operator><name>block_type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>BT_IDB</name></expr>:</case>




<expr_stmt><expr><name>idbp</name> <operator>=</operator> <call><name>get_from_block_data</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cursor</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>idbp</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><name>errbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>idbp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>swapped</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>idbp</name><operator>-&gt;</operator><name>linktype</name></name> <operator>=</operator> <call><name>SWAPSHORT</name><argument_list>(<argument><expr><name><name>idbp</name><operator>-&gt;</operator><name>linktype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>idbp</name><operator>-&gt;</operator><name>snaplen</name></name> <operator>=</operator> <call><name>SWAPLONG</name><argument_list>(<argument><expr><name><name>idbp</name><operator>-&gt;</operator><name>snaplen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>add_interface</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cursor</name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

<goto>goto <name>done</name>;</goto>

<case>case <expr><name>BT_EPB</name></expr>:</case>
<case>case <expr><name>BT_SPB</name></expr>:</case>
<case>case <expr><name>BT_PB</name></expr>:</case>





<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"the capture file has a packet block before any Interface Description Blocks"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>

<default>default:</default>



<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></for>

<label><name>done</name>:</label>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>tzoff</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>linktype</name></name> <operator>=</operator> <call><name>linktype_to_dlt</name><argument_list>(<argument><expr><name><name>idbp</name><operator>-&gt;</operator><name>linktype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>snapshot</name></name> <operator>=</operator> <call><name>pcap_adjust_snapshot</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>linktype</name></name></expr></argument>, <argument><expr><name><name>idbp</name><operator>-&gt;</operator><name>snaplen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>linktype_ext</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>






<if_stmt><if>if <condition>(<expr><call><name>MAX_BLOCKSIZE_FOR_SNAPLEN</name><argument_list>(<argument><expr><call><name>max_snaplen_for_dlt</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>linktype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name><name>ps</name><operator>-&gt;</operator><name>max_blocksize</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ps</name><operator>-&gt;</operator><name>max_blocksize</name></name> <operator>=</operator> <call><name>MAX_BLOCKSIZE_FOR_SNAPLEN</name><argument_list>(<argument><expr><call><name>max_snaplen_for_dlt</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>linktype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>next_packet_op</name></name> <operator>=</operator> <name>pcap_ng_next_packet</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cleanup_op</name></name> <operator>=</operator> <name>pcap_ng_cleanup</name></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>p</name><operator>)</operator></expr>;</return>

<label><name>fail</name>:</label>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>ps</name><operator>-&gt;</operator><name>ifaces</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>err</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>pcap_ng_cleanup</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>pcap_ng_sf</name></name> <modifier>*</modifier></type><name>ps</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>ps</name><operator>-&gt;</operator><name>ifaces</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sf_cleanup</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>int</name></type>
<name>pcap_ng_next_packet</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>pcap_pkthdr</name></name> <modifier>*</modifier></type><name>hdr</name></decl></parameter>, <parameter><decl><type><name>u_char</name> <modifier>*</modifier><modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>pcap_ng_sf</name></name> <modifier>*</modifier></type><name>ps</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>priv</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>block_cursor</name></name></type> <name>cursor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>enhanced_packet_block</name></name> <modifier>*</modifier></type><name>epbp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>simple_packet_block</name></name> <modifier>*</modifier></type><name>spbp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>packet_block</name></name> <modifier>*</modifier></type><name>pbp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bpf_u_int32</name></type> <name>interface_id</name> <init>= <expr><literal type="number">0xFFFFFFFF</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>interface_description_block</name></name> <modifier>*</modifier></type><name>idbp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>section_header_block</name></name> <modifier>*</modifier></type><name>shbp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>rfile</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>t</name></decl>, <decl><type ref="prev"/><name>sec</name></decl>, <decl><type ref="prev"/><name>frac</name></decl>;</decl_stmt>





<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>




<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>read_block</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cursor</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<switch>switch <condition>(<expr><name><name>cursor</name><operator>.</operator><name>block_type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>BT_EPB</name></expr>:</case>




<expr_stmt><expr><name>epbp</name> <operator>=</operator> <call><name>get_from_block_data</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cursor</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>epbp</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>epbp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>swapped</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>interface_id</name> <operator>=</operator> <call><name>SWAPLONG</name><argument_list>(<argument><expr><name><name>epbp</name><operator>-&gt;</operator><name>interface_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>caplen</name></name> <operator>=</operator> <call><name>SWAPLONG</name><argument_list>(<argument><expr><name><name>epbp</name><operator>-&gt;</operator><name>caplen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <call><name>SWAPLONG</name><argument_list>(<argument><expr><name><name>epbp</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>t</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><call><name>SWAPLONG</name><argument_list>(<argument><expr><name><name>epbp</name><operator>-&gt;</operator><name>timestamp_high</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">32</literal> <operator>|</operator>
<call><name>SWAPLONG</name><argument_list>(<argument><expr><name><name>epbp</name><operator>-&gt;</operator><name>timestamp_low</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>interface_id</name> <operator>=</operator> <name><name>epbp</name><operator>-&gt;</operator><name>interface_id</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>caplen</name></name> <operator>=</operator> <name><name>epbp</name><operator>-&gt;</operator><name>caplen</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name><name>epbp</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>t</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>epbp</name><operator>-&gt;</operator><name>timestamp_high</name></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">32</literal> <operator>|</operator>
<name><name>epbp</name><operator>-&gt;</operator><name>timestamp_low</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<goto>goto <name>found</name>;</goto>

<case>case <expr><name>BT_SPB</name></expr>:</case>




<expr_stmt><expr><name>spbp</name> <operator>=</operator> <call><name>get_from_block_data</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cursor</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>spbp</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>spbp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>





<expr_stmt><expr><name>interface_id</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>




<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>swapped</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <call><name>SWAPLONG</name><argument_list>(<argument><expr><name><name>spbp</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name><name>spbp</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>






<expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>caplen</name></name> <operator>=</operator> <name><name>hdr</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>caplen</name></name> <operator>&gt;</operator> <operator>(</operator><name>bpf_u_int32</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>snapshot</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>caplen</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>snapshot</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>t</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<goto>goto <name>found</name>;</goto>

<case>case <expr><name>BT_PB</name></expr>:</case>




<expr_stmt><expr><name>pbp</name> <operator>=</operator> <call><name>get_from_block_data</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cursor</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pbp</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pbp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>swapped</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>interface_id</name> <operator>=</operator> <call><name>SWAPSHORT</name><argument_list>(<argument><expr><name><name>pbp</name><operator>-&gt;</operator><name>interface_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>caplen</name></name> <operator>=</operator> <call><name>SWAPLONG</name><argument_list>(<argument><expr><name><name>pbp</name><operator>-&gt;</operator><name>caplen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <call><name>SWAPLONG</name><argument_list>(<argument><expr><name><name>pbp</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>t</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><call><name>SWAPLONG</name><argument_list>(<argument><expr><name><name>pbp</name><operator>-&gt;</operator><name>timestamp_high</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">32</literal> <operator>|</operator>
<call><name>SWAPLONG</name><argument_list>(<argument><expr><name><name>pbp</name><operator>-&gt;</operator><name>timestamp_low</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>interface_id</name> <operator>=</operator> <name><name>pbp</name><operator>-&gt;</operator><name>interface_id</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>caplen</name></name> <operator>=</operator> <name><name>pbp</name><operator>-&gt;</operator><name>caplen</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name><name>pbp</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>t</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>pbp</name><operator>-&gt;</operator><name>timestamp_high</name></name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">32</literal> <operator>|</operator>
<name><name>pbp</name><operator>-&gt;</operator><name>timestamp_low</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<goto>goto <name>found</name>;</goto>

<case>case <expr><name>BT_IDB</name></expr>:</case>




<expr_stmt><expr><name>idbp</name> <operator>=</operator> <call><name>get_from_block_data</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cursor</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>idbp</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>idbp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>swapped</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>idbp</name><operator>-&gt;</operator><name>linktype</name></name> <operator>=</operator> <call><name>SWAPSHORT</name><argument_list>(<argument><expr><name><name>idbp</name><operator>-&gt;</operator><name>linktype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>idbp</name><operator>-&gt;</operator><name>snaplen</name></name> <operator>=</operator> <call><name>SWAPLONG</name><argument_list>(<argument><expr><name><name>idbp</name><operator>-&gt;</operator><name>snaplen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>









<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>linktype</name></name> <operator>!=</operator> <name><name>idbp</name><operator>-&gt;</operator><name>linktype</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"an interface has a type %u different from the type of the first interface"</literal></expr></argument>,
<argument><expr><name><name>idbp</name><operator>-&gt;</operator><name>linktype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>





<if_stmt><if>if <condition>(<expr><operator>(</operator><name>bpf_u_int32</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>snapshot</name></name> <operator>!=</operator>
<call><name>pcap_adjust_snapshot</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>linktype</name></name></expr></argument>, <argument><expr><name><name>idbp</name><operator>-&gt;</operator><name>snaplen</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"an interface has a snapshot length %u different from the type of the first interface"</literal></expr></argument>,
<argument><expr><name><name>idbp</name><operator>-&gt;</operator><name>snaplen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>add_interface</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cursor</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>BT_SHB</name></expr>:</case>




<expr_stmt><expr><name>shbp</name> <operator>=</operator> <call><name>get_from_block_data</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cursor</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>shbp</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>shbp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>






<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>swapped</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>shbp</name><operator>-&gt;</operator><name>byte_order_magic</name></name> <operator>=</operator>
<call><name>SWAPLONG</name><argument_list>(<argument><expr><name><name>shbp</name><operator>-&gt;</operator><name>byte_order_magic</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shbp</name><operator>-&gt;</operator><name>major_version</name></name> <operator>=</operator>
<call><name>SWAPSHORT</name><argument_list>(<argument><expr><name><name>shbp</name><operator>-&gt;</operator><name>major_version</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>






<switch>switch <condition>(<expr><name><name>shbp</name><operator>-&gt;</operator><name>byte_order_magic</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>BYTE_ORDER_MAGIC</name></expr>:</case>



<break>break;</break>

<case>case <expr><call><name>SWAPLONG</name><argument_list>(<argument><expr><name>BYTE_ORDER_MAGIC</name></expr></argument>)</argument_list></call></expr>:</case>



<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"the file has sections with different byte orders"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>

<default>default:</default>



<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"the file has a section with a bad byte order magic field"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></switch>





<if_stmt><if>if <condition>(<expr><name><name>shbp</name><operator>-&gt;</operator><name>major_version</name></name> <operator>!=</operator> <name>PCAP_NG_VERSION_MAJOR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"unknown pcapng savefile major version number %u"</literal></expr></argument>,
<argument><expr><name><name>shbp</name><operator>-&gt;</operator><name>major_version</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>










<expr_stmt><expr><name><name>ps</name><operator>-&gt;</operator><name>ifcount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>

<default>default:</default>



<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></for>

<label><name>found</name>:</label>



<if_stmt><if>if <condition>(<expr><name>interface_id</name> <operator>&gt;=</operator> <name><name>ps</name><operator>-&gt;</operator><name>ifcount</name></name></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"a packet arrived on interface %u, but there's no Interface Description Block for that interface"</literal></expr></argument>,
<argument><expr><name>interface_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>caplen</name></name> <operator>&gt;</operator> <operator>(</operator><name>bpf_u_int32</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>snapshot</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"invalid packet capture length %u, bigger than "</literal>
<literal type="string">"snaplen of %d"</literal></expr></argument>, <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>caplen</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>





<expr_stmt><expr><name>sec</name> <operator>=</operator> <name>t</name> <operator>/</operator> <name><name>ps</name><operator>-&gt;</operator><name>ifaces</name><index>[<expr><name>interface_id</name></expr>]</index></name><operator>.</operator><name>tsresol</name> <operator>+</operator> <name><name>ps</name><operator>-&gt;</operator><name>ifaces</name><index>[<expr><name>interface_id</name></expr>]</index></name><operator>.</operator><name>tsoffset</name></expr>;</expr_stmt>
<expr_stmt><expr><name>frac</name> <operator>=</operator> <name>t</name> <operator>%</operator> <name><name>ps</name><operator>-&gt;</operator><name>ifaces</name><index>[<expr><name>interface_id</name></expr>]</index></name><operator>.</operator><name>tsresol</name></expr>;</expr_stmt>





<switch>switch <condition>(<expr><name><name>ps</name><operator>-&gt;</operator><name>ifaces</name><index>[<expr><name>interface_id</name></expr>]</index></name><operator>.</operator><name>scale_type</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>PASS_THROUGH</name></expr>:</case>




<break>break;</break>

<case>case <expr><name>SCALE_UP_DEC</name></expr>:</case>













<expr_stmt><expr><name>frac</name> <operator>*=</operator> <name><name>ps</name><operator>-&gt;</operator><name>ifaces</name><index>[<expr><name>interface_id</name></expr>]</index></name><operator>.</operator><name>scale_factor</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>SCALE_UP_BIN</name></expr>:</case>



















<expr_stmt><expr><name>frac</name> <operator>*=</operator> <name><name>ps</name><operator>-&gt;</operator><name>user_tsresol</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>frac</name> <operator>/=</operator> <name><name>ps</name><operator>-&gt;</operator><name>ifaces</name><index>[<expr><name>interface_id</name></expr>]</index></name><operator>.</operator><name>tsresol</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>SCALE_DOWN_DEC</name></expr>:</case>















<expr_stmt><expr><name>frac</name> <operator>/=</operator> <name><name>ps</name><operator>-&gt;</operator><name>ifaces</name><index>[<expr><name>interface_id</name></expr>]</index></name><operator>.</operator><name>scale_factor</name></expr>;</expr_stmt>
<break>break;</break>


<case>case <expr><name>SCALE_DOWN_BIN</name></expr>:</case>






















<expr_stmt><expr><name>frac</name> <operator>*=</operator> <name><name>ps</name><operator>-&gt;</operator><name>user_tsresol</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>frac</name> <operator>/=</operator> <name><name>ps</name><operator>-&gt;</operator><name>ifaces</name><index>[<expr><name>interface_id</name></expr>]</index></name><operator>.</operator><name>tsresol</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>




<expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>ts</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator><name>sec</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>ts</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator><name>frac</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>






<expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>ts</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <operator>(</operator><name>time_t</name><operator>)</operator><name>sec</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>ts</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>frac</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>




<expr_stmt><expr><operator>*</operator><name>data</name> <operator>=</operator> <call><name>get_from_block_data</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cursor</name></expr></argument>, <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>caplen</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>data</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>swapped</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>swap_pseudo_headers</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>linktype</name></name></expr></argument>, <argument><expr><name>hdr</name></expr></argument>, <argument><expr><operator>*</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>
</unit>
