<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/libpcap/gencode.c">





















<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_CONFIG_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;config.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pcap-types.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ws2tcpip.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/socket.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__NetBSD__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/param.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netinet/in.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;arpa/inet.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;memory.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;setjmp.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MSDOS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pcap-dos.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pcap-int.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"extract.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ethertype.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nlpid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gencode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ieee80211.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"atmuni31.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sunatmpos.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ppp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pcap/sll.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pcap/ipnet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"arcnet.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"grammar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"scanner.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>linux</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>PF_PACKET</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SO_ATTACH_FILTER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;linux/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;linux/if_packet.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;linux/filter.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_NET_PFVAR_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/socket.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;net/if.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;net/pfvar.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;net/if_pflog.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>offsetof</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>offsetof</name><parameter_list>(<parameter><type><name>s</name></type></parameter>, <parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((size_t)&amp;((s *)0)-&gt;e)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>INET6</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__MINGW32__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>DEFINE_ADDITIONAL_IPV6_STUFF</name></expr></argument>)</argument_list></call></expr></cpp:if>

<struct>struct <name>in6_addr</name>
<block>{
<union>union
<block>{
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>u6_addr8</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint16_t</name></type> <name><name>u6_addr16</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name><name>u6_addr32</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
}</block> <decl><name>in6_u</name></decl>;</union>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>s6_addr</name></cpp:macro> <cpp:value>in6_u.u6_addr8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>s6_addr16</name></cpp:macro> <cpp:value>in6_u.u6_addr16</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>s6_addr32</name></cpp:macro> <cpp:value>in6_u.u6_addr32</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>s6_addr64</name></cpp:macro> <cpp:value>in6_u.u6_addr64</cpp:value></cpp:define>
}</block>;</struct>

<typedef>typedef <type><name>unsigned</name> <name>short</name></type> <name>sa_family_t</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>__SOCKADDR_COMMON</name><parameter_list>(<parameter><type><name>sa_prefix</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>sa_family_t sa_prefix##family</cpp:value></cpp:define>



<struct>struct <name>sockaddr_in6</name>
<block>{
<expr_stmt><expr><call><name>__SOCKADDR_COMMON</name> <argument_list>(<argument><expr><name>sin6_</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>uint16_t</name></type> <name>sin6_port</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>sin6_flowinfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>in6_addr</name></name></type> <name>sin6_addr</name></decl>;</decl_stmt>
}</block>;</struct>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>EAI_ADDRFAMILY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<struct>struct <name>addrinfo</name> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>ai_flags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ai_family</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ai_socktype</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ai_protocol</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>ai_addrlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ai_canonname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sockaddr</name></name> <modifier>*</modifier></type><name>ai_addr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>addrinfo</name></name> <modifier>*</modifier></type><name>ai_next</name></decl>;</decl_stmt>
}</block>;</struct>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netdb.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pcap/namedb.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nametoaddr.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ETHERMTU</name></cpp:macro> <cpp:value>1500</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>ETHERTYPE_TEB</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ETHERTYPE_TEB</name></cpp:macro> <cpp:value>0x6558</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>IPPROTO_HOPOPTS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IPPROTO_HOPOPTS</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>IPPROTO_ROUTING</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IPPROTO_ROUTING</name></cpp:macro> <cpp:value>43</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>IPPROTO_FRAGMENT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IPPROTO_FRAGMENT</name></cpp:macro> <cpp:value>44</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>IPPROTO_DSTOPTS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IPPROTO_DSTOPTS</name></cpp:macro> <cpp:value>60</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>IPPROTO_SCTP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IPPROTO_SCTP</name></cpp:macro> <cpp:value>132</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GENEVE_PORT</name></cpp:macro> <cpp:value>6081</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_OS_PROTO_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"os-proto.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JMP</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((c)|BPF_JMP|BPF_K)</cpp:value></cpp:define>






<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PUSH_LINKHDR</name><parameter_list>(<parameter><type><name>cs</name></type></parameter>, <parameter><type><name>new_linktype</name></type></parameter>, <parameter><type><name>new_is_variable</name></type></parameter>, <parameter><type><name>new_constant_part</name></type></parameter>, <parameter><type><name>new_reg</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ (cs)-&gt;prevlinktype = (cs)-&gt;linktype; (cs)-&gt;off_prevlinkhdr = (cs)-&gt;off_linkhdr; (cs)-&gt;linktype = (new_linktype); (cs)-&gt;off_linkhdr.is_variable = (new_is_variable); (cs)-&gt;off_linkhdr.constant_part = (new_constant_part); (cs)-&gt;off_linkhdr.reg = (new_reg); (cs)-&gt;is_geneve = 0; }</cpp:value></cpp:define>













<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OFFSET_NOT_SET</name></cpp:macro> <cpp:value>0xffffffffU</cpp:value></cpp:define>


















<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>int</name></type> <name>is_variable</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>u_int</name></type> <name>constant_part</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>reg</name></decl>;</decl_stmt>
}</block></struct></type> <name>bpf_abs_offset</name>;</typedef>





<enum>enum <name>e_offrel</name> <block>{
<decl><name>OR_PACKET</name></decl>,
<decl><name>OR_LINKHDR</name></decl>,
<decl><name>OR_PREVLINKHDR</name></decl>,
<decl><name>OR_LLC</name></decl>,
<decl><name>OR_PREVMPLSHDR</name></decl>,
<decl><name>OR_LINKTYPE</name></decl>,
<decl><name>OR_LINKPL</name></decl>,
<decl><name>OR_LINKPL_NOSNAP</name></decl>,
<decl><name>OR_TRAN_IPV4</name></decl>,
<decl><name>OR_TRAN_IPV6</name></decl>
}</block>;</enum>









<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NCHUNKS</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHUNK0SIZE</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>
<struct>struct <name>chunk</name> <block>{
<decl_stmt><decl><type><name>size_t</name></type> <name>n_left</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>m</name></decl>;</decl_stmt>
}</block>;</struct>



<struct>struct <name>_compiler_state</name> <block>{
<decl_stmt><decl><type><name>jmp_buf</name></type> <name>top_ctx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>bpf_pcap</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>icode</name></name></type> <name>ic</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>snaplen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>linktype</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>prevlinktype</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>outermostlinktype</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bpf_u_int32</name></type> <name>netmask</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>no_optimize</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>u_int</name></type> <name>label_stack_depth</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>u_int</name></type> <name>vlan_stack_depth</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>u_int</name></type> <name>pcap_fddipad</name></decl>;</decl_stmt>










<decl_stmt><decl><type><name><name>struct</name> <name>addrinfo</name></name> <modifier>*</modifier></type><name>ai</name></decl>;</decl_stmt>






<decl_stmt><decl><type><name>u_char</name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>










<decl_stmt><decl><type><name>bpf_abs_offset</name></type> <name>off_linkhdr</name></decl>;</decl_stmt>







<decl_stmt><decl><type><name>bpf_abs_offset</name></type> <name>off_prevlinkhdr</name></decl>;</decl_stmt>





<decl_stmt><decl><type><name>bpf_abs_offset</name></type> <name>off_outermostlinkhdr</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>bpf_abs_offset</name></type> <name>off_linkpl</name></decl>;</decl_stmt>
























<decl_stmt><decl><type><name>bpf_abs_offset</name></type> <name>off_linktype</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>int</name></type> <name>is_atm</name></decl>;</decl_stmt>






<decl_stmt><decl><type><name>int</name></type> <name>is_geneve</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>int</name></type> <name>is_vlan_vloffset</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>u_int</name></type> <name>off_vpi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>u_int</name></type> <name>off_vci</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>u_int</name></type> <name>off_proto</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>u_int</name></type> <name>off_li</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>u_int</name></type> <name>off_li_hsl</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>u_int</name></type> <name>off_sio</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>u_int</name></type> <name>off_opc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>u_int</name></type> <name>off_dpc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>u_int</name></type> <name>off_sls</name></decl>;</decl_stmt>





<decl_stmt><decl><type><name>u_int</name></type> <name>off_payload</name></decl>;</decl_stmt>


























<decl_stmt><decl><type><name>u_int</name></type> <name>off_nl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>u_int</name></type> <name>off_nl_nosnap</name></decl>;</decl_stmt>





<decl_stmt><decl><type><name>int</name></type> <name><name>regused</name><index>[<expr><name>BPF_MEMWORDS</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>curreg</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name><name>struct</name> <name>chunk</name></name></type> <name><name>chunks</name><index>[<expr><name>NCHUNKS</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cur_chunk</name></decl>;</decl_stmt>
}</block>;</struct>





<function><type><name>void</name></type>
<name>bpf_set_error</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>pcap_vsnprintf</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>bpf_pcap</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<function_decl><type><specifier>static</specifier> <name>void</name> <name>PCAP_NORETURN</name></type> <name>bpf_error</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
PCAP_PRINTFLIKE<parameter_list>(</parameter_list>2<operator>,</operator> 3</function_decl>)<empty_stmt>;</empty_stmt>


<function><type><specifier>static</specifier> <name>void</name> <name>PCAP_NORETURN</name></type>
<name>bpf_error</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>pcap_vsnprintf</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>bpf_pcap</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>top_ctx</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>init_linktype</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>init_regs</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>alloc_reg</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>free_reg</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>initchunks</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>newchunk_nolongjmp</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>newchunk</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>freechunks</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>new_block</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>new_stmt</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_retblk</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>syntax</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>backpatch</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>merge</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_cmp</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>e_offrel</name></name></type></decl></parameter>, <parameter><decl><type><name>u_int</name></type></decl></parameter>,
<parameter><decl><type><name>u_int</name></type></decl></parameter>, <parameter><decl><type><name>bpf_int32</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_cmp_gt</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>e_offrel</name></name></type></decl></parameter>, <parameter><decl><type><name>u_int</name></type></decl></parameter>,
<parameter><decl><type><name>u_int</name></type></decl></parameter>, <parameter><decl><type><name>bpf_int32</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_cmp_ge</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>e_offrel</name></name></type></decl></parameter>, <parameter><decl><type><name>u_int</name></type></decl></parameter>,
<parameter><decl><type><name>u_int</name></type></decl></parameter>, <parameter><decl><type><name>bpf_int32</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_cmp_lt</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>e_offrel</name></name></type></decl></parameter>, <parameter><decl><type><name>u_int</name></type></decl></parameter>,
<parameter><decl><type><name>u_int</name></type></decl></parameter>, <parameter><decl><type><name>bpf_int32</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_cmp_le</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>e_offrel</name></name></type></decl></parameter>, <parameter><decl><type><name>u_int</name></type></decl></parameter>,
<parameter><decl><type><name>u_int</name></type></decl></parameter>, <parameter><decl><type><name>bpf_int32</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_mcmp</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>e_offrel</name></name></type></decl></parameter>, <parameter><decl><type><name>u_int</name></type></decl></parameter>,
<parameter><decl><type><name>u_int</name></type></decl></parameter>, <parameter><decl><type><name>bpf_int32</name></type></decl></parameter>, <parameter><decl><type><name>bpf_u_int32</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_bcmp</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>e_offrel</name></name></type></decl></parameter>, <parameter><decl><type><name>u_int</name></type></decl></parameter>,
<parameter><decl><type><name>u_int</name></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>u_char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_ncmp</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>e_offrel</name></name></type></decl></parameter>, <parameter><decl><type><name>bpf_u_int32</name></type></decl></parameter>,
<parameter><decl><type><name>bpf_u_int32</name></type></decl></parameter>, <parameter><decl><type><name>bpf_u_int32</name></type></decl></parameter>, <parameter><decl><type><name>bpf_u_int32</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>bpf_int32</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>gen_load_absoffsetrel</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>bpf_abs_offset</name> <modifier>*</modifier></type></decl></parameter>,
<parameter><decl><type><name>u_int</name></type></decl></parameter>, <parameter><decl><type><name>u_int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>gen_load_a</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>e_offrel</name></name></type></decl></parameter>, <parameter><decl><type><name>u_int</name></type></decl></parameter>,
<parameter><decl><type><name>u_int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>gen_loadx_iphdrlen</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_uncond</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_true</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_false</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_ether_linktype</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_ipnet_linktype</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_linux_sll_linktype</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>gen_load_prism_llprefixlen</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>gen_load_avs_llprefixlen</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>gen_load_radiotap_llprefixlen</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>gen_load_ppi_llprefixlen</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>insert_compute_vloffsets</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>gen_abs_offset_varpart</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>,
<parameter><decl><type><name>bpf_abs_offset</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>ethertype_to_ppptype</name><parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_linktype</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_snap</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>bpf_u_int32</name></type></decl></parameter>, <parameter><decl><type><name>bpf_u_int32</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_llc_linktype</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_hostop</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>bpf_u_int32</name></type></decl></parameter>, <parameter><decl><type><name>bpf_u_int32</name></type></decl></parameter>,
<parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>u_int</name></type></decl></parameter>, <parameter><decl><type><name>u_int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>INET6</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_hostop6</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>in6_addr</name></name> <modifier>*</modifier></type></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>in6_addr</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>u_int</name></type></decl></parameter>, <parameter><decl><type><name>u_int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_ahostop</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>u_char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_ehostop</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>u_char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_fhostop</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>u_char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_thostop</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>u_char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_wlanhostop</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>u_char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_ipfchostop</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>u_char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_dnhostop</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>bpf_u_int32</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_mpls_linktype</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_host</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>bpf_u_int32</name></type></decl></parameter>, <parameter><decl><type><name>bpf_u_int32</name></type></decl></parameter>,
<parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>INET6</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_host6</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>in6_addr</name></name> <modifier>*</modifier></type></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>in6_addr</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>INET6</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_gateway</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>u_char</name> <modifier>*</modifier></type></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>addrinfo</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_ipfrag</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_portatom</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>bpf_int32</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_portrangeatom</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>bpf_int32</name></type></decl></parameter>,
<parameter><decl><type><name>bpf_int32</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_portatom6</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>bpf_int32</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_portrangeatom6</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>bpf_int32</name></type></decl></parameter>,
<parameter><decl><type><name>bpf_int32</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_portop</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_port</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_portrangeop</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_portrange</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_portop6</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_port6</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_portrangeop6</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_portrange6</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>lookup_proto</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_protochain</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_proto</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>xfer_to_x</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>arth</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>xfer_to_a</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>arth</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_mac_multicast</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_len</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_check_802_11_data_frame</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_geneve_ll_check</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_ppi_dlt_check</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_atmfield_code_internal</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>,
<parameter><decl><type><name>bpf_int32</name></type></decl></parameter>, <parameter><decl><type><name>bpf_u_int32</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_atmtype_llc</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>gen_msg_abbrev</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>initchunks</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NCHUNKS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>chunks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n_left</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>chunks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>m</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_chunk</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>newchunk_nolongjmp</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>chunk</name></name> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__NetBSD__</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>n</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>ALIGN</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>cp</name> <operator>=</operator> <operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>chunks</name><index>[<expr><name><name>cstate</name><operator>-&gt;</operator><name>cur_chunk</name></name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <name><name>cp</name><operator>-&gt;</operator><name>n_left</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>cp</name></expr>;</expr_stmt>
<expr_stmt><expr><name>k</name> <operator>=</operator> <operator>++</operator><name><name>cstate</name><operator>-&gt;</operator><name>cur_chunk</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>k</name> <operator>&gt;=</operator> <name>NCHUNKS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bpf_set_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>size</name> <operator>=</operator> <name>CHUNK0SIZE</name> <operator>&lt;&lt;</operator> <name>k</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>m</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>m</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bpf_set_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>cp</name><operator>-&gt;</operator><name>m</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>n_left</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <name>size</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bpf_set_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>n_left</name></name> <operator>-=</operator> <name>n</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>cp</name><operator>-&gt;</operator><name>m</name></name> <operator>+</operator> <name><name>cp</name><operator>-&gt;</operator><name>n_left</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>newchunk</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>newchunk_nolongjmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>top_ctx</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name>p</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>freechunks</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NCHUNKS</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>chunks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>m</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>chunks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
</block_content>}</block></function>







<function><type><name>char</name> <modifier>*</modifier></type>
<name>sdup</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>n</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cp</name> <init>= <expr><call><name>newchunk_nolongjmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>pcap_strlcpy</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>cp</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>new_block</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator>struct <name>block</name> <operator>*</operator><operator>)</operator><call><name>newchunk</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>code</name></name> <operator>=</operator> <name>code</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type>
<name>new_stmt</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator>struct <name>slist</name> <operator>*</operator><operator>)</operator><call><name>newchunk</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>code</name></name> <operator>=</operator> <name>code</name></expr>;</expr_stmt>

<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_retblk</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b</name> <init>= <expr><call><name>new_block</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_RET</name><operator>|</operator><name>BPF_K</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>
<return>return <expr><name>b</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>PCAP_NORETURN_DEF</name> <name>void</name></type>
<name>syntax</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"syntax error in filter expression"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pcap_compile</name><parameter_list>(<parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>bpf_program</name></name> <modifier>*</modifier></type><name>program</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>optimize</name></decl></parameter>, <parameter><decl><type><name>bpf_u_int32</name></type> <name>mask</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>done</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>compiler_state_t</name></type> <name>cstate</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>volatile</specifier></type> <name>xbuf</name> <init>= <expr><name>buf</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>yyscan_t</name></type> <name>scanner</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>volatile</specifier> <name>YY_BUFFER_STATE</name></type> <name>in_buffer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>u_int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>activated</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"not-yet-activated pcap_t passed to pcap_compile"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>done</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>pcap_wsockinit</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>done</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_REMOTE</name></expr></argument>)</argument_list></call></expr></cpp:if>
















<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>save_current_filter_op</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>save_current_filter_op</name></name><operator>)</operator><operator>(</operator><name>p</name><operator>,</operator> <name>buf</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>initchunks</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>.</operator><name>no_optimize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>INET6</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>cstate</name><operator>.</operator><name>ai</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>cstate</name><operator>.</operator><name>e</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>.</operator><name>ic</name><operator>.</operator><name>root</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>.</operator><name>ic</name><operator>.</operator><name>cur_mark</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>.</operator><name>bpf_pcap</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>init_regs</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cstate</name><operator>.</operator><name>netmask</name></name> <operator>=</operator> <name>mask</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cstate</name><operator>.</operator><name>snaplen</name></name> <operator>=</operator> <call><name>pcap_snapshot</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>.</operator><name>snaplen</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"snaplen of 0 rejects all packets"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<goto>goto <name>quit</name>;</goto>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>pcap_lex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scanner</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>pcap_fmt_errmsg_for_errno</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><name>errno</name></expr></argument>, <argument><expr><literal type="string">"can't initialize scanner"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>in_buffer</name> <operator>=</operator> <call><name>pcap__scan_string</name><argument_list>(<argument><expr><ternary><condition><expr><name>xbuf</name></expr> ?</condition><then> <expr><name>xbuf</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name>scanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><call><name>pcap_set_extra</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cstate</name></expr></argument>, <argument><expr><name>scanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>init_linktype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cstate</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<goto>goto <name>quit</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>pcap_parse</name><argument_list>(<argument><expr><name>scanner</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cstate</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>INET6</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>.</operator><name>ai</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>freeaddrinfo</name><argument_list>(<argument><expr><name><name>cstate</name><operator>.</operator><name>ai</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>.</operator><name>e</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>cstate</name><operator>.</operator><name>e</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<goto>goto <name>quit</name>;</goto>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>.</operator><name>ic</name><operator>.</operator><name>root</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>



<if_stmt><if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>.</operator><name>top_ctx</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<goto>goto <name>quit</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>.</operator><name>ic</name><operator>.</operator><name>root</name></name> <operator>=</operator> <call><name>gen_retblk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cstate</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>.</operator><name>snaplen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>optimize</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>cstate</name><operator>.</operator><name>no_optimize</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>bpf_optimize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>.</operator><name>ic</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<goto>goto <name>quit</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>.</operator><name>ic</name><operator>.</operator><name>root</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
<operator>(</operator><name><name>cstate</name><operator>.</operator><name>ic</name><operator>.</operator><name>root</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>code</name></name> <operator>==</operator> <operator>(</operator><name>BPF_RET</name><operator>|</operator><name>BPF_K</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>.</operator><name>ic</name><operator>.</operator><name>root</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>pcap_snprintf</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>, <argument><expr><name>PCAP_ERRBUF_SIZE</name></expr></argument>,
<argument><expr><literal type="string">"expression rejects all packets"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<goto>goto <name>quit</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>program</name><operator>-&gt;</operator><name>bf_insns</name></name> <operator>=</operator> <call><name>icode_to_fcode</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>.</operator><name>ic</name></name></expr></argument>,
<argument><expr><name><name>cstate</name><operator>.</operator><name>ic</name><operator>.</operator><name>root</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>errbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>program</name><operator>-&gt;</operator><name>bf_insns</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<goto>goto <name>quit</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>program</name><operator>-&gt;</operator><name>bf_len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<label><name>quit</name>:</label>



<if_stmt><if>if <condition>(<expr><name>in_buffer</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>pcap__delete_buffer</name><argument_list>(<argument><expr><name>in_buffer</name></expr></argument>, <argument><expr><name>scanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>scanner</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>pcap_lex_destroy</name><argument_list>(<argument><expr><name>scanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>




<expr_stmt><expr><call><name>freechunks</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>rc</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>





<function><type><name>int</name></type>
<name>pcap_compile_nopcap</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>snaplen_arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>linktype_arg</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>bpf_program</name></name> <modifier>*</modifier></type><name>program</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>optimize</name></decl></parameter>, <parameter><decl><type><name>bpf_u_int32</name></type> <name>mask</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>pcap_open_dead</name><argument_list>(<argument><expr><name>linktype_arg</name></expr></argument>, <argument><expr><name>snaplen_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pcap_compile</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>program</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>optimize</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pcap_close</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ret</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>





<function><type><name>void</name></type>
<name>pcap_freecode</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>bpf_program</name></name> <modifier>*</modifier></type><name>program</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>program</name><operator>-&gt;</operator><name>bf_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>program</name><operator>-&gt;</operator><name>bf_insns</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>program</name><operator>-&gt;</operator><name>bf_insns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>program</name><operator>-&gt;</operator><name>bf_insns</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>void</name></type>
<name>backpatch</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

<while>while <condition>(<expr><name>list</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>list</name><operator>-&gt;</operator><name>sense</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>JT</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>JT</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>JF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>JF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>list</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type>
<name>merge</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b1</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>register</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name>b0</name></expr></init></decl>;</decl_stmt>


<while>while <condition>(<expr><operator>*</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <ternary><condition><expr><operator>!</operator><operator>(</operator><name><operator>(</operator><operator>*</operator><name>p</name><operator>)</operator><operator>-&gt;</operator><name>sense</name></name><operator>)</operator></expr> ?</condition><then> <expr><operator>&amp;</operator><call><name>JT</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><operator>&amp;</operator><call><name>JF</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt></block_content></block></while>


<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name>b1</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>finish_parse</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>ppi_dlt_check</name></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>top_ctx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>




















<expr_stmt><expr><call><name>insert_compute_vloffsets</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>head</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>














<expr_stmt><expr><name>ppi_dlt_check</name> <operator>=</operator> <call><name>gen_ppi_dlt_check</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ppi_dlt_check</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>ppi_dlt_check</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>backpatch</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>gen_retblk</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>snaplen</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>sense</name></name> <operator>=</operator> <operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>sense</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>backpatch</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>gen_retblk</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>ic</name><operator>.</operator><name>root</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>head</name></name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>gen_and</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b1</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>backpatch</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name><name>b1</name><operator>-&gt;</operator><name>head</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b0</name><operator>-&gt;</operator><name>sense</name></name> <operator>=</operator> <operator>!</operator><name><name>b0</name><operator>-&gt;</operator><name>sense</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b1</name><operator>-&gt;</operator><name>sense</name></name> <operator>=</operator> <operator>!</operator><name><name>b1</name><operator>-&gt;</operator><name>sense</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>merge</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><name>b0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b1</name><operator>-&gt;</operator><name>sense</name></name> <operator>=</operator> <operator>!</operator><name><name>b1</name><operator>-&gt;</operator><name>sense</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b1</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name><name>b0</name><operator>-&gt;</operator><name>head</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>gen_or</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b1</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>b0</name><operator>-&gt;</operator><name>sense</name></name> <operator>=</operator> <operator>!</operator><name><name>b0</name><operator>-&gt;</operator><name>sense</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>backpatch</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name><name>b1</name><operator>-&gt;</operator><name>head</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b0</name><operator>-&gt;</operator><name>sense</name></name> <operator>=</operator> <operator>!</operator><name><name>b0</name><operator>-&gt;</operator><name>sense</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>merge</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><name>b0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b1</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name><name>b0</name><operator>-&gt;</operator><name>head</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>gen_not</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>sense</name></name> <operator>=</operator> <operator>!</operator><name><name>b</name><operator>-&gt;</operator><name>sense</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_cmp</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>e_offrel</name></name></type> <name>offrel</name></decl></parameter>, <parameter><decl><type><name>u_int</name></type> <name>offset</name></decl></parameter>,
<parameter><decl><type><name>u_int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>bpf_int32</name></type> <name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>gen_ncmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>offrel</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><literal type="number">0xffffffff</literal></expr></argument>, <argument><expr><name>BPF_JEQ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_cmp_gt</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>e_offrel</name></name></type> <name>offrel</name></decl></parameter>, <parameter><decl><type><name>u_int</name></type> <name>offset</name></decl></parameter>,
<parameter><decl><type><name>u_int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>bpf_int32</name></type> <name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>gen_ncmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>offrel</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><literal type="number">0xffffffff</literal></expr></argument>, <argument><expr><name>BPF_JGT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_cmp_ge</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>e_offrel</name></name></type> <name>offrel</name></decl></parameter>, <parameter><decl><type><name>u_int</name></type> <name>offset</name></decl></parameter>,
<parameter><decl><type><name>u_int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>bpf_int32</name></type> <name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>gen_ncmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>offrel</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><literal type="number">0xffffffff</literal></expr></argument>, <argument><expr><name>BPF_JGE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_cmp_lt</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>e_offrel</name></name></type> <name>offrel</name></decl></parameter>, <parameter><decl><type><name>u_int</name></type> <name>offset</name></decl></parameter>,
<parameter><decl><type><name>u_int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>bpf_int32</name></type> <name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>gen_ncmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>offrel</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><literal type="number">0xffffffff</literal></expr></argument>, <argument><expr><name>BPF_JGE</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_cmp_le</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>e_offrel</name></name></type> <name>offrel</name></decl></parameter>, <parameter><decl><type><name>u_int</name></type> <name>offset</name></decl></parameter>,
<parameter><decl><type><name>u_int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>bpf_int32</name></type> <name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>gen_ncmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>offrel</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><literal type="number">0xffffffff</literal></expr></argument>, <argument><expr><name>BPF_JGT</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_mcmp</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>e_offrel</name></name></type> <name>offrel</name></decl></parameter>, <parameter><decl><type><name>u_int</name></type> <name>offset</name></decl></parameter>,
<parameter><decl><type><name>u_int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>bpf_int32</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>bpf_u_int32</name></type> <name>mask</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>gen_ncmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>offrel</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>BPF_JEQ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_bcmp</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>e_offrel</name></name></type> <name>offrel</name></decl></parameter>, <parameter><decl><type><name>u_int</name></type> <name>offset</name></decl></parameter>,
<parameter><decl><type><name>u_int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>u_char</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>register</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>











<expr_stmt><expr><name>b</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>size</name> <operator>&gt;=</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>register</specifier> <specifier>const</specifier> <name>u_char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>v</name><index>[<expr><name>size</name> <operator>-</operator> <literal type="number">4</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>offrel</name></expr></argument>, <argument><expr><name>offset</name> <operator>+</operator> <name>size</name> <operator>-</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>BPF_W</name></expr></argument>,
<argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><call><name>EXTRACT_32BITS</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>b</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>b</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
<expr_stmt><expr><name>size</name> <operator>-=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
</block_content>}</block></while>
<while>while <condition>(<expr><name>size</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>register</specifier> <specifier>const</specifier> <name>u_char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>v</name><index>[<expr><name>size</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>offrel</name></expr></argument>, <argument><expr><name>offset</name> <operator>+</operator> <name>size</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>,
<argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><call><name>EXTRACT_16BITS</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>b</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>b</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
<expr_stmt><expr><name>size</name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>offrel</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name><name>v</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>b</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>b</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>b</name></expr>;</return>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_ncmp</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>e_offrel</name></name></type> <name>offrel</name></decl></parameter>, <parameter><decl><type><name>bpf_u_int32</name></type> <name>offset</name></decl></parameter>,
<parameter><decl><type><name>bpf_u_int32</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>bpf_u_int32</name></type> <name>mask</name></decl></parameter>, <parameter><decl><type><name>bpf_u_int32</name></type> <name>jtype</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reverse</name></decl></parameter>,
<parameter><decl><type><name>bpf_int32</name></type> <name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>s</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>s2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>gen_load_a</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>offrel</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>mask</name> <operator>!=</operator> <literal type="number">0xffffffff</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ALU</name><operator>|</operator><name>BPF_AND</name><operator>|</operator><name>BPF_K</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s2</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name>mask</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>new_block</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>JMP</name><argument_list>(<argument><expr><name>jtype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>stmts</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>reverse</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>jtype</name> <operator>==</operator> <name>BPF_JGT</name> <operator>||</operator> <name>jtype</name> <operator>==</operator> <name>BPF_JGE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>gen_not</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>b</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>init_linktype</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>pcap_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>pcap_fddipad</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>fddipad</name></name></expr>;</expr_stmt>




<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>outermostlinktype</name></name> <operator>=</operator> <call><name>pcap_datalink</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_outermostlinkhdr</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_outermostlinkhdr</name><operator>.</operator><name>is_variable</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_outermostlinkhdr</name><operator>.</operator><name>reg</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>prevlinktype</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>outermostlinktype</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_prevlinkhdr</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_prevlinkhdr</name><operator>.</operator><name>is_variable</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_prevlinkhdr</name><operator>.</operator><name>reg</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>outermostlinktype</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkhdr</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkhdr</name><operator>.</operator><name>is_variable</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkhdr</name><operator>.</operator><name>reg</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>




<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>is_variable</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>reg</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>is_variable</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>reg</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>




<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>is_atm</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_vpi</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_vci</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_proto</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_payload</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>




<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>is_geneve</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>




<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>is_vlan_vloffset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>




<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_li</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_li_hsl</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_sio</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_opc</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_dpc</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_sls</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>label_stack_depth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>vlan_stack_depth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>DLT_ARCNET</name></expr>:</case>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">6</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl_nosnap</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DLT_ARCNET_LINUX</name></expr>:</case>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl_nosnap</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DLT_EN10MB</name></expr>:</case>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">12</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">14</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl_nosnap</name></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DLT_SLIP</name></expr>:</case>




<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl_nosnap</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DLT_SLIP_BSDOS</name></expr>:</case>

<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">24</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl_nosnap</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DLT_NULL</name></expr>:</case>
<case>case <expr><name>DLT_LOOP</name></expr>:</case>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl_nosnap</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DLT_ENC</name></expr>:</case>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">12</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl_nosnap</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DLT_PPP</name></expr>:</case>
<case>case <expr><name>DLT_PPP_PPPD</name></expr>:</case>
<case>case <expr><name>DLT_C_HDLC</name></expr>:</case>
<case>case <expr><name>DLT_PPP_SERIAL</name></expr>:</case>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl_nosnap</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DLT_PPP_ETHER</name></expr>:</case>




<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">6</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl_nosnap</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DLT_PPP_BSDOS</name></expr>:</case>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">24</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl_nosnap</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DLT_FDDI</name></expr>:</case>








<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">13</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>+=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>pcap_fddipad</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">13</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>+=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>pcap_fddipad</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl_nosnap</name></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DLT_IEEE802</name></expr>:</case>























<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">14</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">14</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl_nosnap</name></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DLT_PRISM_HEADER</name></expr>:</case>
<case>case <expr><name>DLT_IEEE802_11_RADIO_AVS</name></expr>:</case>
<case>case <expr><name>DLT_IEEE802_11_RADIO</name></expr>:</case>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkhdr</name><operator>.</operator><name>is_variable</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>




<case>case <expr><name>DLT_IEEE802_11</name></expr>:</case>


















<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">24</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>is_variable</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl_nosnap</name></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DLT_PPI</name></expr>:</case>









<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">24</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>is_variable</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkhdr</name><operator>.</operator><name>is_variable</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl_nosnap</name></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DLT_ATM_RFC1483</name></expr>:</case>
<case>case <expr><name>DLT_ATM_CLIP</name></expr>:</case>











<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl_nosnap</name></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DLT_SUNATM</name></expr>:</case>




<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>is_atm</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_vpi</name></name> <operator>=</operator> <name>SUNATM_VPI_POS</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_vci</name></name> <operator>=</operator> <name>SUNATM_VCI_POS</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_proto</name></name> <operator>=</operator> <name>PROTO_POS</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_payload</name></name> <operator>=</operator> <name>SUNATM_PKT_BEGIN_POS</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_payload</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_payload</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl_nosnap</name></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DLT_RAW</name></expr>:</case>
<case>case <expr><name>DLT_IPV4</name></expr>:</case>
<case>case <expr><name>DLT_IPV6</name></expr>:</case>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl_nosnap</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DLT_LINUX_SLL</name></expr>:</case>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">14</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl_nosnap</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DLT_LINUX_SLL2</name></expr>:</case>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">20</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl_nosnap</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DLT_LTALK</name></expr>:</case>





<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl_nosnap</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DLT_IP_OVER_FC</name></expr>:</case>










<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl_nosnap</name></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DLT_FRELAY</name></expr>:</case>




<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl_nosnap</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>






<case>case <expr><name>DLT_MFR</name></expr>:</case>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl_nosnap</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DLT_APPLE_IP_OVER_IEEE1394</name></expr>:</case>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">18</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl_nosnap</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DLT_SYMANTEC_FIREWALL</name></expr>:</case>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">6</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">44</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl_nosnap</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_NET_PFVAR_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>DLT_PFLOG</name></expr>:</case>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <name>PFLOG_HDRLEN</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl_nosnap</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<case>case <expr><name>DLT_JUNIPER_MFR</name></expr>:</case>
<case>case <expr><name>DLT_JUNIPER_MLFR</name></expr>:</case>
<case>case <expr><name>DLT_JUNIPER_MLPPP</name></expr>:</case>
<case>case <expr><name>DLT_JUNIPER_PPP</name></expr>:</case>
<case>case <expr><name>DLT_JUNIPER_CHDLC</name></expr>:</case>
<case>case <expr><name>DLT_JUNIPER_FRELAY</name></expr>:</case>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl_nosnap</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DLT_JUNIPER_ATM1</name></expr>:</case>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl_nosnap</name></name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DLT_JUNIPER_ATM2</name></expr>:</case>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl_nosnap</name></name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
<break>break;</break>



<case>case <expr><name>DLT_JUNIPER_PPPOE</name></expr>:</case>
<case>case <expr><name>DLT_JUNIPER_ETHER</name></expr>:</case>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">14</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>=</operator> <literal type="number">18</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl_nosnap</name></name> <operator>=</operator> <literal type="number">21</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DLT_JUNIPER_PPPOE_ATM</name></expr>:</case>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">6</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl_nosnap</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DLT_JUNIPER_GGSN</name></expr>:</case>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">6</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">12</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl_nosnap</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DLT_JUNIPER_ES</name></expr>:</case>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">6</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl_nosnap</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DLT_JUNIPER_MONITOR</name></expr>:</case>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">12</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">12</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl_nosnap</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DLT_BACNET_MS_TP</name></expr>:</case>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl_nosnap</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DLT_JUNIPER_SERVICES</name></expr>:</case>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">12</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl_nosnap</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DLT_JUNIPER_VP</name></expr>:</case>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">18</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl_nosnap</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DLT_JUNIPER_ST</name></expr>:</case>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">18</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl_nosnap</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DLT_JUNIPER_ISM</name></expr>:</case>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl_nosnap</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DLT_JUNIPER_VS</name></expr>:</case>
<case>case <expr><name>DLT_JUNIPER_SRX_E2E</name></expr>:</case>
<case>case <expr><name>DLT_JUNIPER_FIBRECHANNEL</name></expr>:</case>
<case>case <expr><name>DLT_JUNIPER_ATM_CEMIC</name></expr>:</case>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl_nosnap</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DLT_MTP2</name></expr>:</case>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_li</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_li_hsl</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_sio</name></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_opc</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_dpc</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_sls</name></name> <operator>=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl_nosnap</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DLT_MTP2_WITH_PHDR</name></expr>:</case>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_li</name></name> <operator>=</operator> <literal type="number">6</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_li_hsl</name></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_sio</name></name> <operator>=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_opc</name></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_dpc</name></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_sls</name></name> <operator>=</operator> <literal type="number">11</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl_nosnap</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DLT_ERF</name></expr>:</case>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_li</name></name> <operator>=</operator> <literal type="number">22</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_li_hsl</name></name> <operator>=</operator> <literal type="number">24</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_sio</name></name> <operator>=</operator> <literal type="number">23</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_opc</name></name> <operator>=</operator> <literal type="number">24</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_dpc</name></name> <operator>=</operator> <literal type="number">24</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_sls</name></name> <operator>=</operator> <literal type="number">27</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl_nosnap</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DLT_PFSYNC</name></expr>:</case>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl_nosnap</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DLT_AX25_KISS</name></expr>:</case>



<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl_nosnap</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DLT_IPNET</name></expr>:</case>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">24</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl_nosnap</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DLT_NETANALYZER</name></expr>:</case>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkhdr</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_linkhdr</name><operator>.</operator><name>constant_part</name></name> <operator>+</operator> <literal type="number">12</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_linkhdr</name><operator>.</operator><name>constant_part</name></name> <operator>+</operator> <literal type="number">14</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl_nosnap</name></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DLT_NETANALYZER_TRANSPARENT</name></expr>:</case>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkhdr</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">12</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_linkhdr</name><operator>.</operator><name>constant_part</name></name> <operator>+</operator> <literal type="number">12</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_linkhdr</name><operator>.</operator><name>constant_part</name></name> <operator>+</operator> <literal type="number">14</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl_nosnap</name></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<break>break;</break>

<default>default:</default>




<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name> <operator>&gt;=</operator> <name>DLT_MATCHING_MIN</name> <operator>&amp;&amp;</operator>
<name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name> <operator>&lt;=</operator> <name>DLT_MATCHING_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl_nosnap</name></name> <operator>=</operator> <name>OFFSET_NOT_SET</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>bpf_set_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"unknown data link type %d"</literal></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></else></if_stmt>
<break>break;</break>
</block_content>}</block></switch>

<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_outermostlinkhdr</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_prevlinkhdr</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_linkhdr</name></name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type>
<name>gen_load_absoffsetrel</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>bpf_abs_offset</name> <modifier>*</modifier></type><name>abs_offset</name></decl></parameter>,
<parameter><decl><type><name>u_int</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>u_int</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>s</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>s2</name></decl>;</decl_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>gen_abs_offset_varpart</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>abs_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>










<if_stmt><if>if <condition>(<expr><name>s</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>





<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LD</name><operator>|</operator><name>BPF_IND</name><operator>|</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s2</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name><name>abs_offset</name><operator>-&gt;</operator><name>constant_part</name></name> <operator>+</operator> <name>offset</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>




<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LD</name><operator>|</operator><name>BPF_ABS</name><operator>|</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name><name>abs_offset</name><operator>-&gt;</operator><name>constant_part</name></name> <operator>+</operator> <name>offset</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>s</name></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type>
<name>gen_load_a</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>e_offrel</name></name></type> <name>offrel</name></decl></parameter>, <parameter><decl><type><name>u_int</name></type> <name>offset</name></decl></parameter>,
<parameter><decl><type><name>u_int</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>s</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>s2</name></decl>;</decl_stmt>












<expr_stmt><expr><name>s</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>offrel</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>OR_PACKET</name></expr>:</case>
<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LD</name><operator>|</operator><name>BPF_ABS</name><operator>|</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>OR_LINKHDR</name></expr>:</case>
<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>gen_load_absoffsetrel</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>off_linkhdr</name></name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>OR_PREVLINKHDR</name></expr>:</case>
<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>gen_load_absoffsetrel</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>off_prevlinkhdr</name></name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>OR_LLC</name></expr>:</case>
<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>gen_load_absoffsetrel</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name></name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>OR_PREVMPLSHDR</name></expr>:</case>
<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>gen_load_absoffsetrel</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>-</operator> <literal type="number">4</literal> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>OR_LINKPL</name></expr>:</case>
<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>gen_load_absoffsetrel</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>OR_LINKPL_NOSNAP</name></expr>:</case>
<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>gen_load_absoffsetrel</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl_nosnap</name></name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>OR_LINKTYPE</name></expr>:</case>
<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>gen_load_absoffsetrel</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name></name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>OR_TRAN_IPV4</name></expr>:</case>






<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>gen_loadx_iphdrlen</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>












<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LD</name><operator>|</operator><name>BPF_IND</name><operator>|</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s2</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>+</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>+</operator> <name>offset</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>OR_TRAN_IPV6</name></expr>:</case>
<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>gen_load_absoffsetrel</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>+</operator> <literal type="number">40</literal> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<return>return <expr><name>s</name></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type>
<name>gen_loadx_iphdrlen</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>s</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>s2</name></decl>;</decl_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>gen_abs_offset_varpart</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>s</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>










<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LD</name><operator>|</operator><name>BPF_IND</name><operator>|</operator><name>BPF_B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s2</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>+</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ALU</name><operator>|</operator><name>BPF_AND</name><operator>|</operator><name>BPF_K</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s2</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">0xf</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ALU</name><operator>|</operator><name>BPF_LSH</name><operator>|</operator><name>BPF_K</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s2</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>







<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ALU</name><operator>|</operator><name>BPF_ADD</name><operator>|</operator><name>BPF_X</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_MISC</name><operator>|</operator><name>BPF_TAX</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>












<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LDX</name><operator>|</operator><name>BPF_MSH</name><operator>|</operator><name>BPF_B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>+</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>s</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_uncond</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rsense</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LD</name><operator>|</operator><name>BPF_IMM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <operator>!</operator><name>rsense</name></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>new_block</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>JMP</name><argument_list>(<argument><expr><name>BPF_JEQ</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>stmts</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>

<return>return <expr><name>b</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_true</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>gen_uncond</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_false</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>gen_uncond</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>






<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SWAPLONG</name><parameter_list>(<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((((y)&amp;0xff)&lt;&lt;24) | (((y)&amp;0xff00)&lt;&lt;8) | (((y)&amp;0xff0000)&gt;&gt;8) | (((y)&gt;&gt;24)&amp;0xff))</cpp:value></cpp:define>











<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_ether_linktype</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>proto</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b1</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>proto</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>LLCSAP_ISONS</name></expr>:</case>
<case>case <expr><name>LLCSAP_IP</name></expr>:</case>
<case>case <expr><name>LLCSAP_NETBEUI</name></expr>:</case>












<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_cmp_gt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKTYPE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>, <argument><expr><name>ETHERMTU</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_not</name><argument_list>(<argument><expr><name>b0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LLC</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator>
<operator>(</operator><operator>(</operator><name>proto</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator> <name>proto</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>

<case>case <expr><name>LLCSAP_IPX</name></expr>:</case>
































<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LLC</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>LLCSAP_IPX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LLC</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><literal type="number">0xFFFF</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_snap</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="number">0x000000</literal></expr></argument>, <argument><expr><name>ETHERTYPE_IPX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_cmp_gt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKTYPE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>, <argument><expr><name>ETHERMTU</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_not</name><argument_list>(<argument><expr><name>b0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>







<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>






<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKTYPE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>ETHERTYPE_IPX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>

<case>case <expr><name>ETHERTYPE_ATALK</name></expr>:</case>
<case>case <expr><name>ETHERTYPE_AARP</name></expr>:</case>










<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_cmp_gt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKTYPE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>, <argument><expr><name>ETHERMTU</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_not</name><argument_list>(<argument><expr><name>b0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>












<if_stmt><if>if <condition>(<expr><name>proto</name> <operator>==</operator> <name>ETHERTYPE_ATALK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_snap</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="number">0x080007</literal></expr></argument>, <argument><expr><name>ETHERTYPE_ATALK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_snap</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="number">0x000000</literal></expr></argument>, <argument><expr><name>ETHERTYPE_AARP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>






<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKTYPE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>

<default>default:</default>
<if_stmt><if>if <condition>(<expr><name>proto</name> <operator>&lt;=</operator> <name>ETHERMTU</name></expr>)</condition> <block>{<block_content>








<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_cmp_gt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKTYPE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>, <argument><expr><name>ETHERMTU</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_not</name><argument_list>(<argument><expr><name>b0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKTYPE</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>









<return>return <expr><call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKTYPE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>,
<argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>proto</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_loopback_linktype</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>proto</name></decl></parameter>)</parameter_list>
<block>{<block_content>













<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name> <operator>==</operator> <name>DLT_NULL</name> <operator>||</operator> <name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name> <operator>==</operator> <name>DLT_ENC</name></expr>)</condition> <block>{<block_content>











<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>bpf_pcap</name><operator>-&gt;</operator><name>rfile</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>bpf_pcap</name><operator>-&gt;</operator><name>swapped</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>proto</name> <operator>=</operator> <call><name>SWAPLONG</name><argument_list>(<argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>proto</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_W</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>proto</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_ipnet_linktype</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>proto</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<switch>switch <condition>(<expr><name>proto</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>ETHERTYPE_IP</name></expr>:</case>
<return>return <expr><call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKTYPE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>IPH_AF_INET</name></expr></argument>)</argument_list></call></expr>;</return>


<case>case <expr><name>ETHERTYPE_IPV6</name></expr>:</case>
<return>return <expr><call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKTYPE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>,
<argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>IPH_AF_INET6</name></expr></argument>)</argument_list></call></expr>;</return>


<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>

<return>return <expr><call><name>gen_false</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>









<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_linux_sll_linktype</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>proto</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b1</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>proto</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>LLCSAP_ISONS</name></expr>:</case>
<case>case <expr><name>LLCSAP_IP</name></expr>:</case>
<case>case <expr><name>LLCSAP_NETBEUI</name></expr>:</case>












<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKTYPE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>, <argument><expr><name>LINUX_SLL_P_802_2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LLC</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator>
<operator>(</operator><operator>(</operator><name>proto</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator> <name>proto</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>

<case>case <expr><name>LLCSAP_IPX</name></expr>:</case>

























<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LLC</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>LLCSAP_IPX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_snap</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="number">0x000000</literal></expr></argument>, <argument><expr><name>ETHERTYPE_IPX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKTYPE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>, <argument><expr><name>LINUX_SLL_P_802_2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKTYPE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>, <argument><expr><name>LINUX_SLL_P_802_3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>






<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKTYPE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>ETHERTYPE_IPX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>

<case>case <expr><name>ETHERTYPE_ATALK</name></expr>:</case>
<case>case <expr><name>ETHERTYPE_AARP</name></expr>:</case>










<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKTYPE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>, <argument><expr><name>LINUX_SLL_P_802_2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>












<if_stmt><if>if <condition>(<expr><name>proto</name> <operator>==</operator> <name>ETHERTYPE_ATALK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_snap</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="number">0x080007</literal></expr></argument>, <argument><expr><name>ETHERTYPE_ATALK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_snap</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="number">0x000000</literal></expr></argument>, <argument><expr><name>ETHERTYPE_AARP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>






<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKTYPE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>

<default>default:</default>
<if_stmt><if>if <condition>(<expr><name>proto</name> <operator>&lt;=</operator> <name>ETHERMTU</name></expr>)</condition> <block>{<block_content>







<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKTYPE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>, <argument><expr><name>LINUX_SLL_P_802_2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>,
<argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>









<return>return <expr><call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKTYPE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>proto</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type>
<name>gen_load_prism_llprefixlen</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>s1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>s2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>sjeq_avs_cookie</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>sjcommon</name></decl>;</decl_stmt>






<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>no_optimize</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>




















<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkhdr</name><operator>.</operator><name>reg</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><name>s1</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LD</name><operator>|</operator><name>BPF_W</name><operator>|</operator><name>BPF_ABS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s1</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>




<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ALU</name><operator>|</operator><name>BPF_AND</name><operator>|</operator><name>BPF_K</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s2</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">0xFFFFF000</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><name>sjeq_avs_cookie</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>JMP</name><argument_list>(<argument><expr><name>BPF_JEQ</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sjeq_avs_cookie</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">0x80211000</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>sjeq_avs_cookie</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>








<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LD</name><operator>|</operator><name>BPF_W</name><operator>|</operator><name>BPF_ABS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s2</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sjeq_avs_cookie</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>jt</name></name> <operator>=</operator> <name>s2</name></expr>;</expr_stmt>









<expr_stmt><expr><name>sjcommon</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>JMP</name><argument_list>(<argument><expr><name>BPF_JA</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sjcommon</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>sjcommon</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>







<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LD</name><operator>|</operator><name>BPF_W</name><operator>|</operator><name>BPF_IMM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s2</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">144</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sjeq_avs_cookie</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>jf</name></name> <operator>=</operator> <name>s2</name></expr>;</expr_stmt>






<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s2</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_linkhdr</name><operator>.</operator><name>reg</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sjcommon</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>jf</name></name> <operator>=</operator> <name>s2</name></expr>;</expr_stmt>




<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_MISC</name><operator>|</operator><name>BPF_TAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>s1</name><operator>)</operator></expr>;</return>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type>
<name>gen_load_avs_llprefixlen</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>s1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>s2</name></decl>;</decl_stmt>








<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkhdr</name><operator>.</operator><name>reg</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>





<expr_stmt><expr><name>s1</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LD</name><operator>|</operator><name>BPF_W</name><operator>|</operator><name>BPF_ABS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s1</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>





<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s2</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_linkhdr</name><operator>.</operator><name>reg</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_MISC</name><operator>|</operator><name>BPF_TAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>s1</name><operator>)</operator></expr>;</return>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type>
<name>gen_load_radiotap_llprefixlen</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>s1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>s2</name></decl>;</decl_stmt>








<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkhdr</name><operator>.</operator><name>reg</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>











<expr_stmt><expr><name>s1</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LD</name><operator>|</operator><name>BPF_B</name><operator>|</operator><name>BPF_ABS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s1</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ALU</name><operator>|</operator><name>BPF_LSH</name><operator>|</operator><name>BPF_K</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s2</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_MISC</name><operator>|</operator><name>BPF_TAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LD</name><operator>|</operator><name>BPF_B</name><operator>|</operator><name>BPF_ABS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s2</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ALU</name><operator>|</operator><name>BPF_OR</name><operator>|</operator><name>BPF_X</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s2</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_linkhdr</name><operator>.</operator><name>reg</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_MISC</name><operator>|</operator><name>BPF_TAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>s1</name><operator>)</operator></expr>;</return>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>










<function><type><specifier>static</specifier> <name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type>
<name>gen_load_ppi_llprefixlen</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>s1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>s2</name></decl>;</decl_stmt>






<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkhdr</name><operator>.</operator><name>reg</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>











<expr_stmt><expr><name>s1</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LD</name><operator>|</operator><name>BPF_B</name><operator>|</operator><name>BPF_ABS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s1</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ALU</name><operator>|</operator><name>BPF_LSH</name><operator>|</operator><name>BPF_K</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s2</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_MISC</name><operator>|</operator><name>BPF_TAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LD</name><operator>|</operator><name>BPF_B</name><operator>|</operator><name>BPF_ABS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s2</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ALU</name><operator>|</operator><name>BPF_OR</name><operator>|</operator><name>BPF_X</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s2</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_linkhdr</name><operator>.</operator><name>reg</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_MISC</name><operator>|</operator><name>BPF_TAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>s1</name><operator>)</operator></expr>;</return>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type>
<name>gen_load_802_11_header_len</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>snext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>s2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>sjset_data_frame_1</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>sjset_data_frame_2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>sjset_qos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>sjset_radiotap_flags_present</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>sjset_radiotap_ext_present</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>sjset_radiotap_tsft_present</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>sjset_tsft_datapad</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sjset_notsft_datapad</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>s_roundup</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>reg</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>






<return>return <expr><operator>(</operator><name>s</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>






<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>no_optimize</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>









<if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>









<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LDX</name><operator>|</operator><name>BPF_IMM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_outermostlinkhdr</name><operator>.</operator><name>constant_part</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>








<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_MISC</name><operator>|</operator><name>BPF_TXA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ALU</name><operator>|</operator><name>BPF_ADD</name><operator>|</operator><name>BPF_K</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s2</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">24</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s2</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>reg</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LD</name><operator>|</operator><name>BPF_IND</name><operator>|</operator><name>BPF_B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s2</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>






<expr_stmt><expr><name>sjset_data_frame_1</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>JMP</name><argument_list>(<argument><expr><name>BPF_JSET</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sjset_data_frame_1</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">0x08</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>sjset_data_frame_1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><name><name>sjset_data_frame_1</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>jt</name></name> <operator>=</operator> <name>sjset_data_frame_2</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>JMP</name><argument_list>(<argument><expr><name>BPF_JSET</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sjset_data_frame_2</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">0x04</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>sjset_data_frame_2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sjset_data_frame_1</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>jf</name></name> <operator>=</operator> <name>snext</name></expr>;</expr_stmt>






<expr_stmt><expr><name><name>sjset_data_frame_2</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>jt</name></name> <operator>=</operator> <name>snext</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sjset_data_frame_2</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>jf</name></name> <operator>=</operator> <name>sjset_qos</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>JMP</name><argument_list>(<argument><expr><name>BPF_JSET</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sjset_qos</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">0x80</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>sjset_qos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>







<expr_stmt><expr><name><name>sjset_qos</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>jt</name></name> <operator>=</operator> <name>s2</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LD</name><operator>|</operator><name>BPF_MEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s2</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>reg</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ALU</name><operator>|</operator><name>BPF_ADD</name><operator>|</operator><name>BPF_IMM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s2</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s2</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>reg</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




















<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name> <operator>==</operator> <name>DLT_IEEE802_11_RADIO</name></expr>)</condition> <block>{<block_content>




<expr_stmt><expr><name><name>sjset_qos</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>jf</name></name> <operator>=</operator> <name>s2</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LD</name><operator>|</operator><name>BPF_ABS</name><operator>|</operator><name>BPF_W</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s2</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sjset_radiotap_flags_present</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>JMP</name><argument_list>(<argument><expr><name>BPF_JSET</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sjset_radiotap_flags_present</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <call><name>SWAPLONG</name><argument_list>(<argument><expr><literal type="number">0x00000002</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>sjset_radiotap_flags_present</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><name><name>sjset_radiotap_flags_present</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>jf</name></name> <operator>=</operator> <name>snext</name></expr>;</expr_stmt>




<expr_stmt><expr><name>sjset_radiotap_ext_present</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>JMP</name><argument_list>(<argument><expr><name>BPF_JSET</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sjset_radiotap_ext_present</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <call><name>SWAPLONG</name><argument_list>(<argument><expr><literal type="number">0x80000000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>sjset_radiotap_ext_present</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sjset_radiotap_flags_present</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>jt</name></name> <operator>=</operator> <name>sjset_radiotap_ext_present</name></expr>;</expr_stmt>




<expr_stmt><expr><name><name>sjset_radiotap_ext_present</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>jt</name></name> <operator>=</operator> <name>snext</name></expr>;</expr_stmt>




<expr_stmt><expr><name>sjset_radiotap_tsft_present</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>JMP</name><argument_list>(<argument><expr><name>BPF_JSET</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sjset_radiotap_tsft_present</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <call><name>SWAPLONG</name><argument_list>(<argument><expr><literal type="number">0x00000001</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>sjset_radiotap_tsft_present</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sjset_radiotap_ext_present</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>jf</name></name> <operator>=</operator> <name>sjset_radiotap_tsft_present</name></expr>;</expr_stmt>










<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LD</name><operator>|</operator><name>BPF_ABS</name><operator>|</operator><name>BPF_B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s2</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sjset_radiotap_tsft_present</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>jt</name></name> <operator>=</operator> <name>s2</name></expr>;</expr_stmt>

<expr_stmt><expr><name>sjset_tsft_datapad</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>JMP</name><argument_list>(<argument><expr><name>BPF_JSET</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sjset_tsft_datapad</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">0x20</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>sjset_tsft_datapad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>









<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LD</name><operator>|</operator><name>BPF_ABS</name><operator>|</operator><name>BPF_B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s2</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sjset_radiotap_tsft_present</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>jf</name></name> <operator>=</operator> <name>s2</name></expr>;</expr_stmt>

<expr_stmt><expr><name>sjset_notsft_datapad</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>JMP</name><argument_list>(<argument><expr><name>BPF_JSET</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sjset_notsft_datapad</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">0x20</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>sjset_notsft_datapad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>








<expr_stmt><expr><name>s_roundup</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LD</name><operator>|</operator><name>BPF_MEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s_roundup</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>reg</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s_roundup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ALU</name><operator>|</operator><name>BPF_ADD</name><operator>|</operator><name>BPF_IMM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s2</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ALU</name><operator>|</operator><name>BPF_AND</name><operator>|</operator><name>BPF_IMM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s2</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <operator>~</operator><literal type="number">3</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s2</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>reg</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sjset_tsft_datapad</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>jt</name></name> <operator>=</operator> <name>s_roundup</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sjset_tsft_datapad</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>jf</name></name> <operator>=</operator> <name>snext</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sjset_notsft_datapad</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>jt</name></name> <operator>=</operator> <name>s_roundup</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sjset_notsft_datapad</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>jf</name></name> <operator>=</operator> <name>snext</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sjset_qos</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>jf</name></name> <operator>=</operator> <name>snext</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return <expr><name>s</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>insert_compute_vloffsets</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>






<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>reg</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_linkhdr</name><operator>.</operator><name>is_variable</name></name> <operator>&amp;&amp;</operator>
<name><name>cstate</name><operator>-&gt;</operator><name>off_linkhdr</name><operator>.</operator><name>reg</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkhdr</name><operator>.</operator><name>reg</name></name> <operator>=</operator> <call><name>alloc_reg</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>












<switch>switch <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>outermostlinktype</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>DLT_PRISM_HEADER</name></expr>:</case>
<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>gen_load_prism_llprefixlen</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DLT_IEEE802_11_RADIO_AVS</name></expr>:</case>
<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>gen_load_avs_llprefixlen</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DLT_IEEE802_11_RADIO</name></expr>:</case>
<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>gen_load_radiotap_llprefixlen</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DLT_PPI</name></expr>:</case>
<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>gen_load_ppi_llprefixlen</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<default>default:</default>
<expr_stmt><expr><name>s</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>






<switch>switch <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>outermostlinktype</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>DLT_IEEE802_11</name></expr>:</case>
<case>case <expr><name>DLT_PRISM_HEADER</name></expr>:</case>
<case>case <expr><name>DLT_IEEE802_11_RADIO_AVS</name></expr>:</case>
<case>case <expr><name>DLT_IEEE802_11_RADIO</name></expr>:</case>
<case>case <expr><name>DLT_PPI</name></expr>:</case>
<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>gen_load_802_11_header_len</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>stmts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>





<if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>is_vlan_vloffset</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>s2</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>reg</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>reg</name></name> <operator>=</operator> <call><name>alloc_reg</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>reg</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>reg</name></name> <operator>=</operator> <call><name>alloc_reg</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LD</name><operator>|</operator><name>BPF_W</name><operator>|</operator><name>BPF_IMM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s2</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>reg</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s2</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>reg</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>







<if_stmt><if>if <condition>(<expr><name>s</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>stmts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>stmts</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_ppi_dlt_check</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>s_load_dlt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name> <operator>==</operator> <name>DLT_PPI</name></expr>)</condition>
<block>{<block_content>


<expr_stmt><expr><name>s_load_dlt</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LD</name><operator>|</operator><name>BPF_W</name><operator>|</operator><name>BPF_ABS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s_load_dlt</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>new_block</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>JMP</name><argument_list>(<argument><expr><name>BPF_JEQ</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>stmts</name></name> <operator>=</operator> <name>s_load_dlt</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <call><name>SWAPLONG</name><argument_list>(<argument><expr><name>DLT_IEEE802_11</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><name>b</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>b</name></expr>;</return>
</block_content>}</block></function>














<function><type><specifier>static</specifier> <name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type>
<name>gen_abs_offset_varpart</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>bpf_abs_offset</name> <modifier>*</modifier></type><name>off</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>off</name><operator>-&gt;</operator><name>is_variable</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>off</name><operator>-&gt;</operator><name>reg</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>





<expr_stmt><expr><name><name>off</name><operator>-&gt;</operator><name>reg</name></name> <operator>=</operator> <call><name>alloc_reg</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>





<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LDX</name><operator>|</operator><name>BPF_MEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name><name>off</name><operator>-&gt;</operator><name>reg</name></name></expr>;</expr_stmt>
<return>return <expr><name>s</name></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>




<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>int</name></type>
<name>ethertype_to_ppptype</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>proto</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<switch>switch <condition>(<expr><name>proto</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>ETHERTYPE_IP</name></expr>:</case>
<expr_stmt><expr><name>proto</name> <operator>=</operator> <name>PPP_IP</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>ETHERTYPE_IPV6</name></expr>:</case>
<expr_stmt><expr><name>proto</name> <operator>=</operator> <name>PPP_IPV6</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>ETHERTYPE_DN</name></expr>:</case>
<expr_stmt><expr><name>proto</name> <operator>=</operator> <name>PPP_DECNET</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>ETHERTYPE_ATALK</name></expr>:</case>
<expr_stmt><expr><name>proto</name> <operator>=</operator> <name>PPP_APPLE</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>ETHERTYPE_NS</name></expr>:</case>
<expr_stmt><expr><name>proto</name> <operator>=</operator> <name>PPP_NS</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>LLCSAP_ISONS</name></expr>:</case>
<expr_stmt><expr><name>proto</name> <operator>=</operator> <name>PPP_OSI</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>LLCSAP_8021D</name></expr>:</case>





<expr_stmt><expr><name>proto</name> <operator>=</operator> <name>PPP_BRPDU</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>LLCSAP_IPX</name></expr>:</case>
<expr_stmt><expr><name>proto</name> <operator>=</operator> <name>PPP_IPX</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<return>return <expr><operator>(</operator><name>proto</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_prevlinkhdr_check</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>is_geneve</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>gen_geneve_ll_check</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>prevlinktype</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>DLT_SUNATM</name></expr>:</case>







<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_PREVLINKHDR</name></expr></argument>, <argument><expr><name>SUNATM_PKT_BEGIN_POS</name></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>, <argument><expr><literal type="number">0xFF00</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_not</name><argument_list>(<argument><expr><name>b0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b0</name></expr>;</return>

<default>default:</default>



<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></switch>

</block_content>}</block></function>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BSD_AFNUM_INET6_BSD</name></cpp:macro> <cpp:value>24</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BSD_AFNUM_INET6_FREEBSD</name></cpp:macro> <cpp:value>28</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BSD_AFNUM_INET6_DARWIN</name></cpp:macro> <cpp:value>30</cpp:value></cpp:define>








<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_linktype</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>proto</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>description</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>label_stack_depth</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name>proto</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ETHERTYPE_IP</name></expr>:</case>
<case>case <expr><name>PPP_IP</name></expr>:</case>

<return>return <expr><call><name>gen_mpls_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>Q_IP</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>ETHERTYPE_IPV6</name></expr>:</case>
<case>case <expr><name>PPP_IPV6</name></expr>:</case>

<return>return <expr><call><name>gen_mpls_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>Q_IPV6</name></expr></argument>)</argument_list></call></expr>;</return>

<default>default:</default>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"unsupported protocol over mpls"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>
</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>DLT_EN10MB</name></expr>:</case>
<case>case <expr><name>DLT_NETANALYZER</name></expr>:</case>
<case>case <expr><name>DLT_NETANALYZER_TRANSPARENT</name></expr>:</case>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>is_geneve</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_prevlinkhdr_check</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_ether_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>b0</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>b1</name></expr>;</return>


<case>case <expr><name>DLT_C_HDLC</name></expr>:</case>
<switch>switch <condition>(<expr><name>proto</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>LLCSAP_ISONS</name></expr>:</case>
<expr_stmt><expr><name>proto</name> <operator>=</operator> <operator>(</operator><name>proto</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal> <operator>|</operator> <name>LLCSAP_ISONS</name><operator>)</operator></expr>;</expr_stmt>


<default>default:</default>
<return>return <expr><call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKTYPE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>proto</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></switch>

<case>case <expr><name>DLT_IEEE802_11</name></expr>:</case>
<case>case <expr><name>DLT_PRISM_HEADER</name></expr>:</case>
<case>case <expr><name>DLT_IEEE802_11_RADIO_AVS</name></expr>:</case>
<case>case <expr><name>DLT_IEEE802_11_RADIO</name></expr>:</case>
<case>case <expr><name>DLT_PPI</name></expr>:</case>



<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_check_802_11_data_frame</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_llc_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>


<case>case <expr><name>DLT_FDDI</name></expr>:</case>



<return>return <expr><call><name>gen_llc_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</return>


<case>case <expr><name>DLT_IEEE802</name></expr>:</case>



<return>return <expr><call><name>gen_llc_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</return>


<case>case <expr><name>DLT_ATM_RFC1483</name></expr>:</case>
<case>case <expr><name>DLT_ATM_CLIP</name></expr>:</case>
<case>case <expr><name>DLT_IP_OVER_FC</name></expr>:</case>
<return>return <expr><call><name>gen_llc_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</return>


<case>case <expr><name>DLT_SUNATM</name></expr>:</case>







<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_atmfield_code_internal</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>A_PROTOTYPE</name></expr></argument>, <argument><expr><name>PT_LLC</name></expr></argument>, <argument><expr><name>BPF_JEQ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_llc_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>


<case>case <expr><name>DLT_LINUX_SLL</name></expr>:</case>
<return>return <expr><call><name>gen_linux_sll_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</return>


<case>case <expr><name>DLT_SLIP</name></expr>:</case>
<case>case <expr><name>DLT_SLIP_BSDOS</name></expr>:</case>
<case>case <expr><name>DLT_RAW</name></expr>:</case>







<switch>switch <condition>(<expr><name>proto</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>ETHERTYPE_IP</name></expr>:</case>

<return>return <expr><call><name>gen_mcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><literal type="number">0x40</literal></expr></argument>, <argument><expr><literal type="number">0xF0</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>ETHERTYPE_IPV6</name></expr>:</case>

<return>return <expr><call><name>gen_mcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><literal type="number">0x60</literal></expr></argument>, <argument><expr><literal type="number">0xF0</literal></expr></argument>)</argument_list></call></expr>;</return>

<default>default:</default>
<return>return <expr><call><name>gen_false</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></switch>


<case>case <expr><name>DLT_IPV4</name></expr>:</case>



<if_stmt><if>if <condition>(<expr><name>proto</name> <operator>==</operator> <name>ETHERTYPE_IP</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>gen_true</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<return>return <expr><call><name>gen_false</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</return>


<case>case <expr><name>DLT_IPV6</name></expr>:</case>



<if_stmt><if>if <condition>(<expr><name>proto</name> <operator>==</operator> <name>ETHERTYPE_IPV6</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>gen_true</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<return>return <expr><call><name>gen_false</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</return>


<case>case <expr><name>DLT_PPP</name></expr>:</case>
<case>case <expr><name>DLT_PPP_PPPD</name></expr>:</case>
<case>case <expr><name>DLT_PPP_SERIAL</name></expr>:</case>
<case>case <expr><name>DLT_PPP_ETHER</name></expr>:</case>




<expr_stmt><expr><name>proto</name> <operator>=</operator> <call><name>ethertype_to_ppptype</name><argument_list>(<argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKTYPE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>proto</name></expr></argument>)</argument_list></call></expr>;</return>


<case>case <expr><name>DLT_PPP_BSDOS</name></expr>:</case>




<switch>switch <condition>(<expr><name>proto</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>ETHERTYPE_IP</name></expr>:</case>




<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKTYPE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>, <argument><expr><name>PPP_IP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKTYPE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>, <argument><expr><name>PPP_VJC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKTYPE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>, <argument><expr><name>PPP_VJNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><name>b0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b0</name></expr>;</return>

<default>default:</default>
<expr_stmt><expr><name>proto</name> <operator>=</operator> <call><name>ethertype_to_ppptype</name><argument_list>(<argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKTYPE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>,
<argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>proto</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></switch>


<case>case <expr><name>DLT_NULL</name></expr>:</case>
<case>case <expr><name>DLT_LOOP</name></expr>:</case>
<case>case <expr><name>DLT_ENC</name></expr>:</case>
<switch>switch <condition>(<expr><name>proto</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>ETHERTYPE_IP</name></expr>:</case>
<return>return <expr><operator>(</operator><call><name>gen_loopback_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>AF_INET</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>

<case>case <expr><name>ETHERTYPE_IPV6</name></expr>:</case>






















<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>bpf_pcap</name><operator>-&gt;</operator><name>rfile</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>




<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_loopback_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BSD_AFNUM_INET6_BSD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_loopback_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BSD_AFNUM_INET6_FREEBSD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_loopback_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BSD_AFNUM_INET6_DARWIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>b1</name><operator>)</operator></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>





<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>






<return>return <expr><operator>(</operator><call><name>gen_loopback_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="number">24</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AF_INET6</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><operator>(</operator><call><name>gen_loopback_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>AF_INET6</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>




<return>return <expr><call><name>gen_false</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></else></if_stmt>

<default>default:</default>





<return>return <expr><call><name>gen_false</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></switch>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_NET_PFVAR_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>DLT_PFLOG</name></expr>:</case>




<if_stmt><if>if <condition>(<expr><name>proto</name> <operator>==</operator> <name>ETHERTYPE_IP</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr>struct <name>pfloghdr</name></expr></argument>, <argument><expr><name>af</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>AF_INET</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>proto</name> <operator>==</operator> <name>ETHERTYPE_IPV6</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr>struct <name>pfloghdr</name></expr></argument>, <argument><expr><name>af</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>AF_INET6</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><call><name>gen_false</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<case>case <expr><name>DLT_ARCNET</name></expr>:</case>
<case>case <expr><name>DLT_ARCNET_LINUX</name></expr>:</case>




<switch>switch <condition>(<expr><name>proto</name></expr>)</condition> <block>{<block_content>

<default>default:</default>
<return>return <expr><call><name>gen_false</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>ETHERTYPE_IPV6</name></expr>:</case>
<return>return <expr><operator>(</operator><call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKTYPE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>,
<argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>ARCTYPE_INET6</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>

<case>case <expr><name>ETHERTYPE_IP</name></expr>:</case>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKTYPE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>,
<argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>ARCTYPE_IP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKTYPE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>,
<argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>ARCTYPE_IP_OLD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>b1</name><operator>)</operator></expr>;</return>

<case>case <expr><name>ETHERTYPE_ARP</name></expr>:</case>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKTYPE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>,
<argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>ARCTYPE_ARP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKTYPE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>,
<argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>ARCTYPE_ARP_OLD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>b1</name><operator>)</operator></expr>;</return>

<case>case <expr><name>ETHERTYPE_REVARP</name></expr>:</case>
<return>return <expr><operator>(</operator><call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKTYPE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>,
<argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>ARCTYPE_REVARP</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>

<case>case <expr><name>ETHERTYPE_ATALK</name></expr>:</case>
<return>return <expr><operator>(</operator><call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKTYPE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>,
<argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>ARCTYPE_ATALK</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></switch>


<case>case <expr><name>DLT_LTALK</name></expr>:</case>
<switch>switch <condition>(<expr><name>proto</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ETHERTYPE_ATALK</name></expr>:</case>
<return>return <expr><call><name>gen_true</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</return>
<default>default:</default>
<return>return <expr><call><name>gen_false</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></switch>


<case>case <expr><name>DLT_FRELAY</name></expr>:</case>




<switch>switch <condition>(<expr><name>proto</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>ETHERTYPE_IP</name></expr>:</case>



<return>return <expr><call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>, <argument><expr><operator>(</operator><literal type="number">0x03</literal><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator> <operator>|</operator> <literal type="number">0xcc</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>ETHERTYPE_IPV6</name></expr>:</case>



<return>return <expr><call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>, <argument><expr><operator>(</operator><literal type="number">0x03</literal><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator> <operator>|</operator> <literal type="number">0x8e</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>LLCSAP_ISONS</name></expr>:</case>











<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>, <argument><expr><operator>(</operator><literal type="number">0x03</literal><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator> <operator>|</operator> <name>ISO8473_CLNP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>, <argument><expr><operator>(</operator><literal type="number">0x03</literal><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator> <operator>|</operator> <name>ISO9542_ESIS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b2</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>, <argument><expr><operator>(</operator><literal type="number">0x03</literal><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator> <operator>|</operator> <name>ISO10589_ISIS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><name>b2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b2</name></expr>;</return>

<default>default:</default>
<return>return <expr><call><name>gen_false</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></switch>


<case>case <expr><name>DLT_MFR</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"Multi-link Frame Relay link-layer type filtering not implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>DLT_JUNIPER_MFR</name></expr>:</case>
<case>case <expr><name>DLT_JUNIPER_MLFR</name></expr>:</case>
<case>case <expr><name>DLT_JUNIPER_MLPPP</name></expr>:</case>
<case>case <expr><name>DLT_JUNIPER_ATM1</name></expr>:</case>
<case>case <expr><name>DLT_JUNIPER_ATM2</name></expr>:</case>
<case>case <expr><name>DLT_JUNIPER_PPPOE</name></expr>:</case>
<case>case <expr><name>DLT_JUNIPER_PPPOE_ATM</name></expr>:</case>
<case>case <expr><name>DLT_JUNIPER_GGSN</name></expr>:</case>
<case>case <expr><name>DLT_JUNIPER_ES</name></expr>:</case>
<case>case <expr><name>DLT_JUNIPER_MONITOR</name></expr>:</case>
<case>case <expr><name>DLT_JUNIPER_SERVICES</name></expr>:</case>
<case>case <expr><name>DLT_JUNIPER_ETHER</name></expr>:</case>
<case>case <expr><name>DLT_JUNIPER_PPP</name></expr>:</case>
<case>case <expr><name>DLT_JUNIPER_FRELAY</name></expr>:</case>
<case>case <expr><name>DLT_JUNIPER_CHDLC</name></expr>:</case>
<case>case <expr><name>DLT_JUNIPER_VP</name></expr>:</case>
<case>case <expr><name>DLT_JUNIPER_ST</name></expr>:</case>
<case>case <expr><name>DLT_JUNIPER_ISM</name></expr>:</case>
<case>case <expr><name>DLT_JUNIPER_VS</name></expr>:</case>
<case>case <expr><name>DLT_JUNIPER_SRX_E2E</name></expr>:</case>
<case>case <expr><name>DLT_JUNIPER_FIBRECHANNEL</name></expr>:</case>
<case>case <expr><name>DLT_JUNIPER_ATM_CEMIC</name></expr>:</case>








<return>return <expr><call><name>gen_mcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_W</name></expr></argument>, <argument><expr><literal type="number">0x4d474300</literal></expr></argument>, <argument><expr><literal type="number">0xffffff00</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>DLT_BACNET_MS_TP</name></expr>:</case>
<return>return <expr><call><name>gen_mcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_W</name></expr></argument>, <argument><expr><literal type="number">0x55FF0000</literal></expr></argument>, <argument><expr><literal type="number">0xffff0000</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>DLT_IPNET</name></expr>:</case>
<return>return <expr><call><name>gen_ipnet_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>DLT_LINUX_IRDA</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"IrDA link-layer type filtering not implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>DLT_DOCSIS</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"DOCSIS link-layer type filtering not implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>DLT_MTP2</name></expr>:</case>
<case>case <expr><name>DLT_MTP2_WITH_PHDR</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"MTP2 link-layer type filtering not implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>DLT_ERF</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"ERF link-layer type filtering not implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>DLT_PFSYNC</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"PFSYNC link-layer type filtering not implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>DLT_LINUX_LAPD</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"LAPD link-layer type filtering not implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>DLT_USB_FREEBSD</name></expr>:</case>
<case>case <expr><name>DLT_USB_LINUX</name></expr>:</case>
<case>case <expr><name>DLT_USB_LINUX_MMAPPED</name></expr>:</case>
<case>case <expr><name>DLT_USBPCAP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"USB link-layer type filtering not implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>DLT_BLUETOOTH_HCI_H4</name></expr>:</case>
<case>case <expr><name>DLT_BLUETOOTH_HCI_H4_WITH_PHDR</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"Bluetooth link-layer type filtering not implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>DLT_CAN20B</name></expr>:</case>
<case>case <expr><name>DLT_CAN_SOCKETCAN</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"CAN link-layer type filtering not implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>DLT_IEEE802_15_4</name></expr>:</case>
<case>case <expr><name>DLT_IEEE802_15_4_LINUX</name></expr>:</case>
<case>case <expr><name>DLT_IEEE802_15_4_NONASK_PHY</name></expr>:</case>
<case>case <expr><name>DLT_IEEE802_15_4_NOFCS</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"IEEE 802.15.4 link-layer type filtering not implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>DLT_IEEE802_16_MAC_CPS_RADIO</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"IEEE 802.16 link-layer type filtering not implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>DLT_SITA</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"SITA link-layer type filtering not implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>DLT_RAIF1</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"RAIF1 link-layer type filtering not implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>DLT_IPMB_KONTRON</name></expr>:</case>
<case>case <expr><name>DLT_IPMB_LINUX</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"IPMB link-layer type filtering not implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>DLT_AX25_KISS</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"AX.25 link-layer type filtering not implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>DLT_NFLOG</name></expr>:</case>




<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"NFLOG link-layer type filtering not implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<default>default:</default>






<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>!=</operator> <name>OFFSET_NOT_SET</name></expr>)</condition> <block>{<block_content>





<return>return <expr><call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKTYPE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>proto</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if> <else>else <block>{<block_content>



<expr_stmt><expr><name>description</name> <operator>=</operator> <call><name>pcap_datalink_val_to_description_or_dlt</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"%s link-layer type filtering not implemented"</literal></expr></argument>,
<argument><expr><name>description</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>
</block_content>}</block></switch>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_snap</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>bpf_u_int32</name></type> <name>orgcode</name></decl></parameter>, <parameter><decl><type><name>bpf_u_int32</name></type> <name>ptype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>u_char</name></type> <name><name>snapblock</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>snapblock</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>LLCSAP_SNAP</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>snapblock</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>LLCSAP_SNAP</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>snapblock</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x03</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>snapblock</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u_char</name><operator>)</operator><operator>(</operator><name>orgcode</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>snapblock</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u_char</name><operator>)</operator><operator>(</operator><name>orgcode</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>snapblock</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u_char</name><operator>)</operator><operator>(</operator><name>orgcode</name> <operator>&gt;&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>snapblock</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u_char</name><operator>)</operator><operator>(</operator><name>ptype</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>snapblock</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>u_char</name><operator>)</operator><operator>(</operator><name>ptype</name> <operator>&gt;&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><call><name>gen_bcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LLC</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>snapblock</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_llc_internal</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b1</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>DLT_EN10MB</name></expr>:</case>




<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_cmp_gt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKTYPE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>, <argument><expr><name>ETHERMTU</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_not</name><argument_list>(<argument><expr><name>b0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LLC</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><literal type="number">0xFFFF</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_not</name><argument_list>(<argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>

<case>case <expr><name>DLT_SUNATM</name></expr>:</case>



<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_atmtype_llc</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b0</name></expr>;</return>

<case>case <expr><name>DLT_IEEE802</name></expr>:</case>



<return>return <expr><call><name>gen_true</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>DLT_FDDI</name></expr>:</case>



<return>return <expr><call><name>gen_true</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>DLT_ATM_RFC1483</name></expr>:</case>








<return>return <expr><call><name>gen_true</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>DLT_IEEE802_11</name></expr>:</case>
<case>case <expr><name>DLT_PRISM_HEADER</name></expr>:</case>
<case>case <expr><name>DLT_IEEE802_11_RADIO</name></expr>:</case>
<case>case <expr><name>DLT_IEEE802_11_RADIO_AVS</name></expr>:</case>
<case>case <expr><name>DLT_PPI</name></expr>:</case>



<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_check_802_11_data_frame</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b0</name></expr>;</return>

<default>default:</default>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'llc' not supported for %s"</literal></expr></argument>,
<argument><expr><call><name>pcap_datalink_val_to_description_or_dlt</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_llc</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>




<if_stmt><if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>top_ctx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>gen_llc_internal</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_llc_i</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b1</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>top_ctx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>




<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_llc_internal</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>gen_load_a</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LLC</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>new_block</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>JMP</name><argument_list>(<argument><expr><name>BPF_JSET</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b1</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">0x01</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b1</name><operator>-&gt;</operator><name>stmts</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_not</name><argument_list>(<argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_llc_s</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b1</name></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>top_ctx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>




<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_llc_internal</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_mcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LLC</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><name>LLC_S_FMT</name></expr></argument>, <argument><expr><literal type="number">0x03</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_llc_u</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b1</name></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>top_ctx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>




<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_llc_internal</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_mcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LLC</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><name>LLC_U_FMT</name></expr></argument>, <argument><expr><literal type="number">0x03</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_llc_s_subtype</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>bpf_u_int32</name></type> <name>subtype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b1</name></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>top_ctx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>




<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_llc_internal</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_mcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LLC</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><name>subtype</name></expr></argument>, <argument><expr><name>LLC_S_CMD_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_llc_u_subtype</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>bpf_u_int32</name></type> <name>subtype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b1</name></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>top_ctx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>




<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_llc_internal</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_mcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LLC</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><name>subtype</name></expr></argument>, <argument><expr><name>LLC_U_CMD_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>
</block_content>}</block></function>













<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_llc_linktype</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>proto</name></decl></parameter>)</parameter_list>
<block>{<block_content>



<switch>switch <condition>(<expr><name>proto</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>LLCSAP_IP</name></expr>:</case>
<case>case <expr><name>LLCSAP_ISONS</name></expr>:</case>
<case>case <expr><name>LLCSAP_NETBEUI</name></expr>:</case>





<return>return <expr><call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LLC</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_u_int32</name><operator>)</operator>
<operator>(</operator><operator>(</operator><name>proto</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator> <name>proto</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>LLCSAP_IPX</name></expr>:</case>




<return>return <expr><call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LLC</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>,
<argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>LLCSAP_IPX</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>ETHERTYPE_ATALK</name></expr>:</case>









<return>return <expr><call><name>gen_snap</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="number">0x080007</literal></expr></argument>, <argument><expr><name>ETHERTYPE_ATALK</name></expr></argument>)</argument_list></call></expr>;</return>

<default>default:</default>




<if_stmt><if>if <condition>(<expr><name>proto</name> <operator>&lt;=</operator> <name>ETHERMTU</name></expr>)</condition> <block>{<block_content>




<return>return <expr><call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LLC</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>proto</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>



















<return>return <expr><call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LLC</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>proto</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_hostop</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>bpf_u_int32</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>bpf_u_int32</name></type> <name>mask</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>dir</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>proto</name></decl></parameter>, <parameter><decl><type><name>u_int</name></type> <name>src_off</name></decl></parameter>, <parameter><decl><type><name>u_int</name></type> <name>dst_off</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b1</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>u_int</name></type> <name>offset</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>dir</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>Q_SRC</name></expr>:</case>
<expr_stmt><expr><name>offset</name> <operator>=</operator> <name>src_off</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Q_DST</name></expr>:</case>
<expr_stmt><expr><name>offset</name> <operator>=</operator> <name>dst_off</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Q_AND</name></expr>:</case>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_hostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>Q_SRC</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>, <argument><expr><name>src_off</name></expr></argument>, <argument><expr><name>dst_off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_hostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>Q_DST</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>, <argument><expr><name>src_off</name></expr></argument>, <argument><expr><name>dst_off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>

<case>case <expr><name>Q_DEFAULT</name></expr>:</case>
<case>case <expr><name>Q_OR</name></expr>:</case>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_hostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>Q_SRC</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>, <argument><expr><name>src_off</name></expr></argument>, <argument><expr><name>dst_off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_hostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>Q_DST</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>, <argument><expr><name>src_off</name></expr></argument>, <argument><expr><name>dst_off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>

<case>case <expr><name>Q_ADDR1</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'addr1' and 'address1' are not valid qualifiers for addresses other than 802.11 MAC addresses"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_ADDR2</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'addr2' and 'address2' are not valid qualifiers for addresses other than 802.11 MAC addresses"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_ADDR3</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'addr3' and 'address3' are not valid qualifiers for addresses other than 802.11 MAC addresses"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_ADDR4</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'addr4' and 'address4' are not valid qualifiers for addresses other than 802.11 MAC addresses"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_RA</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'ra' is not a valid qualifier for addresses other than 802.11 MAC addresses"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_TA</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'ta' is not a valid qualifier for addresses other than 802.11 MAC addresses"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<default>default:</default>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_mcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKPL</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>BPF_W</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>addr</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>INET6</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_hostop6</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>in6_addr</name></name> <modifier>*</modifier></type><name>addr</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>in6_addr</name></name> <modifier>*</modifier></type><name>mask</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dir</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>proto</name></decl></parameter>, <parameter><decl><type><name>u_int</name></type> <name>src_off</name></decl></parameter>, <parameter><decl><type><name>u_int</name></type> <name>dst_off</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b1</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>u_int</name></type> <name>offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>a</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>m</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>dir</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>Q_SRC</name></expr>:</case>
<expr_stmt><expr><name>offset</name> <operator>=</operator> <name>src_off</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Q_DST</name></expr>:</case>
<expr_stmt><expr><name>offset</name> <operator>=</operator> <name>dst_off</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Q_AND</name></expr>:</case>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_hostop6</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>Q_SRC</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>, <argument><expr><name>src_off</name></expr></argument>, <argument><expr><name>dst_off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_hostop6</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>Q_DST</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>, <argument><expr><name>src_off</name></expr></argument>, <argument><expr><name>dst_off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>

<case>case <expr><name>Q_DEFAULT</name></expr>:</case>
<case>case <expr><name>Q_OR</name></expr>:</case>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_hostop6</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>Q_SRC</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>, <argument><expr><name>src_off</name></expr></argument>, <argument><expr><name>dst_off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_hostop6</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>Q_DST</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>, <argument><expr><name>src_off</name></expr></argument>, <argument><expr><name>dst_off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>

<case>case <expr><name>Q_ADDR1</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'addr1' and 'address1' are not valid qualifiers for addresses other than 802.11 MAC addresses"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_ADDR2</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'addr2' and 'address2' are not valid qualifiers for addresses other than 802.11 MAC addresses"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_ADDR3</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'addr3' and 'address3' are not valid qualifiers for addresses other than 802.11 MAC addresses"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_ADDR4</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'addr4' and 'address4' are not valid qualifiers for addresses other than 802.11 MAC addresses"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_RA</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'ra' is not a valid qualifier for addresses other than 802.11 MAC addresses"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_TA</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'ta' is not a valid qualifier for addresses other than 802.11 MAC addresses"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<default>default:</default>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

<expr_stmt><expr><name>a</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><name>addr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>m</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><name>mask</name></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_mcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKPL</name></expr></argument>, <argument><expr><name>offset</name> <operator>+</operator> <literal type="number">12</literal></expr></argument>, <argument><expr><name>BPF_W</name></expr></argument>, <argument><expr><call><name>ntohl</name><argument_list>(<argument><expr><name><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ntohl</name><argument_list>(<argument><expr><name><name>m</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_mcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKPL</name></expr></argument>, <argument><expr><name>offset</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><name>BPF_W</name></expr></argument>, <argument><expr><call><name>ntohl</name><argument_list>(<argument><expr><name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ntohl</name><argument_list>(<argument><expr><name><name>m</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_mcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKPL</name></expr></argument>, <argument><expr><name>offset</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>BPF_W</name></expr></argument>, <argument><expr><call><name>ntohl</name><argument_list>(<argument><expr><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ntohl</name><argument_list>(<argument><expr><name><name>m</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_mcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKPL</name></expr></argument>, <argument><expr><name>offset</name> <operator>+</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_W</name></expr></argument>, <argument><expr><call><name>ntohl</name><argument_list>(<argument><expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ntohl</name><argument_list>(<argument><expr><name><name>m</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_ehostop</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>u_char</name> <modifier>*</modifier></type><name>eaddr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>register</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b1</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>dir</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>Q_SRC</name></expr>:</case>
<return>return <expr><call><name>gen_bcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>Q_DST</name></expr>:</case>
<return>return <expr><call><name>gen_bcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>Q_AND</name></expr>:</case>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_ehostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>, <argument><expr><name>Q_SRC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_ehostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>, <argument><expr><name>Q_DST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>

<case>case <expr><name>Q_DEFAULT</name></expr>:</case>
<case>case <expr><name>Q_OR</name></expr>:</case>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_ehostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>, <argument><expr><name>Q_SRC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_ehostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>, <argument><expr><name>Q_DST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>

<case>case <expr><name>Q_ADDR1</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'addr1' and 'address1' are only supported on 802.11 with 802.11 headers"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_ADDR2</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'addr2' and 'address2' are only supported on 802.11 with 802.11 headers"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_ADDR3</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'addr3' and 'address3' are only supported on 802.11 with 802.11 headers"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_ADDR4</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'addr4' and 'address4' are only supported on 802.11 with 802.11 headers"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_RA</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'ra' is only supported on 802.11 with 802.11 headers"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_TA</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'ta' is only supported on 802.11 with 802.11 headers"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>




<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_fhostop</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>u_char</name> <modifier>*</modifier></type><name>eaddr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b1</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>dir</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>Q_SRC</name></expr>:</case>
<return>return <expr><call><name>gen_bcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">6</literal> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name><name>cstate</name><operator>-&gt;</operator><name>pcap_fddipad</name></name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>Q_DST</name></expr>:</case>
<return>return <expr><call><name>gen_bcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">0</literal> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name><name>cstate</name><operator>-&gt;</operator><name>pcap_fddipad</name></name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>Q_AND</name></expr>:</case>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_fhostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>, <argument><expr><name>Q_SRC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_fhostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>, <argument><expr><name>Q_DST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>

<case>case <expr><name>Q_DEFAULT</name></expr>:</case>
<case>case <expr><name>Q_OR</name></expr>:</case>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_fhostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>, <argument><expr><name>Q_SRC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_fhostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>, <argument><expr><name>Q_DST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>

<case>case <expr><name>Q_ADDR1</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'addr1' and 'address1' are only supported on 802.11"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_ADDR2</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'addr2' and 'address2' are only supported on 802.11"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_ADDR3</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'addr3' and 'address3' are only supported on 802.11"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_ADDR4</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'addr4' and 'address4' are only supported on 802.11"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_RA</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'ra' is only supported on 802.11"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_TA</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'ta' is only supported on 802.11"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>




<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_thostop</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>u_char</name> <modifier>*</modifier></type><name>eaddr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>register</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b1</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>dir</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>Q_SRC</name></expr>:</case>
<return>return <expr><call><name>gen_bcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>Q_DST</name></expr>:</case>
<return>return <expr><call><name>gen_bcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>Q_AND</name></expr>:</case>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_thostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>, <argument><expr><name>Q_SRC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_thostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>, <argument><expr><name>Q_DST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>

<case>case <expr><name>Q_DEFAULT</name></expr>:</case>
<case>case <expr><name>Q_OR</name></expr>:</case>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_thostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>, <argument><expr><name>Q_SRC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_thostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>, <argument><expr><name>Q_DST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>

<case>case <expr><name>Q_ADDR1</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'addr1' and 'address1' are only supported on 802.11"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_ADDR2</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'addr2' and 'address2' are only supported on 802.11"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_ADDR3</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'addr3' and 'address3' are only supported on 802.11"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_ADDR4</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'addr4' and 'address4' are only supported on 802.11"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_RA</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'ra' is only supported on 802.11"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_TA</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'ta' is only supported on 802.11"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>





<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_wlanhostop</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>u_char</name> <modifier>*</modifier></type><name>eaddr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>register</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>register</specifier> <name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_WLAN_FILTERING_PATCH</name></expr></argument>)</argument_list></call></expr></cpp:if>






<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>no_optimize</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<switch>switch <condition>(<expr><name>dir</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>Q_SRC</name></expr>:</case>

























<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>gen_load_a</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>new_block</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>JMP</name><argument_list>(<argument><expr><name>BPF_JSET</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b1</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">0x01</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b1</name><operator>-&gt;</operator><name>stmts</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>




<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_bcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">24</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><name>b0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>gen_load_a</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b2</name> <operator>=</operator> <call><name>new_block</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>JMP</name><argument_list>(<argument><expr><name>BPF_JSET</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b2</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">0x01</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b2</name><operator>-&gt;</operator><name>stmts</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_not</name><argument_list>(<argument><expr><name>b2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_bcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b2</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>






<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><name>b0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>gen_load_a</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>new_block</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>JMP</name><argument_list>(<argument><expr><name>BPF_JSET</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b1</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">0x02</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b1</name><operator>-&gt;</operator><name>stmts</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><name>b0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>gen_load_a</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b2</name> <operator>=</operator> <call><name>new_block</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>JMP</name><argument_list>(<argument><expr><name>BPF_JSET</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b2</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">0x02</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b2</name><operator>-&gt;</operator><name>stmts</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_not</name><argument_list>(<argument><expr><name>b2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_bcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b2</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>






<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><name>b0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>gen_load_a</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>new_block</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>JMP</name><argument_list>(<argument><expr><name>BPF_JSET</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b1</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">0x08</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b1</name><operator>-&gt;</operator><name>stmts</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>




<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><name>b0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>






<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>gen_load_a</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b2</name> <operator>=</operator> <call><name>new_block</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>JMP</name><argument_list>(<argument><expr><name>BPF_JSET</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b2</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">0x08</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b2</name><operator>-&gt;</operator><name>stmts</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_not</name><argument_list>(<argument><expr><name>b2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_bcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b2</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>






<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><name>b0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>









<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>gen_load_a</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>new_block</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>JMP</name><argument_list>(<argument><expr><name>BPF_JSET</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b1</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">0x04</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b1</name><operator>-&gt;</operator><name>stmts</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_not</name><argument_list>(<argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><name>b0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b0</name></expr>;</return>

<case>case <expr><name>Q_DST</name></expr>:</case>





















<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>gen_load_a</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>new_block</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>JMP</name><argument_list>(<argument><expr><name>BPF_JSET</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b1</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">0x01</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b1</name><operator>-&gt;</operator><name>stmts</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>




<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_bcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><name>b0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>gen_load_a</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b2</name> <operator>=</operator> <call><name>new_block</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>JMP</name><argument_list>(<argument><expr><name>BPF_JSET</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b2</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">0x01</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b2</name><operator>-&gt;</operator><name>stmts</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_not</name><argument_list>(<argument><expr><name>b2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_bcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b2</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><name>b0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>gen_load_a</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>new_block</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>JMP</name><argument_list>(<argument><expr><name>BPF_JSET</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b1</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">0x08</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b1</name><operator>-&gt;</operator><name>stmts</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>




<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><name>b0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>






<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>gen_load_a</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b2</name> <operator>=</operator> <call><name>new_block</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>JMP</name><argument_list>(<argument><expr><name>BPF_JSET</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b2</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">0x08</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b2</name><operator>-&gt;</operator><name>stmts</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_not</name><argument_list>(<argument><expr><name>b2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_bcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b2</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>






<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><name>b0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>









<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>gen_load_a</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>new_block</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>JMP</name><argument_list>(<argument><expr><name>BPF_JSET</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b1</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">0x04</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b1</name><operator>-&gt;</operator><name>stmts</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_not</name><argument_list>(<argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><name>b0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b0</name></expr>;</return>

<case>case <expr><name>Q_AND</name></expr>:</case>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_wlanhostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>, <argument><expr><name>Q_SRC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_wlanhostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>, <argument><expr><name>Q_DST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>

<case>case <expr><name>Q_DEFAULT</name></expr>:</case>
<case>case <expr><name>Q_OR</name></expr>:</case>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_wlanhostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>, <argument><expr><name>Q_SRC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_wlanhostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>, <argument><expr><name>Q_DST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>




<case>case <expr><name>Q_ADDR1</name></expr>:</case>
<return>return <expr><operator>(</operator><call><name>gen_bcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>

<case>case <expr><name>Q_ADDR2</name></expr>:</case>



<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_mcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><name>IEEE80211_FC0_TYPE_CTL</name></expr></argument>,
<argument><expr><name>IEEE80211_FC0_TYPE_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_not</name><argument_list>(<argument><expr><name>b0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_mcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><name>IEEE80211_FC0_SUBTYPE_CTS</name></expr></argument>,
<argument><expr><name>IEEE80211_FC0_SUBTYPE_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_not</name><argument_list>(<argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b2</name> <operator>=</operator> <call><name>gen_mcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><name>IEEE80211_FC0_SUBTYPE_ACK</name></expr></argument>,
<argument><expr><name>IEEE80211_FC0_SUBTYPE_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_not</name><argument_list>(<argument><expr><name>b2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><name>b2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_bcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b2</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>

<case>case <expr><name>Q_ADDR3</name></expr>:</case>



<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_mcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><name>IEEE80211_FC0_TYPE_CTL</name></expr></argument>,
<argument><expr><name>IEEE80211_FC0_TYPE_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_not</name><argument_list>(<argument><expr><name>b0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_bcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>

<case>case <expr><name>Q_ADDR4</name></expr>:</case>






<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_mcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>,
<argument><expr><name>IEEE80211_FC1_DIR_DSTODS</name></expr></argument>, <argument><expr><name>IEEE80211_FC1_DIR_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_bcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">24</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>

<case>case <expr><name>Q_RA</name></expr>:</case>










<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>gen_load_a</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>new_block</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>JMP</name><argument_list>(<argument><expr><name>BPF_JSET</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b1</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">0x08</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b1</name><operator>-&gt;</operator><name>stmts</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>




<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_bcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><name>b0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>b0</name><operator>)</operator></expr>;</return>

<case>case <expr><name>Q_TA</name></expr>:</case>








<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_mcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><name>IEEE80211_FC0_TYPE_CTL</name></expr></argument>,
<argument><expr><name>IEEE80211_FC0_TYPE_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_not</name><argument_list>(<argument><expr><name>b0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_mcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><name>IEEE80211_FC0_SUBTYPE_CTS</name></expr></argument>,
<argument><expr><name>IEEE80211_FC0_SUBTYPE_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_not</name><argument_list>(<argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b2</name> <operator>=</operator> <call><name>gen_mcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><name>IEEE80211_FC0_SUBTYPE_ACK</name></expr></argument>,
<argument><expr><name>IEEE80211_FC0_SUBTYPE_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_not</name><argument_list>(<argument><expr><name>b2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><name>b2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>






<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>gen_load_a</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>new_block</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>JMP</name><argument_list>(<argument><expr><name>BPF_JSET</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b1</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">0x08</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b1</name><operator>-&gt;</operator><name>stmts</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>





<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><name>b2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_bcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b2</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>






<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_ipfchostop</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>u_char</name> <modifier>*</modifier></type><name>eaddr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>register</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b1</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>dir</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>Q_SRC</name></expr>:</case>
<return>return <expr><call><name>gen_bcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>Q_DST</name></expr>:</case>
<return>return <expr><call><name>gen_bcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>Q_AND</name></expr>:</case>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_ipfchostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>, <argument><expr><name>Q_SRC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_ipfchostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>, <argument><expr><name>Q_DST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>

<case>case <expr><name>Q_DEFAULT</name></expr>:</case>
<case>case <expr><name>Q_OR</name></expr>:</case>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_ipfchostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>, <argument><expr><name>Q_SRC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_ipfchostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>, <argument><expr><name>Q_DST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>

<case>case <expr><name>Q_ADDR1</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'addr1' and 'address1' are only supported on 802.11"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_ADDR2</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'addr2' and 'address2' are only supported on 802.11"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_ADDR3</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'addr3' and 'address3' are only supported on 802.11"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_ADDR4</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'addr4' and 'address4' are only supported on 802.11"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_RA</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'ra' is only supported on 802.11"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_TA</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'ta' is only supported on 802.11"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>



















<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_dnhostop</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>bpf_u_int32</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b2</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>u_int</name></type> <name>offset_lh</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>u_int</name></type> <name>offset_sh</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>dir</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>Q_DST</name></expr>:</case>
<expr_stmt><expr><name>offset_sh</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>offset_lh</name> <operator>=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Q_SRC</name></expr>:</case>
<expr_stmt><expr><name>offset_sh</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>offset_lh</name> <operator>=</operator> <literal type="number">15</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Q_AND</name></expr>:</case>

<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_dnhostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>Q_SRC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_dnhostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>Q_DST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>

<case>case <expr><name>Q_DEFAULT</name></expr>:</case>
<case>case <expr><name>Q_OR</name></expr>:</case>

<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_dnhostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>Q_SRC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_dnhostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>Q_DST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>

<case>case <expr><name>Q_ADDR1</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'addr1' and 'address1' are not valid qualifiers for addresses other than 802.11 MAC addresses"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_ADDR2</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'addr2' and 'address2' are not valid qualifiers for addresses other than 802.11 MAC addresses"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_ADDR3</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'addr3' and 'address3' are not valid qualifiers for addresses other than 802.11 MAC addresses"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_ADDR4</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'addr4' and 'address4' are not valid qualifiers for addresses other than 802.11 MAC addresses"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_RA</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'ra' is not a valid qualifier for addresses other than 802.11 MAC addresses"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_TA</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'ta' is not a valid qualifier for addresses other than 802.11 MAC addresses"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<default>default:</default>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ETHERTYPE_DN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>gen_mcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKPL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>,
<argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><call><name>ntohs</name><argument_list>(<argument><expr><literal type="number">0x0681</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><call><name>ntohs</name><argument_list>(<argument><expr><literal type="number">0x07FF</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKPL</name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>offset_lh</name></expr></argument>,
<argument><expr><name>BPF_H</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><call><name>ntohs</name><argument_list>(<argument><expr><operator>(</operator><name>u_short</name><operator>)</operator><name>addr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>gen_mcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKPL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><literal type="number">0x06</literal></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><literal type="number">0x7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b2</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKPL</name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>+</operator> <name>offset_lh</name></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><call><name>ntohs</name><argument_list>(<argument><expr><operator>(</operator><name>u_short</name><operator>)</operator><name>addr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>b2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b2</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>gen_mcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKPL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>,
<argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><call><name>ntohs</name><argument_list>(<argument><expr><literal type="number">0x0281</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><call><name>ntohs</name><argument_list>(<argument><expr><literal type="number">0x07FF</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b2</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKPL</name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>offset_sh</name></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><call><name>ntohs</name><argument_list>(<argument><expr><operator>(</operator><name>u_short</name><operator>)</operator><name>addr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>b2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b2</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>gen_mcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKPL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><literal type="number">0x02</literal></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><literal type="number">0x7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b2</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKPL</name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>+</operator> <name>offset_sh</name></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><call><name>ntohs</name><argument_list>(<argument><expr><operator>(</operator><name>u_short</name><operator>)</operator><name>addr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>b2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b2</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_mpls_linktype</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>proto</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b1</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>proto</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>Q_IP</name></expr>:</case>

<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_mcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKPL</name></expr></argument>, <argument><expr><operator>(</operator><name>u_int</name><operator>)</operator><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><literal type="number">0x01</literal></expr></argument>, <argument><expr><literal type="number">0x01</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_mcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKPL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><literal type="number">0x40</literal></expr></argument>, <argument><expr><literal type="number">0xf0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>

<case>case <expr><name>Q_IPV6</name></expr>:</case>

<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_mcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKPL</name></expr></argument>, <argument><expr><operator>(</operator><name>u_int</name><operator>)</operator><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><literal type="number">0x01</literal></expr></argument>, <argument><expr><literal type="number">0x01</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_mcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKPL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><literal type="number">0x60</literal></expr></argument>, <argument><expr><literal type="number">0xf0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>

<default>default:</default>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_host</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>bpf_u_int32</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>bpf_u_int32</name></type> <name>mask</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>proto</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dir</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b1</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>typestr</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>Q_NET</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>typestr</name> <operator>=</operator> <literal type="string">"net"</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>typestr</name> <operator>=</operator> <literal type="string">"host"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<switch>switch <condition>(<expr><name>proto</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>Q_DEFAULT</name></expr>:</case>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_host</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>Q_IP</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>label_stack_depth</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_host</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>Q_ARP</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_host</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>Q_RARP</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><name>b0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>b0</name></expr>;</return>

<case>case <expr><name>Q_LINK</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"link-layer modifier applied to %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_IP</name></expr>:</case>
<return>return <expr><call><name>gen_hostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name>ETHERTYPE_IP</name></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>Q_RARP</name></expr>:</case>
<return>return <expr><call><name>gen_hostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name>ETHERTYPE_REVARP</name></expr></argument>, <argument><expr><literal type="number">14</literal></expr></argument>, <argument><expr><literal type="number">24</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>Q_ARP</name></expr>:</case>
<return>return <expr><call><name>gen_hostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name>ETHERTYPE_ARP</name></expr></argument>, <argument><expr><literal type="number">14</literal></expr></argument>, <argument><expr><literal type="number">24</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>Q_SCTP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'sctp' modifier applied to %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_TCP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'tcp' modifier applied to %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_UDP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'udp' modifier applied to %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_ICMP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'icmp' modifier applied to %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_IGMP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'igmp' modifier applied to %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_IGRP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'igrp' modifier applied to %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_ATALK</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"AppleTalk host filtering not implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_DECNET</name></expr>:</case>
<return>return <expr><call><name>gen_dnhostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>Q_LAT</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"LAT host filtering not implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_SCA</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"SCA host filtering not implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_MOPRC</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"MOPRC host filtering not implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_MOPDL</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"MOPDL host filtering not implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_IPV6</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'ip6' modifier applied to ip host"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_ICMPV6</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'icmp6' modifier applied to %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_AH</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'ah' modifier applied to %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_ESP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'esp' modifier applied to %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_PIM</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'pim' modifier applied to %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_VRRP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'vrrp' modifier applied to %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_AARP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"AARP host filtering not implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_ISO</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"ISO host filtering not implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_ESIS</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'esis' modifier applied to %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_ISIS</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'isis' modifier applied to %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_CLNP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'clnp' modifier applied to %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_STP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'stp' modifier applied to %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_IPX</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"IPX host filtering not implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_NETBEUI</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'netbeui' modifier applied to %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_ISIS_L1</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'l1' modifier applied to %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_ISIS_L2</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'l2' modifier applied to %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_ISIS_IIH</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'iih' modifier applied to %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_ISIS_SNP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'snp' modifier applied to %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_ISIS_CSNP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'csnp' modifier applied to %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_ISIS_PSNP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'psnp' modifier applied to %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_ISIS_LSP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'lsp' modifier applied to %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_RADIO</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'radio' modifier applied to %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_CARP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'carp' modifier applied to %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<default>default:</default>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>INET6</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_host6</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>in6_addr</name></name> <modifier>*</modifier></type><name>addr</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>in6_addr</name></name> <modifier>*</modifier></type><name>mask</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>proto</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dir</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>typestr</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>Q_NET</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>typestr</name> <operator>=</operator> <literal type="string">"net"</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>typestr</name> <operator>=</operator> <literal type="string">"host"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<switch>switch <condition>(<expr><name>proto</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>Q_DEFAULT</name></expr>:</case>
<return>return <expr><call><name>gen_host6</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>Q_IPV6</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>Q_LINK</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"link-layer modifier applied to ip6 %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_IP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'ip' modifier applied to ip6 %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_RARP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'rarp' modifier applied to ip6 %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_ARP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'arp' modifier applied to ip6 %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_SCTP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'sctp' modifier applied to ip6 %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_TCP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'tcp' modifier applied to ip6 %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_UDP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'udp' modifier applied to ip6 %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_ICMP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'icmp' modifier applied to ip6 %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_IGMP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'igmp' modifier applied to ip6 %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_IGRP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'igrp' modifier applied to ip6 %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_ATALK</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"AppleTalk modifier applied to ip6 %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_DECNET</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'decnet' modifier applied to ip6 %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_LAT</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'lat' modifier applied to ip6 %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_SCA</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'sca' modifier applied to ip6 %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_MOPRC</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'moprc' modifier applied to ip6 %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_MOPDL</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'mopdl' modifier applied to ip6 %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_IPV6</name></expr>:</case>
<return>return <expr><call><name>gen_hostop6</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name>ETHERTYPE_IPV6</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><literal type="number">24</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>Q_ICMPV6</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'icmp6' modifier applied to ip6 %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_AH</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'ah' modifier applied to ip6 %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_ESP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'esp' modifier applied to ip6 %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_PIM</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'pim' modifier applied to ip6 %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_VRRP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'vrrp' modifier applied to ip6 %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_AARP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'aarp' modifier applied to ip6 %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_ISO</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'iso' modifier applied to ip6 %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_ESIS</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'esis' modifier applied to ip6 %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_ISIS</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'isis' modifier applied to ip6 %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_CLNP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'clnp' modifier applied to ip6 %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_STP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'stp' modifier applied to ip6 %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_IPX</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'ipx' modifier applied to ip6 %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_NETBEUI</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'netbeui' modifier applied to ip6 %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_ISIS_L1</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'l1' modifier applied to ip6 %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_ISIS_L2</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'l2' modifier applied to ip6 %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_ISIS_IIH</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'iih' modifier applied to ip6 %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_ISIS_SNP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'snp' modifier applied to ip6 %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_ISIS_CSNP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'csnp' modifier applied to ip6 %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_ISIS_PSNP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'psnp' modifier applied to ip6 %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_ISIS_LSP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'lsp' modifier applied to ip6 %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_RADIO</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'radio' modifier applied to ip6 %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_CARP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'carp' modifier applied to ip6 %s"</literal></expr></argument>, <argument><expr><name>typestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<default>default:</default>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>

</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>INET6</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_gateway</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>u_char</name> <modifier>*</modifier></type><name>eaddr</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>addrinfo</name></name> <modifier>*</modifier></type><name>alist</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>proto</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>addrinfo</name></name> <modifier>*</modifier></type><name>ai</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sockaddr_in</name></name> <modifier>*</modifier></type><name>sin</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>dir</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"direction applied to 'gateway'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name>proto</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>Q_DEFAULT</name></expr>:</case>
<case>case <expr><name>Q_IP</name></expr>:</case>
<case>case <expr><name>Q_ARP</name></expr>:</case>
<case>case <expr><name>Q_RARP</name></expr>:</case>
<switch>switch <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DLT_EN10MB</name></expr>:</case>
<case>case <expr><name>DLT_NETANALYZER</name></expr>:</case>
<case>case <expr><name>DLT_NETANALYZER_TRANSPARENT</name></expr>:</case>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_prevlinkhdr_check</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_ehostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>, <argument><expr><name>Q_OR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>b1</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><name>b0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>DLT_FDDI</name></expr>:</case>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_fhostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>, <argument><expr><name>Q_OR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DLT_IEEE802</name></expr>:</case>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_thostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>, <argument><expr><name>Q_OR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DLT_IEEE802_11</name></expr>:</case>
<case>case <expr><name>DLT_PRISM_HEADER</name></expr>:</case>
<case>case <expr><name>DLT_IEEE802_11_RADIO_AVS</name></expr>:</case>
<case>case <expr><name>DLT_IEEE802_11_RADIO</name></expr>:</case>
<case>case <expr><name>DLT_PPI</name></expr>:</case>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_wlanhostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>, <argument><expr><name>Q_OR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DLT_SUNATM</name></expr>:</case>





<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>,
<argument><expr><literal type="string">"'gateway' supported only on ethernet/FDDI/token ring/802.11/ATM LANE/Fibre Channel"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DLT_IP_OVER_FC</name></expr>:</case>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_ipfchostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>, <argument><expr><name>Q_OR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>,
<argument><expr><literal type="string">"'gateway' supported only on ethernet/FDDI/token ring/802.11/ATM LANE/Fibre Channel"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>ai</name> <operator>=</operator> <name>alist</name></expr>;</init> <condition><expr><name>ai</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ai</name> <operator>=</operator> <name><name>ai</name><operator>-&gt;</operator><name>ai_next</name></name></expr></incr>)</control> <block>{<block_content>



<if_stmt><if>if <condition>(<expr><name><name>ai</name><operator>-&gt;</operator><name>ai_addr</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>



<if_stmt><if>if <condition>(<expr><name><name>ai</name><operator>-&gt;</operator><name>ai_addr</name><operator>-&gt;</operator><name>sa_family</name></name> <operator>==</operator> <name>AF_INET</name></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><name>sin</name> <operator>=</operator> <operator>(</operator>struct <name>sockaddr_in</name> <operator>*</operator><operator>)</operator><name><name>ai</name><operator>-&gt;</operator><name>ai_addr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>gen_host</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>,
<argument><expr><call><name>ntohl</name><argument_list>(<argument><expr><name><name>sin</name><operator>-&gt;</operator><name>sin_addr</name><operator>.</operator><name>s_addr</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><literal type="number">0xffffffff</literal></expr></argument>, <argument><expr><name>proto</name></expr></argument>, <argument><expr><name>Q_OR</name></expr></argument>, <argument><expr><name>Q_HOST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name>b1</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><name>b1</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>





<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>b1</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>



<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>gen_not</name><argument_list>(<argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"illegal modifier of 'gateway'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_proto_abbrev_internal</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>proto</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b1</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>proto</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>Q_SCTP</name></expr>:</case>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_proto</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>IPPROTO_SCTP</name></expr></argument>, <argument><expr><name>Q_IP</name></expr></argument>, <argument><expr><name>Q_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_proto</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>IPPROTO_SCTP</name></expr></argument>, <argument><expr><name>Q_IPV6</name></expr></argument>, <argument><expr><name>Q_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Q_TCP</name></expr>:</case>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_proto</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>IPPROTO_TCP</name></expr></argument>, <argument><expr><name>Q_IP</name></expr></argument>, <argument><expr><name>Q_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_proto</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>IPPROTO_TCP</name></expr></argument>, <argument><expr><name>Q_IPV6</name></expr></argument>, <argument><expr><name>Q_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Q_UDP</name></expr>:</case>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_proto</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>IPPROTO_UDP</name></expr></argument>, <argument><expr><name>Q_IP</name></expr></argument>, <argument><expr><name>Q_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_proto</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>IPPROTO_UDP</name></expr></argument>, <argument><expr><name>Q_IPV6</name></expr></argument>, <argument><expr><name>Q_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Q_ICMP</name></expr>:</case>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_proto</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>IPPROTO_ICMP</name></expr></argument>, <argument><expr><name>Q_IP</name></expr></argument>, <argument><expr><name>Q_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>IPPROTO_IGMP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IPPROTO_IGMP</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<case>case <expr><name>Q_IGMP</name></expr>:</case>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_proto</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>IPPROTO_IGMP</name></expr></argument>, <argument><expr><name>Q_IP</name></expr></argument>, <argument><expr><name>Q_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>IPPROTO_IGRP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IPPROTO_IGRP</name></cpp:macro> <cpp:value>9</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<case>case <expr><name>Q_IGRP</name></expr>:</case>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_proto</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>IPPROTO_IGRP</name></expr></argument>, <argument><expr><name>Q_IP</name></expr></argument>, <argument><expr><name>Q_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>IPPROTO_PIM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IPPROTO_PIM</name></cpp:macro> <cpp:value>103</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<case>case <expr><name>Q_PIM</name></expr>:</case>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_proto</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>IPPROTO_PIM</name></expr></argument>, <argument><expr><name>Q_IP</name></expr></argument>, <argument><expr><name>Q_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_proto</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>IPPROTO_PIM</name></expr></argument>, <argument><expr><name>Q_IPV6</name></expr></argument>, <argument><expr><name>Q_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>IPPROTO_VRRP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IPPROTO_VRRP</name></cpp:macro> <cpp:value>112</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<case>case <expr><name>Q_VRRP</name></expr>:</case>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_proto</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>IPPROTO_VRRP</name></expr></argument>, <argument><expr><name>Q_IP</name></expr></argument>, <argument><expr><name>Q_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>IPPROTO_CARP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IPPROTO_CARP</name></cpp:macro> <cpp:value>112</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<case>case <expr><name>Q_CARP</name></expr>:</case>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_proto</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>IPPROTO_CARP</name></expr></argument>, <argument><expr><name>Q_IP</name></expr></argument>, <argument><expr><name>Q_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Q_IP</name></expr>:</case>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ETHERTYPE_IP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Q_ARP</name></expr>:</case>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ETHERTYPE_ARP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Q_RARP</name></expr>:</case>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ETHERTYPE_REVARP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Q_LINK</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"link layer applied in wrong context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_ATALK</name></expr>:</case>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ETHERTYPE_ATALK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Q_AARP</name></expr>:</case>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ETHERTYPE_AARP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Q_DECNET</name></expr>:</case>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ETHERTYPE_DN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Q_SCA</name></expr>:</case>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ETHERTYPE_SCA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Q_LAT</name></expr>:</case>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ETHERTYPE_LAT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Q_MOPDL</name></expr>:</case>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ETHERTYPE_MOPDL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Q_MOPRC</name></expr>:</case>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ETHERTYPE_MOPRC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Q_IPV6</name></expr>:</case>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ETHERTYPE_IPV6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>IPPROTO_ICMPV6</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IPPROTO_ICMPV6</name></cpp:macro> <cpp:value>58</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<case>case <expr><name>Q_ICMPV6</name></expr>:</case>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_proto</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>IPPROTO_ICMPV6</name></expr></argument>, <argument><expr><name>Q_IPV6</name></expr></argument>, <argument><expr><name>Q_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>IPPROTO_AH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IPPROTO_AH</name></cpp:macro> <cpp:value>51</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<case>case <expr><name>Q_AH</name></expr>:</case>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_proto</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>IPPROTO_AH</name></expr></argument>, <argument><expr><name>Q_IP</name></expr></argument>, <argument><expr><name>Q_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_proto</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>IPPROTO_AH</name></expr></argument>, <argument><expr><name>Q_IPV6</name></expr></argument>, <argument><expr><name>Q_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>IPPROTO_ESP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IPPROTO_ESP</name></cpp:macro> <cpp:value>50</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<case>case <expr><name>Q_ESP</name></expr>:</case>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_proto</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>IPPROTO_ESP</name></expr></argument>, <argument><expr><name>Q_IP</name></expr></argument>, <argument><expr><name>Q_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_proto</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>IPPROTO_ESP</name></expr></argument>, <argument><expr><name>Q_IPV6</name></expr></argument>, <argument><expr><name>Q_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Q_ISO</name></expr>:</case>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>LLCSAP_ISONS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Q_ESIS</name></expr>:</case>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_proto</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ISO9542_ESIS</name></expr></argument>, <argument><expr><name>Q_ISO</name></expr></argument>, <argument><expr><name>Q_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Q_ISIS</name></expr>:</case>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_proto</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ISO10589_ISIS</name></expr></argument>, <argument><expr><name>Q_ISO</name></expr></argument>, <argument><expr><name>Q_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Q_ISIS_L1</name></expr>:</case>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_proto</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ISIS_L1_LAN_IIH</name></expr></argument>, <argument><expr><name>Q_ISIS</name></expr></argument>, <argument><expr><name>Q_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_proto</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ISIS_PTP_IIH</name></expr></argument>, <argument><expr><name>Q_ISIS</name></expr></argument>, <argument><expr><name>Q_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_proto</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ISIS_L1_LSP</name></expr></argument>, <argument><expr><name>Q_ISIS</name></expr></argument>, <argument><expr><name>Q_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_proto</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ISIS_L1_CSNP</name></expr></argument>, <argument><expr><name>Q_ISIS</name></expr></argument>, <argument><expr><name>Q_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_proto</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ISIS_L1_PSNP</name></expr></argument>, <argument><expr><name>Q_ISIS</name></expr></argument>, <argument><expr><name>Q_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Q_ISIS_L2</name></expr>:</case>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_proto</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ISIS_L2_LAN_IIH</name></expr></argument>, <argument><expr><name>Q_ISIS</name></expr></argument>, <argument><expr><name>Q_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_proto</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ISIS_PTP_IIH</name></expr></argument>, <argument><expr><name>Q_ISIS</name></expr></argument>, <argument><expr><name>Q_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_proto</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ISIS_L2_LSP</name></expr></argument>, <argument><expr><name>Q_ISIS</name></expr></argument>, <argument><expr><name>Q_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_proto</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ISIS_L2_CSNP</name></expr></argument>, <argument><expr><name>Q_ISIS</name></expr></argument>, <argument><expr><name>Q_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_proto</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ISIS_L2_PSNP</name></expr></argument>, <argument><expr><name>Q_ISIS</name></expr></argument>, <argument><expr><name>Q_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Q_ISIS_IIH</name></expr>:</case>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_proto</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ISIS_L1_LAN_IIH</name></expr></argument>, <argument><expr><name>Q_ISIS</name></expr></argument>, <argument><expr><name>Q_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_proto</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ISIS_L2_LAN_IIH</name></expr></argument>, <argument><expr><name>Q_ISIS</name></expr></argument>, <argument><expr><name>Q_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_proto</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ISIS_PTP_IIH</name></expr></argument>, <argument><expr><name>Q_ISIS</name></expr></argument>, <argument><expr><name>Q_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Q_ISIS_LSP</name></expr>:</case>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_proto</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ISIS_L1_LSP</name></expr></argument>, <argument><expr><name>Q_ISIS</name></expr></argument>, <argument><expr><name>Q_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_proto</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ISIS_L2_LSP</name></expr></argument>, <argument><expr><name>Q_ISIS</name></expr></argument>, <argument><expr><name>Q_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Q_ISIS_SNP</name></expr>:</case>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_proto</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ISIS_L1_CSNP</name></expr></argument>, <argument><expr><name>Q_ISIS</name></expr></argument>, <argument><expr><name>Q_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_proto</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ISIS_L2_CSNP</name></expr></argument>, <argument><expr><name>Q_ISIS</name></expr></argument>, <argument><expr><name>Q_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_proto</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ISIS_L1_PSNP</name></expr></argument>, <argument><expr><name>Q_ISIS</name></expr></argument>, <argument><expr><name>Q_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_proto</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ISIS_L2_PSNP</name></expr></argument>, <argument><expr><name>Q_ISIS</name></expr></argument>, <argument><expr><name>Q_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Q_ISIS_CSNP</name></expr>:</case>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_proto</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ISIS_L1_CSNP</name></expr></argument>, <argument><expr><name>Q_ISIS</name></expr></argument>, <argument><expr><name>Q_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_proto</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ISIS_L2_CSNP</name></expr></argument>, <argument><expr><name>Q_ISIS</name></expr></argument>, <argument><expr><name>Q_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Q_ISIS_PSNP</name></expr>:</case>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_proto</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ISIS_L1_PSNP</name></expr></argument>, <argument><expr><name>Q_ISIS</name></expr></argument>, <argument><expr><name>Q_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_proto</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ISIS_L2_PSNP</name></expr></argument>, <argument><expr><name>Q_ISIS</name></expr></argument>, <argument><expr><name>Q_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Q_CLNP</name></expr>:</case>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_proto</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ISO8473_CLNP</name></expr></argument>, <argument><expr><name>Q_ISO</name></expr></argument>, <argument><expr><name>Q_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Q_STP</name></expr>:</case>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>LLCSAP_8021D</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Q_IPX</name></expr>:</case>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>LLCSAP_IPX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Q_NETBEUI</name></expr>:</case>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>LLCSAP_NETBEUI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Q_RADIO</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'radio' is not a valid protocol type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<default>default:</default>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
<return>return <expr><name>b1</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_proto_abbrev</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>proto</name></decl></parameter>)</parameter_list>
<block>{<block_content>




<if_stmt><if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>top_ctx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>gen_proto_abbrev_internal</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_ipfrag</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>


<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>gen_load_a</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKPL</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>new_block</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>JMP</name><argument_list>(<argument><expr><name>BPF_JSET</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">0x1fff</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>stmts</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_not</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>b</name></expr>;</return>
</block_content>}</block></function>










<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_portatom</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>off</name></decl></parameter>, <parameter><decl><type><name>bpf_int32</name></type> <name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_TRAN_IPV4</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_portatom6</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>off</name></decl></parameter>, <parameter><decl><type><name>bpf_int32</name></type> <name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_TRAN_IPV6</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_portop</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>port</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>proto</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>


<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKPL</name></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_ipfrag</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>b0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>dir</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>Q_SRC</name></expr>:</case>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_portatom</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Q_DST</name></expr>:</case>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_portatom</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Q_AND</name></expr>:</case>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>gen_portatom</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_portatom</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Q_DEFAULT</name></expr>:</case>
<case>case <expr><name>Q_OR</name></expr>:</case>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>gen_portatom</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_portatom</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Q_ADDR1</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'addr1' and 'address1' are not valid qualifiers for ports"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_ADDR2</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'addr2' and 'address2' are not valid qualifiers for ports"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_ADDR3</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'addr3' and 'address3' are not valid qualifiers for ports"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_ADDR4</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'addr4' and 'address4' are not valid qualifiers for ports"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_RA</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'ra' is not a valid qualifier for ports"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_TA</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'ta' is not a valid qualifier for ports"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<default>default:</default>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>b1</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_port</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>port</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ip_proto</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>


















<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ETHERTYPE_IP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>ip_proto</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>IPPROTO_UDP</name></expr>:</case>
<case>case <expr><name>IPPROTO_TCP</name></expr>:</case>
<case>case <expr><name>IPPROTO_SCTP</name></expr>:</case>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_portop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><name>ip_proto</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>PROTO_UNDEF</name></expr>:</case>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>gen_portop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><name>IPPROTO_TCP</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_portop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><name>IPPROTO_UDP</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>gen_portop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><name>IPPROTO_SCTP</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<default>default:</default>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_portop6</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>port</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>proto</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>



<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKPL</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>dir</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>Q_SRC</name></expr>:</case>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_portatom6</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Q_DST</name></expr>:</case>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_portatom6</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Q_AND</name></expr>:</case>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>gen_portatom6</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_portatom6</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Q_DEFAULT</name></expr>:</case>
<case>case <expr><name>Q_OR</name></expr>:</case>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>gen_portatom6</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_portatom6</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<default>default:</default>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>b1</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_port6</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>port</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ip_proto</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>


<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ETHERTYPE_IPV6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>ip_proto</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>IPPROTO_UDP</name></expr>:</case>
<case>case <expr><name>IPPROTO_TCP</name></expr>:</case>
<case>case <expr><name>IPPROTO_SCTP</name></expr>:</case>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_portop6</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><name>ip_proto</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>PROTO_UNDEF</name></expr>:</case>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>gen_portop6</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><name>IPPROTO_TCP</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_portop6</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><name>IPPROTO_UDP</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>gen_portop6</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><name>IPPROTO_SCTP</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<default>default:</default>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_portrangeatom</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>off</name></decl></parameter>, <parameter><decl><type><name>bpf_int32</name></type> <name>v1</name></decl></parameter>,
<parameter><decl><type><name>bpf_int32</name></type> <name>v2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b2</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>v1</name> <operator>&gt;</operator> <name>v2</name></expr>)</condition> <block>{<block_content>



<decl_stmt><decl><type><name>bpf_int32</name></type> <name>vtemp</name></decl>;</decl_stmt>

<expr_stmt><expr><name>vtemp</name> <operator>=</operator> <name>v1</name></expr>;</expr_stmt>
<expr_stmt><expr><name>v1</name> <operator>=</operator> <name>v2</name></expr>;</expr_stmt>
<expr_stmt><expr><name>v2</name> <operator>=</operator> <name>vtemp</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_cmp_ge</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_TRAN_IPV4</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>, <argument><expr><name>v1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b2</name> <operator>=</operator> <call><name>gen_cmp_le</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_TRAN_IPV4</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><name>b2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>b2</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_portrangeop</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>port1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>port2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>proto</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>


<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKPL</name></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_ipfrag</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>b0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>dir</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>Q_SRC</name></expr>:</case>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_portrangeatom</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>port1</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>port2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Q_DST</name></expr>:</case>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_portrangeatom</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>port1</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>port2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Q_AND</name></expr>:</case>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>gen_portrangeatom</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>port1</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>port2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_portrangeatom</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>port1</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>port2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Q_DEFAULT</name></expr>:</case>
<case>case <expr><name>Q_OR</name></expr>:</case>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>gen_portrangeatom</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>port1</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>port2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_portrangeatom</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>port1</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>port2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Q_ADDR1</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'addr1' and 'address1' are not valid qualifiers for port ranges"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_ADDR2</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'addr2' and 'address2' are not valid qualifiers for port ranges"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_ADDR3</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'addr3' and 'address3' are not valid qualifiers for port ranges"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_ADDR4</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'addr4' and 'address4' are not valid qualifiers for port ranges"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_RA</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'ra' is not a valid qualifier for port ranges"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_TA</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'ta' is not a valid qualifier for port ranges"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<default>default:</default>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>b1</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_portrange</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>port1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>port2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ip_proto</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>


<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ETHERTYPE_IP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>ip_proto</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>IPPROTO_UDP</name></expr>:</case>
<case>case <expr><name>IPPROTO_TCP</name></expr>:</case>
<case>case <expr><name>IPPROTO_SCTP</name></expr>:</case>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_portrangeop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>port1</name></expr></argument>, <argument><expr><name>port2</name></expr></argument>, <argument><expr><name>ip_proto</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>PROTO_UNDEF</name></expr>:</case>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>gen_portrangeop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>port1</name></expr></argument>, <argument><expr><name>port2</name></expr></argument>, <argument><expr><name>IPPROTO_TCP</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_portrangeop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>port1</name></expr></argument>, <argument><expr><name>port2</name></expr></argument>, <argument><expr><name>IPPROTO_UDP</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>gen_portrangeop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>port1</name></expr></argument>, <argument><expr><name>port2</name></expr></argument>, <argument><expr><name>IPPROTO_SCTP</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<default>default:</default>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_portrangeatom6</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>off</name></decl></parameter>, <parameter><decl><type><name>bpf_int32</name></type> <name>v1</name></decl></parameter>,
<parameter><decl><type><name>bpf_int32</name></type> <name>v2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b2</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>v1</name> <operator>&gt;</operator> <name>v2</name></expr>)</condition> <block>{<block_content>



<decl_stmt><decl><type><name>bpf_int32</name></type> <name>vtemp</name></decl>;</decl_stmt>

<expr_stmt><expr><name>vtemp</name> <operator>=</operator> <name>v1</name></expr>;</expr_stmt>
<expr_stmt><expr><name>v1</name> <operator>=</operator> <name>v2</name></expr>;</expr_stmt>
<expr_stmt><expr><name>v2</name> <operator>=</operator> <name>vtemp</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_cmp_ge</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_TRAN_IPV6</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>, <argument><expr><name>v1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b2</name> <operator>=</operator> <call><name>gen_cmp_le</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_TRAN_IPV6</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><name>b2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>b2</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_portrangeop6</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>port1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>port2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>proto</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>



<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKPL</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>dir</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>Q_SRC</name></expr>:</case>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_portrangeatom6</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>port1</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>port2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Q_DST</name></expr>:</case>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_portrangeatom6</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>port1</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>port2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Q_AND</name></expr>:</case>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>gen_portrangeatom6</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>port1</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>port2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_portrangeatom6</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>port1</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>port2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Q_DEFAULT</name></expr>:</case>
<case>case <expr><name>Q_OR</name></expr>:</case>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>gen_portrangeatom6</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>port1</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>port2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_portrangeatom6</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>port1</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>port2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<default>default:</default>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>b1</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_portrange6</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>port1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>port2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ip_proto</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>


<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ETHERTYPE_IPV6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>ip_proto</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>IPPROTO_UDP</name></expr>:</case>
<case>case <expr><name>IPPROTO_TCP</name></expr>:</case>
<case>case <expr><name>IPPROTO_SCTP</name></expr>:</case>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_portrangeop6</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>port1</name></expr></argument>, <argument><expr><name>port2</name></expr></argument>, <argument><expr><name>ip_proto</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>PROTO_UNDEF</name></expr>:</case>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>gen_portrangeop6</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>port1</name></expr></argument>, <argument><expr><name>port2</name></expr></argument>, <argument><expr><name>IPPROTO_TCP</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_portrangeop6</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>port1</name></expr></argument>, <argument><expr><name>port2</name></expr></argument>, <argument><expr><name>IPPROTO_UDP</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>gen_portrangeop6</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>port1</name></expr></argument>, <argument><expr><name>port2</name></expr></argument>, <argument><expr><name>IPPROTO_SCTP</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<default>default:</default>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>lookup_proto</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>proto</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type> <name>v</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>proto</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>Q_DEFAULT</name></expr>:</case>
<case>case <expr><name>Q_IP</name></expr>:</case>
<case>case <expr><name>Q_IPV6</name></expr>:</case>
<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>pcap_nametoproto</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>v</name> <operator>==</operator> <name>PROTO_UNDEF</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"unknown ip proto '%s'"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>Q_LINK</name></expr>:</case>

<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>pcap_nametoeproto</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>v</name> <operator>==</operator> <name>PROTO_UNDEF</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>pcap_nametollc</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>v</name> <operator>==</operator> <name>PROTO_UNDEF</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"unknown ether proto '%s'"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>Q_ISO</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"esis"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>v</name> <operator>=</operator> <name>ISO9542_ESIS</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"isis"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>v</name> <operator>=</operator> <name>ISO10589_ISIS</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"clnp"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>v</name> <operator>=</operator> <name>ISO8473_CLNP</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"unknown osi proto '%s'"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<break>break;</break>

<default>default:</default>
<expr_stmt><expr><name>v</name> <operator>=</operator> <name>PROTO_UNDEF</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<return>return <expr><name>v</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
struct stmt *
gen_joinsp(struct stmt **s, int n)
{
return NULL;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_protochain</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>proto</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NO_PROTOCHAIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><call><name>gen_proto</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name><name>s</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fix2</name></decl>, <decl><type ref="prev"/><name>fix3</name></decl>, <decl><type ref="prev"/><name>fix4</name></decl>, <decl><type ref="prev"/><name>fix5</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ahcheck</name></decl>, <decl><type ref="prev"/><name>again</name></decl>, <decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>max</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>reg2</name> <init>= <expr><call><name>alloc_reg</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>fix3</name> <operator>=</operator> <name>fix4</name> <operator>=</operator> <name>fix5</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>proto</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>Q_IP</name></expr>:</case>
<case>case <expr><name>Q_IPV6</name></expr>:</case>
<break>break;</break>
<case>case <expr><name>Q_DEFAULT</name></expr>:</case>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_protochain</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>Q_IP</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>gen_protochain</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>Q_IPV6</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b</name></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"bad protocol applied for 'protochain'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>












<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>is_variable</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'protochain' not supported with variable length headers"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>no_optimize</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>






<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>proto</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>Q_IP</name></expr>:</case>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ETHERTYPE_IP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LD</name><operator>|</operator><name>BPF_ABS</name><operator>|</operator><name>BPF_B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>+</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>+</operator> <literal type="number">9</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LDX</name><operator>|</operator><name>BPF_MSH</name><operator>|</operator><name>BPF_B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>+</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Q_IPV6</name></expr>:</case>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ETHERTYPE_IPV6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LD</name><operator>|</operator><name>BPF_ABS</name><operator>|</operator><name>BPF_B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>+</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>+</operator> <literal type="number">6</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LDX</name><operator>|</operator><name>BPF_IMM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">40</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
<break>break;</break>

<default>default:</default>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"unsupported proto to gen_protochain"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>


<expr_stmt><expr><name>again</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_JMP</name><operator>|</operator><name>BPF_JEQ</name><operator>|</operator><name>BPF_K</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>jt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>jf</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>fix5</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>IPPROTO_NONE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IPPROTO_NONE</name></cpp:macro> <cpp:value>59</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_JMP</name><operator>|</operator><name>BPF_JEQ</name><operator>|</operator><name>BPF_K</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>jt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>jf</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name>IPPROTO_NONE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>fix5</name></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>jf</name></name> <operator>=</operator> <name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>fix2</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>proto</name> <operator>==</operator> <name>Q_IPV6</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>v6start</name></decl>, <decl><type ref="prev"/><name>v6end</name></decl>, <decl><type ref="prev"/><name>v6advance</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<expr_stmt><expr><name>v6start</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_JMP</name><operator>|</operator><name>BPF_JEQ</name><operator>|</operator><name>BPF_K</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>jt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>jf</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name>IPPROTO_HOPOPTS</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>fix2</name></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>jf</name></name> <operator>=</operator> <name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>jf</name></name> <operator>=</operator> <name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_JMP</name><operator>|</operator><name>BPF_JEQ</name><operator>|</operator><name>BPF_K</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>jt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>jf</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name>IPPROTO_DSTOPTS</name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>jf</name></name> <operator>=</operator> <name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_JMP</name><operator>|</operator><name>BPF_JEQ</name><operator>|</operator><name>BPF_K</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>jt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>jf</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name>IPPROTO_ROUTING</name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>jf</name></name> <operator>=</operator> <name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_JMP</name><operator>|</operator><name>BPF_JEQ</name><operator>|</operator><name>BPF_K</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>jt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>jf</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name>IPPROTO_FRAGMENT</name></expr>;</expr_stmt>
<expr_stmt><expr><name>fix3</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name>v6end</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>


<expr_stmt><expr><name>v6advance</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>







<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LD</name><operator>|</operator><name>BPF_IND</name><operator>|</operator><name>BPF_B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>+</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name>reg2</name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LD</name><operator>|</operator><name>BPF_IND</name><operator>|</operator><name>BPF_B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>+</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ALU</name><operator>|</operator><name>BPF_ADD</name><operator>|</operator><name>BPF_K</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ALU</name><operator>|</operator><name>BPF_MUL</name><operator>|</operator><name>BPF_K</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ALU</name><operator>|</operator><name>BPF_ADD</name><operator>|</operator><name>BPF_X</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_MISC</name><operator>|</operator><name>BPF_TAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LD</name><operator>|</operator><name>BPF_MEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name>reg2</name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>


<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_JMP</name><operator>|</operator><name>BPF_JA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name>again</name> <operator>-</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>jf</name></name> <operator>=</operator> <name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>


<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>v6start</name></expr>;</init> <condition><expr><name>j</name> <operator>&lt;=</operator> <name>v6end</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>jt</name></name> <operator>=</operator> <name><name>s</name><index>[<expr><name>v6advance</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ALU</name><operator>|</operator><name>BPF_ADD</name><operator>|</operator><name>BPF_K</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>fix2</name></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>jf</name></name> <operator>=</operator> <name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<expr_stmt><expr><name>ahcheck</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_JMP</name><operator>|</operator><name>BPF_JEQ</name><operator>|</operator><name>BPF_K</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>jt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>jf</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name>IPPROTO_AH</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fix3</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>fix3</name></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>jf</name></name> <operator>=</operator> <name><name>s</name><index>[<expr><name>ahcheck</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>fix4</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>







<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>jt</name></name> <operator>=</operator> <name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_MISC</name><operator>|</operator><name>BPF_TXA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LD</name><operator>|</operator><name>BPF_IND</name><operator>|</operator><name>BPF_B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>+</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name>reg2</name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>jt</name></name> <operator>=</operator> <name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_MISC</name><operator>|</operator><name>BPF_TXA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ALU</name><operator>|</operator><name>BPF_ADD</name><operator>|</operator><name>BPF_K</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_MISC</name><operator>|</operator><name>BPF_TAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LD</name><operator>|</operator><name>BPF_IND</name><operator>|</operator><name>BPF_B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>+</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ALU</name><operator>|</operator><name>BPF_ADD</name><operator>|</operator><name>BPF_K</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ALU</name><operator>|</operator><name>BPF_MUL</name><operator>|</operator><name>BPF_K</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_MISC</name><operator>|</operator><name>BPF_TAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LD</name><operator>|</operator><name>BPF_MEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name>reg2</name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>


<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_JMP</name><operator>|</operator><name>BPF_JA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name>again</name> <operator>-</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>


<expr_stmt><expr><name>end</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ALU</name><operator>|</operator><name>BPF_ADD</name><operator>|</operator><name>BPF_K</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>fix2</name></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>jt</name></name> <operator>=</operator> <name><name>s</name><index>[<expr><name>end</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>fix4</name></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>jf</name></name> <operator>=</operator> <name><name>s</name><index>[<expr><name>end</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>fix5</name></expr>]</index></name><operator>-&gt;</operator><name><name>s</name><operator>.</operator><name>jt</name></name> <operator>=</operator> <name><name>s</name><index>[<expr><name>end</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>




<expr_stmt><expr><name>max</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>next</name> <operator>=</operator> <name><name>s</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>max</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>next</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>




<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>new_block</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>JMP</name><argument_list>(<argument><expr><name>BPF_JEQ</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>stmts</name></name> <operator>=</operator> <name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free_reg</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>reg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_check_802_11_data_frame</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b1</name></decl>;</decl_stmt>





<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>gen_load_a</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>new_block</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>JMP</name><argument_list>(<argument><expr><name>BPF_JSET</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b0</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">0x08</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b0</name><operator>-&gt;</operator><name>stmts</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>gen_load_a</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>new_block</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>JMP</name><argument_list>(<argument><expr><name>BPF_JSET</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b1</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">0x04</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b1</name><operator>-&gt;</operator><name>stmts</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_not</name><argument_list>(<argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><name>b0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>b0</name></expr>;</return>
</block_content>}</block></function>










<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_proto</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>proto</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b1</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>CHASE_CHAIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b2</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>dir</name> <operator>!=</operator> <name>Q_DEFAULT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"direction applied to 'proto'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name>proto</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>Q_DEFAULT</name></expr>:</case>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_proto</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>Q_IP</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_proto</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>Q_IPV6</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>

<case>case <expr><name>Q_LINK</name></expr>:</case>
<return>return <expr><call><name>gen_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>Q_IP</name></expr>:</case>















<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ETHERTYPE_IP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>CHASE_CHAIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKPL</name></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_protochain</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>Q_IP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>

<case>case <expr><name>Q_ARP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"arp does not encapsulate another protocol"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_RARP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"rarp does not encapsulate another protocol"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_SCTP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'sctp proto' is bogus"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_TCP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'tcp proto' is bogus"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_UDP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'udp proto' is bogus"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_ICMP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'icmp proto' is bogus"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_IGMP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'igmp proto' is bogus"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_IGRP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'igrp proto' is bogus"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_ATALK</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"AppleTalk encapsulation is not specifiable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_DECNET</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"DECNET encapsulation is not specifiable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_LAT</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"LAT does not encapsulate another protocol"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_SCA</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"SCA does not encapsulate another protocol"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_MOPRC</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"MOPRC does not encapsulate another protocol"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_MOPDL</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"MOPDL does not encapsulate another protocol"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_IPV6</name></expr>:</case>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ETHERTYPE_IPV6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>CHASE_CHAIN</name></expr></argument>)</argument_list></call></expr></cpp:if>




<expr_stmt><expr><name>b2</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKPL</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><name>IPPROTO_FRAGMENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKPL</name></expr></argument>, <argument><expr><literal type="number">40</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b2</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b2</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKPL</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b2</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_protochain</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>Q_IPV6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>

<case>case <expr><name>Q_ICMPV6</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'icmp6 proto' is bogus"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_AH</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'ah proto' is bogus"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_ESP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'ah proto' is bogus"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_PIM</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'pim proto' is bogus"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_VRRP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'vrrp proto' is bogus"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_AARP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'aarp proto' is bogus"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_ISO</name></expr>:</case>
<switch>switch <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>DLT_FRELAY</name></expr>:</case>


















<return>return <expr><call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>, <argument><expr><operator>(</operator><literal type="number">0x03</literal><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator> <operator>|</operator> <name>v</name></expr></argument>)</argument_list></call></expr>;</return>


<case>case <expr><name>DLT_C_HDLC</name></expr>:</case>




<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>LLCSAP_ISONS</name><operator>&lt;&lt;</operator><literal type="number">8</literal> <operator>|</operator> <name>LLCSAP_ISONS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKPL_NOSNAP</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>

<default>default:</default>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>LLCSAP_ISONS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKPL_NOSNAP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>
</block_content>}</block></switch>

<case>case <expr><name>Q_ESIS</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'esis proto' is bogus"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_ISIS</name></expr>:</case>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_proto</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ISO10589_ISIS</name></expr></argument>, <argument><expr><name>Q_ISO</name></expr></argument>, <argument><expr><name>Q_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKPL_NOSNAP</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>

<case>case <expr><name>Q_CLNP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'clnp proto' is not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_STP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'stp proto' is bogus"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_IPX</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'ipx proto' is bogus"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_NETBEUI</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'netbeui proto' is bogus"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_ISIS_L1</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'l1 proto' is bogus"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_ISIS_L2</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'l2 proto' is bogus"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_ISIS_IIH</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'iih proto' is bogus"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_ISIS_SNP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'snp proto' is bogus"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_ISIS_CSNP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'csnp proto' is bogus"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_ISIS_PSNP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'psnp proto' is bogus"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_ISIS_LSP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'lsp proto' is bogus"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_RADIO</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'radio proto' is bogus"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_CARP</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'carp proto' is bogus"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<default>default:</default>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_scode</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>qual</name></name></type> <name>q</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>proto</name> <init>= <expr><name><name>q</name><operator>.</operator><name>proto</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>dir</name> <init>= <expr><name><name>q</name><operator>.</operator><name>dir</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tproto</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>u_char</name> <modifier>*</modifier></type><name>eaddr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bpf_u_int32</name></type> <name>mask</name></decl>, <decl><type ref="prev"/><name>addr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>addrinfo</name></name> <modifier>*</modifier></type><name>res</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>res0</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sockaddr_in</name></name> <modifier>*</modifier></type><name>sin4</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>INET6</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>tproto6</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sockaddr_in6</name></name> <modifier>*</modifier></type><name>sin6</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>in6_addr</name></name></type> <name>mask128</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>port</name></decl>, <decl><type ref="prev"/><name>real_proto</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>port1</name></decl>, <decl><type ref="prev"/><name>port2</name></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>top_ctx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>q</name><operator>.</operator><name>addr</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>Q_NET</name></expr>:</case>
<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>pcap_nametonetaddr</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"unknown network '%s'"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>mask</name> <operator>=</operator> <literal type="number">0xffffffff</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name>addr</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>addr</name> <operator>&amp;</operator> <literal type="number">0xff000000</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>addr</name> <operator>&lt;&lt;=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>mask</name> <operator>&lt;&lt;=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><call><name>gen_host</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name><name>q</name><operator>.</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>Q_DEFAULT</name></expr>:</case>
<case>case <expr><name>Q_HOST</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>proto</name> <operator>==</operator> <name>Q_LINK</name></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>DLT_EN10MB</name></expr>:</case>
<case>case <expr><name>DLT_NETANALYZER</name></expr>:</case>
<case>case <expr><name>DLT_NETANALYZER_TRANSPARENT</name></expr>:</case>
<expr_stmt><expr><name>eaddr</name> <operator>=</operator> <call><name>pcap_ether_hostton</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>eaddr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>,
<argument><expr><literal type="string">"unknown ether host '%s'"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>gen_prevlinkhdr_check</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>gen_ehostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tmp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>eaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b</name></expr>;</return>

<case>case <expr><name>DLT_FDDI</name></expr>:</case>
<expr_stmt><expr><name>eaddr</name> <operator>=</operator> <call><name>pcap_ether_hostton</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>eaddr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>,
<argument><expr><literal type="string">"unknown FDDI host '%s'"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>gen_fhostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>eaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b</name></expr>;</return>

<case>case <expr><name>DLT_IEEE802</name></expr>:</case>
<expr_stmt><expr><name>eaddr</name> <operator>=</operator> <call><name>pcap_ether_hostton</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>eaddr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>,
<argument><expr><literal type="string">"unknown token ring host '%s'"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>gen_thostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>eaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b</name></expr>;</return>

<case>case <expr><name>DLT_IEEE802_11</name></expr>:</case>
<case>case <expr><name>DLT_PRISM_HEADER</name></expr>:</case>
<case>case <expr><name>DLT_IEEE802_11_RADIO_AVS</name></expr>:</case>
<case>case <expr><name>DLT_IEEE802_11_RADIO</name></expr>:</case>
<case>case <expr><name>DLT_PPI</name></expr>:</case>
<expr_stmt><expr><name>eaddr</name> <operator>=</operator> <call><name>pcap_ether_hostton</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>eaddr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>,
<argument><expr><literal type="string">"unknown 802.11 host '%s'"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>gen_wlanhostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>eaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b</name></expr>;</return>

<case>case <expr><name>DLT_IP_OVER_FC</name></expr>:</case>
<expr_stmt><expr><name>eaddr</name> <operator>=</operator> <call><name>pcap_ether_hostton</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>eaddr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>,
<argument><expr><literal type="string">"unknown Fibre Channel host '%s'"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>gen_ipfchostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>eaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b</name></expr>;</return>
</block_content>}</block></switch>

<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"only ethernet/FDDI/token ring/802.11/ATM LANE/Fibre Channel supports link-level host name"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>proto</name> <operator>==</operator> <name>Q_DECNET</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>dn_addr</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>__pcap_nametodnaddr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dn_addr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DECNETLIB</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"unknown decnet host name '%s'\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"decnet name support not included, '%s' cannot be translated\n"</literal></expr></argument>,
<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if></if_stmt>




<return>return <expr><operator>(</operator><call><name>gen_host</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>dn_addr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>proto</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name><name>q</name><operator>.</operator><name>addr</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>INET6</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mask128</name></expr></argument>, <argument><expr><literal type="number">0xff</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mask128</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>res0</name> <operator>=</operator> <name>res</name> <operator>=</operator> <call><name>pcap_nametoaddrinfo</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"unknown host '%s'"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>ai</name></name> <operator>=</operator> <name>res</name></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name> <operator>=</operator> <name>tmp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>tproto</name> <operator>=</operator> <name>proto</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>INET6</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>tproto6</name> <operator>=</operator> <name>proto</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>==</operator> <name>OFFSET_NOT_SET</name> <operator>&amp;&amp;</operator>
<name>tproto</name> <operator>==</operator> <name>Q_DEFAULT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tproto</name> <operator>=</operator> <name>Q_IP</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>INET6</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>tproto6</name> <operator>=</operator> <name>Q_IPV6</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>res</name> <operator>=</operator> <name>res0</name></expr>;</init> <condition><expr><name>res</name></expr>;</condition> <incr><expr><name>res</name> <operator>=</operator> <name><name>res</name><operator>-&gt;</operator><name>ai_next</name></name></expr></incr>)</control> <block>{<block_content>
<switch>switch <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>ai_family</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>AF_INET</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>INET6</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>tproto</name> <operator>==</operator> <name>Q_IPV6</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>sin4</name> <operator>=</operator> <operator>(</operator>struct <name>sockaddr_in</name> <operator>*</operator><operator>)</operator>
<name><name>res</name><operator>-&gt;</operator><name>ai_addr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>gen_host</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>ntohl</name><argument_list>(<argument><expr><name><name>sin4</name><operator>-&gt;</operator><name>sin_addr</name><operator>.</operator><name>s_addr</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><literal type="number">0xffffffff</literal></expr></argument>, <argument><expr><name>tproto</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name><name>q</name><operator>.</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>INET6</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>AF_INET6</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>tproto6</name> <operator>==</operator> <name>Q_IP</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>sin6</name> <operator>=</operator> <operator>(</operator>struct <name>sockaddr_in6</name> <operator>*</operator><operator>)</operator>
<name><name>res</name><operator>-&gt;</operator><name>ai_addr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>gen_host6</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sin6</name><operator>-&gt;</operator><name>sin6_addr</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>mask128</name></expr></argument>, <argument><expr><name>tproto6</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name><name>q</name><operator>.</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<default>default:</default>
<continue>continue;</continue>
</block_content>}</block></switch>
<if_stmt><if>if <condition>(<expr><name>b</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>b</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>ai</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>freeaddrinfo</name><argument_list>(<argument><expr><name>res0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>b</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"unknown host '%s'%s"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>,
<argument><expr><ternary><condition><expr><operator>(</operator><name>proto</name> <operator>==</operator> <name>Q_DEFAULT</name><operator>)</operator></expr>
?</condition><then> <expr><literal type="string">""</literal></expr>
</then><else>: <expr><literal type="string">" for specified address family"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>b</name></expr>;</return>
</block_content>}</block></else></if_stmt>

<case>case <expr><name>Q_PORT</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>proto</name> <operator>!=</operator> <name>Q_DEFAULT</name> <operator>&amp;&amp;</operator>
<name>proto</name> <operator>!=</operator> <name>Q_UDP</name> <operator>&amp;&amp;</operator> <name>proto</name> <operator>!=</operator> <name>Q_TCP</name> <operator>&amp;&amp;</operator> <name>proto</name> <operator>!=</operator> <name>Q_SCTP</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"illegal qualifier of 'port'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>pcap_nametoport</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>port</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>real_proto</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"unknown port '%s'"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>proto</name> <operator>==</operator> <name>Q_UDP</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>real_proto</name> <operator>==</operator> <name>IPPROTO_TCP</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"port '%s' is tcp"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>real_proto</name> <operator>==</operator> <name>IPPROTO_SCTP</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"port '%s' is sctp"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>real_proto</name> <operator>=</operator> <name>IPPROTO_UDP</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>proto</name> <operator>==</operator> <name>Q_TCP</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>real_proto</name> <operator>==</operator> <name>IPPROTO_UDP</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"port '%s' is udp"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>real_proto</name> <operator>==</operator> <name>IPPROTO_SCTP</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"port '%s' is sctp"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>real_proto</name> <operator>=</operator> <name>IPPROTO_TCP</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>proto</name> <operator>==</operator> <name>Q_SCTP</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>real_proto</name> <operator>==</operator> <name>IPPROTO_UDP</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"port '%s' is udp"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>real_proto</name> <operator>==</operator> <name>IPPROTO_TCP</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"port '%s' is tcp"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>real_proto</name> <operator>=</operator> <name>IPPROTO_SCTP</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>port</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"illegal port number %d &lt; 0"</literal></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>port</name> <operator>&gt;</operator> <literal type="number">65535</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"illegal port number %d &gt; 65535"</literal></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>gen_port</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><name>real_proto</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><call><name>gen_port6</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><name>real_proto</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b</name></expr>;</return>

<case>case <expr><name>Q_PORTRANGE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>proto</name> <operator>!=</operator> <name>Q_DEFAULT</name> <operator>&amp;&amp;</operator>
<name>proto</name> <operator>!=</operator> <name>Q_UDP</name> <operator>&amp;&amp;</operator> <name>proto</name> <operator>!=</operator> <name>Q_TCP</name> <operator>&amp;&amp;</operator> <name>proto</name> <operator>!=</operator> <name>Q_SCTP</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"illegal qualifier of 'portrange'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>pcap_nametoportrange</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>port1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>port2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>real_proto</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"unknown port in range '%s'"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>proto</name> <operator>==</operator> <name>Q_UDP</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>real_proto</name> <operator>==</operator> <name>IPPROTO_TCP</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"port in range '%s' is tcp"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>real_proto</name> <operator>==</operator> <name>IPPROTO_SCTP</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"port in range '%s' is sctp"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>real_proto</name> <operator>=</operator> <name>IPPROTO_UDP</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>proto</name> <operator>==</operator> <name>Q_TCP</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>real_proto</name> <operator>==</operator> <name>IPPROTO_UDP</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"port in range '%s' is udp"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>real_proto</name> <operator>==</operator> <name>IPPROTO_SCTP</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"port in range '%s' is sctp"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>real_proto</name> <operator>=</operator> <name>IPPROTO_TCP</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>proto</name> <operator>==</operator> <name>Q_SCTP</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>real_proto</name> <operator>==</operator> <name>IPPROTO_UDP</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"port in range '%s' is udp"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>real_proto</name> <operator>==</operator> <name>IPPROTO_TCP</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"port in range '%s' is tcp"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>real_proto</name> <operator>=</operator> <name>IPPROTO_SCTP</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>port1</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"illegal port number %d &lt; 0"</literal></expr></argument>, <argument><expr><name>port1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>port1</name> <operator>&gt;</operator> <literal type="number">65535</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"illegal port number %d &gt; 65535"</literal></expr></argument>, <argument><expr><name>port1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>port2</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"illegal port number %d &lt; 0"</literal></expr></argument>, <argument><expr><name>port2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>port2</name> <operator>&gt;</operator> <literal type="number">65535</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"illegal port number %d &gt; 65535"</literal></expr></argument>, <argument><expr><name>port2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>gen_portrange</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>port1</name></expr></argument>, <argument><expr><name>port2</name></expr></argument>, <argument><expr><name>real_proto</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><call><name>gen_portrange6</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>port1</name></expr></argument>, <argument><expr><name>port2</name></expr></argument>, <argument><expr><name>real_proto</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b</name></expr>;</return>

<case>case <expr><name>Q_GATEWAY</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>INET6</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>eaddr</name> <operator>=</operator> <call><name>pcap_ether_hostton</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>eaddr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"unknown ether host: %s"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pcap_nametoaddrinfo</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>ai</name></name> <operator>=</operator> <name>res</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"unknown host '%s'"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>gen_gateway</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>ai</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>freeaddrinfo</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>b</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"unknown host '%s'"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>b</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'gateway' not supported in this configuration"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<case>case <expr><name>Q_PROTO</name></expr>:</case>
<expr_stmt><expr><name>real_proto</name> <operator>=</operator> <call><name>lookup_proto</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>real_proto</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>gen_proto</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>real_proto</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"unknown protocol: %s"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<case>case <expr><name>Q_PROTOCHAIN</name></expr>:</case>
<expr_stmt><expr><name>real_proto</name> <operator>=</operator> <call><name>lookup_proto</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>real_proto</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>gen_protochain</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>real_proto</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"unknown protocol: %s"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<case>case <expr><name>Q_UNDEF</name></expr>:</case>
<expr_stmt><expr><call><name>syntax</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_mcode</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s2</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>masklen</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>qual</name></name></type> <name>q</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type> <name>nlen</name></decl>, <decl><type ref="prev"/><name>mlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bpf_u_int32</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>m</name></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>top_ctx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>nlen</name> <operator>=</operator> <call><name>__pcap_atoin</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nlen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"invalid IPv4 address '%s'"</literal></expr></argument>, <argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>n</name> <operator>&lt;&lt;=</operator> <literal type="number">32</literal> <operator>-</operator> <name>nlen</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>s2</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>mlen</name> <operator>=</operator> <call><name>__pcap_atoin</name><argument_list>(<argument><expr><name>s2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>mlen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"invalid IPv4 address '%s'"</literal></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>m</name> <operator>&lt;&lt;=</operator> <literal type="number">32</literal> <operator>-</operator> <name>mlen</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>n</name> <operator>&amp;</operator> <operator>~</operator><name>m</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"non-network bits set in \"%s mask %s\""</literal></expr></argument>,
<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>masklen</name> <operator>&gt;</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"mask length must be &lt;= 32"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>masklen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>




<expr_stmt><expr><name>m</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>m</name> <operator>=</operator> <literal type="number">0xffffffff</literal> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">32</literal> <operator>-</operator> <name>masklen</name><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>n</name> <operator>&amp;</operator> <operator>~</operator><name>m</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"non-network bits set in \"%s/%d\""</literal></expr></argument>,
<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>masklen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<switch>switch <condition>(<expr><name><name>q</name><operator>.</operator><name>addr</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>Q_NET</name></expr>:</case>
<return>return <expr><call><name>gen_host</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name><name>q</name><operator>.</operator><name>proto</name></name></expr></argument>, <argument><expr><name><name>q</name><operator>.</operator><name>dir</name></name></expr></argument>, <argument><expr><name><name>q</name><operator>.</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</return>

<default>default:</default>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"Mask syntax for networks only"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_ncode</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>bpf_u_int32</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>qual</name></name></type> <name>q</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>bpf_u_int32</name></type> <name>mask</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>proto</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>dir</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type> <name>vlen</name></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>top_ctx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>proto</name> <operator>=</operator> <name><name>q</name><operator>.</operator><name>proto</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>dir</name> <operator>=</operator> <name><name>q</name><operator>.</operator><name>dir</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>vlen</name> <operator>=</operator> <literal type="number">32</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>q</name><operator>.</operator><name>proto</name></name> <operator>==</operator> <name>Q_DECNET</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>vlen</name> <operator>=</operator> <call><name>__pcap_atodn</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>vlen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"malformed decnet address '%s'"</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>vlen</name> <operator>=</operator> <call><name>__pcap_atoin</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>vlen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"invalid IPv4 address '%s'"</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<switch>switch <condition>(<expr><name><name>q</name><operator>.</operator><name>addr</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>Q_DEFAULT</name></expr>:</case>
<case>case <expr><name>Q_HOST</name></expr>:</case>
<case>case <expr><name>Q_NET</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>proto</name> <operator>==</operator> <name>Q_DECNET</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>gen_host</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>proto</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name><name>q</name><operator>.</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>proto</name> <operator>==</operator> <name>Q_LINK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"illegal link layer address"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>mask</name> <operator>=</operator> <literal type="number">0xffffffff</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>q</name><operator>.</operator><name>addr</name></name> <operator>==</operator> <name>Q_NET</name></expr>)</condition> <block>{<block_content>

<while>while <condition>(<expr><name>v</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>v</name> <operator>&amp;</operator> <literal type="number">0xff000000</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>v</name> <operator>&lt;&lt;=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>mask</name> <operator>&lt;&lt;=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>v</name> <operator>&lt;&lt;=</operator> <literal type="number">32</literal> <operator>-</operator> <name>vlen</name></expr>;</expr_stmt>
<expr_stmt><expr><name>mask</name> <operator>&lt;&lt;=</operator> <literal type="number">32</literal> <operator>-</operator> <name>vlen</name></expr> ;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><call><name>gen_host</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name><name>q</name><operator>.</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>

<case>case <expr><name>Q_PORT</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>proto</name> <operator>==</operator> <name>Q_UDP</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>proto</name> <operator>=</operator> <name>IPPROTO_UDP</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>proto</name> <operator>==</operator> <name>Q_TCP</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>proto</name> <operator>=</operator> <name>IPPROTO_TCP</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>proto</name> <operator>==</operator> <name>Q_SCTP</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>proto</name> <operator>=</operator> <name>IPPROTO_SCTP</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>proto</name> <operator>==</operator> <name>Q_DEFAULT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>proto</name> <operator>=</operator> <name>PROTO_UNDEF</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"illegal qualifier of 'port'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>v</name> <operator>&gt;</operator> <literal type="number">65535</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"illegal port number %u &gt; 65535"</literal></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>
<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>gen_port</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>v</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><call><name>gen_port6</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>v</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b</name></expr>;</return>
</block_content>}</block>

<case>case <expr><name>Q_PORTRANGE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>proto</name> <operator>==</operator> <name>Q_UDP</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>proto</name> <operator>=</operator> <name>IPPROTO_UDP</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>proto</name> <operator>==</operator> <name>Q_TCP</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>proto</name> <operator>=</operator> <name>IPPROTO_TCP</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>proto</name> <operator>==</operator> <name>Q_SCTP</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>proto</name> <operator>=</operator> <name>IPPROTO_SCTP</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>proto</name> <operator>==</operator> <name>Q_DEFAULT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>proto</name> <operator>=</operator> <name>PROTO_UNDEF</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"illegal qualifier of 'portrange'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>v</name> <operator>&gt;</operator> <literal type="number">65535</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"illegal port number %u &gt; 65535"</literal></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>
<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>gen_portrange</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>v</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>v</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><call><name>gen_portrange6</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>v</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>v</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b</name></expr>;</return>
</block_content>}</block>

<case>case <expr><name>Q_GATEWAY</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'gateway' requires a name"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_PROTO</name></expr>:</case>
<return>return <expr><call><name>gen_proto</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>v</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>Q_PROTOCHAIN</name></expr>:</case>
<return>return <expr><call><name>gen_protochain</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>v</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>Q_UNDEF</name></expr>:</case>
<expr_stmt><expr><call><name>syntax</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<default>default:</default>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>INET6</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_mcode6</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s2</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>masklen</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>qual</name></name></type> <name>q</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>addrinfo</name></name> <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>in6_addr</name></name> <modifier>*</modifier></type><name>addr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>in6_addr</name></name></type> <name>mask</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>a</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>m</name></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>top_ctx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>s2</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"no mask %s supported"</literal></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pcap_nametoaddrinfo</name><argument_list>(<argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"invalid ip6 address %s"</literal></expr></argument>, <argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>ai</name></name> <operator>=</operator> <name>res</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>ai_next</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"%s resolved to multiple address"</literal></expr></argument>, <argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>addr</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><operator>(</operator>struct <name>sockaddr_in6</name> <operator>*</operator><operator>)</operator><name><name>res</name><operator>-&gt;</operator><name>ai_addr</name></name><operator>)</operator><operator>-&gt;</operator><name>sin6_addr</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><sizeof>sizeof<argument_list>(<argument><expr><name>mask</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">8</literal> <operator>&lt;</operator> <name>masklen</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"mask length must be &lt;= %u"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>mask</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">8</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mask</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mask</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mask</name></expr></argument>, <argument><expr><literal type="number">0xff</literal></expr></argument>, <argument><expr><name>masklen</name> <operator>/</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>masklen</name> <operator>%</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>mask</name><operator>.</operator><name>s6_addr</name><index>[<expr><name>masklen</name> <operator>/</operator> <literal type="number">8</literal></expr>]</index></name> <operator>=</operator>
<operator>(</operator><literal type="number">0xff</literal> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">8</literal> <operator>-</operator> <name>masklen</name> <operator>%</operator> <literal type="number">8</literal><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>a</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><name>addr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>m</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>mask</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <operator>~</operator><name><name>m</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <operator>~</operator><name><name>m</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator>
<operator>||</operator> <operator>(</operator><name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&amp;</operator> <operator>~</operator><name><name>m</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>&amp;</operator> <operator>~</operator><name><name>m</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"non-network bits set in \"%s/%d\""</literal></expr></argument>, <argument><expr><name>s1</name></expr></argument>, <argument><expr><name>masklen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>q</name><operator>.</operator><name>addr</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>Q_DEFAULT</name></expr>:</case>
<case>case <expr><name>Q_HOST</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>masklen</name> <operator>!=</operator> <literal type="number">128</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"Mask syntax for networks only"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<case>case <expr><name>Q_NET</name></expr>:</case>
<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>gen_host6</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mask</name></expr></argument>, <argument><expr><name><name>q</name><operator>.</operator><name>proto</name></name></expr></argument>, <argument><expr><name><name>q</name><operator>.</operator><name>dir</name></name></expr></argument>, <argument><expr><name><name>q</name><operator>.</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>ai</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>freeaddrinfo</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b</name></expr>;</return>

<default>default:</default>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"invalid qualifier against IPv6 address"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_ecode</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>qual</name></name></type> <name>q</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>top_ctx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>q</name><operator>.</operator><name>addr</name></name> <operator>==</operator> <name>Q_HOST</name> <operator>||</operator> <name><name>q</name><operator>.</operator><name>addr</name></name> <operator>==</operator> <name>Q_DEFAULT</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>q</name><operator>.</operator><name>proto</name></name> <operator>==</operator> <name>Q_LINK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>e</name></name> <operator>=</operator> <call><name>pcap_ether_aton</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>e</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"malloc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<switch>switch <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DLT_EN10MB</name></expr>:</case>
<case>case <expr><name>DLT_NETANALYZER</name></expr>:</case>
<case>case <expr><name>DLT_NETANALYZER_TRANSPARENT</name></expr>:</case>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>gen_prevlinkhdr_check</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>gen_ehostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>e</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>q</name><operator>.</operator><name>dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tmp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>DLT_FDDI</name></expr>:</case>
<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>gen_fhostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>e</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>q</name><operator>.</operator><name>dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DLT_IEEE802</name></expr>:</case>
<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>gen_thostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>e</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>q</name><operator>.</operator><name>dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DLT_IEEE802_11</name></expr>:</case>
<case>case <expr><name>DLT_PRISM_HEADER</name></expr>:</case>
<case>case <expr><name>DLT_IEEE802_11_RADIO_AVS</name></expr>:</case>
<case>case <expr><name>DLT_IEEE802_11_RADIO</name></expr>:</case>
<case>case <expr><name>DLT_PPI</name></expr>:</case>
<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>gen_wlanhostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>e</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>q</name><operator>.</operator><name>dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DLT_IP_OVER_FC</name></expr>:</case>
<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>gen_ipfchostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>e</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>q</name><operator>.</operator><name>dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>e</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>e</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"ethernet addresses supported only on ethernet/FDDI/token ring/802.11/ATM LANE/Fibre Channel"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>e</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>e</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>b</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"ethernet address used in non-ether expression"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>
<name>sappend</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>s0</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>s1</name></decl></parameter>)</parameter_list>
<block>{<block_content>




<while>while <condition>(<expr><name><name>s0</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>s0</name> <operator>=</operator> <name><name>s0</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><name><name>s0</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>s1</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type>
<name>xfer_to_x</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>arth</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LDX</name><operator>|</operator><name>BPF_MEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>regno</name></name></expr>;</expr_stmt>
<return>return <expr><name>s</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type>
<name>xfer_to_a</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>arth</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LD</name><operator>|</operator><name>BPF_MEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>regno</name></name></expr>;</expr_stmt>
<return>return <expr><name>s</name></expr>;</return>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name><name>struct</name> <name>arth</name></name> <modifier>*</modifier></type>
<name>gen_load_internal</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>proto</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>arth</name></name> <modifier>*</modifier></type><name>inst</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>s</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>regno</name> <init>= <expr><call><name>alloc_reg</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>free_reg</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name><name>inst</name><operator>-&gt;</operator><name>regno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>size</name></expr>)</condition> <block>{<block_content>

<default>default:</default>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"data size must be 1, 2, or 4"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><literal type="number">1</literal></expr>:</case>
<expr_stmt><expr><name>size</name> <operator>=</operator> <name>BPF_B</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="number">2</literal></expr>:</case>
<expr_stmt><expr><name>size</name> <operator>=</operator> <name>BPF_H</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="number">4</literal></expr>:</case>
<expr_stmt><expr><name>size</name> <operator>=</operator> <name>BPF_W</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<switch>switch <condition>(<expr><name>proto</name></expr>)</condition> <block>{<block_content>
<default>default:</default>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"unsupported index operation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>Q_RADIO</name></expr>:</case>





<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name> <operator>!=</operator> <name>DLT_IEEE802_11_RADIO_AVS</name> <operator>&amp;&amp;</operator>
<name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name> <operator>!=</operator> <name>DLT_IEEE802_11_RADIO</name> <operator>&amp;&amp;</operator>
<name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name> <operator>!=</operator> <name>DLT_PRISM_HEADER</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"radio information not present in capture"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>





<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>xfer_to_x</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LD</name><operator>|</operator><name>BPF_IND</name><operator>|</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name><name>inst</name><operator>-&gt;</operator><name>s</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Q_LINK</name></expr>:</case>











<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>gen_abs_offset_varpart</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>off_linkhdr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>










<if_stmt><if>if <condition>(<expr><name>s</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>xfer_to_a</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ALU</name><operator>|</operator><name>BPF_ADD</name><operator>|</operator><name>BPF_X</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_MISC</name><operator>|</operator><name>BPF_TAX</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>xfer_to_x</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>








<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LD</name><operator>|</operator><name>BPF_IND</name><operator>|</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_linkhdr</name><operator>.</operator><name>constant_part</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name><name>inst</name><operator>-&gt;</operator><name>s</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Q_IP</name></expr>:</case>
<case>case <expr><name>Q_ARP</name></expr>:</case>
<case>case <expr><name>Q_RARP</name></expr>:</case>
<case>case <expr><name>Q_ATALK</name></expr>:</case>
<case>case <expr><name>Q_DECNET</name></expr>:</case>
<case>case <expr><name>Q_SCA</name></expr>:</case>
<case>case <expr><name>Q_LAT</name></expr>:</case>
<case>case <expr><name>Q_MOPRC</name></expr>:</case>
<case>case <expr><name>Q_MOPDL</name></expr>:</case>
<case>case <expr><name>Q_IPV6</name></expr>:</case>






<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>gen_abs_offset_varpart</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>










<if_stmt><if>if <condition>(<expr><name>s</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>xfer_to_a</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ALU</name><operator>|</operator><name>BPF_ADD</name><operator>|</operator><name>BPF_X</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_MISC</name><operator>|</operator><name>BPF_TAX</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>xfer_to_x</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>








<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LD</name><operator>|</operator><name>BPF_IND</name><operator>|</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>+</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name><name>inst</name><operator>-&gt;</operator><name>s</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>gen_proto_abbrev_internal</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>inst</name><operator>-&gt;</operator><name>b</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name><name>inst</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>inst</name><operator>-&gt;</operator><name>b</name></name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>Q_SCTP</name></expr>:</case>
<case>case <expr><name>Q_TCP</name></expr>:</case>
<case>case <expr><name>Q_UDP</name></expr>:</case>
<case>case <expr><name>Q_ICMP</name></expr>:</case>
<case>case <expr><name>Q_IGMP</name></expr>:</case>
<case>case <expr><name>Q_IGRP</name></expr>:</case>
<case>case <expr><name>Q_PIM</name></expr>:</case>
<case>case <expr><name>Q_VRRP</name></expr>:</case>
<case>case <expr><name>Q_CARP</name></expr>:</case>














<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>gen_loadx_iphdrlen</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>















<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>xfer_to_a</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ALU</name><operator>|</operator><name>BPF_ADD</name><operator>|</operator><name>BPF_X</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_MISC</name><operator>|</operator><name>BPF_TAX</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>tmp</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LD</name><operator>|</operator><name>BPF_IND</name><operator>|</operator><name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>+</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name><name>inst</name><operator>-&gt;</operator><name>s</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>







<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><call><name>gen_proto_abbrev_internal</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>b</name> <operator>=</operator> <call><name>gen_ipfrag</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>inst</name><operator>-&gt;</operator><name>b</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name><name>inst</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><call><name>gen_proto_abbrev_internal</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>Q_IP</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>inst</name><operator>-&gt;</operator><name>b</name></name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>Q_ICMPV6</name></expr>:</case>




<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>gen_proto_abbrev_internal</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>Q_IPV6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>inst</name><operator>-&gt;</operator><name>b</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name><name>inst</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>inst</name><operator>-&gt;</operator><name>b</name></name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>




<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKPL</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><literal type="number">58</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>inst</name><operator>-&gt;</operator><name>b</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name><name>inst</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>inst</name><operator>-&gt;</operator><name>b</name></name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>


<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>gen_abs_offset_varpart</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>









<if_stmt><if>if <condition>(<expr><name>s</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>xfer_to_a</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ALU</name><operator>|</operator><name>BPF_ADD</name><operator>|</operator><name>BPF_X</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_MISC</name><operator>|</operator><name>BPF_TAX</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>xfer_to_x</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>








<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LD</name><operator>|</operator><name>BPF_IND</name><operator>|</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>+</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>+</operator> <literal type="number">40</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name><name>inst</name><operator>-&gt;</operator><name>s</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>
</block_content>}</block></switch>
<expr_stmt><expr><name><name>inst</name><operator>-&gt;</operator><name>regno</name></name> <operator>=</operator> <name>regno</name></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name>regno</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name><name>inst</name><operator>-&gt;</operator><name>s</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>inst</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>arth</name></name> <modifier>*</modifier></type>
<name>gen_load</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>proto</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>arth</name></name> <modifier>*</modifier></type><name>inst</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>




<if_stmt><if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>top_ctx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>gen_load_internal</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>proto</name></expr></argument>, <argument><expr><name>inst</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_relation_internal</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>arth</name></name> <modifier>*</modifier></type><name>a0</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>arth</name></name> <modifier>*</modifier></type><name>a1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reversed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>s0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>s1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>s2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>

<expr_stmt><expr><name>s0</name> <operator>=</operator> <call><name>xfer_to_x</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>s1</name> <operator>=</operator> <call><name>xfer_to_a</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>a0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>code</name> <operator>==</operator> <name>BPF_JEQ</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ALU</name><operator>|</operator><name>BPF_SUB</name><operator>|</operator><name>BPF_X</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>new_block</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>JMP</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>new_block</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_JMP</name><operator>|</operator><name>code</name><operator>|</operator><name>BPF_X</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>reversed</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>gen_not</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s0</name></expr></argument>, <argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name><name>a1</name><operator>-&gt;</operator><name>s</name></name></expr></argument>, <argument><expr><name>s0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name><name>a0</name><operator>-&gt;</operator><name>s</name></name></expr></argument>, <argument><expr><name><name>a1</name><operator>-&gt;</operator><name>s</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>stmts</name></name> <operator>=</operator> <name><name>a0</name><operator>-&gt;</operator><name>s</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free_reg</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name><name>a0</name><operator>-&gt;</operator><name>regno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free_reg</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name><name>a1</name><operator>-&gt;</operator><name>regno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>a0</name><operator>-&gt;</operator><name>b</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>a1</name><operator>-&gt;</operator><name>b</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name><name>a0</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>tmp</name> <operator>=</operator> <name><name>a1</name><operator>-&gt;</operator><name>b</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <name><name>a0</name><operator>-&gt;</operator><name>b</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <name><name>a1</name><operator>-&gt;</operator><name>b</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>tmp</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>b</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_relation</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>arth</name></name> <modifier>*</modifier></type><name>a0</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>arth</name></name> <modifier>*</modifier></type><name>a1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reversed</name></decl></parameter>)</parameter_list>
<block>{<block_content>




<if_stmt><if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>top_ctx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>gen_relation_internal</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>a0</name></expr></argument>, <argument><expr><name>a1</name></expr></argument>, <argument><expr><name>reversed</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>arth</name></name> <modifier>*</modifier></type>
<name>gen_loadlen</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>regno</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>arth</name></name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>top_ctx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>regno</name> <operator>=</operator> <call><name>alloc_reg</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>a</name> <operator>=</operator> <operator>(</operator>struct <name>arth</name> <operator>*</operator><operator>)</operator><call><name>newchunk</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>a</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LD</name><operator>|</operator><name>BPF_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>next</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name>regno</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>regno</name></name> <operator>=</operator> <name>regno</name></expr>;</expr_stmt>

<return>return <expr><name>a</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>arth</name></name> <modifier>*</modifier></type>
<name>gen_loadi_internal</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>arth</name></name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>reg</name></decl>;</decl_stmt>

<expr_stmt><expr><name>a</name> <operator>=</operator> <operator>(</operator>struct <name>arth</name> <operator>*</operator><operator>)</operator><call><name>newchunk</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>a</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>reg</name> <operator>=</operator> <call><name>alloc_reg</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LD</name><operator>|</operator><name>BPF_IMM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>next</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name>reg</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>s</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>regno</name></name> <operator>=</operator> <name>reg</name></expr>;</expr_stmt>

<return>return <expr><name>a</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>arth</name></name> <modifier>*</modifier></type>
<name>gen_loadi</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>




<if_stmt><if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>top_ctx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>gen_loadi_internal</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>






<function><type><name><name>struct</name> <name>arth</name></name> <modifier>*</modifier></type>
<name>gen_neg</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>arth</name></name> <modifier>*</modifier></type><name>a_arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>arth</name></name> <modifier>*</modifier></type><name>a</name> <init>= <expr><name>a_arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>top_ctx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>xfer_to_a</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>s</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ALU</name><operator>|</operator><name>BPF_NEG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>s</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>regno</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>s</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>a</name></expr>;</return>
</block_content>}</block></function>






<function><type><name><name>struct</name> <name>arth</name></name> <modifier>*</modifier></type>
<name>gen_arth</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>arth</name></name> <modifier>*</modifier></type><name>a0_arg</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>arth</name></name> <modifier>*</modifier></type><name>a1</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>arth</name></name> <modifier>*</modifier></type><name>a0</name> <init>= <expr><name>a0_arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>s0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>s1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>s2</name></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>top_ctx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>








<if_stmt><if>if <condition>(<expr><name>code</name> <operator>==</operator> <name>BPF_DIV</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>a1</name><operator>-&gt;</operator><name>s</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>code</name></name> <operator>==</operator> <operator>(</operator><name>BPF_LD</name><operator>|</operator><name>BPF_IMM</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>a1</name><operator>-&gt;</operator><name>s</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"division by zero"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>code</name> <operator>==</operator> <name>BPF_MOD</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>a1</name><operator>-&gt;</operator><name>s</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>code</name></name> <operator>==</operator> <operator>(</operator><name>BPF_LD</name><operator>|</operator><name>BPF_IMM</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>a1</name><operator>-&gt;</operator><name>s</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"modulus by zero"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>code</name> <operator>==</operator> <name>BPF_LSH</name> <operator>||</operator> <name>code</name> <operator>==</operator> <name>BPF_RSH</name></expr>)</condition> <block>{<block_content>





<if_stmt><if>if <condition>(<expr><name><name>a1</name><operator>-&gt;</operator><name>s</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>code</name></name> <operator>==</operator> <operator>(</operator><name>BPF_LD</name><operator>|</operator><name>BPF_IMM</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>a1</name><operator>-&gt;</operator><name>s</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>a1</name><operator>-&gt;</operator><name>s</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>&gt;</operator> <literal type="number">31</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"shift by more than 31 bits"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>s0</name> <operator>=</operator> <call><name>xfer_to_x</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>s1</name> <operator>=</operator> <call><name>xfer_to_a</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>a0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ALU</name><operator>|</operator><name>BPF_X</name><operator>|</operator><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s0</name></expr></argument>, <argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name><name>a1</name><operator>-&gt;</operator><name>s</name></name></expr></argument>, <argument><expr><name>s0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name><name>a0</name><operator>-&gt;</operator><name>s</name></name></expr></argument>, <argument><expr><name><name>a1</name><operator>-&gt;</operator><name>s</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free_reg</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name><name>a0</name><operator>-&gt;</operator><name>regno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free_reg</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name><name>a1</name><operator>-&gt;</operator><name>regno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s0</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>a0</name><operator>-&gt;</operator><name>regno</name></name> <operator>=</operator> <name><name>s0</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <call><name>alloc_reg</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name><name>a0</name><operator>-&gt;</operator><name>s</name></name></expr></argument>, <argument><expr><name>s0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>a0</name></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_regs</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>curreg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>regused</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof <name><name>cstate</name><operator>-&gt;</operator><name>regused</name></name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>int</name></type>
<name>alloc_reg</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name>BPF_MEMWORDS</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>--</operator><name>n</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>regused</name><index>[<expr><name><name>cstate</name><operator>-&gt;</operator><name>curreg</name></name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>curreg</name></name> <operator>=</operator> <operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>curreg</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name>BPF_MEMWORDS</name></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>regused</name><index>[<expr><name><name>cstate</name><operator>-&gt;</operator><name>curreg</name></name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><name><name>cstate</name><operator>-&gt;</operator><name>curreg</name></name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"too many registers needed to evaluate expression"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type>
<name>free_reg</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>regused</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_len</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>jmp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LD</name><operator>|</operator><name>BPF_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>new_block</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>JMP</name><argument_list>(<argument><expr><name>jmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>stmts</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>

<return>return <expr><name>b</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_greater</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>




<if_stmt><if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>top_ctx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>gen_len</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_JGE</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>




<function><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_less</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>top_ctx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>gen_len</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_JGT</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_not</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>b</name></expr>;</return>
</block_content>}</block></function>











<function><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_byteop</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>top_ctx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{<block_content>
<default>default:</default>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<case>case <expr><literal type="char">'='</literal></expr>:</case>
<return>return <expr><call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><operator>(</operator><name>u_int</name><operator>)</operator><name>idx</name></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><literal type="char">'&lt;'</literal></expr>:</case>
<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>gen_cmp_lt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><operator>(</operator><name>u_int</name><operator>)</operator><name>idx</name></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b</name></expr>;</return>

<case>case <expr><literal type="char">'&gt;'</literal></expr>:</case>
<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>gen_cmp_gt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><operator>(</operator><name>u_int</name><operator>)</operator><name>idx</name></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b</name></expr>;</return>

<case>case <expr><literal type="char">'|'</literal></expr>:</case>
<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ALU</name><operator>|</operator><name>BPF_OR</name><operator>|</operator><name>BPF_K</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'&amp;'</literal></expr>:</case>
<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ALU</name><operator>|</operator><name>BPF_AND</name><operator>|</operator><name>BPF_K</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>new_block</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>JMP</name><argument_list>(<argument><expr><name>BPF_JEQ</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>stmts</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_not</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>b</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>u_char</name></type> <name><name>abroadcast</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="number">0x0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<function><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_broadcast</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>proto</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>bpf_u_int32</name></type> <name>hostmask</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>u_char</name></type> <name><name>ebroadcast</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="number">0xff</literal></expr>, <expr><literal type="number">0xff</literal></expr>, <expr><literal type="number">0xff</literal></expr>, <expr><literal type="number">0xff</literal></expr>, <expr><literal type="number">0xff</literal></expr>, <expr><literal type="number">0xff</literal></expr> }</block></expr></init></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>top_ctx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name>proto</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>Q_DEFAULT</name></expr>:</case>
<case>case <expr><name>Q_LINK</name></expr>:</case>
<switch>switch <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DLT_ARCNET</name></expr>:</case>
<case>case <expr><name>DLT_ARCNET_LINUX</name></expr>:</case>
<return>return <expr><call><name>gen_ahostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>abroadcast</name></expr></argument>, <argument><expr><name>Q_DST</name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>DLT_EN10MB</name></expr>:</case>
<case>case <expr><name>DLT_NETANALYZER</name></expr>:</case>
<case>case <expr><name>DLT_NETANALYZER_TRANSPARENT</name></expr>:</case>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_prevlinkhdr_check</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_ehostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ebroadcast</name></expr></argument>, <argument><expr><name>Q_DST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>b1</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><name>b0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>b0</name></expr>;</return>
<case>case <expr><name>DLT_FDDI</name></expr>:</case>
<return>return <expr><call><name>gen_fhostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ebroadcast</name></expr></argument>, <argument><expr><name>Q_DST</name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>DLT_IEEE802</name></expr>:</case>
<return>return <expr><call><name>gen_thostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ebroadcast</name></expr></argument>, <argument><expr><name>Q_DST</name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>DLT_IEEE802_11</name></expr>:</case>
<case>case <expr><name>DLT_PRISM_HEADER</name></expr>:</case>
<case>case <expr><name>DLT_IEEE802_11_RADIO_AVS</name></expr>:</case>
<case>case <expr><name>DLT_IEEE802_11_RADIO</name></expr>:</case>
<case>case <expr><name>DLT_PPI</name></expr>:</case>
<return>return <expr><call><name>gen_wlanhostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ebroadcast</name></expr></argument>, <argument><expr><name>Q_DST</name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>DLT_IP_OVER_FC</name></expr>:</case>
<return>return <expr><call><name>gen_ipfchostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ebroadcast</name></expr></argument>, <argument><expr><name>Q_DST</name></expr></argument>)</argument_list></call></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"not a broadcast link"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>


<case>case <expr><name>Q_IP</name></expr>:</case>





<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>netmask</name></name> <operator>==</operator> <name>PCAP_NETMASK_UNKNOWN</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"netmask not known, so 'ip broadcast' not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ETHERTYPE_IP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>hostmask</name> <operator>=</operator> <operator>~</operator><name><name>cstate</name><operator>-&gt;</operator><name>netmask</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_mcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKPL</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><name>BPF_W</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><literal type="number">0</literal></expr></argument>, <argument><expr><name>hostmask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b2</name> <operator>=</operator> <call><name>gen_mcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKPL</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><name>BPF_W</name></expr></argument>,
<argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><operator>(</operator><operator>~</operator><literal type="number">0</literal> <operator>&amp;</operator> <name>hostmask</name><operator>)</operator></expr></argument>, <argument><expr><name>hostmask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><name>b2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b2</name></expr>;</return>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"only link-layer/IP broadcast filters supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>





<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_mac_multicast</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>register</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>register</specifier> <name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>


<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>gen_load_a</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>new_block</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>JMP</name><argument_list>(<argument><expr><name>BPF_JSET</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b0</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b0</name><operator>-&gt;</operator><name>stmts</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<return>return <expr><name>b0</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_multicast</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>proto</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>register</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>register</specifier> <name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>top_ctx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name>proto</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>Q_DEFAULT</name></expr>:</case>
<case>case <expr><name>Q_LINK</name></expr>:</case>
<switch>switch <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DLT_ARCNET</name></expr>:</case>
<case>case <expr><name>DLT_ARCNET_LINUX</name></expr>:</case>

<return>return <expr><call><name>gen_ahostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>abroadcast</name></expr></argument>, <argument><expr><name>Q_DST</name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>DLT_EN10MB</name></expr>:</case>
<case>case <expr><name>DLT_NETANALYZER</name></expr>:</case>
<case>case <expr><name>DLT_NETANALYZER_TRANSPARENT</name></expr>:</case>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_prevlinkhdr_check</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_mac_multicast</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>b1</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><name>b0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>b0</name></expr>;</return>
<case>case <expr><name>DLT_FDDI</name></expr>:</case>






<return>return <expr><call><name>gen_mac_multicast</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>DLT_IEEE802</name></expr>:</case>

<return>return <expr><call><name>gen_mac_multicast</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>DLT_IEEE802_11</name></expr>:</case>
<case>case <expr><name>DLT_PRISM_HEADER</name></expr>:</case>
<case>case <expr><name>DLT_IEEE802_11_RADIO_AVS</name></expr>:</case>
<case>case <expr><name>DLT_IEEE802_11_RADIO</name></expr>:</case>
<case>case <expr><name>DLT_PPI</name></expr>:</case>





















<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>gen_load_a</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>new_block</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>JMP</name><argument_list>(<argument><expr><name>BPF_JSET</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b1</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">0x01</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b1</name><operator>-&gt;</operator><name>stmts</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>




<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_mac_multicast</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><name>b0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>gen_load_a</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b2</name> <operator>=</operator> <call><name>new_block</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>JMP</name><argument_list>(<argument><expr><name>BPF_JSET</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b2</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">0x01</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b2</name><operator>-&gt;</operator><name>stmts</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_not</name><argument_list>(<argument><expr><name>b2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_mac_multicast</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b2</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><name>b0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>gen_load_a</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>new_block</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>JMP</name><argument_list>(<argument><expr><name>BPF_JSET</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b1</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">0x08</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b1</name><operator>-&gt;</operator><name>stmts</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>




<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><name>b0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>






<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>gen_load_a</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b2</name> <operator>=</operator> <call><name>new_block</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>JMP</name><argument_list>(<argument><expr><name>BPF_JSET</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b2</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">0x08</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b2</name><operator>-&gt;</operator><name>stmts</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_not</name><argument_list>(<argument><expr><name>b2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_mac_multicast</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b2</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>






<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><name>b0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>









<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>gen_load_a</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>new_block</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>JMP</name><argument_list>(<argument><expr><name>BPF_JSET</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b1</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">0x04</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b1</name><operator>-&gt;</operator><name>stmts</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_not</name><argument_list>(<argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><name>b0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b0</name></expr>;</return>
<case>case <expr><name>DLT_IP_OVER_FC</name></expr>:</case>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_mac_multicast</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b0</name></expr>;</return>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><name>Q_IP</name></expr>:</case>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ETHERTYPE_IP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_cmp_ge</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKPL</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><literal type="number">224</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>

<case>case <expr><name>Q_IPV6</name></expr>:</case>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ETHERTYPE_IPV6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKPL</name></expr></argument>, <argument><expr><literal type="number">24</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><literal type="number">255</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"link-layer multicast filters supported only on ethernet/FDDI/token ring/ARCNET/802.11/ATM LANE/Fibre Channel"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>










<function><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_inbound</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>register</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>top_ctx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>




<switch>switch <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DLT_SLIP</name></expr>:</case>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_relation_internal</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_JEQ</name></expr></argument>,
<argument><expr><call><name>gen_load_internal</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>Q_LINK</name></expr></argument>, <argument><expr><call><name>gen_loadi_internal</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>gen_loadi_internal</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DLT_IPNET</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>dir</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>, <argument><expr><name>IPNET_OUTBOUND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>, <argument><expr><name>IPNET_INBOUND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>

<case>case <expr><name>DLT_LINUX_SLL</name></expr>:</case>

<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>, <argument><expr><name>LINUX_SLL_OUTGOING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dir</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>gen_not</name><argument_list>(<argument><expr><name>b0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>DLT_LINUX_SLL2</name></expr>:</case>

<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><name>LINUX_SLL_OUTGOING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dir</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>gen_not</name><argument_list>(<argument><expr><name>b0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_NET_PFVAR_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>DLT_PFLOG</name></expr>:</case>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr>struct <name>pfloghdr</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>,
<argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><operator>(</operator><ternary><condition><expr><operator>(</operator><name>dir</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>PF_IN</name></expr> </then><else>: <expr><name>PF_OUT</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<case>case <expr><name>DLT_PPP_PPPD</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>dir</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><name>PPP_PPPD_OUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><name>PPP_PPPD_IN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>

<case>case <expr><name>DLT_JUNIPER_MFR</name></expr>:</case>
<case>case <expr><name>DLT_JUNIPER_MLFR</name></expr>:</case>
<case>case <expr><name>DLT_JUNIPER_MLPPP</name></expr>:</case>
<case>case <expr><name>DLT_JUNIPER_ATM1</name></expr>:</case>
<case>case <expr><name>DLT_JUNIPER_ATM2</name></expr>:</case>
<case>case <expr><name>DLT_JUNIPER_PPPOE</name></expr>:</case>
<case>case <expr><name>DLT_JUNIPER_PPPOE_ATM</name></expr>:</case>
<case>case <expr><name>DLT_JUNIPER_GGSN</name></expr>:</case>
<case>case <expr><name>DLT_JUNIPER_ES</name></expr>:</case>
<case>case <expr><name>DLT_JUNIPER_MONITOR</name></expr>:</case>
<case>case <expr><name>DLT_JUNIPER_SERVICES</name></expr>:</case>
<case>case <expr><name>DLT_JUNIPER_ETHER</name></expr>:</case>
<case>case <expr><name>DLT_JUNIPER_PPP</name></expr>:</case>
<case>case <expr><name>DLT_JUNIPER_FRELAY</name></expr>:</case>
<case>case <expr><name>DLT_JUNIPER_CHDLC</name></expr>:</case>
<case>case <expr><name>DLT_JUNIPER_VP</name></expr>:</case>
<case>case <expr><name>DLT_JUNIPER_ST</name></expr>:</case>
<case>case <expr><name>DLT_JUNIPER_ISM</name></expr>:</case>
<case>case <expr><name>DLT_JUNIPER_VS</name></expr>:</case>
<case>case <expr><name>DLT_JUNIPER_SRX_E2E</name></expr>:</case>
<case>case <expr><name>DLT_JUNIPER_FIBRECHANNEL</name></expr>:</case>
<case>case <expr><name>DLT_JUNIPER_ATM_CEMIC</name></expr>:</case>



<if_stmt><if>if <condition>(<expr><name>dir</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_mcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0x01</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_mcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0x01</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>

<default>default:</default>















<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>linux</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>PF_PACKET</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SO_ATTACH_FILTER</name></expr></argument>)</argument_list></call></expr></cpp:if>






<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>bpf_pcap</name><operator>-&gt;</operator><name>rfile</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"inbound/outbound not supported on %s when reading savefiles"</literal></expr></argument>,
<argument><expr><call><name>pcap_datalink_val_to_description_or_dlt</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><name>SKF_AD_OFF</name> <operator>+</operator> <name>SKF_AD_PKTTYPE</name></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>,
<argument><expr><name>PACKET_OUTGOING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dir</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>gen_not</name><argument_list>(<argument><expr><name>b0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"inbound/outbound not supported on %s"</literal></expr></argument>,
<argument><expr><call><name>pcap_datalink_val_to_description_or_dlt</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></switch>
<return>return <expr><operator>(</operator><name>b0</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_NET_PFVAR_H</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_pf_ifname</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ifname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>u_int</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>off</name></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>top_ctx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name> <operator>!=</operator> <name>DLT_PFLOG</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"ifname supported only on PF linktype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>(</operator><operator>(</operator>struct <name>pfloghdr</name> <operator>*</operator><operator>)</operator><literal type="number">0</literal><operator>)</operator><operator>-&gt;</operator><name>ifname</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr>struct <name>pfloghdr</name></expr></argument>, <argument><expr><name>ifname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>ifname</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>len</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"ifname interface names can only be %d characters"</literal></expr></argument>,
<argument><expr><name>len</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_bcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><operator>(</operator><name>u_int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>ifname</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>(</operator><specifier>const</specifier> <name>u_char</name> <operator>*</operator><operator>)</operator><name>ifname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>b0</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_pf_ruleset</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>ruleset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>top_ctx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name> <operator>!=</operator> <name>DLT_PFLOG</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"ruleset supported only on PF linktype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>ruleset</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>(</operator><operator>(</operator>struct <name>pfloghdr</name> <operator>*</operator><operator>)</operator><literal type="number">0</literal><operator>)</operator><operator>-&gt;</operator><name>ruleset</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"ruleset names can only be %ld characters"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>long</name><operator>)</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><operator>(</operator><operator>(</operator>struct <name>pfloghdr</name> <operator>*</operator><operator>)</operator><literal type="number">0</literal><operator>)</operator><operator>-&gt;</operator><name>ruleset</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_bcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr>struct <name>pfloghdr</name></expr></argument>, <argument><expr><name>ruleset</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>(</operator><name>u_int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>ruleset</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>u_char</name> <operator>*</operator><operator>)</operator><name>ruleset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>b0</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_pf_rnr</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rnr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>top_ctx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name> <operator>!=</operator> <name>DLT_PFLOG</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"rnr supported only on PF linktype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr>struct <name>pfloghdr</name></expr></argument>, <argument><expr><name>rulenr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>BPF_W</name></expr></argument>,
<argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>rnr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>b0</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_pf_srnr</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>srnr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>top_ctx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name> <operator>!=</operator> <name>DLT_PFLOG</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"srnr supported only on PF linktype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr>struct <name>pfloghdr</name></expr></argument>, <argument><expr><name>subrulenr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>BPF_W</name></expr></argument>,
<argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>srnr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>b0</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_pf_reason</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reason</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>top_ctx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name> <operator>!=</operator> <name>DLT_PFLOG</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"reason supported only on PF linktype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr>struct <name>pfloghdr</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>,
<argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>b0</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_pf_action</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>action</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>top_ctx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name> <operator>!=</operator> <name>DLT_PFLOG</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"action supported only on PF linktype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_cmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr>struct <name>pfloghdr</name></expr></argument>, <argument><expr><name>action</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>,
<argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>b0</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_pf_ifname</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><name>ifname</name></type> <name>_U_</name></decl></parameter>)</parameter_list>
<block>{<block_content>




<if_stmt><if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>top_ctx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"libpcap was compiled without pf support"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_pf_ruleset</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><name>ruleset</name></type> <name>_U_</name></decl></parameter>)</parameter_list>
<block>{<block_content>




<if_stmt><if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>top_ctx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"libpcap was compiled on a machine without pf support"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_pf_rnr</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name> <name>rnr</name></type> <name>_U_</name></decl></parameter>)</parameter_list>
<block>{<block_content>




<if_stmt><if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>top_ctx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"libpcap was compiled on a machine without pf support"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_pf_srnr</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name> <name>srnr</name></type> <name>_U_</name></decl></parameter>)</parameter_list>
<block>{<block_content>




<if_stmt><if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>top_ctx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"libpcap was compiled on a machine without pf support"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_pf_reason</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name> <name>reason</name></type> <name>_U_</name></decl></parameter>)</parameter_list>
<block>{<block_content>




<if_stmt><if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>top_ctx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"libpcap was compiled on a machine without pf support"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_pf_action</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name> <name>action</name></type> <name>_U_</name></decl></parameter>)</parameter_list>
<block>{<block_content>




<if_stmt><if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>top_ctx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"libpcap was compiled on a machine without pf support"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<function><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_p80211_type</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mask</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>top_ctx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>DLT_IEEE802_11</name></expr>:</case>
<case>case <expr><name>DLT_PRISM_HEADER</name></expr>:</case>
<case>case <expr><name>DLT_IEEE802_11_RADIO_AVS</name></expr>:</case>
<case>case <expr><name>DLT_IEEE802_11_RADIO</name></expr>:</case>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_mcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>type</name></expr></argument>,
<argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<default>default:</default>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"802.11 link-layer types supported only on 802.11"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

<return>return <expr><operator>(</operator><name>b0</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_p80211_fcdir</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fcdir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>top_ctx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>DLT_IEEE802_11</name></expr>:</case>
<case>case <expr><name>DLT_PRISM_HEADER</name></expr>:</case>
<case>case <expr><name>DLT_IEEE802_11_RADIO_AVS</name></expr>:</case>
<case>case <expr><name>DLT_IEEE802_11_RADIO</name></expr>:</case>
<break>break;</break>

<default>default:</default>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"frame direction supported only with 802.11 headers"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_mcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>fcdir</name></expr></argument>,
<argument><expr><operator>(</operator><name>bpf_u_int32</name><operator>)</operator><name>IEEE80211_FC1_DIR_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>b0</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_acode</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>qual</name></name></type> <name>q</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>top_ctx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>DLT_ARCNET</name></expr>:</case>
<case>case <expr><name>DLT_ARCNET_LINUX</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>q</name><operator>.</operator><name>addr</name></name> <operator>==</operator> <name>Q_HOST</name> <operator>||</operator> <name><name>q</name><operator>.</operator><name>addr</name></name> <operator>==</operator> <name>Q_DEFAULT</name><operator>)</operator> <operator>&amp;&amp;</operator>
<name><name>q</name><operator>.</operator><name>proto</name></name> <operator>==</operator> <name>Q_LINK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>e</name></name> <operator>=</operator> <call><name>pcap_ether_aton</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>e</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"malloc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>gen_ahostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>e</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>q</name><operator>.</operator><name>dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>e</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>e</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>b</name><operator>)</operator></expr>;</return>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"ARCnet address used in non-arc expression"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>


<default>default:</default>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"aid supported only on ARCnet"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_ahostop</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>u_char</name> <modifier>*</modifier></type><name>eaddr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>register</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b1</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>dir</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>Q_SRC</name></expr>:</case>
<return>return <expr><call><name>gen_bcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>Q_DST</name></expr>:</case>
<return>return <expr><call><name>gen_bcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>Q_AND</name></expr>:</case>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_ahostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>, <argument><expr><name>Q_SRC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_ahostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>, <argument><expr><name>Q_DST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>

<case>case <expr><name>Q_DEFAULT</name></expr>:</case>
<case>case <expr><name>Q_OR</name></expr>:</case>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_ahostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>, <argument><expr><name>Q_SRC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_ahostop</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>eaddr</name></expr></argument>, <argument><expr><name>Q_DST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>

<case>case <expr><name>Q_ADDR1</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'addr1' and 'address1' are only supported on 802.11"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_ADDR2</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'addr2' and 'address2' are only supported on 802.11"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_ADDR3</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'addr3' and 'address3' are only supported on 802.11"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_ADDR4</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'addr4' and 'address4' are only supported on 802.11"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_RA</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'ra' is only supported on 802.11"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<case>case <expr><name>Q_TA</name></expr>:</case>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'ta' is only supported on 802.11"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_vlan_tpid_test</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b1</name></decl>;</decl_stmt>


<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ETHERTYPE_8021Q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ETHERTYPE_8021AD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>,<argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <name>b1</name></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ETHERTYPE_8021QINQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>,<argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>b1</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_vlan_vid_test</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>bpf_u_int32</name></type> <name>vlan_num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>vlan_num</name> <operator>&gt;</operator> <literal type="number">0x0fff</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"VLAN tag %u greater than maximum %u"</literal></expr></argument>,
<argument><expr><name>vlan_num</name></expr></argument>, <argument><expr><literal type="number">0x0fff</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>gen_mcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKPL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>vlan_num</name></expr></argument>, <argument><expr><literal type="number">0x0fff</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_vlan_no_bpf_extensions</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>bpf_u_int32</name></type> <name>vlan_num</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>has_vlan_tag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b1</name></decl>;</decl_stmt>

<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_vlan_tpid_test</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>has_vlan_tag</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_vlan_vid_test</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>vlan_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <name>b1</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>





<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

<return>return <expr><name>b0</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SKF_AD_VLAN_TAG_PRESENT</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>gen_vlan_vloffset_add</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>bpf_abs_offset</name> <modifier>*</modifier></type><name>off</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>s2</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>off</name><operator>-&gt;</operator><name>is_variable</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>off</name><operator>-&gt;</operator><name>is_variable</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>off</name><operator>-&gt;</operator><name>reg</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>off</name><operator>-&gt;</operator><name>reg</name></name> <operator>=</operator> <call><name>alloc_reg</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LD</name><operator>|</operator><name>BPF_MEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s2</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name><name>off</name><operator>-&gt;</operator><name>reg</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ALU</name><operator>|</operator><name>BPF_ADD</name><operator>|</operator><name>BPF_IMM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s2</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s2</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name><name>off</name><operator>-&gt;</operator><name>reg</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type>
<name>gen_vlan_patch_tpid_test</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b_tpid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>slist</name></name></type> <name>s</name></decl>;</decl_stmt>


<expr_stmt><expr><name><name>s</name><operator>.</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>is_vlan_vloffset</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_vlan_vloffset_add</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_vlan_vloffset_add</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name><name>s</name><operator>.</operator><name>next</name></name></expr></argument>, <argument><expr><name><name>b_tpid</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>stmts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b_tpid</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>stmts</name></name> <operator>=</operator> <name><name>s</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type>
<name>gen_vlan_patch_vid_test</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b_vid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>s</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>s2</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sjeq</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>cnt</name></decl>;</decl_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LD</name><operator>|</operator><name>BPF_B</name><operator>|</operator><name>BPF_ABS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name>SKF_AD_OFF</name> <operator>+</operator> <name>SKF_AD_VLAN_TAG_PRESENT</name></expr>;</expr_stmt>


<expr_stmt><expr><name>sjeq</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>JMP</name><argument_list>(<argument><expr><name>BPF_JEQ</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sjeq</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sjeq</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>jf</name></name> <operator>=</operator> <name><name>b_vid</name><operator>-&gt;</operator><name>stmts</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>sjeq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LD</name><operator>|</operator><name>BPF_B</name><operator>|</operator><name>BPF_ABS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s2</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name>SKF_AD_OFF</name> <operator>+</operator> <name>SKF_AD_VLAN_TAG</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sjeq</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>jt</name></name> <operator>=</operator> <name>s2</name></expr>;</expr_stmt>





<expr_stmt><expr><name>cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>s2</name> <operator>=</operator> <name><name>b_vid</name><operator>-&gt;</operator><name>stmts</name></name></expr>;</init> <condition><expr><name>s2</name></expr>;</condition> <incr><expr><name>s2</name> <operator>=</operator> <name><name>s2</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name>cnt</name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>JMP</name><argument_list>(<argument><expr><name>BPF_JA</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s2</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name>cnt</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>b_vid</name><operator>-&gt;</operator><name>stmts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b_vid</name><operator>-&gt;</operator><name>stmts</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
</block_content>}</block></function>









<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_vlan_bpf_extensions</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>bpf_u_int32</name></type> <name>vlan_num</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>has_vlan_tag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b_tpid</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b_vid</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>



<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LD</name><operator>|</operator><name>BPF_B</name><operator>|</operator><name>BPF_ABS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name>SKF_AD_OFF</name> <operator>+</operator> <name>SKF_AD_VLAN_TAG_PRESENT</name></expr>;</expr_stmt>

<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>new_block</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>JMP</name><argument_list>(<argument><expr><name>BPF_JEQ</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b0</name><operator>-&gt;</operator><name>stmts</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b0</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>











<expr_stmt><expr><name>b_tpid</name> <operator>=</operator> <call><name>gen_vlan_tpid_test</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>has_vlan_tag</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>b_vid</name> <operator>=</operator> <call><name>gen_vlan_vid_test</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>vlan_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>gen_vlan_patch_tpid_test</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>b_tpid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b_tpid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <name>b_tpid</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>has_vlan_tag</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>gen_vlan_patch_vid_test</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>b_vid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b_vid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <name>b_vid</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>b0</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>




<function><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_vlan</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>bpf_u_int32</name></type> <name>vlan_num</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>has_vlan_tag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>top_ctx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>label_stack_depth</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"no VLAN match after MPLS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
































<switch>switch <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>DLT_EN10MB</name></expr>:</case>
<case>case <expr><name>DLT_NETANALYZER</name></expr>:</case>
<case>case <expr><name>DLT_NETANALYZER_TRANSPARENT</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SKF_AD_VLAN_TAG_PRESENT</name></expr></argument>)</argument_list></call></expr></cpp:if>


<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>vlan_stack_depth</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>off_linkhdr</name><operator>.</operator><name>is_variable</name></name> <operator>&amp;&amp;</operator>
<name><name>cstate</name><operator>-&gt;</operator><name>off_linkhdr</name><operator>.</operator><name>constant_part</name></name> <operator>==</operator>
<name><name>cstate</name><operator>-&gt;</operator><name>off_outermostlinkhdr</name><operator>.</operator><name>constant_part</name></name></expr>)</condition> <block>{<block_content>



<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>bpf_pcap</name><operator>-&gt;</operator><name>bpf_codegen_flags</name></name> <operator>&amp;</operator> <name>BPF_SPECIAL_VLAN_HANDLING</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_vlan_bpf_extensions</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>vlan_num</name></expr></argument>,
<argument><expr><name>has_vlan_tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_vlan_no_bpf_extensions</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>,
<argument><expr><name>vlan_num</name></expr></argument>, <argument><expr><name>has_vlan_tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_vlan_no_bpf_extensions</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>vlan_num</name></expr></argument>,
<argument><expr><name>has_vlan_tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<break>break;</break>

<case>case <expr><name>DLT_IEEE802_11</name></expr>:</case>
<case>case <expr><name>DLT_PRISM_HEADER</name></expr>:</case>
<case>case <expr><name>DLT_IEEE802_11_RADIO_AVS</name></expr>:</case>
<case>case <expr><name>DLT_IEEE802_11_RADIO</name></expr>:</case>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_vlan_no_bpf_extensions</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>vlan_num</name></expr></argument>, <argument><expr><name>has_vlan_tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<default>default:</default>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"no VLAN support for %s"</literal></expr></argument>,
<argument><expr><call><name>pcap_datalink_val_to_description_or_dlt</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>vlan_stack_depth</name></name><operator>++</operator></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>b0</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>








<function><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_mpls</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>bpf_u_int32</name></type> <name>label_num_arg</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>has_label_num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>volatile</specifier> <name>bpf_u_int32</name></type> <name>label_num</name> <init>= <expr><name>label_num_arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b1</name></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>top_ctx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>label_stack_depth</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_mcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_PREVMPLSHDR</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0x01</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>




<switch>switch <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>DLT_C_HDLC</name></expr>:</case>
<case>case <expr><name>DLT_EN10MB</name></expr>:</case>
<case>case <expr><name>DLT_NETANALYZER</name></expr>:</case>
<case>case <expr><name>DLT_NETANALYZER_TRANSPARENT</name></expr>:</case>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>ETHERTYPE_MPLS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>DLT_PPP</name></expr>:</case>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>PPP_MPLS_UCAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>





<default>default:</default>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"no MPLS support for %s"</literal></expr></argument>,
<argument><expr><call><name>pcap_datalink_val_to_description_or_dlt</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>
</block_content>}</block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><name>has_label_num</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>label_num</name> <operator>&gt;</operator> <literal type="number">0xFFFFF</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"MPLS label %u greater than maximum %u"</literal></expr></argument>,
<argument><expr><name>label_num</name></expr></argument>, <argument><expr><literal type="number">0xFFFFF</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>label_num</name> <operator>=</operator> <name>label_num</name> <operator>&lt;&lt;</operator> <literal type="number">12</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_mcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKPL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_W</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>label_num</name></expr></argument>,
<argument><expr><literal type="number">0xfffff000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <name>b1</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>















<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl_nosnap</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>label_stack_depth</name></name><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>b0</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>




<function><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_pppoed</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>




<if_stmt><if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>top_ctx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>


<return>return <expr><call><name>gen_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>ETHERTYPE_PPPOED</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_pppoes</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>bpf_u_int32</name></type> <name>sess_num</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>has_sess_num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b1</name></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>top_ctx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>




<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_linktype</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>ETHERTYPE_PPPOES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>has_sess_num</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>sess_num</name> <operator>&gt;</operator> <literal type="number">0x0000ffff</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"PPPoE session number %u greater than maximum %u"</literal></expr></argument>,
<argument><expr><name>sess_num</name></expr></argument>, <argument><expr><literal type="number">0x0000ffff</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_mcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKPL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_W</name></expr></argument>,
<argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>sess_num</name></expr></argument>, <argument><expr><literal type="number">0x0000ffff</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <name>b1</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>



















<expr_stmt><expr><call><name>PUSH_LINKHDR</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>DLT_PPP</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>is_variable</name></name></expr></argument>,
<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>+</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>+</operator> <literal type="number">6</literal></expr></argument>,
<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>reg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_linkhdr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_linkhdr</name><operator>.</operator><name>constant_part</name></name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl_nosnap</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<return>return <expr><name>b0</name></expr>;</return>
</block_content>}</block></function>



<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_geneve_check</name><argument_list>(<argument><expr><name>compiler_state_t</name> <operator>*</operator><name>cstate</name></expr></argument>,
<argument><expr>struct <name>block</name> <operator>*</operator><call>(<modifier>*</modifier><name>gen_portfn</name>)<argument_list>(<argument><expr><name>compiler_state_t</name> <operator>*</operator></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr>enum <name>e_offrel</name> <name>offrel</name></expr></argument>, <argument><expr><name>bpf_u_int32</name> <name>vni</name></expr></argument>, <argument><expr><name>int</name> <name>has_vni</name></expr></argument>)</argument_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b1</name></decl>;</decl_stmt>

<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_portfn</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>GENEVE_PORT</name></expr></argument>, <argument><expr><name>IPPROTO_UDP</name></expr></argument>, <argument><expr><name>Q_DST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_mcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>offrel</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0xc0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <name>b1</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>has_vni</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>vni</name> <operator>&gt;</operator> <literal type="number">0xffffff</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"Geneve VNI %u greater than maximum %u"</literal></expr></argument>,
<argument><expr><name>vni</name></expr></argument>, <argument><expr><literal type="number">0xffffff</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>vni</name> <operator>&lt;&lt;=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_mcmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>offrel</name></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>, <argument><expr><name>BPF_W</name></expr></argument>, <argument><expr><operator>(</operator><name>bpf_int32</name><operator>)</operator><name>vni</name></expr></argument>,
<argument><expr><literal type="number">0xffffff00</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <name>b1</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>b0</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>






<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_geneve4</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>bpf_u_int32</name></type> <name>vni</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>has_vni</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b1</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>s</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>s1</name></decl>;</decl_stmt>

<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_geneve_check</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>gen_port</name></expr></argument>, <argument><expr><name>OR_TRAN_IPV4</name></expr></argument>, <argument><expr><name>vni</name></expr></argument>, <argument><expr><name>has_vni</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>gen_loadx_iphdrlen</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s1</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_MISC</name><operator>|</operator><name>BPF_TXA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>new_block</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_JMP</name><operator>|</operator><name>BPF_JEQ</name><operator>|</operator><name>BPF_X</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b1</name><operator>-&gt;</operator><name>stmts</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b1</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>b1</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_geneve6</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>bpf_u_int32</name></type> <name>vni</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>has_vni</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b1</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>s</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>s1</name></decl>;</decl_stmt>

<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_geneve_check</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>gen_port6</name></expr></argument>, <argument><expr><name>OR_TRAN_IPV6</name></expr></argument>, <argument><expr><name>vni</name></expr></argument>, <argument><expr><name>has_vni</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>gen_abs_offset_varpart</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>s</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>s1</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LD</name><operator>|</operator><name>BPF_IMM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s1</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">40</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s1</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ALU</name><operator>|</operator><name>BPF_ADD</name><operator>|</operator><name>BPF_X</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s1</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LD</name><operator>|</operator><name>BPF_IMM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">40</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>




<expr_stmt><expr><name>s1</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_MISC</name><operator>|</operator><name>BPF_TAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>new_block</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_JMP</name><operator>|</operator><name>BPF_JEQ</name><operator>|</operator><name>BPF_X</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b1</name><operator>-&gt;</operator><name>stmts</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b1</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>b1</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type>
<name>gen_geneve_offsets</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>s</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>s1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>s_proto</name></decl>;</decl_stmt>






<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ALU</name><operator>|</operator><name>BPF_ADD</name><operator>|</operator><name>BPF_K</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>+</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>+</operator> <literal type="number">8</literal></expr>;</expr_stmt>


<expr_stmt><expr><name>s1</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_MISC</name><operator>|</operator><name>BPF_TAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>s1</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ALU</name><operator>|</operator><name>BPF_ADD</name><operator>|</operator><name>BPF_K</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s1</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>reg</name></name> <operator>=</operator> <call><name>alloc_reg</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>is_variable</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>s1</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s1</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>reg</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><name>s1</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LD</name><operator>|</operator><name>BPF_IND</name><operator>|</operator><name>BPF_B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s1</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s1</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ALU</name><operator>|</operator><name>BPF_AND</name><operator>|</operator><name>BPF_K</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s1</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">0x3f</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s1</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ALU</name><operator>|</operator><name>BPF_MUL</name><operator>|</operator><name>BPF_K</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s1</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>s1</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ALU</name><operator>|</operator><name>BPF_ADD</name><operator>|</operator><name>BPF_K</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s1</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>s1</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ALU</name><operator>|</operator><name>BPF_ADD</name><operator>|</operator><name>BPF_X</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s1</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>









<expr_stmt><expr><call><name>PUSH_LINKHDR</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>DLT_EN10MB</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>alloc_reg</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s1</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s1</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_linkhdr</name><operator>.</operator><name>reg</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>







<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>no_optimize</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>


<expr_stmt><expr><name>s1</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LD</name><operator>|</operator><name>BPF_IND</name><operator>|</operator><name>BPF_H</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s1</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>s1</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LDX</name><operator>|</operator><name>BPF_MEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s1</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_linkhdr</name><operator>.</operator><name>reg</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><name>s_proto</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><call><name>JMP</name><argument_list>(<argument><expr><name>BPF_JEQ</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s_proto</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name>ETHERTYPE_TEB</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s_proto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s1</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_MISC</name><operator>|</operator><name>BPF_TXA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s_proto</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>jt</name></name> <operator>=</operator> <name>s1</name></expr>;</expr_stmt>



<expr_stmt><expr><name>s1</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ALU</name><operator>|</operator><name>BPF_ADD</name><operator>|</operator><name>BPF_K</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s1</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">12</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s1</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s1</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>reg</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>s1</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_ALU</name><operator>|</operator><name>BPF_ADD</name><operator>|</operator><name>BPF_K</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s1</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>s1</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_MISC</name><operator>|</operator><name>BPF_TAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>reg</name></name> <operator>=</operator> <call><name>alloc_reg</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>is_variable</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>s1</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_STX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s1</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>reg</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s_proto</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>jf</name></name> <operator>=</operator> <name>s1</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<return>return <expr><name>s</name></expr>;</return>
</block_content>}</block></function>


<function><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_geneve</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>bpf_u_int32</name></type> <name>vni</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>has_vni</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b1</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>top_ctx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_geneve4</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>vni</name></expr></argument>, <argument><expr><name>has_vni</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_geneve6</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>vni</name></expr></argument>, <argument><expr><name>has_vni</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <name>b1</name></expr>;</expr_stmt>




<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>gen_geneve_offsets</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_true</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>b1</name><operator>-&gt;</operator><name>stmts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b1</name><operator>-&gt;</operator><name>stmts</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>is_geneve</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<return>return <expr><name>b1</name></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_geneve_ll_check</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>slist</name></name> <modifier>*</modifier></type><name>s</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>s1</name></decl>;</decl_stmt>







<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LD</name><operator>|</operator><name>BPF_MEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_linkhdr</name><operator>.</operator><name>reg</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>s1</name> <operator>=</operator> <call><name>new_stmt</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_LDX</name><operator>|</operator><name>BPF_MEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s1</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>reg</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sappend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>new_block</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>BPF_JMP</name><operator>|</operator><name>BPF_JEQ</name><operator>|</operator><name>BPF_X</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b0</name><operator>-&gt;</operator><name>stmts</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b0</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>k</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_not</name><argument_list>(<argument><expr><name>b0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>b0</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_atmfield_code_internal</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>atmfield</name></decl></parameter>,
<parameter><decl><type><name>bpf_int32</name></type> <name>jvalue</name></decl></parameter>, <parameter><decl><type><name>bpf_u_int32</name></type> <name>jtype</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reverse</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>atmfield</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>A_VPI</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>is_atm</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'vpi' supported only on raw ATM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>off_vpi</name></name> <operator>==</operator> <name>OFFSET_NOT_SET</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_ncmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_vpi</name></name></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><literal type="number">0xffffffff</literal></expr></argument>, <argument><expr><name>jtype</name></expr></argument>,
<argument><expr><name>reverse</name></expr></argument>, <argument><expr><name>jvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>A_VCI</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>is_atm</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'vci' supported only on raw ATM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>off_vci</name></name> <operator>==</operator> <name>OFFSET_NOT_SET</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_ncmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_vci</name></name></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>, <argument><expr><literal type="number">0xffffffff</literal></expr></argument>, <argument><expr><name>jtype</name></expr></argument>,
<argument><expr><name>reverse</name></expr></argument>, <argument><expr><name>jvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>A_PROTOTYPE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>off_proto</name></name> <operator>==</operator> <name>OFFSET_NOT_SET</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_ncmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_proto</name></name></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><literal type="number">0x0f</literal></expr></argument>, <argument><expr><name>jtype</name></expr></argument>,
<argument><expr><name>reverse</name></expr></argument>, <argument><expr><name>jvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>A_MSGTYPE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>off_payload</name></name> <operator>==</operator> <name>OFFSET_NOT_SET</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_ncmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_payload</name></name> <operator>+</operator> <name>MSG_TYPE_POS</name></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>,
<argument><expr><literal type="number">0xffffffff</literal></expr></argument>, <argument><expr><name>jtype</name></expr></argument>, <argument><expr><name>reverse</name></expr></argument>, <argument><expr><name>jvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>A_CALLREFTYPE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>is_atm</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'callref' supported only on raw ATM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>off_proto</name></name> <operator>==</operator> <name>OFFSET_NOT_SET</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_ncmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_LINKHDR</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_proto</name></name></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><literal type="number">0xffffffff</literal></expr></argument>,
<argument><expr><name>jtype</name></expr></argument>, <argument><expr><name>reverse</name></expr></argument>, <argument><expr><name>jvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<default>default:</default>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
<return>return <expr><name>b0</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_atmtype_metac</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b1</name></decl>;</decl_stmt>

<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_atmfield_code_internal</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>A_VPI</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_JEQ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_atmfield_code_internal</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>A_VCI</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>BPF_JEQ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_atmtype_sc</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b1</name></decl>;</decl_stmt>

<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_atmfield_code_internal</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>A_VPI</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_JEQ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_atmfield_code_internal</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>A_VCI</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><name>BPF_JEQ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b1</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_atmtype_llc</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>;</decl_stmt>

<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_atmfield_code_internal</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>A_PROTOTYPE</name></expr></argument>, <argument><expr><name>PT_LLC</name></expr></argument>, <argument><expr><name>BPF_JEQ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>prevlinktype</name></name></expr>;</expr_stmt>
<return>return <expr><name>b0</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_atmfield_code</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>atmfield</name></decl></parameter>,
<parameter><decl><type><name>bpf_int32</name></type> <name>jvalue</name></decl></parameter>, <parameter><decl><type><name>bpf_u_int32</name></type> <name>jtype</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reverse</name></decl></parameter>)</parameter_list>
<block>{<block_content>




<if_stmt><if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>top_ctx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>gen_atmfield_code_internal</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>atmfield</name></expr></argument>, <argument><expr><name>jvalue</name></expr></argument>, <argument><expr><name>jtype</name></expr></argument>,
<argument><expr><name>reverse</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_atmtype_abbrev</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b1</name></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>top_ctx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>A_METAC</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>is_atm</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'metac' supported only on raw ATM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_atmtype_metac</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>A_BCC</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>is_atm</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'bcc' supported only on raw ATM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_atmfield_code_internal</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>A_VPI</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_JEQ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_atmfield_code_internal</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>A_VCI</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>BPF_JEQ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>A_OAMF4SC</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>is_atm</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'oam4sc' supported only on raw ATM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_atmfield_code_internal</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>A_VPI</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_JEQ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_atmfield_code_internal</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>A_VCI</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>BPF_JEQ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>A_OAMF4EC</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>is_atm</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'oam4ec' supported only on raw ATM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_atmfield_code_internal</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>A_VPI</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_JEQ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_atmfield_code_internal</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>A_VCI</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>BPF_JEQ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>A_SC</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>is_atm</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'sc' supported only on raw ATM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_atmtype_sc</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>A_ILMIC</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>is_atm</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'ilmic' supported only on raw ATM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_atmfield_code_internal</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>A_VPI</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_JEQ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_atmfield_code_internal</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>A_VCI</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><name>BPF_JEQ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>A_LANE</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>is_atm</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'lane' supported only on raw ATM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_atmfield_code_internal</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>A_PROTOTYPE</name></expr></argument>, <argument><expr><name>PT_LANE</name></expr></argument>, <argument><expr><name>BPF_JEQ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>









<expr_stmt><expr><call><name>PUSH_LINKHDR</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>DLT_EN10MB</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_payload</name></name> <operator>+</operator> <literal type="number">2</literal></expr></argument>,
<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linktype</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_linkhdr</name><operator>.</operator><name>constant_part</name></name> <operator>+</operator> <literal type="number">12</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_linkpl</name><operator>.</operator><name>constant_part</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_linkhdr</name><operator>.</operator><name>constant_part</name></name> <operator>+</operator> <literal type="number">14</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_nl_nosnap</name></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>A_LLC</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>is_atm</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'llc' supported only on raw ATM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_atmtype_llc</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<default>default:</default>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
<return>return <expr><name>b1</name></expr>;</return>
</block_content>}</block></function>








<function><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_mtp2type_abbrev</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b1</name></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>top_ctx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>M_FISU</name></expr>:</case>
<if_stmt><if>if <condition>( <expr><operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name> <operator>!=</operator> <name>DLT_MTP2</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name> <operator>!=</operator> <name>DLT_ERF</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name> <operator>!=</operator> <name>DLT_MTP2_WITH_PHDR</name><operator>)</operator></expr> )</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'fisu' supported only on MTP2"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_ncmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_PACKET</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_li</name></name></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><literal type="number">0x3f</literal></expr></argument>, <argument><expr><name>BPF_JEQ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>M_LSSU</name></expr>:</case>
<if_stmt><if>if <condition>( <expr><operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name> <operator>!=</operator> <name>DLT_MTP2</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name> <operator>!=</operator> <name>DLT_ERF</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name> <operator>!=</operator> <name>DLT_MTP2_WITH_PHDR</name><operator>)</operator></expr> )</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'lssu' supported only on MTP2"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_ncmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_PACKET</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_li</name></name></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><literal type="number">0x3f</literal></expr></argument>, <argument><expr><name>BPF_JGT</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_ncmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_PACKET</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_li</name></name></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><literal type="number">0x3f</literal></expr></argument>, <argument><expr><name>BPF_JGT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><name>b0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>M_MSU</name></expr>:</case>
<if_stmt><if>if <condition>( <expr><operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name> <operator>!=</operator> <name>DLT_MTP2</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name> <operator>!=</operator> <name>DLT_ERF</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name> <operator>!=</operator> <name>DLT_MTP2_WITH_PHDR</name><operator>)</operator></expr> )</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'msu' supported only on MTP2"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_ncmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_PACKET</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_li</name></name></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><literal type="number">0x3f</literal></expr></argument>, <argument><expr><name>BPF_JGT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>MH_FISU</name></expr>:</case>
<if_stmt><if>if <condition>( <expr><operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name> <operator>!=</operator> <name>DLT_MTP2</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name> <operator>!=</operator> <name>DLT_ERF</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name> <operator>!=</operator> <name>DLT_MTP2_WITH_PHDR</name><operator>)</operator></expr> )</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'hfisu' supported only on MTP2_HSL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_ncmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_PACKET</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_li_hsl</name></name></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>, <argument><expr><literal type="number">0xff80</literal></expr></argument>, <argument><expr><name>BPF_JEQ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>MH_LSSU</name></expr>:</case>
<if_stmt><if>if <condition>( <expr><operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name> <operator>!=</operator> <name>DLT_MTP2</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name> <operator>!=</operator> <name>DLT_ERF</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name> <operator>!=</operator> <name>DLT_MTP2_WITH_PHDR</name><operator>)</operator></expr> )</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'hlssu' supported only on MTP2_HSL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_ncmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_PACKET</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_li_hsl</name></name></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>, <argument><expr><literal type="number">0xff80</literal></expr></argument>, <argument><expr><name>BPF_JGT</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0x0100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_ncmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_PACKET</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_li_hsl</name></name></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>, <argument><expr><literal type="number">0xff80</literal></expr></argument>, <argument><expr><name>BPF_JGT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b1</name></expr></argument>, <argument><expr><name>b0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>MH_MSU</name></expr>:</case>
<if_stmt><if>if <condition>( <expr><operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name> <operator>!=</operator> <name>DLT_MTP2</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name> <operator>!=</operator> <name>DLT_ERF</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>linktype</name></name> <operator>!=</operator> <name>DLT_MTP2_WITH_PHDR</name><operator>)</operator></expr> )</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'hmsu' supported only on MTP2_HSL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_ncmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_PACKET</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>off_li_hsl</name></name></expr></argument>, <argument><expr><name>BPF_H</name></expr></argument>, <argument><expr><literal type="number">0xff80</literal></expr></argument>, <argument><expr><name>BPF_JGT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0x0100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<default>default:</default>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
<return>return <expr><name>b0</name></expr>;</return>
</block_content>}</block></function>






<function><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_mtp3field_code</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mtp3field</name></decl></parameter>,
<parameter><decl><type><name>bpf_u_int32</name></type> <name>jvalue_arg</name></decl></parameter>, <parameter><decl><type><name>bpf_u_int32</name></type> <name>jtype</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reverse</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>volatile</specifier> <name>bpf_u_int32</name></type> <name>jvalue</name> <init>= <expr><name>jvalue_arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bpf_u_int32</name></type> <name>val1</name></decl> , <decl><type ref="prev"/><name>val2</name></decl> , <decl><type ref="prev"/><name>val3</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>u_int</name></type> <name>newoff_sio</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>u_int</name></type> <name>newoff_opc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>u_int</name></type> <name>newoff_dpc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>u_int</name></type> <name>newoff_sls</name></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>top_ctx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>newoff_sio</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_sio</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>newoff_opc</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_opc</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>newoff_dpc</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_dpc</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>newoff_sls</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>off_sls</name></name></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>mtp3field</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>MH_SIO</name></expr>:</case>
<expr_stmt><expr><name>newoff_sio</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>


<case>case <expr><name>M_SIO</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>off_sio</name></name> <operator>==</operator> <name>OFFSET_NOT_SET</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'sio' supported only on SS7"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name>jvalue</name> <operator>&gt;</operator> <literal type="number">255</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"sio value %u too big; max value = 255"</literal></expr></argument>,
<argument><expr><name>jvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_ncmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_PACKET</name></expr></argument>, <argument><expr><name>newoff_sio</name></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><literal type="number">0xffffffff</literal></expr></argument>,
<argument><expr><operator>(</operator><name>u_int</name><operator>)</operator><name>jtype</name></expr></argument>, <argument><expr><name>reverse</name></expr></argument>, <argument><expr><operator>(</operator><name>u_int</name><operator>)</operator><name>jvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>MH_OPC</name></expr>:</case>
<expr_stmt><expr><name>newoff_opc</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>


<case>case <expr><name>M_OPC</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>off_opc</name></name> <operator>==</operator> <name>OFFSET_NOT_SET</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'opc' supported only on SS7"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>jvalue</name> <operator>&gt;</operator> <literal type="number">16383</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"opc value %u too big; max value = 16383"</literal></expr></argument>,
<argument><expr><name>jvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><name>val1</name> <operator>=</operator> <name>jvalue</name> <operator>&amp;</operator> <literal type="number">0x00003c00</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>val1</name> <operator>=</operator> <name>val1</name> <operator>&gt;&gt;</operator><literal type="number">10</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>val2</name> <operator>=</operator> <name>jvalue</name> <operator>&amp;</operator> <literal type="number">0x000003fc</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>val2</name> <operator>=</operator> <name>val2</name> <operator>&lt;&lt;</operator><literal type="number">6</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>val3</name> <operator>=</operator> <name>jvalue</name> <operator>&amp;</operator> <literal type="number">0x00000003</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>val3</name> <operator>=</operator> <name>val3</name> <operator>&lt;&lt;</operator><literal type="number">22</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>jvalue</name> <operator>=</operator> <name>val1</name> <operator>+</operator> <name>val2</name> <operator>+</operator> <name>val3</name></expr>;</expr_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_ncmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_PACKET</name></expr></argument>, <argument><expr><name>newoff_opc</name></expr></argument>, <argument><expr><name>BPF_W</name></expr></argument>, <argument><expr><literal type="number">0x00c0ff0f</literal></expr></argument>,
<argument><expr><operator>(</operator><name>u_int</name><operator>)</operator><name>jtype</name></expr></argument>, <argument><expr><name>reverse</name></expr></argument>, <argument><expr><operator>(</operator><name>u_int</name><operator>)</operator><name>jvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>MH_DPC</name></expr>:</case>
<expr_stmt><expr><name>newoff_dpc</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>


<case>case <expr><name>M_DPC</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>off_dpc</name></name> <operator>==</operator> <name>OFFSET_NOT_SET</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'dpc' supported only on SS7"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>jvalue</name> <operator>&gt;</operator> <literal type="number">16383</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"dpc value %u too big; max value = 16383"</literal></expr></argument>,
<argument><expr><name>jvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><name>val1</name> <operator>=</operator> <name>jvalue</name> <operator>&amp;</operator> <literal type="number">0x000000ff</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>val1</name> <operator>=</operator> <name>val1</name> <operator>&lt;&lt;</operator> <literal type="number">24</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>val2</name> <operator>=</operator> <name>jvalue</name> <operator>&amp;</operator> <literal type="number">0x00003f00</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>val2</name> <operator>=</operator> <name>val2</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>jvalue</name> <operator>=</operator> <name>val1</name> <operator>+</operator> <name>val2</name></expr>;</expr_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_ncmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_PACKET</name></expr></argument>, <argument><expr><name>newoff_dpc</name></expr></argument>, <argument><expr><name>BPF_W</name></expr></argument>, <argument><expr><literal type="number">0xff3f0000</literal></expr></argument>,
<argument><expr><operator>(</operator><name>u_int</name><operator>)</operator><name>jtype</name></expr></argument>, <argument><expr><name>reverse</name></expr></argument>, <argument><expr><operator>(</operator><name>u_int</name><operator>)</operator><name>jvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>MH_SLS</name></expr>:</case>
<expr_stmt><expr><name>newoff_sls</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>


<case>case <expr><name>M_SLS</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>off_sls</name></name> <operator>==</operator> <name>OFFSET_NOT_SET</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'sls' supported only on SS7"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>jvalue</name> <operator>&gt;</operator> <literal type="number">15</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"sls value %u too big; max value = 15"</literal></expr></argument>,
<argument><expr><name>jvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><name>jvalue</name> <operator>=</operator> <name>jvalue</name> <operator>&lt;&lt;</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_ncmp</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>OR_PACKET</name></expr></argument>, <argument><expr><name>newoff_sls</name></expr></argument>, <argument><expr><name>BPF_B</name></expr></argument>, <argument><expr><literal type="number">0xf0</literal></expr></argument>,
<argument><expr><operator>(</operator><name>u_int</name><operator>)</operator><name>jtype</name></expr></argument>,<argument><expr><name>reverse</name></expr></argument>, <argument><expr><operator>(</operator><name>u_int</name><operator>)</operator><name>jvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<default>default:</default>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
<return>return <expr><name>b0</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_msg_abbrev</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b1</name></decl>;</decl_stmt>





<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>A_SETUP</name></expr>:</case>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_atmfield_code_internal</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>A_MSGTYPE</name></expr></argument>, <argument><expr><name>SETUP</name></expr></argument>, <argument><expr><name>BPF_JEQ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>A_CALLPROCEED</name></expr>:</case>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_atmfield_code_internal</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>A_MSGTYPE</name></expr></argument>, <argument><expr><name>CALL_PROCEED</name></expr></argument>, <argument><expr><name>BPF_JEQ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>A_CONNECT</name></expr>:</case>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_atmfield_code_internal</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>A_MSGTYPE</name></expr></argument>, <argument><expr><name>CONNECT</name></expr></argument>, <argument><expr><name>BPF_JEQ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>A_CONNECTACK</name></expr>:</case>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_atmfield_code_internal</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>A_MSGTYPE</name></expr></argument>, <argument><expr><name>CONNECT_ACK</name></expr></argument>, <argument><expr><name>BPF_JEQ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>A_RELEASE</name></expr>:</case>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_atmfield_code_internal</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>A_MSGTYPE</name></expr></argument>, <argument><expr><name>RELEASE</name></expr></argument>, <argument><expr><name>BPF_JEQ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>A_RELEASE_DONE</name></expr>:</case>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_atmfield_code_internal</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>A_MSGTYPE</name></expr></argument>, <argument><expr><name>RELEASE_DONE</name></expr></argument>, <argument><expr><name>BPF_JEQ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<default>default:</default>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
<return>return <expr><name>b1</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type>
<name>gen_atmmulti_abbrev</name><parameter_list>(<parameter><decl><type><name>compiler_state_t</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>block</name></name> <modifier>*</modifier></type><name>b0</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b1</name></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>top_ctx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>A_OAM</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>is_atm</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'oam' supported only on raw ATM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_atmfield_code_internal</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>A_VCI</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>BPF_JEQ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_atmfield_code_internal</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>A_VCI</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>BPF_JEQ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_atmfield_code_internal</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>A_VPI</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_JEQ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>A_OAMF4</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>is_atm</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'oamf4' supported only on raw ATM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_atmfield_code_internal</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>A_VCI</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>BPF_JEQ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_atmfield_code_internal</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>A_VCI</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>BPF_JEQ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_atmfield_code_internal</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>A_VPI</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>BPF_JEQ</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>A_CONNECTMSG</name></expr>:</case>




<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>is_atm</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'connectmsg' supported only on raw ATM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_msg_abbrev</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>A_SETUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_msg_abbrev</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>A_CALLPROCEED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_msg_abbrev</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>A_CONNECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_msg_abbrev</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>A_CONNECTACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_msg_abbrev</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>A_RELEASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_msg_abbrev</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>A_RELEASE_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_atmtype_sc</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>A_METACONNECT</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>is_atm</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>bpf_error</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><literal type="string">"'metaconnect' supported only on raw ATM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_msg_abbrev</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>A_SETUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b1</name> <operator>=</operator> <call><name>gen_msg_abbrev</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>A_CALLPROCEED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_msg_abbrev</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>A_CONNECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_msg_abbrev</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>A_RELEASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_msg_abbrev</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>A_RELEASE_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_or</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b0</name> <operator>=</operator> <call><name>gen_atmtype_metac</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gen_and</name><argument_list>(<argument><expr><name>b0</name></expr></argument>, <argument><expr><name>b1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<default>default:</default>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
<return>return <expr><name>b1</name></expr>;</return>
</block_content>}</block></function>
</unit>
