<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/libarchive/libarchive/test/main.c">
























<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"test.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"test_utils.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_IOCTL_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/ioctl.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_TIME_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_ICONV_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;iconv.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>




<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LINUX_EXT2_FS_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;linux/ext2_fs.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_EXT2FS_EXT2_FS_H</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ext2fs/ext2_fs.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;locale.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SIGNAL_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>








<expr_stmt><expr><call><name>__FBSDID</name><argument_list>(<argument><expr><literal type="string">"$FreeBSD$"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>KNOWNREF</name></cpp:macro> <cpp:value>"test_compat_gtar_1.tar.uu"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENVBASE</name></cpp:macro> <cpp:value>"LIBARCHIVE"</cpp:value></cpp:define>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PROGRAM</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LIBRARY</name></cpp:macro> <cpp:value>"libarchive"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXTRA_DUMP</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>archive_error_string((struct archive *)(x))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXTRA_ERRNO</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>archive_errno((struct archive *)(x))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXTRA_VERSION</name></cpp:macro> <cpp:value>archive_version_details()</cpp:value></cpp:define>




















<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;io.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;direct.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>F_OK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>F_OK</name></cpp:macro> <cpp:value>(0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>S_ISDIR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_ISDIR</name><parameter_list>(<parameter><type><name>m</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((m) &amp; _S_IFDIR)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>S_ISREG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_ISREG</name><parameter_list>(<parameter><type><name>m</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((m) &amp; _S_IFREG)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__BORLANDC__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>access</name></cpp:macro> <cpp:value>_access</cpp:value></cpp:define>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>chdir</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>chdir</name></cpp:macro> <cpp:value>_chdir</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>fileno</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fileno</name></cpp:macro> <cpp:value>_fileno</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__BORLANDC__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>getcwd</name></cpp:macro> <cpp:value>_getcwd</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lstat</name></cpp:macro> <cpp:value>stat</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rmdir</name></cpp:macro> <cpp:value>_rmdir</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__BORLANDC__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>strdup</name></cpp:macro> <cpp:value>_strdup</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>umask</name></cpp:macro> <cpp:value>_umask</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>int64_t</name></cpp:macro> <cpp:value>__int64</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE__CrtSetReportMode</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;crtdbg.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>mode_t</name></type> <name>umasked</name><parameter_list>(<parameter><decl><type><name>mode_t</name></type> <name>expected_mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>mode_t</name></type> <name>mode</name> <init>= <expr><call><name>umask</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>umask</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>expected_mode</name> <operator>&amp;</operator> <operator>~</operator><name>mode</name></expr>;</return>
</block_content>}</block></function>


<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>testworkdir</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PROGRAM</name></expr></argument>)</argument_list></call></expr></cpp:if>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>testprogfile</name></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>testprog</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>GetFunctionKernel32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>my_CreateSymbolicLinkA</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>my_CreateHardLinkA</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>my_GetFileInformationByName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>,
<parameter><decl><type><name>BY_HANDLE_FILE_INFORMATION</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>GetFunctionKernel32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>HINSTANCE</name></type> <name>lib</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>set</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>set</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>set</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>lib</name> <operator>=</operator> <call><name>LoadLibrary</name><argument_list>(<argument><expr><literal type="string">"kernel32.dll"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>lib</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Can't load kernel32.dll?!\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><call><name>GetProcAddress</name><argument_list>(<argument><expr><name>lib</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>my_CreateSymbolicLinkA</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>linkname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<function_decl><type><specifier>static</specifier> <name>BOOLEAN</name></type> (<name>WINAPI</name> <modifier>*</modifier><name>f</name>)<parameter_list>(<parameter><decl><type><name>LPCSTR</name></type></decl></parameter>, <parameter><decl><type><name>LPCSTR</name></type></decl></parameter>, <parameter><decl><type><name>DWORD</name></type></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>set</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>set</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>set</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>GetFunctionKernel32</name><argument_list>(<argument><expr><literal type="string">"CreateSymbolicLinkA"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><ternary><condition><expr><name>f</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call>(<modifier>*</modifier><name>f</name>)<argument_list>(<argument><expr><name>linkname</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>my_CreateHardLinkA</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>linkname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<function_decl><type><specifier>static</specifier> <name>BOOLEAN</name></type> (<name>WINAPI</name> <modifier>*</modifier><name>f</name>)<parameter_list>(<parameter><decl><type><name>LPCSTR</name></type></decl></parameter>, <parameter><decl><type><name>LPCSTR</name></type></decl></parameter>, <parameter><decl><type><name>LPSECURITY_ATTRIBUTES</name></type></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>set</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>set</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>set</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>GetFunctionKernel32</name><argument_list>(<argument><expr><literal type="string">"CreateHardLinkA"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><ternary><condition><expr><name>f</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call>(<modifier>*</modifier><name>f</name>)<argument_list>(<argument><expr><name>linkname</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>my_GetFileInformationByName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>BY_HANDLE_FILE_INFORMATION</name> <modifier>*</modifier></type><name>bhfi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>HANDLE</name></type> <name>h</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>bhfi</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>bhfi</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>CreateFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>FILE_READ_ATTRIBUTES</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>OPEN_EXISTING</name></expr></argument>, <argument><expr><name>FILE_FLAG_BACKUP_SEMANTICS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>h</name> <operator>==</operator> <name>INVALID_HANDLE_VALUE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>GetFileInformationByHandle</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>bhfi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>r</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE__CrtSetReportMode</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__WATCOMC__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>invalid_parameter_handler</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>wchar_t</name> <modifier>*</modifier></type> <name>expression</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>wchar_t</name> <modifier>*</modifier></type> <name>function</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>wchar_t</name> <modifier>*</modifier></type> <name>file</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><name>uintptr_t</name></type> <name>pReserved</name></decl></parameter>)</parameter_list>
<block>{<block_content>


<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>expression</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>function</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>file</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>line</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>pReserved</name></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>








<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>dump_on_failure</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>keep_temp_files</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>until_failure</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>verbosity</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VERBOSITY_SUMMARY_ONLY</name></cpp:macro> <cpp:value>-1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VERBOSITY_PASSFAIL</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VERBOSITY_LIGHT_REPORT</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VERBOSITY_FULL</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>



<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>failures</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>skips</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>assertions</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refdir</name></decl>;</decl_stmt>




<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>log_console</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>FILE</name> <modifier>*</modifier></type><name>logfile</name></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>vlogprintf</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>ap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>va_copy</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>va_list</name></type> <name>lfap</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>va_copy</name><argument_list>(<argument><expr><name>lfap</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><name>log_console</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>vfprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>logfile</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>va_copy</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>vfprintf</name><argument_list>(<argument><expr><name>logfile</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>lfap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>lfap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>vfprintf</name><argument_list>(<argument><expr><name>logfile</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>logprintf</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vlogprintf</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>msgbuff</name><index>[<expr><literal type="number">4096</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>nextmsg</name></decl>;</decl_stmt>
<function><type><name>void</name></type>
<name>failure</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>fmt</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>nextmsg</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vsprintf</name><argument_list>(<argument><expr><name>msgbuff</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nextmsg</name> <operator>=</operator> <name>msgbuff</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>












<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>skipping_filename</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>skipping_line</name></decl>;</decl_stmt>
<function><type><name>void</name></type> <name>skipping_setup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>skipping_filename</name> <operator>=</operator> <name>filename</name></expr>;</expr_stmt>
<expr_stmt><expr><name>skipping_line</name> <operator>=</operator> <name>line</name></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>assertion_count</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>file</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>line</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>assertions</name></expr>;</expr_stmt>

<expr_stmt><expr><name>msg</name> <operator>=</operator> <name>nextmsg</name></expr>;</expr_stmt>
<expr_stmt><expr><name>nextmsg</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>



</block_content>}</block></function>






<struct><specifier>static</specifier> struct <name>line</name> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>skip</name></decl>;</decl_stmt>
}</block> <decl><name><name>failed_lines</name><index>[<expr><literal type="number">10000</literal></expr>]</index></name></decl>;</struct>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>failed_filename</name></decl>;</decl_stmt>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>failure_start</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>


<expr_stmt><expr><operator>++</operator><name>failures</name></expr>;</expr_stmt>
<expr_stmt><expr><name>failed_filename</name> <operator>=</operator> <name>filename</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>failed_lines</name><index>[<expr><name>line</name></expr>]</index></name><operator>.</operator><name>count</name><operator>++</operator></expr>;</expr_stmt>


<switch>switch <condition>(<expr><name>verbosity</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>VERBOSITY_LIGHT_REPORT</name></expr>:</case>
<expr_stmt><expr><name>log_console</name> <operator>=</operator> <operator>(</operator><name><name>failed_lines</name><index>[<expr><name>line</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>&lt;</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><name>log_console</name> <operator>=</operator> <operator>(</operator><name>verbosity</name> <operator>&gt;=</operator> <name>VERBOSITY_FULL</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></switch>


<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>_MSC_VER</name></expr></cpp:if>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">"%s(%d): "</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">"%s:%d: "</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>vlogprintf</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>msg</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>msg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">" Description: %s\n"</literal></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>msg</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>verbosity</name> <operator>==</operator> <name>VERBOSITY_LIGHT_REPORT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>log_console</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>void</name></type>
<name>failure_finish</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>extra</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EXTRA_DUMP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>extra</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">" errno: %d\n"</literal></expr></argument>, <argument><expr><call><name>EXTRA_ERRNO</name><argument_list>(<argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">" detail: %s\n"</literal></expr></argument>, <argument><expr><call><name>EXTRA_DUMP</name><argument_list>(<argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>dump_on_failure</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">" *** forcing core dump so failure can be debugged ***\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>test_skipping</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buff</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vsprintf</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>msg</name> <operator>=</operator> <name>nextmsg</name></expr>;</expr_stmt>
<expr_stmt><expr><name>nextmsg</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>skipping_filename</name></expr></argument>, <argument><expr><name>skipping_line</name></expr></argument>, <argument><expr><literal type="string">"SKIPPING: %s"</literal></expr></argument>, <argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>--</operator><name>failures</name></expr>;</expr_stmt>


<expr_stmt><expr><name><name>failed_lines</name><index>[<expr><name>skipping_line</name></expr>]</index></name><operator>.</operator><name>skip</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>skips</name></expr>;</expr_stmt>
</block_content>}</block></function>








<function><type><name>int</name></type>
<name>assertion_assert</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>value</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>condition</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>assertion_count</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>value</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"Assertion failed: %s"</literal></expr></argument>, <argument><expr><name>condition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name>value</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type>
<name>assertion_chdir</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pathname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>assertion_count</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>chdir</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"chdir(\"%s\")"</literal></expr></argument>, <argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>

</block_content>}</block></function>


<function><type><name>int</name></type>
<name>assertion_equal_int</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>,
<parameter><decl><type><name>long</name> <name>long</name></type> <name>v1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>e1</name></decl></parameter>, <parameter><decl><type><name>long</name> <name>long</name></type> <name>v2</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>e2</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>assertion_count</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>v1</name> <operator>==</operator> <name>v2</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"%s != %s"</literal></expr></argument>, <argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">" %s=%lld (0x%llx, 0%llo)\n"</literal></expr></argument>, <argument><expr><name>e1</name></expr></argument>, <argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">" %s=%lld (0x%llx, 0%llo)\n"</literal></expr></argument>, <argument><expr><name>e2</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>int</name></type>
<name>_utf8_to_unicode</name><parameter_list>(<parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>pwc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>utf8_count</name><index>[<expr><literal type="number">256</literal></expr>]</index></name> <init>= <expr><block>{
<expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,
<expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,
<expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,
<expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,
<expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,
<expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,
<expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,
<expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,
<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>,
<expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>,
<expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>,
<expr><literal type="number">4</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ch</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cnt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>wc</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>pwc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>



<expr_stmt><expr><name>ch</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>*</operator><name>s</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>cnt</name> <operator>=</operator> <name><name>utf8_count</name><index>[<expr><name>ch</name></expr>]</index></name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>cnt</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>


<switch>switch <condition>(<expr><name>cnt</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">1</literal></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>pwc</name> <operator>=</operator> <name>ch</name> <operator>&amp;</operator> <literal type="number">0x7f</literal></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>cnt</name><operator>)</operator></expr>;</return>
<case>case <expr><literal type="number">2</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xc0</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0x80</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>pwc</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>ch</name> <operator>&amp;</operator> <literal type="number">0x1f</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">6</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>cnt</name><operator>)</operator></expr>;</return>
<case>case <expr><literal type="number">3</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xc0</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0x80</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>s</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xc0</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0x80</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>wc</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>ch</name> <operator>&amp;</operator> <literal type="number">0x0f</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">12</literal><operator>)</operator>
<operator>|</operator> <operator>(</operator><operator>(</operator><name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">6</literal><operator>)</operator>
<operator>|</operator> <operator>(</operator><name><name>s</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>wc</name> <operator>&lt;</operator> <literal type="number">0x800</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><literal type="number">4</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xc0</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0x80</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>s</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xc0</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0x80</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>s</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xc0</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0x80</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>wc</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>ch</name> <operator>&amp;</operator> <literal type="number">0x07</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">18</literal><operator>)</operator>
<operator>|</operator> <operator>(</operator><operator>(</operator><name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">12</literal><operator>)</operator>
<operator>|</operator> <operator>(</operator><operator>(</operator><name><name>s</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">6</literal><operator>)</operator>
<operator>|</operator> <operator>(</operator><name><name>s</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>wc</name> <operator>&lt;</operator> <literal type="number">0x10000</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<break>break;</break>
<default>default:</default>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></switch>



<if_stmt><if>if <condition>(<expr><name>wc</name> <operator>&gt;</operator> <literal type="number">0x10FFFF</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>pwc</name> <operator>=</operator> <name>wc</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>cnt</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>strdump</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ewidth</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>utf8</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>q</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">" %*s = "</literal></expr></argument>, <argument><expr><name>ewidth</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">"NULL\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">"\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>c</name> <init>= <expr><literal type="number">0xff</literal> <operator>&amp;</operator> <operator>*</operator><name>p</name><operator>++</operator></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'\a'</literal></expr>:</case> <expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">"\\a"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'\b'</literal></expr>:</case> <expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">"\\b"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'\n'</literal></expr>:</case> <expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">"\\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'\r'</literal></expr>:</case> <expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">"\\r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<default>default:</default>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <literal type="number">32</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;</operator> <literal type="number">127</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">"%c"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">"\\x%02X"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></switch>
</block_content>}</block></while>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">"\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">" (length %d)"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>q</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<if_stmt><if>if <condition>(<expr><name>utf8</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>uc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>q</name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">" ["</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>(</operator><name>n</name> <operator>=</operator> <call><name>_utf8_to_unicode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>uc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>q</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">"%04X"</literal></expr></argument>, <argument><expr><name>uc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>-=</operator> <name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><name>cnt</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">"]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">" (count %d"</literal></expr></argument>, <argument><expr><name>cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">",unknown %d bytes"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>int</name></type>
<name>assertion_equal_string</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>v1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>e1</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>v2</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>e2</name></decl></parameter>,
<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>utf8</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>l1</name></decl>, <decl><type ref="prev"/><name>l2</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assertion_count</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>v1</name> <operator>==</operator> <name>v2</name> <operator>||</operator> <operator>(</operator><name>v1</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>v2</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"%s != %s"</literal></expr></argument>, <argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>l1</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>l2</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>l1</name> <operator>&lt;</operator> <name>l2</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>l1</name> <operator>=</operator> <name>l2</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>strdump</name><argument_list>(<argument><expr><name>e1</name></expr></argument>, <argument><expr><name>v1</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>, <argument><expr><name>utf8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strdump</name><argument_list>(<argument><expr><name>e2</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><name>l1</name></expr></argument>, <argument><expr><name>utf8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>wcsdump</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>wchar_t</name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">" %s = "</literal></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>w</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">"(null)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">"\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>w</name> <operator>!=</operator> <name>L</name><literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>c</name> <init>= <expr><operator>*</operator><name>w</name><operator>++</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <literal type="number">32</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;</operator> <literal type="number">127</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">"%c"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>c</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">"\\x%02X"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>c</name> <operator>&lt;</operator> <literal type="number">0x10000</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">"\\u%04X"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">"\\U%08X"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">"\"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WCSCMP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>wcscmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>wchar_t</name> <modifier>*</modifier></type><name>s1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>wchar_t</name> <modifier>*</modifier></type><name>s2</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<while>while <condition>(<expr><operator>*</operator><name>s1</name> <operator>==</operator> <operator>*</operator><name>s2</name><operator>++</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s1</name><operator>++</operator> <operator>==</operator> <name>L</name><literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s1</name> <operator>&gt;</operator> <operator>*</operator><operator>--</operator><name>s2</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<function><type><name>int</name></type>
<name>assertion_equal_wstring</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>wchar_t</name> <modifier>*</modifier></type><name>v1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>e1</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>wchar_t</name> <modifier>*</modifier></type><name>v2</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>e2</name></decl></parameter>,
<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>assertion_count</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>v1</name> <operator>==</operator> <name>v2</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>v1</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>v2</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>wcscmp</name><argument_list>(<argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"%s != %s"</literal></expr></argument>, <argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>wcsdump</name><argument_list>(<argument><expr><name>e1</name></expr></argument>, <argument><expr><name>v1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>wcsdump</name><argument_list>(<argument><expr><name>e2</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>void</name></type>
<name>hexdump</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ref</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>l</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>sep</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">"(null)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>l</name></expr>;</condition> <incr><expr><name>i</name><operator>+=</operator><literal type="number">16</literal></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">"%04x"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name>i</name> <operator>+</operator> <name>offset</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">16</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>+</operator> <name>j</name> <operator>&lt;</operator> <name>l</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>ref</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><name>i</name> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>!=</operator> <name><name>ref</name><index>[<expr><name>i</name> <operator>+</operator> <name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="char">'_'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">"%c%02x"</literal></expr></argument>, <argument><expr><name>sep</name></expr></argument>, <argument><expr><literal type="number">0xff</literal> <operator>&amp;</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>p</name><index>[<expr><name>i</name><operator>+</operator><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ref</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><name>i</name> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>==</operator> <name><name>ref</name><index>[<expr><name>i</name> <operator>+</operator> <name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<for>for <control>(<init>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">16</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">"%c "</literal></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">"%c"</literal></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">16</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>+</operator> <name>j</name> <operator>&lt;</operator> <name>l</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><name><name>p</name><index>[<expr><name>i</name> <operator>+</operator> <name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <literal type="char">' '</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="number">126</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">"%c"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>



<function><type><name>int</name></type>
<name>assertion_equal_mem</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_v1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>e1</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_v2</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>e2</name></decl></parameter>,
<parameter><decl><type><name>size_t</name></type> <name>l</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ld</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>v1</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>_v1</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>v2</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>_v2</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>offset</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assertion_count</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>v1</name> <operator>==</operator> <name>v2</name> <operator>||</operator> <operator>(</operator><name>v1</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>v2</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>v1</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>v2</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"%s != %s"</literal></expr></argument>, <argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">" size %s = %d\n"</literal></expr></argument>, <argument><expr><name>ld</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name>l</name> <operator>&gt;</operator> <literal type="number">64</literal> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>v1</name> <operator>+=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>v2</name> <operator>+=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>l</name> <operator>-=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name> <operator>+=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">" Dump of %s\n"</literal></expr></argument>, <argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hexdump</name><argument_list>(<argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><ternary><condition><expr><name>l</name> <operator>&lt;</operator> <literal type="number">128</literal></expr> ?</condition><then> <expr><name>l</name></expr> </then><else>: <expr><literal type="number">128</literal></expr></else></ternary></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">" Dump of %s\n"</literal></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hexdump</name><argument_list>(<argument><expr><name>v2</name></expr></argument>, <argument><expr><name>v1</name></expr></argument>, <argument><expr><ternary><condition><expr><name>l</name> <operator>&lt;</operator> <literal type="number">128</literal></expr> ?</condition><then> <expr><name>l</name></expr> </then><else>: <expr><literal type="number">128</literal></expr></else></ternary></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type>
<name>assertion_memory_filled_with</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_v1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>vd</name></decl></parameter>,
<parameter><decl><type><name>size_t</name></type> <name>l</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ld</name></decl></parameter>,
<parameter><decl><type><name>char</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>bd</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>v1</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>_v1</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>c</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>ld</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assertion_count</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>l</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>v1</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>b</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>c</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>l</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"%s (size %d) not filled with %s"</literal></expr></argument>, <argument><expr><name>vd</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>l</name></expr></argument>, <argument><expr><name>bd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">" Only %d bytes were correct\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type>
<name>assertion_empty_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>f1</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buff</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assertion_count</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>f1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"Stat failed: %s"</literal></expr></argument>, <argument><expr><name>f1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>.</operator><name>st_size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"File should be empty: %s"</literal></expr></argument>, <argument><expr><name>f1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">" File size: %d\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>st</name><operator>.</operator><name>st_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">" Contents:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>f1</name></expr></argument>, <argument><expr><literal type="string">"rb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>f</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">" Unable to open %s\n"</literal></expr></argument>, <argument><expr><name>f1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>(</operator><name>off_t</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></sizeof> <operator>&lt;</operator> <name><name>st</name><operator>.</operator><name>st_size</name></name><operator>)</operator></expr> ?</condition><then>
<expr><operator>(</operator><name>ssize_t</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></sizeof></expr> </then><else>: <expr><operator>(</operator><name>ssize_t</name><operator>)</operator><name><name>st</name><operator>.</operator><name>st_size</name></name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>fread</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hexdump</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type>
<name>assertion_non_empty_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>f1</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assertion_count</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>f1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"Stat failed: %s"</literal></expr></argument>, <argument><expr><name>f1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>st</name><operator>.</operator><name>st_size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"File empty: %s"</literal></expr></argument>, <argument><expr><name>f1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>



<function><type><name>int</name></type>
<name>assertion_equal_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fn1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fn2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buff1</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buff2</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>f2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n1</name></decl>, <decl><type ref="prev"/><name>n2</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assertion_count</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>f1</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>fn1</name></expr></argument>, <argument><expr><literal type="string">"rb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>f2</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>fn2</name></expr></argument>, <argument><expr><literal type="string">"rb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>f1</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>f2</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>f1</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>f2</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<expr_stmt><expr><name>n1</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>fread</name><argument_list>(<argument><expr><name>buff1</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buff1</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>f1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n2</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>fread</name><argument_list>(<argument><expr><name>buff2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buff2</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>f2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n1</name> <operator>!=</operator> <name>n2</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>n1</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>n2</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>buff1</name></expr></argument>, <argument><expr><name>buff2</name></expr></argument>, <argument><expr><name>n1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"Files not identical"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">" file1=\"%s\"\n"</literal></expr></argument>, <argument><expr><name>fn1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">" file2=\"%s\"\n"</literal></expr></argument>, <argument><expr><name>fn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type>
<name>assertion_file_exists</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>assertion_count</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>_access</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>access</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>F_OK</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"File should exist: %s"</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type>
<name>assertion_file_not_exists</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>assertion_count</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>_access</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if_stmt><if>if <condition>(<expr><call><name>access</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>F_OK</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"File should not exist: %s"</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type>
<name>assertion_file_contents</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>buff</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>contents</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assertion_count</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>fn</name></expr></argument>, <argument><expr><literal type="string">"rb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>f</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>line</name></expr></argument>,
<argument><expr><literal type="string">"File should exist: %s"</literal></expr></argument>, <argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>contents</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>s</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>fread</name><argument_list>(<argument><expr><name>contents</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>s</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <name>s</name> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name>contents</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>contents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"File contents don't match"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">" file=\"%s\"\n"</literal></expr></argument>, <argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>hexdump</name><argument_list>(<argument><expr><name>contents</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><ternary><condition><expr><name>n</name> <operator>&gt;</operator> <literal type="number">512</literal></expr> ?</condition><then> <expr><literal type="number">512</literal></expr> </then><else>: <expr><name>n</name></expr></else></ternary></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">" File empty, contents should be:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hexdump</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><ternary><condition><expr><name>s</name> <operator>&gt;</operator> <literal type="number">512</literal></expr> ?</condition><then> <expr><literal type="number">512</literal></expr> </then><else>: <expr><name>s</name></expr></else></ternary></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>contents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type>
<name>assertion_text_file_contents</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buff</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>contents</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>btxt</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ftxt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>s</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assertion_count</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>fn</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>f</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>line</name></expr></argument>,
<argument><expr><literal type="string">"File doesn't exist: %s"</literal></expr></argument>, <argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>contents</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>s</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">128</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>fread</name><argument_list>(<argument><expr><name>contents</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>s</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">128</literal> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>contents</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>btxt</name> <operator>=</operator> <name>buff</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ftxt</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>contents</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>btxt</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>ftxt</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>btxt</name> <operator>==</operator> <operator>*</operator><name>ftxt</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>btxt</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>ftxt</name></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>btxt</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>&amp;&amp;</operator> <name><name>ftxt</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\r'</literal> <operator>&amp;&amp;</operator> <name><name>ftxt</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>++</operator><name>btxt</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ftxt</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>btxt</name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>ftxt</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>contents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"Contents don't match"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">" file=\"%s\"\n"</literal></expr></argument>, <argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>hexdump</name><argument_list>(<argument><expr><name>contents</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">" expected\n"</literal></expr></argument>, <argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hexdump</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name>contents</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">" File empty, contents should be:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hexdump</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>contents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>





<function><type><name>int</name></type>
<name>assertion_file_contains_lines_any_order</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pathname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>lines</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buff</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>buff_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>expected_count</name></decl>, <decl><type ref="prev"/><name>actual_count</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>expected</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>actual</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>expected_failure</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>actual_failure</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assertion_count</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>buff</name> <operator>=</operator> <call><name>slurpfile</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buff_size</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>buff</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"Can't read file: %s"</literal></expr></argument>, <argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>



<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
</block_content>}</block></for>
<expr_stmt><expr><name>expected_count</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>expected_count</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>expected</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>expected_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>expected</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"Can't allocate memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>expected</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name><name>lines</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>actual_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>c</name> <operator>=</operator> <literal type="char">'\0'</literal></expr><operator>,</operator> <expr><name>p</name> <operator>=</operator> <name>buff</name></expr>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>buff</name> <operator>+</operator> <name>buff_size</name></expr>;</condition> <incr><expr><operator>++</operator><name>p</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\x0d'</literal> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\x0a'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>actual_count</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>actual_count</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>actual</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>actual_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>actual</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"Can't allocate memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>p</name> <operator>=</operator> <name>buff</name></expr>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>buff</name> <operator>+</operator> <name>buff_size</name></expr>;</condition>
<incr><expr><name>p</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>actual</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>j</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>expected_count</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>expected</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>actual_count</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>actual</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>expected</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>actual</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>expected</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>expected</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>actual</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>expected_count</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>expected</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>expected_failure</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>actual_count</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>actual</name><index>[<expr><name>j</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>actual_failure</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>expected_failure</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>actual_failure</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>actual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"File doesn't match: %s"</literal></expr></argument>, <argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>expected_count</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>expected</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">" Expected but not present: %s\n"</literal></expr></argument>, <argument><expr><name><name>expected</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>expected</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>actual_count</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>actual</name><index>[<expr><name>j</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">" Present but not expected: %s\n"</literal></expr></argument>, <argument><expr><name><name>actual</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>actual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type>
<name>assertion_file_contains_no_invalid_strings</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pathname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>strings</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buff</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>buff</name> <operator>=</operator> <call><name>slurpfile</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>buff</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"Can't read file: %s"</literal></expr></argument>, <argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>strings</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name><name>strings</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"Invalid string in %s: %s"</literal></expr></argument>, <argument><expr><name>pathname</name></expr></argument>,
<argument><expr><name><name>strings</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return<expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>int</name></type>
<name>is_hardlink</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>BY_HANDLE_FILE_INFORMATION</name></type> <name>bhfi1</name></decl>, <decl><type ref="prev"/><name>bhfi2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assertion_count</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>my_GetFileInformationByName</name><argument_list>(<argument><expr><name>path1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bhfi1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"File %s can't be inspected?"</literal></expr></argument>, <argument><expr><name>path1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>my_GetFileInformationByName</name><argument_list>(<argument><expr><name>path2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bhfi2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"File %s can't be inspected?"</literal></expr></argument>, <argument><expr><name>path2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name><name>bhfi1</name><operator>.</operator><name>dwVolumeSerialNumber</name></name> <operator>==</operator> <name><name>bhfi2</name><operator>.</operator><name>dwVolumeSerialNumber</name></name>
<operator>&amp;&amp;</operator> <name><name>bhfi1</name><operator>.</operator><name>nFileIndexHigh</name></name> <operator>==</operator> <name><name>bhfi2</name><operator>.</operator><name>nFileIndexHigh</name></name>
<operator>&amp;&amp;</operator> <name><name>bhfi1</name><operator>.</operator><name>nFileIndexLow</name></name> <operator>==</operator> <name><name>bhfi2</name><operator>.</operator><name>nFileIndexLow</name></name><operator>)</operator></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st1</name></decl>, <decl><type ref="prev"/><name>st2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assertion_count</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>lstat</name><argument_list>(<argument><expr><name>path1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"File should exist: %s"</literal></expr></argument>, <argument><expr><name>path1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>lstat</name><argument_list>(<argument><expr><name>path2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"File should exist: %s"</literal></expr></argument>, <argument><expr><name>path2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name><name>st1</name><operator>.</operator><name>st_ino</name></name> <operator>==</operator> <name><name>st2</name><operator>.</operator><name>st_ino</name></name> <operator>&amp;&amp;</operator> <name><name>st1</name><operator>.</operator><name>st_dev</name></name> <operator>==</operator> <name><name>st2</name><operator>.</operator><name>st_dev</name></name><operator>)</operator></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>assertion_is_hardlink</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>is_hardlink</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>path1</name></expr></argument>, <argument><expr><name>path2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>,
<argument><expr><literal type="string">"Files %s and %s are not hardlinked"</literal></expr></argument>, <argument><expr><name>path1</name></expr></argument>, <argument><expr><name>path2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>assertion_is_not_hardlink</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_hardlink</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>path1</name></expr></argument>, <argument><expr><name>path2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>,
<argument><expr><literal type="string">"Files %s and %s should not be hardlinked"</literal></expr></argument>, <argument><expr><name>path1</name></expr></argument>, <argument><expr><name>path2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>int</name></type>
<name>assertion_file_time</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pathname</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>t</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>nsec</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>recent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>filet</name></decl>, <decl><type ref="prev"/><name>filet_nsec</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EPOC_TIME</name></cpp:macro> <cpp:value>(116444736000000000ULL)</cpp:value></cpp:define>
<decl_stmt><decl><type><name>FILETIME</name></type> <name>fxtime</name></decl>, <decl><type ref="prev"/><name>fbirthtime</name></decl>, <decl><type ref="prev"/><name>fatime</name></decl>, <decl><type ref="prev"/><name>fmtime</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULARGE_INTEGER</name></type> <name>wintm</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HANDLE</name></type> <name>h</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>fxtime</name><operator>.</operator><name>dwLowDateTime</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fxtime</name><operator>.</operator><name>dwHighDateTime</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assertion_count</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>CreateFile</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>FILE_READ_ATTRIBUTES</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>OPEN_EXISTING</name></expr></argument>, <argument><expr><name>FILE_FLAG_BACKUP_SEMANTICS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>h</name> <operator>==</operator> <name>INVALID_HANDLE_VALUE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"Can't access %s\n"</literal></expr></argument>, <argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>GetFileTime</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fbirthtime</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fatime</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fmtime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'a'</literal></expr>:</case> <expr_stmt><expr><name>fxtime</name> <operator>=</operator> <name>fatime</name></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'b'</literal></expr>:</case> <expr_stmt><expr><name>fxtime</name> <operator>=</operator> <name>fbirthtime</name></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'m'</literal></expr>:</case> <expr_stmt><expr><name>fxtime</name> <operator>=</operator> <name>fmtime</name></expr>;</expr_stmt> <break>break;</break>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"Can't GetFileTime %s\n"</literal></expr></argument>, <argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>wintm</name><operator>.</operator><name>LowPart</name></name> <operator>=</operator> <name><name>fxtime</name><operator>.</operator><name>dwLowDateTime</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>wintm</name><operator>.</operator><name>HighPart</name></name> <operator>=</operator> <name><name>fxtime</name><operator>.</operator><name>dwHighDateTime</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>filet</name> <operator>=</operator> <operator>(</operator><name><name>wintm</name><operator>.</operator><name>QuadPart</name></name> <operator>-</operator> <name>EPOC_TIME</name><operator>)</operator> <operator>/</operator> <literal type="number">10000000</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>filet_nsec</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>wintm</name><operator>.</operator><name>QuadPart</name></name> <operator>-</operator> <name>EPOC_TIME</name><operator>)</operator> <operator>%</operator> <literal type="number">10000000</literal><operator>)</operator> <operator>*</operator> <literal type="number">100</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>nsec</name> <operator>=</operator> <operator>(</operator><name>nsec</name> <operator>/</operator> <literal type="number">100</literal><operator>)</operator> <operator>*</operator> <literal type="number">100</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assertion_count</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>lstat</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"Can't stat %s\n"</literal></expr></argument>, <argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'a'</literal></expr>:</case> <expr_stmt><expr><name>filet</name> <operator>=</operator> <name><name>st</name><operator>.</operator><name>st_atime</name></name></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'m'</literal></expr>:</case> <expr_stmt><expr><name>filet</name> <operator>=</operator> <name><name>st</name><operator>.</operator><name>st_mtime</name></name></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'b'</literal></expr>:</case> <expr_stmt><expr><name>filet</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <break>break;</break>
<default>default:</default> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"INTERNAL: Bad type %c for file time"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__FreeBSD__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'a'</literal></expr>:</case> <expr_stmt><expr><name>filet_nsec</name> <operator>=</operator> <name><name>st</name><operator>.</operator><name>st_atimespec</name><operator>.</operator><name>tv_nsec</name></name></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'b'</literal></expr>:</case> <expr_stmt><expr><name>filet</name> <operator>=</operator> <name><name>st</name><operator>.</operator><name>st_birthtime</name></name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>filet</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>filet_nsec</name> <operator>=</operator> <name><name>st</name><operator>.</operator><name>st_birthtimespec</name><operator>.</operator><name>tv_nsec</name></name></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'m'</literal></expr>:</case> <expr_stmt><expr><name>filet_nsec</name> <operator>=</operator> <name><name>st</name><operator>.</operator><name>st_mtimespec</name><operator>.</operator><name>tv_nsec</name></name></expr>;</expr_stmt> <break>break;</break>
<default>default:</default> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"INTERNAL: Bad type %c for file time"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>

<expr_stmt><expr><name>filet_nsec</name> <operator>=</operator> <operator>(</operator><name>filet_nsec</name> <operator>/</operator> <literal type="number">1000</literal><operator>)</operator> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>nsec</name> <operator>=</operator> <operator>(</operator><name>nsec</name> <operator>/</operator> <literal type="number">1000</literal><operator>)</operator> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>filet_nsec</name> <operator>=</operator> <name>nsec</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <literal type="char">'b'</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__HAIKU__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <literal type="char">'a'</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><name>recent</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>time_t</name></type> <name>now</name> <init>= <expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>filet</name> <argument_list type="generic">&lt; <argument><expr><name>now</name> <operator>-</operator> <literal type="number">10</literal> <operator>||</operator> <name>filet</name></expr></argument> &gt;</argument_list></name> <name>now</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>,
<argument><expr><literal type="string">"File %s has %ctime %lld, %lld seconds ago\n"</literal></expr></argument>,
<argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>filet</name></expr></argument>, <argument><expr><name>now</name> <operator>-</operator> <name>filet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>filet</name> <operator>!=</operator> <name>t</name> <operator>||</operator> <name>filet_nsec</name> <operator>!=</operator> <name>nsec</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>,
<argument><expr><literal type="string">"File %s has %ctime %lld.%09lld, expected %lld.%09lld"</literal></expr></argument>,
<argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>filet</name></expr></argument>, <argument><expr><name>filet_nsec</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>nsec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type>
<name>assertion_file_atime</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pathname</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>t</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>nsec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>assertion_file_time</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>nsec</name></expr></argument>, <argument><expr><literal type="char">'a'</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type>
<name>assertion_file_atime_recent</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pathname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>assertion_file_time</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="char">'a'</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type>
<name>assertion_file_birthtime</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pathname</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>t</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>nsec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>assertion_file_time</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>nsec</name></expr></argument>, <argument><expr><literal type="char">'b'</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type>
<name>assertion_file_birthtime_recent</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pathname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>assertion_file_time</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="char">'b'</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type>
<name>assertion_file_mode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pathname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>expected_mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>mode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assertion_count</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"assertFileMode not yet implemented for Windows"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>mode</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>r</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>pathname</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>expected_mode</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>lstat</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>mode</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>st</name><operator>.</operator><name>st_mode</name></name> <operator>&amp;</operator> <literal type="number">0777</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>mode</name> <operator>==</operator> <name>expected_mode</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"File %s has mode %o, expected %o"</literal></expr></argument>,
<argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>expected_mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type>
<name>assertion_file_mtime</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pathname</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>t</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>nsec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>assertion_file_time</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>nsec</name></expr></argument>, <argument><expr><literal type="char">'m'</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type>
<name>assertion_file_mtime_recent</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pathname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>assertion_file_time</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="char">'m'</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type>
<name>assertion_file_nlinks</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pathname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nlinks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>BY_HANDLE_FILE_INFORMATION</name></type> <name>bhfi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assertion_count</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>my_GetFileInformationByName</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bhfi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>bhfi</name><operator>.</operator><name>nNumberOfLinks</name></name> <operator>==</operator> <operator>(</operator><name>DWORD</name><operator>)</operator><name>nlinks</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"File %s has %d links, expected %d"</literal></expr></argument>,
<argument><expr><name>pathname</name></expr></argument>, <argument><expr><name><name>bhfi</name><operator>.</operator><name>nNumberOfLinks</name></name></expr></argument>, <argument><expr><name>nlinks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assertion_count</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>lstat</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>st</name><operator>.</operator><name>st_nlink</name></name> <operator>==</operator> <name>nlinks</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"File %s has %d links, expected %d"</literal></expr></argument>,
<argument><expr><name>pathname</name></expr></argument>, <argument><expr><name><name>st</name><operator>.</operator><name>st_nlink</name></name></expr></argument>, <argument><expr><name>nlinks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<function><type><name>int</name></type>
<name>assertion_file_size</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pathname</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name></type> <name>filesize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assertion_count</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<block>{<block_content>
<decl_stmt><decl><type><name>BY_HANDLE_FILE_INFORMATION</name></type> <name>bhfi</name></decl>;</decl_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <operator>!</operator><call><name>my_GetFileInformationByName</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bhfi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>filesize</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>int64_t</name><operator>)</operator><name><name>bhfi</name><operator>.</operator><name>nFileSizeHigh</name></name> <operator>&lt;&lt;</operator> <literal type="number">32</literal><operator>)</operator> <operator>+</operator> <name><name>bhfi</name><operator>.</operator><name>nFileSizeLow</name></name></expr>;</expr_stmt>
</block_content>}</block>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>lstat</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>filesize</name> <operator>=</operator> <name><name>st</name><operator>.</operator><name>st_size</name></name></expr>;</expr_stmt>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>filesize</name> <operator>==</operator> <name>size</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"File %s has size %ld, expected %ld"</literal></expr></argument>,
<argument><expr><name>pathname</name></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator><name>filesize</name></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type>
<name>assertion_is_dir</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pathname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>mode</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>assertion_count</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>lstat</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"Dir should exist: %s"</literal></expr></argument>, <argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"%s is not a dir"</literal></expr></argument>, <argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>



<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>mode_t</name><operator>)</operator><name>mode</name> <operator>!=</operator> <operator>(</operator><name><name>st</name><operator>.</operator><name>st_mode</name></name> <operator>&amp;</operator> <literal type="number">07777</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"Dir %s has wrong mode"</literal></expr></argument>, <argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">" Expected: 0%3o\n"</literal></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">" Found: 0%3o\n"</literal></expr></argument>, <argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name> <operator>&amp;</operator> <literal type="number">07777</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>



<function><type><name>int</name></type>
<name>assertion_is_reg</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pathname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>mode</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>assertion_count</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>lstat</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><call><name>S_ISREG</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"File should exist: %s"</literal></expr></argument>, <argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>



<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>mode_t</name><operator>)</operator><name>mode</name> <operator>!=</operator> <operator>(</operator><name><name>st</name><operator>.</operator><name>st_mode</name></name> <operator>&amp;</operator> <literal type="number">07777</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"File %s has wrong mode"</literal></expr></argument>, <argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">" Expected: 0%3o\n"</literal></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">" Found: 0%3o\n"</literal></expr></argument>, <argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name> <operator>&amp;</operator> <literal type="number">07777</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>int</name></type>
<name>is_symlink</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pathname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>contents</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>pathname</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>contents</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertion_count</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>char</name></type> <name><name>buff</name><index>[<expr><literal type="number">300</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>linklen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assertion_count</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>lstat</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>,
<argument><expr><literal type="string">"Symlink should exist: %s"</literal></expr></argument>, <argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>S_ISLNK</name><argument_list>(<argument><expr><name><name>st</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>contents</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>linklen</name> <operator>=</operator> <call><name>readlink</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>linklen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"Can't read symlink %s"</literal></expr></argument>, <argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>buff</name><index>[<expr><name>linklen</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name>contents</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<function><type><name>int</name></type>
<name>assertion_is_symlink</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>contents</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>is_symlink</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>contents</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>contents</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"File %s is not a symlink to %s"</literal></expr></argument>,
<argument><expr><name>path</name></expr></argument>, <argument><expr><name>contents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"File %s is not a symlink"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>



<function><type><name>int</name></type>
<name>assertion_make_dir</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dirname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>assertion_count</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>mode</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>_mkdir</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>mkdir</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>chmod</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assertion_file_mode</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"Could not create directory %s"</literal></expr></argument>, <argument><expr><name>dirname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return<expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type>
<name>assertion_make_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>csize</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>contents</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>

<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>mode</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertion_count</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"wb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>f</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"Could not create file %s"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>contents</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>wsize</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>csize</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>wsize</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>contents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>wsize</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>csize</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>wsize</name> <operator>!=</operator> <call><name>fwrite</name><argument_list>(<argument><expr><name>contents</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>wsize</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>,
<argument><expr><literal type="string">"Could not write file %s"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assertion_count</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_CREAT</name> <operator>|</operator> <name>O_WRONLY</name></expr></argument>, <argument><expr><ternary><condition><expr><name>mode</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>mode</name></expr> </then><else>: <expr><literal type="number">0644</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"Could not create %s"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>!=</operator> <call><name>chmod</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"Could not chmod %s"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>contents</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>wsize</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>csize</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>wsize</name> <operator>=</operator> <operator>(</operator><name>ssize_t</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>contents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>wsize</name> <operator>=</operator> <operator>(</operator><name>ssize_t</name><operator>)</operator><name>csize</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>wsize</name> <operator>!=</operator> <call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>contents</name></expr></argument>, <argument><expr><name>wsize</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>,
<argument><expr><literal type="string">"Could not write to %s"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertion_file_mode</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<function><type><name>int</name></type>
<name>assertion_make_hardlink</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newpath</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>linkto</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>succeeded</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assertion_count</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>succeeded</name> <operator>=</operator> <call><name>my_CreateHardLinkA</name><argument_list>(<argument><expr><name>newpath</name></expr></argument>, <argument><expr><name>linkto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>HAVE_LINK</name></expr></cpp:elif>
<expr_stmt><expr><name>succeeded</name> <operator>=</operator> <operator>!</operator><call><name>link</name><argument_list>(<argument><expr><name>linkto</name></expr></argument>, <argument><expr><name>newpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>succeeded</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><name>succeeded</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"Could not create hardlink"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">" New link: %s\n"</literal></expr></argument>, <argument><expr><name>newpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">" Old name: %s\n"</literal></expr></argument>, <argument><expr><name>linkto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return<expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type>
<name>assertion_make_symlink</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newpath</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>linkto</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>targetIsDir</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assertion_count</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>my_CreateSymbolicLinkA</name><argument_list>(<argument><expr><name>newpath</name></expr></argument>, <argument><expr><name>linkto</name></expr></argument>, <argument><expr><name>targetIsDir</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>HAVE_SYMLINK</name></expr></cpp:elif>
<expr_stmt><expr><call><name>assertion_count</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>symlink</name><argument_list>(<argument><expr><name>linkto</name></expr></argument>, <argument><expr><name>newpath</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"Could not create symlink"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">" New link: %s\n"</literal></expr></argument>, <argument><expr><name>newpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">" Old name: %s\n"</literal></expr></argument>, <argument><expr><name>linkto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return<expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type>
<name>assertion_umask</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mask</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>assertion_count</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>file</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>line</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>umask</name><argument_list>(<argument><expr><name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type>
<name>assertion_utimes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pathname</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>at</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>at_nsec</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>mt</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>mt_nsec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WINTIME</name><parameter_list>(<parameter><type><name>sec</name></type></parameter>, <parameter><type><name>nsec</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((Int32x32To64(sec, 10000000) + EPOC_TIME)+ (((nsec)/1000)*10))</cpp:value></cpp:define>

<decl_stmt><decl><type><name>HANDLE</name></type> <name>h</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULARGE_INTEGER</name></type> <name>wintm</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILETIME</name></type> <name>fatime</name></decl>, <decl><type ref="prev"/><name>fmtime</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILETIME</name> <modifier>*</modifier></type><name>pat</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pmt</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assertion_count</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>CreateFileA</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>,<argument><expr><name>GENERIC_READ</name> <operator>|</operator> <name>GENERIC_WRITE</name></expr></argument>,
<argument><expr><name>FILE_SHARE_READ</name> <operator>|</operator> <name>FILE_SHARE_WRITE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>OPEN_EXISTING</name></expr></argument>,
<argument><expr><name>FILE_FLAG_BACKUP_SEMANTICS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>h</name> <operator>==</operator> <name>INVALID_HANDLE_VALUE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"Can't access %s\n"</literal></expr></argument>, <argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>at</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>at_nsec</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>wintm</name><operator>.</operator><name>QuadPart</name></name> <operator>=</operator> <call><name>WINTIME</name><argument_list>(<argument><expr><name>at</name></expr></argument>, <argument><expr><name>at_nsec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fatime</name><operator>.</operator><name>dwLowDateTime</name></name> <operator>=</operator> <name><name>wintm</name><operator>.</operator><name>LowPart</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fatime</name><operator>.</operator><name>dwHighDateTime</name></name> <operator>=</operator> <name><name>wintm</name><operator>.</operator><name>HighPart</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>pat</name> <operator>=</operator> <operator>&amp;</operator><name>fatime</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>pat</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>mt</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>mt_nsec</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>wintm</name><operator>.</operator><name>QuadPart</name></name> <operator>=</operator> <call><name>WINTIME</name><argument_list>(<argument><expr><name>mt</name></expr></argument>, <argument><expr><name>mt_nsec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fmtime</name><operator>.</operator><name>dwLowDateTime</name></name> <operator>=</operator> <name><name>wintm</name><operator>.</operator><name>LowPart</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fmtime</name><operator>.</operator><name>dwHighDateTime</name></name> <operator>=</operator> <name><name>wintm</name><operator>.</operator><name>HighPart</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>pmt</name> <operator>=</operator> <operator>&amp;</operator><name>fmtime</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>pmt</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>pat</name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <name>pmt</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>SetFileTime</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pat</name></expr></argument>, <argument><expr><name>pmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"Can't SetFileTime %s\n"</literal></expr></argument>, <argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name><name>times</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__FreeBSD__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>mt_nsec</name> <operator>=</operator> <name>at_nsec</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><name>mt</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>mt_nsec</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>at</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>at_nsec</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>lstat</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"Can't stat %s\n"</literal></expr></argument>, <argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>mt</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>mt_nsec</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>mt</name> <operator>=</operator> <name><name>st</name><operator>.</operator><name>st_mtime</name></name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__FreeBSD__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>mt_nsec</name> <operator>=</operator> <name><name>st</name><operator>.</operator><name>st_mtimespec</name><operator>.</operator><name>tv_nsec</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>mt_nsec</name> <operator>=</operator> <operator>(</operator><name>mt_nsec</name> <operator>/</operator> <literal type="number">1000</literal><operator>)</operator> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>at</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>at_nsec</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>at</name> <operator>=</operator> <name><name>st</name><operator>.</operator><name>st_atime</name></name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__FreeBSD__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>at_nsec</name> <operator>=</operator> <name><name>st</name><operator>.</operator><name>st_atimespec</name><operator>.</operator><name>tv_nsec</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>at_nsec</name> <operator>=</operator> <operator>(</operator><name>at_nsec</name> <operator>/</operator> <literal type="number">1000</literal><operator>)</operator> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>times</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>tv_sec</name> <operator>=</operator> <name>mt</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>times</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>tv_usec</name> <operator>=</operator> <name>mt_nsec</name> <operator>/</operator> <literal type="number">1000</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>times</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>tv_sec</name> <operator>=</operator> <name>at</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>times</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>tv_usec</name> <operator>=</operator> <name>at_nsec</name> <operator>/</operator> <literal type="number">1000</literal></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LUTIMES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>lutimes</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>times</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>utimes</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>times</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"Can't utimes %s\n"</literal></expr></argument>, <argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<function><type><name>int</name></type>
<name>assertion_nodump</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pathname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRUCT_STAT_ST_FLAGS</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>UF_NODUMP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assertion_count</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>chflags</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>UF_NODUMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"Can't set nodump %s\n"</literal></expr></argument>, <argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EXT2_IOC_GETFLAGS</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WORKING_EXT2_IOC_GETFLAGS</name></expr></argument>)</argument_list></call><operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>EXT2_NODUMP_FL</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>, <decl><type ref="prev"/><name>r</name></decl>, <decl><type ref="prev"/><name>flags</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assertion_count</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>O_RDONLY</name> <operator>|</operator> <name>O_NONBLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"Can't open %s\n"</literal></expr></argument>, <argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>ioctl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>EXT2_IOC_GETFLAGS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"Can't get flags %s\n"</literal></expr></argument>, <argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>EXT2_NODUMP_FL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>ioctl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>EXT2_IOC_SETFLAGS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>failure_start</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"Can't set nodump %s\n"</literal></expr></argument>, <argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure_finish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>pathname</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertion_count</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>




















<function><type><name>int</name></type>
<name>canSymlink</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>tested</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>tested</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>value</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>++</operator><name>tested</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertion_make_file</name><argument_list>(<argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>, <argument><expr><literal type="string">"canSymlink.0"</literal></expr></argument>, <argument><expr><literal type="number">0644</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>my_CreateSymbolicLinkA</name><argument_list>(<argument><expr><literal type="string">"canSymlink.1"</literal></expr></argument>, <argument><expr><literal type="string">"canSymlink.0"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <call><name>is_symlink</name><argument_list>(<argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>, <argument><expr><literal type="string">"canSymlink.1"</literal></expr></argument>, <argument><expr><literal type="string">"canSymlink.0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>HAVE_SYMLINK</name></expr></cpp:elif>
<expr_stmt><expr><name>value</name> <operator>=</operator> <operator>(</operator><literal type="number">0</literal> <operator>==</operator> <call><name>symlink</name><argument_list>(<argument><expr><literal type="string">"canSymlink.0"</literal></expr></argument>, <argument><expr><literal type="string">"canSymlink.1"</literal></expr></argument>)</argument_list></call><operator>)</operator>
<operator>&amp;&amp;</operator> <call><name>is_symlink</name><argument_list>(<argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>, <argument><expr><literal type="string">"canSymlink.1"</literal></expr></argument>,<argument><expr><literal type="string">"canSymlink.0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><operator>(</operator><name>value</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>redirectArgs</name> <init>= <expr><literal type="string">"&gt;NUL 2&gt;NUL"</literal></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>redirectArgs</name> <init>= <expr><literal type="string">"&gt;/dev/null 2&gt;/dev/null"</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



<function><type><name>int</name></type>
<name>canBzip2</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>tested</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tested</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tested</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>systemf</name><argument_list>(<argument><expr><literal type="string">"bzip2 -d -V %s"</literal></expr></argument>, <argument><expr><name>redirectArgs</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>value</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name>value</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>




<function><type><name>int</name></type>
<name>canGrzip</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>tested</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tested</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tested</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>systemf</name><argument_list>(<argument><expr><literal type="string">"grzip -V %s"</literal></expr></argument>, <argument><expr><name>redirectArgs</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>value</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name>value</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>




<function><type><name>int</name></type>
<name>canGzip</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>tested</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tested</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tested</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>systemf</name><argument_list>(<argument><expr><literal type="string">"gzip -V %s"</literal></expr></argument>, <argument><expr><name>redirectArgs</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>value</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name>value</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>




<function><type><name>int</name></type>
<name>canRunCommand</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>tested</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tested</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tested</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>systemf</name><argument_list>(<argument><expr><literal type="string">"%s %s"</literal></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>redirectArgs</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>value</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name>value</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>canLrzip</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>tested</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tested</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tested</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>systemf</name><argument_list>(<argument><expr><literal type="string">"lrzip -V %s"</literal></expr></argument>, <argument><expr><name>redirectArgs</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>value</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name>value</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>




<function><type><name>int</name></type>
<name>canLz4</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>tested</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tested</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tested</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>systemf</name><argument_list>(<argument><expr><literal type="string">"lz4 -V %s"</literal></expr></argument>, <argument><expr><name>redirectArgs</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>value</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name>value</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>




<function><type><name>int</name></type>
<name>canLzip</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>tested</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tested</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tested</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>systemf</name><argument_list>(<argument><expr><literal type="string">"lzip -V %s"</literal></expr></argument>, <argument><expr><name>redirectArgs</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>value</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name>value</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>




<function><type><name>int</name></type>
<name>canLzma</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>tested</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tested</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tested</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>systemf</name><argument_list>(<argument><expr><literal type="string">"lzma -V %s"</literal></expr></argument>, <argument><expr><name>redirectArgs</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>value</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name>value</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>




<function><type><name>int</name></type>
<name>canLzop</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>tested</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tested</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tested</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>systemf</name><argument_list>(<argument><expr><literal type="string">"lzop -V %s"</literal></expr></argument>, <argument><expr><name>redirectArgs</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>value</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name>value</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>




<function><type><name>int</name></type>
<name>canXz</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>tested</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tested</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tested</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>systemf</name><argument_list>(<argument><expr><literal type="string">"xz -V %s"</literal></expr></argument>, <argument><expr><name>redirectArgs</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>value</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name>value</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>




<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRUCT_STAT_ST_FLAGS</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>UF_NODUMP</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><name>int</name></type>
<name>canNodump</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><literal type="string">"cannodumptest"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>sb</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assertion_make_file</name><argument_list>(<argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="number">0644</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>chflags</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>UF_NODUMP</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sb</name><operator>.</operator><name>st_flags</name></name> <operator>&amp;</operator> <name>UF_NODUMP</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EXT2_IOC_GETFLAGS</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WORKING_EXT2_IOC_GETFLAGS</name></expr></argument>)</argument_list></call><operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>EXT2_NODUMP_FL</name></expr></argument>)</argument_list></call></expr></cpp:elif>


<function><type><name>int</name></type>
<name>canNodump</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><literal type="string">"cannodumptest"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>, <decl><type ref="prev"/><name>r</name></decl>, <decl><type ref="prev"/><name>flags</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assertion_make_file</name><argument_list>(<argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="number">0644</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDONLY</name> <operator>|</operator> <name>O_NONBLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>ioctl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>EXT2_IOC_GETFLAGS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>EXT2_NODUMP_FL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>ioctl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>EXT2_IOC_SETFLAGS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDONLY</name> <operator>|</operator> <name>O_NONBLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>ioctl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>EXT2_IOC_GETFLAGS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>EXT2_NODUMP_FL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<function><type><name>int</name></type>
<name>canNodump</name><parameter_list>()</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>






<function><type><name>void</name></type>
<name>sleepUntilAfter</name><parameter_list>(<parameter><decl><type><name>time_t</name></type> <name>t</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<while>while <condition>(<expr><name>t</name> <operator>&gt;=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>Sleep</name><argument_list>(<argument><expr><literal type="number">500</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>sleep</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>





<function><type><name>int</name></type>
<name>systemf</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buff</name><index>[<expr><literal type="number">8192</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vsprintf</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>verbosity</name> <operator>&gt;</operator> <name>VERBOSITY_FULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">"Cmd: %s\n"</literal></expr></argument>, <argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>system</name><argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>r</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>






<function><type><name>char</name> <modifier>*</modifier></type>
<name>slurpfile</name><parameter_list>(<parameter><decl><type><name>size_t</name> <modifier>*</modifier></type> <name>sizep</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>filename</name><index>[<expr><literal type="number">8192</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>bytes_read</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vsprintf</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"rb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>f</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>fstat</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">"Can't stat file %s\n"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>st</name><operator>.</operator><name>st_size</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">"Can't allocate %ld bytes of memory to read file %s\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>long</name> <name>int</name><operator>)</operator><name><name>st</name><operator>.</operator><name>st_size</name></name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>bytes_read</name> <operator>=</operator> <call><name>fread</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>st</name><operator>.</operator><name>st_size</name></name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bytes_read</name> <operator>&lt;</operator> <name><name>st</name><operator>.</operator><name>st_size</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">"Can't read file %s\n"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>p</name><index>[<expr><name><name>st</name><operator>.</operator><name>st_size</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>sizep</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>sizep</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name><name>st</name><operator>.</operator><name>st_size</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>p</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>






<function><type><name>void</name></type>
<name>dumpfile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>bytes_written</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>

<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"wb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>f</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">"Can't open file %s for writing\n"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>bytes_written</name> <operator>=</operator> <call><name>fwrite</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bytes_written</name> <operator>&lt;</operator> <operator>(</operator><name>ssize_t</name><operator>)</operator><name>len</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">"Can't write file %s\n"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VALID_UUDECODE</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(c &gt;= 32 &amp;&amp; c &lt;= 96)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UUDECODE</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((c) - 0x20) &amp; 0x3f)</cpp:value></cpp:define>
<function><type><name>void</name></type>
<name>extract_reference_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buff</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>in</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>out</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><literal type="string">"%s/%s.uu"</literal></expr></argument>, <argument><expr><name>refdir</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>in</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure</name><argument_list>(<argument><expr><literal type="string">"Couldn't open reference file %s"</literal></expr></argument>, <argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>in</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>in</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>in</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><literal type="string">"begin "</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"wb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>in</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>buff</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bytes</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><literal type="string">"end"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>bytes</name> <operator>=</operator> <call><name>UUDECODE</name><argument_list>(<argument><expr><operator>*</operator><name>p</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>bytes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>bytes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>VALID_UUDECODE</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>VALID_UUDECODE</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>UUDECODE</name><argument_list>(<argument><expr><operator>*</operator><name>p</name><operator>++</operator></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">18</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>|=</operator> <call><name>UUDECODE</name><argument_list>(<argument><expr><operator>*</operator><name>p</name><operator>++</operator></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">12</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><name>n</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>--</operator><name>bytes</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>bytes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>VALID_UUDECODE</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>|=</operator> <call><name>UUDECODE</name><argument_list>(<argument><expr><operator>*</operator><name>p</name><operator>++</operator></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">6</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><operator>(</operator><name>n</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>--</operator><name>bytes</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>bytes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>VALID_UUDECODE</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>|=</operator> <call><name>UUDECODE</name><argument_list>(<argument><expr><operator>*</operator><name>p</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><name>n</name> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>--</operator><name>bytes</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
</block_content>}</block></while>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>copy_reference_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buff</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>in</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>out</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>rbytes</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>refdir</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>in</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><literal type="string">"rb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure</name><argument_list>(<argument><expr><literal type="string">"Couldn't open reference file %s"</literal></expr></argument>, <argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>in</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>in</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"wb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>(</operator><name>rbytes</name> <operator>=</operator> <call><name>fread</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>in</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>fwrite</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>rbytes</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>rbytes</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">"Error: fwrite\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>is_LargeInode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>BY_HANDLE_FILE_INFORMATION</name></type> <name>bhfi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>my_GetFileInformationByName</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bhfi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><name><name>bhfi</name><operator>.</operator><name>nFileIndexHigh</name></name> <operator>&amp;</operator> <literal type="number">0x0000FFFFUL</literal><operator>)</operator></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>ino</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ino</name> <operator>=</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><name><name>st</name><operator>.</operator><name>st_ino</name></name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ino</name> <operator>&gt;</operator> <literal type="number">0xffffffff</literal><operator>)</operator></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>extract_reference_files</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>names</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<while>while <condition>(<expr><name>names</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>names</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>extract_reference_file</name><argument_list>(<argument><expr><operator>*</operator><name>names</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>archive_test_set_acls</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_entry</name></name> <modifier>*</modifier></type><name>ae</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>archive_test_acl_t</name></name> <modifier>*</modifier></type><name>acls</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>archive_entry_acl_clear</name><argument_list>(<argument><expr><name>ae</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>failure</name><argument_list>(<argument><expr><literal type="string">"type=%#010x, permset=%#010x, tag=%d, qual=%d name=%s"</literal></expr></argument>,
<argument><expr><name><name>acls</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name></expr></argument>, <argument><expr><name><name>acls</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>permset</name></expr></argument>, <argument><expr><name><name>acls</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tag</name></expr></argument>,
<argument><expr><name><name>acls</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>qual</name></expr></argument>, <argument><expr><name><name>acls</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualInt</name><argument_list>(<argument><expr><name>ARCHIVE_OK</name></expr></argument>,
<argument><expr><call><name>archive_entry_acl_add_entry</name><argument_list>(<argument><expr><name>ae</name></expr></argument>,
<argument><expr><name><name>acls</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name></expr></argument>, <argument><expr><name><name>acls</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>permset</name></expr></argument>, <argument><expr><name><name>acls</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tag</name></expr></argument>,
<argument><expr><name><name>acls</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>qual</name></expr></argument>, <argument><expr><name><name>acls</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>archive_test_acl_match</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_test_acl_t</name></name> <modifier>*</modifier></type><name>acl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>permset</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>tag</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>qual</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name><name>acl</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>permset</name> <operator>!=</operator> <name><name>acl</name><operator>-&gt;</operator><name>permset</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>tag</name> <operator>!=</operator> <name><name>acl</name><operator>-&gt;</operator><name>tag</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>tag</name> <operator>==</operator> <name>ARCHIVE_ENTRY_ACL_USER_OBJ</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>tag</name> <operator>==</operator> <name>ARCHIVE_ENTRY_ACL_GROUP_OBJ</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>tag</name> <operator>==</operator> <name>ARCHIVE_ENTRY_ACL_EVERYONE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>tag</name> <operator>==</operator> <name>ARCHIVE_ENTRY_ACL_OTHER</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>qual</name> <operator>!=</operator> <name><name>acl</name><operator>-&gt;</operator><name>qual</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>name</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>acl</name><operator>-&gt;</operator><name>name</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>acl</name><operator>-&gt;</operator><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>acl</name><operator>-&gt;</operator><name>name</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal> <operator>==</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>acl</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>archive_test_compare_acls</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_entry</name></name> <modifier>*</modifier></type><name>ae</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>archive_test_acl_t</name></name> <modifier>*</modifier></type><name>acls</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cnt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>want_type</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>marker</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>r</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>, <decl><type ref="prev"/><name>permset</name></decl>, <decl><type ref="prev"/><name>tag</name></decl>, <decl><type ref="prev"/><name>qual</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>matched</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>marker</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>marker</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>cnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>acls</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>&amp;</operator> <name>want_type</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>marker</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>failure</name><argument_list>(<argument><expr><literal type="string">"No ACL's to compare, type mask: %d"</literal></expr></argument>, <argument><expr><name>want_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<while>while <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <operator>(</operator><name>r</name> <operator>=</operator> <call><name>archive_entry_acl_next</name><argument_list>(<argument><expr><name>ae</name></expr></argument>, <argument><expr><name>want_type</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>permset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>qual</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>matched</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>matched</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>archive_test_acl_match</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>acls</name><index>[<expr><name><name>marker</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr></argument>, <argument><expr><name>type</name></expr></argument>,
<argument><expr><name>permset</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>qual</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>marker</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>marker</name><index>[<expr><name>n</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>matched</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>ARCHIVE_ENTRY_ACL_TYPE_ACCESS</name>
<operator>&amp;&amp;</operator> <name>tag</name> <operator>==</operator> <name>ARCHIVE_ENTRY_ACL_USER_OBJ</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>matched</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"No match for user_obj perm\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>failure</name><argument_list>(<argument><expr><literal type="string">"USER_OBJ permset (%02o) != user mode (%02o)"</literal></expr></argument>,
<argument><expr><name>permset</name></expr></argument>, <argument><expr><literal type="number">07</literal> <operator>&amp;</operator> <operator>(</operator><name>mode</name> <operator>&gt;&gt;</operator> <literal type="number">6</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>permset</name> <operator>&lt;&lt;</operator> <literal type="number">6</literal><operator>)</operator> <operator>==</operator> <operator>(</operator><name>mode</name> <operator>&amp;</operator> <literal type="number">0700</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>ARCHIVE_ENTRY_ACL_TYPE_ACCESS</name>
<operator>&amp;&amp;</operator> <name>tag</name> <operator>==</operator> <name>ARCHIVE_ENTRY_ACL_GROUP_OBJ</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>matched</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"No match for group_obj perm\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>failure</name><argument_list>(<argument><expr><literal type="string">"GROUP_OBJ permset %02o != group mode %02o"</literal></expr></argument>,
<argument><expr><name>permset</name></expr></argument>, <argument><expr><literal type="number">07</literal> <operator>&amp;</operator> <operator>(</operator><name>mode</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>permset</name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>==</operator> <operator>(</operator><name>mode</name> <operator>&amp;</operator> <literal type="number">0070</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>ARCHIVE_ENTRY_ACL_TYPE_ACCESS</name>
<operator>&amp;&amp;</operator> <name>tag</name> <operator>==</operator> <name>ARCHIVE_ENTRY_ACL_OTHER</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>matched</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"No match for other perm\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>failure</name><argument_list>(<argument><expr><literal type="string">"OTHER permset (%02o) != other mode (%02o)"</literal></expr></argument>,
<argument><expr><name>permset</name></expr></argument>, <argument><expr><name>mode</name> <operator>&amp;</operator> <literal type="number">07</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>permset</name> <operator>&lt;&lt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>==</operator> <operator>(</operator><name>mode</name> <operator>&amp;</operator> <literal type="number">0007</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>failure</name><argument_list>(<argument><expr><literal type="string">"Could not find match for ACL "</literal>
<literal type="string">"(type=%#010x,permset=%#010x,tag=%d,qual=%d,"</literal>
<literal type="string">"name=``%s'')"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>permset</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>qual</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>matched</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>assertEqualInt</name><argument_list>(<argument><expr><name>ARCHIVE_EOF</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>want_type</name> <operator>&amp;</operator> <name>ARCHIVE_ENTRY_ACL_TYPE_ACCESS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>mode_t</name><operator>)</operator><operator>(</operator><name>mode</name> <operator>&amp;</operator> <literal type="number">0777</literal><operator>)</operator> <operator>==</operator> <operator>(</operator><call><name>archive_entry_mode</name><argument_list>(<argument><expr><name>ae</name></expr></argument>)</argument_list></call>
<operator>&amp;</operator> <literal type="number">0777</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>failure</name><argument_list>(<argument><expr><literal type="string">"Could not find match for ACL "</literal>
<literal type="string">"(type=%#010x,permset=%#010x,tag=%d,qual=%d,name=``%s'')"</literal></expr></argument>,
<argument><expr><name><name>acls</name><index>[<expr><name><name>marker</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>]</index></name><operator>.</operator><name>type</name></expr></argument>, <argument><expr><name><name>acls</name><index>[<expr><name><name>marker</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>]</index></name><operator>.</operator><name>permset</name></expr></argument>,
<argument><expr><name><name>acls</name><index>[<expr><name><name>marker</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>]</index></name><operator>.</operator><name>tag</name></expr></argument>, <argument><expr><name><name>acls</name><index>[<expr><name><name>marker</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>]</index></name><operator>.</operator><name>qual</name></expr></argument>, <argument><expr><name><name>acls</name><index>[<expr><name><name>marker</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>marker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>















<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DEFINE_TEST</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFINE_TEST</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>void name(void);</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"list.h"</cpp:file></cpp:include>


<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DEFINE_TEST</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFINE_TEST</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ n, #n, 0 },</cpp:value></cpp:define>
<decl_stmt><decl><type><name><name>struct</name> <name>test_list_t</name></name></type> <name><name>tests</name><index>[]</index></name> <init>= <expr><block>{
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"list.h"</cpp:file></cpp:include>
}</block></expr></init></decl>;</decl_stmt>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_summarize</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>failed</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>skips_num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>verbosity</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>VERBOSITY_SUMMARY_ONLY</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><ternary><condition><expr><name>failed</name></expr> ?</condition><then> <expr><literal type="string">"E"</literal></expr> </then><else>: <expr><literal type="string">"."</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>VERBOSITY_PASSFAIL</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><ternary><condition><expr><name>failed</name></expr> ?</condition><then> <expr><literal type="string">"FAIL\n"</literal></expr> </then><else>: <expr><ternary><condition><expr><name>skips_num</name></expr> ?</condition><then> <expr><literal type="string">"ok (S)\n"</literal></expr> </then><else>: <expr><literal type="string">"ok\n"</literal></expr></else></ternary></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>

<expr_stmt><expr><name>log_console</name> <operator>=</operator> <operator>(</operator><name>verbosity</name> <operator>==</operator> <name>VERBOSITY_LIGHT_REPORT</name><operator>)</operator></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>failed_lines</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>failed_lines</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>failed_lines</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>failed_lines</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>skip</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>logprintf</name><argument_list>(<argument><expr><literal type="string">"%s:%d: Summary: Failed %d times\n"</literal></expr></argument>,
<argument><expr><name>failed_filename</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>failed_lines</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>failed_filename</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>failed_lines</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>failed_lines</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>int</name></type>
<name>test_run</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tmpdir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>workdir</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>logfilename</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>failures_before</name> <init>= <expr><name>failures</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>skips_before</name> <init>= <expr><name>skips</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>oldumask</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>verbosity</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>VERBOSITY_SUMMARY_ONLY</name></expr>:</case>
<break>break;</break>
<case>case <expr><name>VERBOSITY_PASSFAIL</name></expr>:</case>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%3d: %-64s"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%3d: %s\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>assertChdir</name><argument_list>(<argument><expr><name>tmpdir</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"ERROR: Can't chdir to top work dir %s\n"</literal></expr></argument>, <argument><expr><name>tmpdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>logfilename</name></expr></argument>, <argument><expr><literal type="string">"%s.log"</literal></expr></argument>, <argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>logfile</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>logfilename</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>logfile</name></expr></argument>, <argument><expr><literal type="string">"%s\n\n"</literal></expr></argument>, <argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>workdir</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>workdir</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>tmpdir</name></expr></argument>, <argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>testworkdir</name> <operator>=</operator> <name>workdir</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>assertMakeDir</name><argument_list>(<argument><expr><name>testworkdir</name></expr></argument>, <argument><expr><literal type="number">0755</literal></expr></argument>)</argument_list></call>
<operator>||</operator> <operator>!</operator><call><name>assertChdir</name><argument_list>(<argument><expr><name>testworkdir</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"ERROR: Can't chdir to work dir %s\n"</literal></expr></argument>, <argument><expr><name>testworkdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>setlocale</name><argument_list>(<argument><expr><name>LC_ALL</name></expr></argument>, <argument><expr><literal type="string">"C"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>umask</name><argument_list>(<argument><expr><name>oldumask</name> <operator>=</operator> <call><name>umask</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><operator>(</operator><operator>*</operator><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>func</name><operator>)</operator><operator>(</operator><operator>)</operator></expr>;</expr_stmt>



<expr_stmt><expr><name>testworkdir</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>umask</name><argument_list>(<argument><expr><name>oldumask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>setlocale</name><argument_list>(<argument><expr><name>LC_ALL</name></expr></argument>, <argument><expr><literal type="string">"C"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>assertChdir</name><argument_list>(<argument><expr><name>tmpdir</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"ERROR: Couldn't chdir to temp dir %s\n"</literal></expr></argument>,
<argument><expr><name>tmpdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>failures</name> <operator>=</operator> <name>failures</name> <operator>-</operator> <name>failures_before</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>test_summarize</name><argument_list>(<argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>failures</name></expr></argument>, <argument><expr><name>skips</name> <operator>-</operator> <name>skips_before</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>logfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>logfile</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>failures</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>keep_temp_files</name> <operator>&amp;&amp;</operator> <call><name>assertChdir</name><argument_list>(<argument><expr><name>tmpdir</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>





<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>t</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>t</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>t</name> <operator>&lt;</operator> <literal type="number">10</literal></expr>;</condition> <incr><expr><name>t</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>t</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Sleep</name><argument_list>(<argument><expr><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>systemf</name><argument_list>(<argument><expr><literal type="string">"rmdir /S /Q %s"</literal></expr></argument>, <argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>systemf</name><argument_list>(<argument><expr><literal type="string">"del %s"</literal></expr></argument>, <argument><expr><name>logfilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>systemf</name><argument_list>(<argument><expr><literal type="string">"rm -rf %s"</literal></expr></argument>, <argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>systemf</name><argument_list>(<argument><expr><literal type="string">"rm %s"</literal></expr></argument>, <argument><expr><name>logfilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><operator>(</operator><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>failures</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>









<function><type><specifier>static</specifier> <name>void</name></type>
<name>usage</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>program</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>limit</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>tests</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>tests</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Usage: %s [options] &lt;test&gt; &lt;test&gt; ...\n"</literal></expr></argument>, <argument><expr><name>program</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Default is to run all tests.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Otherwise, specify the numbers of the tests you wish to run.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Options:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" -d Dump core after any failure, for debugging.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" -k Keep all temp files.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Default: temp files for successful tests deleted.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PROGRAM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" -p &lt;path&gt; Path to executable to be tested.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Default: path taken from "</literal> <name>ENVBASE</name> <literal type="string">" environment variable.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" -q Quiet.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" -r &lt;dir&gt; Path to dir containing reference files.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Default: Current directory.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" -u Keep running specifies tests until one fails.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" -v Verbose.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Available tests:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>limit</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %d: %s\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_refdir</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>d</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>tried_size</name></decl>, <decl><type ref="prev"/><name>buff_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buff</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tried</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pwd</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PATH_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>buff_size</name> <operator>=</operator> <name>PATH_MAX</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>buff_size</name> <operator>=</operator> <literal type="number">8192</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>buff</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><name>buff_size</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>buff</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Unable to allocate memory\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>tried_size</name> <operator>=</operator> <name>buff_size</name> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>tried</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><name>tried_size</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tried</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Unable to allocate memory\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>d</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>pwd</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name>buff_size</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>slurpfile</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><name>KNOWNREF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>success</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>strncat</name><argument_list>(<argument><expr><name>tried</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><name>tried_size</name> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>tried</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strncat</name><argument_list>(<argument><expr><name>tried</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>tried_size</name> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>tried</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>failure</name>;</goto>
</block_content>}</block></if></if_stmt>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PATH_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>pwd</name> <operator>=</operator> <call><name>getcwd</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>PATH_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>pwd</name> <operator>=</operator> <call><name>getcwd</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<while>while <condition>(<expr><name><name>pwd</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>pwd</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>pwd</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>pwd</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></while>


<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name>buff_size</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>pwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>slurpfile</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><name>KNOWNREF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>success</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>strncat</name><argument_list>(<argument><expr><name>tried</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><name>tried_size</name> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>tried</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strncat</name><argument_list>(<argument><expr><name>tried</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>tried_size</name> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>tried</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name>buff_size</name></expr></argument>, <argument><expr><literal type="string">"%s/test"</literal></expr></argument>, <argument><expr><name>pwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>slurpfile</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><name>KNOWNREF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>success</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>strncat</name><argument_list>(<argument><expr><name>tried</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><name>tried_size</name> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>tried</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strncat</name><argument_list>(<argument><expr><name>tried</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>tried_size</name> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>tried</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LIBRARY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name>buff_size</name></expr></argument>, <argument><expr><literal type="string">"%s/%s/test"</literal></expr></argument>, <argument><expr><name>pwd</name></expr></argument>, <argument><expr><name>LIBRARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name>buff_size</name></expr></argument>, <argument><expr><literal type="string">"%s/%s/test"</literal></expr></argument>, <argument><expr><name>pwd</name></expr></argument>, <argument><expr><name>PROGRAM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>slurpfile</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><name>KNOWNREF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>success</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>strncat</name><argument_list>(<argument><expr><name>tried</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><name>tried_size</name> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>tried</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strncat</name><argument_list>(<argument><expr><name>tried</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>tried_size</name> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>tried</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PROGRAM_ALIAS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name>buff_size</name></expr></argument>, <argument><expr><literal type="string">"%s/%s/test"</literal></expr></argument>, <argument><expr><name>pwd</name></expr></argument>, <argument><expr><name>PROGRAM_ALIAS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>slurpfile</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><name>KNOWNREF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>success</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>strncat</name><argument_list>(<argument><expr><name>tried</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><name>tried_size</name> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>tried</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strncat</name><argument_list>(<argument><expr><name>tried</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>tried_size</name> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>tried</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>pwd</name></expr></argument>, <argument><expr><literal type="string">"/usr/obj"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name>buff_size</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>pwd</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>slurpfile</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><name>KNOWNREF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>success</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>strncat</name><argument_list>(<argument><expr><name>tried</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><name>tried_size</name> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>tried</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strncat</name><argument_list>(<argument><expr><name>tried</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>tried_size</name> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>tried</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name>buff_size</name></expr></argument>, <argument><expr><literal type="string">"%s/test"</literal></expr></argument>, <argument><expr><name>pwd</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>slurpfile</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><name>KNOWNREF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>success</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>strncat</name><argument_list>(<argument><expr><name>tried</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><name>tried_size</name> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>tried</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strncat</name><argument_list>(<argument><expr><name>tried</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>tried_size</name> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>tried</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<label><name>failure</name>:</label>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Unable to locate known reference file %s\n"</literal></expr></argument>, <argument><expr><name>KNOWNREF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Checked following directories:\n%s\n"</literal></expr></argument>, <argument><expr><name>tried</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Use -r option to specify full path to reference directory\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>DebugBreak</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>success</name>:</label>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>pwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tried</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>limit</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>tests</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>tests</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>test_set</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>tests</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>tests</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>tests_run</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>tests_failed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>option</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>time_t</name></type> <name>now</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>refdir_alloc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>saved_argv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tmp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>option_arg</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>tmpdir</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pwd</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>testprogdir</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tmp2</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>vlevel</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>tmpdir_timestamp</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>argc</name></expr>;</expr_stmt>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PATH_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>pwd</name> <operator>=</operator> <call><name>getcwd</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>PATH_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>pwd</name> <operator>=</operator> <call><name>getcwd</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<while>while <condition>(<expr><name><name>pwd</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>pwd</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>pwd</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>pwd</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></while>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE__CrtSetReportMode</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__WATCOMC__</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr_stmt><expr><call><name>_set_invalid_parameter_handler</name><argument_list>(<argument><expr><name>invalid_parameter_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>_CrtSetReportMode</name><argument_list>(<argument><expr><name>_CRT_ASSERT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>





<expr_stmt><expr><name>progname</name> <operator>=</operator> <name>p</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>testprogdir</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>progname</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"ERROR: Out of memory."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>testprogdir</name></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'/'</literal> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>progname</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name><name>testprogdir</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>testprogdir</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'/'</literal> <operator>&amp;&amp;</operator> <name><name>testprogdir</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator>
<operator>!</operator><operator>(</operator><operator>(</operator><operator>(</operator><name><name>testprogdir</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <name><name>testprogdir</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">'z'</literal><operator>)</operator> <operator>||</operator>
<operator>(</operator><name><name>testprogdir</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name><name>testprogdir</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">'Z'</literal><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
<name><name>testprogdir</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>testprogdir</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal> <operator>||</operator> <name><name>testprogdir</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if_stmt><if>if <condition>(<expr><name><name>testprogdir</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'/'</literal></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>testprogdir</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>realloc</name><argument_list>(<argument><expr><name>testprogdir</name></expr></argument>,
<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>pwd</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>testprogdir</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"ERROR: Out of memory."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>testprogdir</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>pwd</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>testprogdir</name></expr></argument>,
<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>testprogdir</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>testprogdir</name></expr></argument>, <argument><expr><name>pwd</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>pwd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>testprogdir</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>pwd</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PROGRAM</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr_stmt><expr><name>testprogfile</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><name>ENVBASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"TMPDIR"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"TMPDIR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"TMP"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"TMP"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"TEMP"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"TEMP"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"TEMPDIR"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"TEMPDIR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <literal type="string">"/tmp"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>getenv</name><argument_list>(<argument><expr><name>ENVBASE</name> <literal type="string">"_DEBUG"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>dump_on_failure</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"_VERBOSITY_LEVEL"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>vlevel</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"_VERBOSITY_LEVEL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>verbosity</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>vlevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>verbosity</name> <argument_list type="generic">&lt; <argument><expr><name>VERBOSITY_SUMMARY_ONLY</name> <operator>||</operator> <name>verbosity</name></expr></argument> &gt;</argument_list></name> <name>VERBOSITY_FULL</name></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><name>vlevel</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>verbosity</name> <operator>=</operator> <name>VERBOSITY_PASSFAIL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>refdir</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><name>ENVBASE</name> <literal type="string">"_TEST_FILES"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><operator>++</operator><name>argv</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>argv</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>*</operator><name>argv</name> <operator>!=</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>*</operator><name>argv</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>option</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>option_arg</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>option</name> <operator>==</operator> <literal type="char">'p'</literal> <operator>||</operator> <name>option</name> <operator>==</operator> <literal type="char">'r'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>option_arg</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>*</operator><name>argv</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"Option -%c requires argument.\n"</literal></expr></argument>,
<argument><expr><name>option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>usage</name><argument_list>(<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>option_arg</name> <operator>=</operator> <operator>*</operator><name>argv</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<switch>switch <condition>(<expr><name>option</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'d'</literal></expr>:</case>
<expr_stmt><expr><name>dump_on_failure</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'k'</literal></expr>:</case>
<expr_stmt><expr><name>keep_temp_files</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'p'</literal></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PROGRAM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>testprogfile</name> <operator>=</operator> <name>option_arg</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"-p option not permitted\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>usage</name><argument_list>(<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<break>break;</break>
<case>case <expr><literal type="char">'q'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>vlevel</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>verbosity</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'r'</literal></expr>:</case>
<expr_stmt><expr><name>refdir</name> <operator>=</operator> <name>option_arg</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'u'</literal></expr>:</case>
<expr_stmt><expr><name>until_failure</name><operator>++</operator></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'v'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>vlevel</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>verbosity</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Unrecognized option '%c'\n"</literal></expr></argument>,
<argument><expr><name>option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>usage</name><argument_list>(<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></while>
</block_content>}</block></while>




<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PROGRAM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>testprogfile</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>tmp2</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>testprogdir</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator>
<call><name>strlen</name><argument_list>(<argument><expr><name>PROGRAM</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"ERROR: Out of memory."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>tmp2</name></expr></argument>, <argument><expr><name>testprogdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>tmp2</name></expr></argument>, <argument><expr><literal type="string">"/"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>tmp2</name></expr></argument>, <argument><expr><name>PROGRAM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>testprogfile</name> <operator>=</operator> <name>tmp2</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>testprg</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr_stmt><expr><name>testprg</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>testprogfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>testprg</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>testprg</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>testprg</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>testprogfile</name> <operator>=</operator> <name>testprg</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>testprg</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>testprogfile</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>testprg</name></expr></argument>, <argument><expr><literal type="string">"\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>testprg</name></expr></argument>, <argument><expr><name>testprogfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>testprg</name></expr></argument>, <argument><expr><literal type="string">"\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>testprog</name> <operator>=</operator> <name>testprg</name></expr>;</expr_stmt>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>sigaction</name></name></type> <name>sa</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>sa</name><operator>.</operator><name>sa_handler</name></name> <operator>=</operator> <name>SIG_IGN</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sigemptyset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sa</name><operator>.</operator><name>sa_mask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sa</name><operator>.</operator><name>sa_flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sigaction</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sa</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>






<expr_stmt><expr><name>now</name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>strftime</name><argument_list>(<argument><expr><name>tmpdir_timestamp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tmpdir_timestamp</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><literal type="string">"%Y-%m-%dT%H.%M.%S"</literal></expr></argument>,
<argument><expr><call><name>localtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>now</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>tmpdir</name></expr></argument>, <argument><expr><literal type="string">"%s/%s.%s-%03d"</literal></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>progname</name></expr></argument>,
<argument><expr><name>tmpdir_timestamp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>assertMakeDir</name><argument_list>(<argument><expr><name>tmpdir</name></expr></argument>,<argument><expr><literal type="number">0755</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <literal type="number">999</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"ERROR: Unable to create temp directory %s\n"</literal></expr></argument>,
<argument><expr><name>tmpdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>






<expr_stmt><expr><name>refdir</name> <operator>=</operator> <name>refdir_alloc</name> <operator>=</operator> <call><name>get_refdir</name><argument_list>(<argument><expr><name>refdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"If tests fail or crash, details will be in:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %s\n"</literal></expr></argument>, <argument><expr><name>tmpdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>verbosity</name> <operator>&gt;</operator> <name>VERBOSITY_SUMMARY_ONLY</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Reference files will be read from: %s\n"</literal></expr></argument>, <argument><expr><name>refdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PROGRAM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Running tests on: %s\n"</literal></expr></argument>, <argument><expr><name>testprog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Exercising: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>EXTRA_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Running "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>




<expr_stmt><expr><name>saved_argv</name> <operator>=</operator> <name>argv</name></expr>;</expr_stmt>
<do>do <block>{<block_content>
<expr_stmt><expr><name>argv</name> <operator>=</operator> <name>saved_argv</name></expr>;</expr_stmt>
<do>do <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>test_num</name></decl>;</decl_stmt>

<expr_stmt><expr><name>test_num</name> <operator>=</operator> <call><name>get_test_set</name><argument_list>(<argument><expr><name>test_set</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>, <argument><expr><operator>*</operator><name>argv</name></expr></argument>, <argument><expr><name>tests</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>test_num</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"*** INVALID Test %s\n"</literal></expr></argument>, <argument><expr><operator>*</operator><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>refdir_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>testprogdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>usage</name><argument_list>(<argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>test_num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>tests_run</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>test_run</name><argument_list>(<argument><expr><name><name>test_set</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>tmpdir</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tests_failed</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>until_failure</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>finish</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>argv</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>argv</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block> while <condition>(<expr><operator>*</operator><name>argv</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>;</do>
</block_content>}</block> while <condition>(<expr><name>until_failure</name></expr>)</condition>;</do>

<label><name>finish</name>:</label>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tmp2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>testprogdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>pwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<if_stmt><if>if <condition>(<expr><name>verbosity</name> <operator>&gt;</operator> <name>VERBOSITY_SUMMARY_ONLY</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Totals:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Tests run: %8d\n"</literal></expr></argument>, <argument><expr><name>tests_run</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Tests failed: %8d\n"</literal></expr></argument>, <argument><expr><name>tests_failed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Assertions checked:%8d\n"</literal></expr></argument>, <argument><expr><name>assertions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Assertions failed: %8d\n"</literal></expr></argument>, <argument><expr><name>failures</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" Skips reported: %8d\n"</literal></expr></argument>, <argument><expr><name>skips</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>failures</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Failing tests:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>limit</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>failures</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %d: %s (%d failures)\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>,
<argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>failures</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Details for failing tests: %s\n"</literal></expr></argument>, <argument><expr><name>tmpdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>verbosity</name> <operator>==</operator> <name>VERBOSITY_SUMMARY_ONLY</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%d tests passed, no failures\n"</literal></expr></argument>, <argument><expr><name>tests_run</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>refdir_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><call><name>assertChdir</name><argument_list>(<argument><expr><literal type="string">".."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rmdir</name><argument_list>(<argument><expr><name>tmpdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><ternary><condition><expr><name>tests_failed</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>
</unit>
