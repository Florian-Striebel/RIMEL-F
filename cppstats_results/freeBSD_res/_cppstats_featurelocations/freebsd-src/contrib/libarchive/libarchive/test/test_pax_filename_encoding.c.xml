<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/libarchive/libarchive/test/test_pax_filename_encoding.c">























<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"test.h"</cpp:file></cpp:include>
<expr_stmt><expr><call><name>__FBSDID</name><argument_list>(<argument><expr><literal type="string">"$FreeBSD$"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;locale.h&gt;</cpp:file></cpp:include>














<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_pax_filename_encoding_1</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>testname</name><index>[]</index></name> <init>= <expr><literal type="string">"test_pax_filename_encoding.tar"</literal></expr></init></decl>;</decl_stmt>




<decl_stmt><decl><type><name>char</name></type> <name><name>filename</name><index>[]</index></name> <init>= <expr><literal type="string">"abc\314\214mno\374xyz"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>archive</name></name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>archive_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>




<expr_stmt><expr><call><name>extract_reference_file</name><argument_list>(<argument><expr><name>testname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>archive_read_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualInt</name><argument_list>(<argument><expr><name>ARCHIVE_OK</name></expr></argument>, <argument><expr><call><name>archive_read_support_format_tar</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualInt</name><argument_list>(<argument><expr><name>ARCHIVE_OK</name></expr></argument>, <argument><expr><call><name>archive_read_support_filter_all</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualInt</name><argument_list>(<argument><expr><name>ARCHIVE_OK</name></expr></argument>,
<argument><expr><call><name>archive_read_open_filename</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>testname</name></expr></argument>, <argument><expr><literal type="number">10240</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><call><name>failure</name><argument_list>(<argument><expr><literal type="string">"Invalid UTF8 in a pax archive pathname should cause a warning"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualInt</name><argument_list>(<argument><expr><name>ARCHIVE_WARN</name></expr></argument>, <argument><expr><call><name>archive_read_next_header</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualString</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><call><name>archive_entry_pathname</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><call><name>failure</name><argument_list>(<argument><expr><literal type="string">"A pathname with hdrcharset=BINARY can have invalid UTF8\n"</literal>
<literal type="string">" characters in it without generating a warning"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualInt</name><argument_list>(<argument><expr><name>ARCHIVE_OK</name></expr></argument>, <argument><expr><call><name>archive_read_next_header</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualString</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><call><name>archive_entry_pathname</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_read_free</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_pax_filename_encoding_2</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>filename</name><index>[]</index></name> <init>= <expr><literal type="string">"abc\314\214mno\374xyz"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>archive</name></name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>archive_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buff</name><index>[<expr><literal type="number">65536</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>longname</name><index>[]</index></name> <init>= <expr><literal type="string">"abc\314\214mno\374xyz"</literal>
<literal type="string">"/abc\314\214mno\374xyz/abcdefghijklmnopqrstuvwxyz"</literal>
<literal type="string">"/abc\314\214mno\374xyz/abcdefghijklmnopqrstuvwxyz"</literal>
<literal type="string">"/abc\314\214mno\374xyz/abcdefghijklmnopqrstuvwxyz"</literal>
<literal type="string">"/abc\314\214mno\374xyz/abcdefghijklmnopqrstuvwxyz"</literal>
<literal type="string">"/abc\314\214mno\374xyz/abcdefghijklmnopqrstuvwxyz"</literal>
<literal type="string">"/abc\314\214mno\374xyz/abcdefghijklmnopqrstuvwxyz"</literal></expr></init></decl>
;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>used</name></decl>;</decl_stmt>






<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <call><name>setlocale</name><argument_list>(<argument><expr><name>LC_ALL</name></expr></argument>, <argument><expr><literal type="string">"en_US.UTF-8"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>skipping</name><argument_list>(<argument><expr><literal type="string">"invalid encoding tests require a suitable locale;"</literal>
<literal type="string">" en_US.UTF-8 not available on this system"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>a</name> <operator>=</operator> <call><name>archive_write_new</name><argument_list>()</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualIntA</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>archive_write_set_format_pax</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualIntA</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>archive_write_add_filter_none</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualIntA</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>archive_write_set_bytes_per_block</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualInt</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,
<argument><expr><call><name>archive_write_open_memory</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>used</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>entry</name> <operator>=</operator> <call><name>archive_entry_new</name><argument_list>()</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>archive_entry_copy_pathname</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_entry_copy_gname</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_entry_copy_uname</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_entry_copy_hardlink</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_entry_set_filetype</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>AE_IFREG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure</name><argument_list>(<argument><expr><literal type="string">"This should generate a warning for nonconvertible names."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualInt</name><argument_list>(<argument><expr><name>ARCHIVE_WARN</name></expr></argument>, <argument><expr><call><name>archive_write_header</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_entry_free</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>entry</name> <operator>=</operator> <call><name>archive_entry_new</name><argument_list>()</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>archive_entry_copy_pathname</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_entry_copy_gname</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_entry_copy_uname</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_entry_copy_symlink</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_entry_set_filetype</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>AE_IFLNK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure</name><argument_list>(<argument><expr><literal type="string">"This should generate a warning for nonconvertible names."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualInt</name><argument_list>(<argument><expr><name>ARCHIVE_WARN</name></expr></argument>, <argument><expr><call><name>archive_write_header</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_entry_free</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>entry</name> <operator>=</operator> <call><name>archive_entry_new</name><argument_list>()</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>archive_entry_copy_pathname</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>longname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_entry_set_filetype</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>AE_IFREG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>failure</name><argument_list>(<argument><expr><literal type="string">"This should generate a warning for nonconvertible names."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualInt</name><argument_list>(<argument><expr><name>ARCHIVE_WARN</name></expr></argument>, <argument><expr><call><name>archive_write_header</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_entry_free</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assertEqualIntA</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>ARCHIVE_OK</name></expr></argument>, <argument><expr><call><name>archive_write_close</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualInt</name><argument_list>(<argument><expr><name>ARCHIVE_OK</name></expr></argument>, <argument><expr><call><name>archive_write_free</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>a</name> <operator>=</operator> <call><name>archive_read_new</name><argument_list>()</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualInt</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>archive_read_support_format_tar</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualInt</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>archive_read_open_memory</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><name>used</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assertEqualInt</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>archive_read_next_header</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualString</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><call><name>archive_entry_pathname</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualString</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><call><name>archive_entry_gname</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualString</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><call><name>archive_entry_uname</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualString</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><call><name>archive_entry_hardlink</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assertEqualInt</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>archive_read_next_header</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualString</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><call><name>archive_entry_pathname</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualString</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><call><name>archive_entry_gname</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualString</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><call><name>archive_entry_uname</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualString</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><call><name>archive_entry_symlink</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assertEqualInt</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>archive_read_next_header</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualString</name><argument_list>(<argument><expr><name>longname</name></expr></argument>, <argument><expr><call><name>archive_entry_pathname</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assertEqualIntA</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>ARCHIVE_OK</name></expr></argument>, <argument><expr><call><name>archive_read_close</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualInt</name><argument_list>(<argument><expr><name>ARCHIVE_OK</name></expr></argument>, <argument><expr><call><name>archive_read_free</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>






static void
test_pax_filename_encoding_3(void)
{
wchar_t badname[] = L"xxxAyyyBzzz";
const char badname_utf8[] = "xxx\xE1\x88\xB4yyy\xE5\x99\xB8zzz";
struct archive *a;
struct archive_entry *entry;
char buff[65536];
size_t used;

badname[3] = 0x1234;
badname[7] = 0x5678;


if (NULL == setlocale(LC_ALL, "C")) {
skipping("Can't set \"C\" locale, so can't exercise "
"certain character-conversion failures");
return;
}


if (wctomb(buff, 0x1234) &gt; 0) {
skipping("Cannot test conversion failures because \"C\" "
"locale on this system has no invalid characters.");
return;
}


if (wctomb(buff, 0x1234) &gt; 0) {
skipping("Cannot test conversion failures because \"C\" "
"locale on this system has no invalid characters.");
return;
}




entry = archive_entry_new();
if (archive_entry_update_pathname_utf8(entry, badname_utf8)) {
archive_entry_free(entry);
skipping("Cannot test conversion failures.");
return;
}
archive_entry_free(entry);

assert((a = archive_write_new()) != NULL);
assertEqualIntA(a, 0, archive_write_set_format_pax(a));
assertEqualIntA(a, 0, archive_write_add_filter_none(a));
assertEqualIntA(a, 0, archive_write_set_bytes_per_block(a, 0));
assertEqualInt(0,
archive_write_open_memory(a, buff, sizeof(buff), &amp;used));

assert((entry = archive_entry_new()) != NULL);

archive_entry_copy_pathname_w(entry, badname);
archive_entry_set_filetype(entry, AE_IFREG);
assertEqualInt(ARCHIVE_OK, archive_write_header(a, entry));
archive_entry_free(entry);

assert((entry = archive_entry_new()) != NULL);
archive_entry_copy_pathname_w(entry, L"abc");

archive_entry_copy_gname_w(entry, badname);
archive_entry_set_filetype(entry, AE_IFREG);
assertEqualInt(ARCHIVE_OK, archive_write_header(a, entry));
archive_entry_free(entry);

assert((entry = archive_entry_new()) != NULL);
archive_entry_copy_pathname_w(entry, L"abc");

archive_entry_copy_uname_w(entry, badname);
archive_entry_set_filetype(entry, AE_IFREG);
assertEqualInt(ARCHIVE_OK, archive_write_header(a, entry));
archive_entry_free(entry);

assert((entry = archive_entry_new()) != NULL);
archive_entry_copy_pathname_w(entry, L"abc");

archive_entry_copy_hardlink_w(entry, badname);
archive_entry_set_filetype(entry, AE_IFREG);
assertEqualInt(ARCHIVE_OK, archive_write_header(a, entry));
archive_entry_free(entry);

assert((entry = archive_entry_new()) != NULL);
archive_entry_copy_pathname_w(entry, L"abc");

archive_entry_copy_symlink_w(entry, badname);
archive_entry_set_filetype(entry, AE_IFLNK);
assertEqualInt(ARCHIVE_OK, archive_write_header(a, entry));
archive_entry_free(entry);

assertEqualIntA(a, ARCHIVE_OK, archive_write_close(a));
assertEqualInt(ARCHIVE_OK, archive_write_free(a));





assert((a = archive_read_new()) != NULL);
assertEqualInt(0, archive_read_support_format_tar(a));
assertEqualInt(0, archive_read_open_memory(a, buff, used));

failure("A non-convertible pathname should cause a warning.");
assertEqualInt(ARCHIVE_WARN, archive_read_next_header(a, &amp;entry));
assertEqualWString(badname, archive_entry_pathname_w(entry));
failure("If native locale can't convert, we should get UTF-8 back.");
assertEqualString(badname_utf8, archive_entry_pathname(entry));

failure("A non-convertible gname should cause a warning.");
assertEqualInt(ARCHIVE_WARN, archive_read_next_header(a, &amp;entry));
assertEqualWString(badname, archive_entry_gname_w(entry));
failure("If native locale can't convert, we should get UTF-8 back.");
assertEqualString(badname_utf8, archive_entry_gname(entry));

failure("A non-convertible uname should cause a warning.");
assertEqualInt(ARCHIVE_WARN, archive_read_next_header(a, &amp;entry));
assertEqualWString(badname, archive_entry_uname_w(entry));
failure("If native locale can't convert, we should get UTF-8 back.");
assertEqualString(badname_utf8, archive_entry_uname(entry));

failure("A non-convertible hardlink should cause a warning.");
assertEqualInt(ARCHIVE_WARN, archive_read_next_header(a, &amp;entry));
assertEqualWString(badname, archive_entry_hardlink_w(entry));
failure("If native locale can't convert, we should get UTF-8 back.");
assertEqualString(badname_utf8, archive_entry_hardlink(entry));

failure("A non-convertible symlink should cause a warning.");
assertEqualInt(ARCHIVE_WARN, archive_read_next_header(a, &amp;entry));
assertEqualWString(badname, archive_entry_symlink_w(entry));
assertEqualWString(NULL, archive_entry_hardlink_w(entry));
failure("If native locale can't convert, we should get UTF-8 back.");
assertEqualString(badname_utf8, archive_entry_symlink(entry));

assertEqualInt(ARCHIVE_EOF, archive_read_next_header(a, &amp;entry));

assertEqualIntA(a, ARCHIVE_OK, archive_read_close(a));
assertEqualInt(ARCHIVE_OK, archive_read_free(a));
}
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>test_pax_filename_encoding_3</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>




<macro><name>DEFINE_TEST</name><argument_list>(<argument>test_pax_filename_encoding_KOI8R</argument>)</argument_list></macro>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>archive</name></name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>archive_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buff</name><index>[<expr><literal type="number">4096</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>used</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <call><name>setlocale</name><argument_list>(<argument><expr><name>LC_ALL</name></expr></argument>, <argument><expr><literal type="string">"ru_RU.KOI8-R"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>skipping</name><argument_list>(<argument><expr><literal type="string">"KOI8-R locale not available on this system."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>archive_write_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualInt</name><argument_list>(<argument><expr><name>ARCHIVE_OK</name></expr></argument>, <argument><expr><call><name>archive_write_set_format_pax</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>archive_write_set_options</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"hdrcharset=UTF-8"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ARCHIVE_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>skipping</name><argument_list>(<argument><expr><literal type="string">"This system cannot convert character-set"</literal>
<literal type="string">" from KOI8-R to UTF-8."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_write_free</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>archive_write_free</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>archive_write_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualInt</name><argument_list>(<argument><expr><name>ARCHIVE_OK</name></expr></argument>, <argument><expr><call><name>archive_write_set_format_pax</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualInt</name><argument_list>(<argument><expr><name>ARCHIVE_OK</name></expr></argument>,
<argument><expr><call><name>archive_write_open_memory</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>used</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>archive_entry_new2</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_entry_set_pathname</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><literal type="string">"\xD0\xD2\xC9"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_entry_set_filetype</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>AE_IFREG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_entry_set_size</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualInt</name><argument_list>(<argument><expr><name>ARCHIVE_OK</name></expr></argument>, <argument><expr><call><name>archive_write_header</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_entry_free</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualInt</name><argument_list>(<argument><expr><name>ARCHIVE_OK</name></expr></argument>, <argument><expr><call><name>archive_write_free</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><call><name>assertEqualMem</name><argument_list>(<argument><expr><name>buff</name> <operator>+</operator> <literal type="number">512</literal></expr></argument>, <argument><expr><literal type="string">"15 path=\xD0\xBF\xD1\x80\xD0\xB8\x0A"</literal></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>




<macro><name>DEFINE_TEST</name><argument_list>(<argument>test_pax_filename_encoding_CP1251</argument>)</argument_list></macro>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>archive</name></name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>archive_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buff</name><index>[<expr><literal type="number">4096</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>used</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <call><name>setlocale</name><argument_list>(<argument><expr><name>LC_ALL</name></expr></argument>, <argument><expr><literal type="string">"Russian_Russia"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<name>NULL</name> <operator>==</operator> <call><name>setlocale</name><argument_list>(<argument><expr><name>LC_ALL</name></expr></argument>, <argument><expr><literal type="string">"ru_RU.CP1251"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>skipping</name><argument_list>(<argument><expr><literal type="string">"KOI8-R locale not available on this system."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>archive_write_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualInt</name><argument_list>(<argument><expr><name>ARCHIVE_OK</name></expr></argument>, <argument><expr><call><name>archive_write_set_format_pax</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>archive_write_set_options</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"hdrcharset=UTF-8"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ARCHIVE_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>skipping</name><argument_list>(<argument><expr><literal type="string">"This system cannot convert character-set"</literal>
<literal type="string">" from KOI8-R to UTF-8."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_write_free</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>archive_write_free</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>archive_write_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualInt</name><argument_list>(<argument><expr><name>ARCHIVE_OK</name></expr></argument>, <argument><expr><call><name>archive_write_set_format_pax</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualInt</name><argument_list>(<argument><expr><name>ARCHIVE_OK</name></expr></argument>,
<argument><expr><call><name>archive_write_open_memory</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>used</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>archive_entry_new2</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_entry_set_pathname</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><literal type="string">"\xef\xf0\xe8"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_entry_set_filetype</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>AE_IFREG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_entry_set_size</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualInt</name><argument_list>(<argument><expr><name>ARCHIVE_OK</name></expr></argument>, <argument><expr><call><name>archive_write_header</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_entry_free</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualInt</name><argument_list>(<argument><expr><name>ARCHIVE_OK</name></expr></argument>, <argument><expr><call><name>archive_write_free</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><call><name>assertEqualMem</name><argument_list>(<argument><expr><name>buff</name> <operator>+</operator> <literal type="number">512</literal></expr></argument>, <argument><expr><literal type="string">"15 path=\xD0\xBF\xD1\x80\xD0\xB8\x0A"</literal></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>




<macro><name>DEFINE_TEST</name><argument_list>(<argument>test_pax_filename_encoding_EUCJP</argument>)</argument_list></macro>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>archive</name></name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>archive_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buff</name><index>[<expr><literal type="number">4096</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>used</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <call><name>setlocale</name><argument_list>(<argument><expr><name>LC_ALL</name></expr></argument>, <argument><expr><literal type="string">"ja_JP.eucJP"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>skipping</name><argument_list>(<argument><expr><literal type="string">"eucJP locale not available on this system."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>archive_write_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualInt</name><argument_list>(<argument><expr><name>ARCHIVE_OK</name></expr></argument>, <argument><expr><call><name>archive_write_set_format_pax</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>archive_write_set_options</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"hdrcharset=UTF-8"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ARCHIVE_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>skipping</name><argument_list>(<argument><expr><literal type="string">"This system cannot convert character-set"</literal>
<literal type="string">" from eucJP to UTF-8."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_write_free</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>archive_write_free</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>archive_write_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualInt</name><argument_list>(<argument><expr><name>ARCHIVE_OK</name></expr></argument>, <argument><expr><call><name>archive_write_set_format_pax</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualInt</name><argument_list>(<argument><expr><name>ARCHIVE_OK</name></expr></argument>,
<argument><expr><call><name>archive_write_open_memory</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>used</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>archive_entry_new2</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_entry_set_pathname</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><literal type="string">"\xC9\xBD.txt"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>archive_entry_set_filetype</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>AE_IFREG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_entry_set_size</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualInt</name><argument_list>(<argument><expr><name>ARCHIVE_OK</name></expr></argument>, <argument><expr><call><name>archive_write_header</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_entry_free</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualInt</name><argument_list>(<argument><expr><name>ARCHIVE_OK</name></expr></argument>, <argument><expr><call><name>archive_write_free</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>assertEqualMem</name><argument_list>(<argument><expr><name>buff</name> <operator>+</operator> <literal type="number">512</literal></expr></argument>, <argument><expr><literal type="string">"16 path=\xE8\xA1\xA8.txt\x0A"</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>




<macro><name>DEFINE_TEST</name><argument_list>(<argument>test_pax_filename_encoding_CP932</argument>)</argument_list></macro>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>archive</name></name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>archive_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buff</name><index>[<expr><literal type="number">4096</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>used</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <call><name>setlocale</name><argument_list>(<argument><expr><name>LC_ALL</name></expr></argument>, <argument><expr><literal type="string">"Japanese_Japan"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<name>NULL</name> <operator>==</operator> <call><name>setlocale</name><argument_list>(<argument><expr><name>LC_ALL</name></expr></argument>, <argument><expr><literal type="string">"ja_JP.SJIS"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>skipping</name><argument_list>(<argument><expr><literal type="string">"eucJP locale not available on this system."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>archive_write_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualInt</name><argument_list>(<argument><expr><name>ARCHIVE_OK</name></expr></argument>, <argument><expr><call><name>archive_write_set_format_pax</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>archive_write_set_options</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"hdrcharset=UTF-8"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ARCHIVE_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>skipping</name><argument_list>(<argument><expr><literal type="string">"This system cannot convert character-set"</literal>
<literal type="string">" from CP932/SJIS to UTF-8."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_write_free</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>archive_write_free</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>archive_write_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualInt</name><argument_list>(<argument><expr><name>ARCHIVE_OK</name></expr></argument>, <argument><expr><call><name>archive_write_set_format_pax</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualInt</name><argument_list>(<argument><expr><name>ARCHIVE_OK</name></expr></argument>,
<argument><expr><call><name>archive_write_open_memory</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>used</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>archive_entry_new2</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_entry_set_pathname</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><literal type="string">"\x95\x5C.txt"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>archive_entry_set_filetype</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>AE_IFREG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_entry_set_size</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualInt</name><argument_list>(<argument><expr><name>ARCHIVE_OK</name></expr></argument>, <argument><expr><call><name>archive_write_header</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_entry_free</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualInt</name><argument_list>(<argument><expr><name>ARCHIVE_OK</name></expr></argument>, <argument><expr><call><name>archive_write_free</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>assertEqualMem</name><argument_list>(<argument><expr><name>buff</name> <operator>+</operator> <literal type="number">512</literal></expr></argument>, <argument><expr><literal type="string">"16 path=\xE8\xA1\xA8.txt\x0A"</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>





<macro><name>DEFINE_TEST</name><argument_list>(<argument>test_pax_filename_encoding_KOI8R_BINARY</argument>)</argument_list></macro>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>archive</name></name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>archive_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buff</name><index>[<expr><literal type="number">4096</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>used</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <call><name>setlocale</name><argument_list>(<argument><expr><name>LC_ALL</name></expr></argument>, <argument><expr><literal type="string">"ru_RU.KOI8-R"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>skipping</name><argument_list>(<argument><expr><literal type="string">"KOI8-R locale not available on this system."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>archive_write_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualInt</name><argument_list>(<argument><expr><name>ARCHIVE_OK</name></expr></argument>, <argument><expr><call><name>archive_write_set_format_pax</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assertEqualInt</name><argument_list>(<argument><expr><name>ARCHIVE_OK</name></expr></argument>,
<argument><expr><call><name>archive_write_set_options</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"hdrcharset=BINARY"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualInt</name><argument_list>(<argument><expr><name>ARCHIVE_OK</name></expr></argument>,
<argument><expr><call><name>archive_write_open_memory</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>used</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>archive_entry_new2</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_entry_set_pathname</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><literal type="string">"\xD0\xD2\xC9"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_entry_set_filetype</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>AE_IFREG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_entry_set_size</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualInt</name><argument_list>(<argument><expr><name>ARCHIVE_OK</name></expr></argument>, <argument><expr><call><name>archive_write_header</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_entry_free</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualInt</name><argument_list>(<argument><expr><name>ARCHIVE_OK</name></expr></argument>, <argument><expr><call><name>archive_write_free</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>assertEqualMem</name><argument_list>(<argument><expr><name>buff</name> <operator>+</operator> <literal type="number">512</literal></expr></argument>, <argument><expr><literal type="string">"21 hdrcharset=BINARY\x0A"</literal></expr></argument>, <argument><expr><literal type="number">21</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>assertEqualMem</name><argument_list>(<argument><expr><name>buff</name> <operator>+</operator> <literal type="number">512</literal><operator>+</operator><literal type="number">21</literal></expr></argument>, <argument><expr><literal type="string">"12 path=\xD0\xD2\xC9\x0A"</literal></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>





<macro><name>DEFINE_TEST</name><argument_list>(<argument>test_pax_filename_encoding_KOI8R_CP1251</argument>)</argument_list></macro>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>archive</name></name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <call><name>setlocale</name><argument_list>(<argument><expr><name>LC_ALL</name></expr></argument>, <argument><expr><literal type="string">"ru_RU.KOI8-R"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>skipping</name><argument_list>(<argument><expr><literal type="string">"KOI8-R locale not available on this system."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>archive_write_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualInt</name><argument_list>(<argument><expr><name>ARCHIVE_OK</name></expr></argument>, <argument><expr><call><name>archive_write_set_format_pax</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assertEqualInt</name><argument_list>(<argument><expr><name>ARCHIVE_FAILED</name></expr></argument>,
<argument><expr><call><name>archive_write_set_options</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"hdrcharset=CP1251"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assertEqualInt</name><argument_list>(<argument><expr><name>ARCHIVE_OK</name></expr></argument>, <argument><expr><call><name>archive_write_free</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>


<macro><name>DEFINE_TEST</name><argument_list>(<argument>test_pax_filename_encoding</argument>)</argument_list></macro>
<block>{<block_content>
<expr_stmt><expr><call><name>test_pax_filename_encoding_1</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>test_pax_filename_encoding_2</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>test_pax_filename_encoding_3</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
</unit>
