<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/libarchive/libarchive/archive_read_support_format_zip.c">


























<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"archive_platform.h"</cpp:file></cpp:include>
<expr_stmt><expr><call><name>__FBSDID</name><argument_list>(<argument><expr><literal type="string">"$FreeBSD$"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
















<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_ERRNO_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STDLIB_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_ZLIB_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;zlib.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_BZLIB_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;bzlib.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LZMA_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;lzma.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"archive.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"archive_digest_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"archive_cryptor_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"archive_endian.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"archive_entry.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"archive_entry_locale.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"archive_hmac_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"archive_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"archive_rb.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"archive_read_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"archive_ppmd8_private.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_ZLIB_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"archive_crc32.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<struct>struct <name>zip_entry</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>archive_rb_node</name></name></type> <name>node</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>zip_entry</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>local_header_offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>compressed_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>uncompressed_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>gid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>uid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>archive_string</name></name></type> <name>rsrcname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>time_t</name></type> <name>mtime</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>time_t</name></type> <name>atime</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>time_t</name></type> <name>ctime</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>crc32</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint16_t</name></type> <name>mode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint16_t</name></type> <name>zip_flags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>compression</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>system</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>flags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>decdat</name></decl>;</decl_stmt>



<struct>struct <block>{

<decl_stmt><decl><type><name>unsigned</name></type> <name>vendor</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AES_VENDOR_AE_1</name></cpp:macro> <cpp:value>0x0001</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AES_VENDOR_AE_2</name></cpp:macro> <cpp:value>0x0002</cpp:value></cpp:define>


<decl_stmt><decl><type><name>unsigned</name></type> <name>strength</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>compression</name></decl>;</decl_stmt>
}</block> <decl><name>aes_extra</name></decl>;</struct>
}</block>;</struct>

<struct>struct <name>trad_enc_ctx</name> <block>{
<decl_stmt><decl><type><name>uint32_t</name></type> <name><name>keys</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIP_ENCRYPTED</name></cpp:macro> <cpp:value>(1 &lt;&lt; 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIP_LENGTH_AT_END</name></cpp:macro> <cpp:value>(1 &lt;&lt; 3)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIP_STRONG_ENCRYPTED</name></cpp:macro> <cpp:value>(1 &lt;&lt; 6)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIP_UTF8_NAME</name></cpp:macro> <cpp:value>(1 &lt;&lt; 11)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIP_CENTRAL_DIRECTORY_ENCRYPTED</name></cpp:macro> <cpp:value>(1 &lt;&lt; 13)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LA_USED_ZIP64</name></cpp:macro> <cpp:value>(1 &lt;&lt; 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LA_FROM_CENTRAL_DIRECTORY</name></cpp:macro> <cpp:value>(1 &lt;&lt; 1)</cpp:value></cpp:define>






<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WINZIP_AES_ENCRYPTION</name></cpp:macro> <cpp:value>99</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AUTH_CODE_SIZE</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_DERIVED_KEY_BUF_SIZE</name></cpp:macro> <cpp:value>(AES_MAX_KEY_SIZE * 2 + 2)</cpp:value></cpp:define>

<struct>struct <name>zip</name> <block>{

<decl_stmt><decl><type><name><name>struct</name> <name>archive_string</name></name></type> <name>format_name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>central_directory_offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>central_directory_offset_adjusted</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>central_directory_entries_total</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>central_directory_entries_on_this_disk</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>has_encrypted_entries</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name><name>struct</name> <name>zip_entry</name></name> <modifier>*</modifier></type><name>zip_entries</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>archive_rb_tree</name></name></type> <name>tree</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>archive_rb_tree</name></name></type> <name>tree_rsrc</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>size_t</name></type> <name>unconsumed</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name><name>struct</name> <name>zip_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>entry_bytes_remaining</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>int64_t</name></type> <name>entry_compressed_bytes_read</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>entry_uncompressed_bytes_read</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>entry_crc32</name></decl>;</decl_stmt>
<function_decl><type><name>unsigned</name> <name>long</name></type> (<modifier>*</modifier><name>crc32func</name>)<parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>long</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>,
<parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>char</name></type> <name>ignore_crc32</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>char</name></type> <name>decompress_init</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>end_of_entry</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>uncompressed_buffer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>uncompressed_buffer_size</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_ZLIB_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>z_stream</name></type> <name>stream</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>stream_valid</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_LZMA_H</name> <operator>&amp;&amp;</operator> <name>HAVE_LIBLZMA</name></expr></cpp:if>
<decl_stmt><decl><type><name>lzma_stream</name></type> <name>zipx_lzma_stream</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>zipx_lzma_valid</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_BZLIB_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>bz_stream</name></type> <name>bzstream</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>bzstream_valid</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>IByteIn</name></type> <name>zipx_ppmd_stream</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>zipx_ppmd_read_compressed</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CPpmd8</name></type> <name>ppmd8</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>ppmd8_valid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>ppmd8_stream_failed</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>archive_string_conv</name></name> <modifier>*</modifier></type><name>sconv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>archive_string_conv</name></name> <modifier>*</modifier></type><name>sconv_default</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>archive_string_conv</name></name> <modifier>*</modifier></type><name>sconv_utf8</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>init_default_conversion</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>process_mac_extensions</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name>init_decryption</name></decl>;</decl_stmt>










<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>decrypted_buffer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>decrypted_ptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>decrypted_buffer_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>decrypted_bytes_remaining</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>decrypted_unconsumed_bytes</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name><name>struct</name> <name>trad_enc_ctx</name></name></type> <name>tctx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>tctx_valid</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>archive_crypto_ctx</name></type> <name>cctx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>cctx_valid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>archive_hmac_sha1_ctx</name></type> <name>hctx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>hctx_valid</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>iv_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>alg_id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>bit_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>flags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>erd_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>v_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>v_crc32</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>iv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>erd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>v_data</name></decl>;</decl_stmt>
}</block>;</struct>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>zipmin</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((a) &lt; (b) ? (a) : (b))</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_ZLIB_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>static</specifier> <name>int</name></type>
<name>zip_read_data_deflate</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_read</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>buff</name></decl></parameter>,
<parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>size</name></decl></parameter>, <parameter><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>offset</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_LZMA_H</name> <operator>&amp;&amp;</operator> <name>HAVE_LIBLZMA</name></expr></cpp:if>
<function_decl><type><specifier>static</specifier> <name>int</name></type>
<name>zip_read_data_zipx_lzma_alone</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_read</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>buff</name></decl></parameter>,
<parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>size</name></decl></parameter>, <parameter><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>offset</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>





<function><type><specifier>static</specifier> <name>Byte</name></type>
<name>ppmd_read</name><parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>archive_read</name></name> <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>(</operator><operator>(</operator><name>IByteIn</name><operator>*</operator><operator>)</operator><name>p</name><operator>)</operator><operator>-&gt;</operator><name>a</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>zip</name></name> <modifier>*</modifier></type><name>zip</name> <init>= <expr><operator>(</operator>struct <name>zip</name><operator>*</operator><operator>)</operator> <name><name>a</name><operator>-&gt;</operator><name>format</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>bytes_avail</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name><modifier>*</modifier></type> <name>data</name> <init>= <expr><call><name>__archive_read_ahead</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytes_avail</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>bytes_avail</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>ppmd8_stream_failed</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>__archive_read_consume</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><operator>++</operator><name><name>zip</name><operator>-&gt;</operator><name>zipx_ppmd_read_compressed</name></name></expr>;</expr_stmt>


<return>return <expr><name><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>void</name></type>
<name>trad_enc_update_keys</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>trad_enc_ctx</name></name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>t</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CRC32</name><parameter_list>(<parameter><type><name>c</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(crc32(c ^ 0xffffffffUL, &amp;b, 1) ^ 0xffffffffUL)</cpp:value></cpp:define>

<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>keys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>CRC32</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>keys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>keys</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>keys</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>keys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator><operator>)</operator> <operator>*</operator> <literal type="number">134775813L</literal> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>t</name> <operator>=</operator> <operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>keys</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">24</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>keys</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>CRC32</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>keys</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CRC32</name></cpp:undef>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint8_t</name></type>
<name>trad_enc_decrypt_byte</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>trad_enc_ctx</name></name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>temp</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>keys</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>|</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name>temp</name> <operator>*</operator> <operator>(</operator><name>temp</name> <operator>^</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>trad_enc_decrypt_update</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>trad_enc_ctx</name></name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>in</name></decl></parameter>,
<parameter><decl><type><name>size_t</name></type> <name>in_len</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>out_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>max</name></decl>;</decl_stmt>

<expr_stmt><expr><name>max</name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><ternary><condition><expr><operator>(</operator><name>in_len</name> <operator>&lt;</operator> <name>out_len</name><operator>)</operator></expr>?</condition><then> <expr><name>in_len</name></expr></then><else>: <expr><name>out_len</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>t</name> <init>= <expr><name><name>in</name><index>[<expr><name>i</name></expr>]</index></name> <operator>^</operator> <call><name>trad_enc_decrypt_byte</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>out</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>trad_enc_update_keys</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>trad_enc_init</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>trad_enc_ctx</name></name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pw</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>pw_len</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>key_len</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>crcchk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>header</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>key_len</name> <operator>&lt;</operator> <literal type="number">12</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>crcchk</name> <operator>=</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>keys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">305419896L</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>keys</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">591751049L</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>keys</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">878082192L</literal></expr>;</expr_stmt>

<for>for <control>(<init>;</init><condition><expr><name>pw_len</name></expr>;</condition> <incr><expr><operator>--</operator><name>pw_len</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>trad_enc_update_keys</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>*</operator><name>pw</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><call><name>trad_enc_decrypt_update</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>, <argument><expr><name>header</name></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>crcchk</name> <operator>=</operator> <name><name>header</name><index>[<expr><literal type="number">11</literal></expr>]</index></name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
static void
crypt_derive_key_sha1(const void *p, int size, unsigned char *key,
int key_size)
{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MD_SIZE</name></cpp:macro> <cpp:value>20</cpp:value></cpp:define>
archive_sha1_ctx ctx;
unsigned char md1[MD_SIZE];
unsigned char md2[MD_SIZE * 2];
unsigned char mkb[64];
int i;

archive_sha1_init(&amp;ctx);
archive_sha1_update(&amp;ctx, p, size);
archive_sha1_final(&amp;ctx, md1);

memset(mkb, 0x36, sizeof(mkb));
for (i = 0; i &lt; MD_SIZE; i++)
mkb[i] ^= md1[i];
archive_sha1_init(&amp;ctx);
archive_sha1_update(&amp;ctx, mkb, sizeof(mkb));
archive_sha1_final(&amp;ctx, md2);

memset(mkb, 0x5C, sizeof(mkb));
for (i = 0; i &lt; MD_SIZE; i++)
mkb[i] ^= md1[i];
archive_sha1_init(&amp;ctx);
archive_sha1_update(&amp;ctx, mkb, sizeof(mkb));
archive_sha1_final(&amp;ctx, md2 + MD_SIZE);

if (key_size &gt; 32)
key_size = 32;
memcpy(key, md2, key_size);
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MD_SIZE</name></cpp:undef>
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>








<function><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type>
<name>real_crc32</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>crc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>buff</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>crc32</name><argument_list>(<argument><expr><name>crc</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type>
<name>fake_crc32</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>crc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>buff</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>crc</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>buff</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>len</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<struct><specifier>static</specifier> <specifier>const</specifier> struct <block>{
<decl_stmt><decl><type><name>int</name></type> <name>id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>name</name></decl>;</decl_stmt>
}</block> <decl><name><name>compression_methods</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="string">"uncompressed"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">1</literal></expr>, <expr><literal type="string">"shrinking"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">2</literal></expr>, <expr><literal type="string">"reduced-1"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">3</literal></expr>, <expr><literal type="string">"reduced-2"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">4</literal></expr>, <expr><literal type="string">"reduced-3"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">5</literal></expr>, <expr><literal type="string">"reduced-4"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">6</literal></expr>, <expr><literal type="string">"imploded"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">7</literal></expr>, <expr><literal type="string">"reserved"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">8</literal></expr>, <expr><literal type="string">"deflation"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">9</literal></expr>, <expr><literal type="string">"deflation-64-bit"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">10</literal></expr>, <expr><literal type="string">"ibm-terse"</literal></expr>}</block></expr>,

<expr><block>{<expr><literal type="number">11</literal></expr>, <expr><literal type="string">"reserved"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">12</literal></expr>, <expr><literal type="string">"bzip"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">13</literal></expr>, <expr><literal type="string">"reserved"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">14</literal></expr>, <expr><literal type="string">"lzma"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">15</literal></expr>, <expr><literal type="string">"reserved"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">16</literal></expr>, <expr><literal type="string">"reserved"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">17</literal></expr>, <expr><literal type="string">"reserved"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">18</literal></expr>, <expr><literal type="string">"ibm-terse-new"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">19</literal></expr>, <expr><literal type="string">"ibm-lz777"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">95</literal></expr>, <expr><literal type="string">"xz"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">96</literal></expr>, <expr><literal type="string">"jpeg"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">97</literal></expr>, <expr><literal type="string">"wav-pack"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">98</literal></expr>, <expr><literal type="string">"ppmd-1"</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="number">99</literal></expr>, <expr><literal type="string">"aes"</literal></expr>}</block></expr>
}</block></expr></init></decl>;</struct>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>compression_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>compression</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>num_compression_methods</name> <init>=
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>compression_methods</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>compression_methods</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<while>while<condition>(<expr><name>compression</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name>num_compression_methods</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>compression_methods</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>id</name> <operator>==</operator> <name>compression</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>compression_methods</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><literal type="string">"??"</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>time_t</name></type>
<name>zip_time</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>msTime</name></decl>, <decl><type ref="prev"/><name>msDate</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>tm</name></name></type> <name>ts</name></decl>;</decl_stmt>

<expr_stmt><expr><name>msTime</name> <operator>=</operator> <operator>(</operator><literal type="number">0xff</literal> <operator>&amp;</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator> <operator>+</operator> <literal type="number">256</literal> <operator>*</operator> <operator>(</operator><literal type="number">0xff</literal> <operator>&amp;</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>msDate</name> <operator>=</operator> <operator>(</operator><literal type="number">0xff</literal> <operator>&amp;</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>)</operator> <operator>+</operator> <literal type="number">256</literal> <operator>*</operator> <operator>(</operator><literal type="number">0xff</literal> <operator>&amp;</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ts</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ts</name><operator>.</operator><name>tm_year</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>msDate</name> <operator>&gt;&gt;</operator> <literal type="number">9</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x7f</literal><operator>)</operator> <operator>+</operator> <literal type="number">80</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ts</name><operator>.</operator><name>tm_mon</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>msDate</name> <operator>&gt;&gt;</operator> <literal type="number">5</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x0f</literal><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ts</name><operator>.</operator><name>tm_mday</name></name> <operator>=</operator> <name>msDate</name> <operator>&amp;</operator> <literal type="number">0x1f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ts</name><operator>.</operator><name>tm_hour</name></name> <operator>=</operator> <operator>(</operator><name>msTime</name> <operator>&gt;&gt;</operator> <literal type="number">11</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x1f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ts</name><operator>.</operator><name>tm_min</name></name> <operator>=</operator> <operator>(</operator><name>msTime</name> <operator>&gt;&gt;</operator> <literal type="number">5</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3f</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ts</name><operator>.</operator><name>tm_sec</name></name> <operator>=</operator> <operator>(</operator><name>msTime</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3e</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ts</name><operator>.</operator><name>tm_isdst</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><call><name>mktime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ts</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>int</name></type>
<name>process_extra</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_read</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>archive_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>extra_length</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>zip_entry</name></name><modifier>*</modifier></type> <name>zip_entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>zip</name></name> <modifier>*</modifier></type><name>zip</name> <init>= <expr><operator>(</operator>struct <name>zip</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>format</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>extra_length</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>ARCHIVE_OK</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>extra_length</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>







<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>extra_length</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>,
<argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>,
<argument><expr><literal type="string">"Too-small extra data: "</literal>
<literal type="string">"Need at least 4 bytes, "</literal>
<literal type="string">"but only found %d bytes"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>extra_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ARCHIVE_FAILED</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<return>return <expr><name>ARCHIVE_OK</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><name>offset</name> <operator>&lt;=</operator> <name>extra_length</name> <operator>-</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>headerid</name> <init>= <expr><call><name>archive_le16dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>offset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>datasize</name> <init>= <expr><call><name>archive_le16dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>offset</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>offset</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>+</operator> <name>datasize</name> <operator>&gt;</operator> <name>extra_length</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>,
<argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>, <argument><expr><literal type="string">"Extra data overflow: "</literal>
<literal type="string">"Need %d bytes but only found %d bytes"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>datasize</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>extra_length</name> <operator>-</operator> <name>offset</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ARCHIVE_FAILED</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Header id 0x%04x, length %d\n"</literal></expr></argument>,
<argument><expr><name>headerid</name></expr></argument>, <argument><expr><name>datasize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<switch>switch <condition>(<expr><name>headerid</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0x0001</literal></expr>:</case>

<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>LA_USED_ZIP64</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip_entry</name><operator>-&gt;</operator><name>uncompressed_size</name></name> <operator>==</operator> <literal type="number">0xffffffff</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>t</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>datasize</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">8</literal>
<operator>||</operator> <operator>(</operator><name>t</name> <operator>=</operator> <name>archive_le64dec</name><operator>(</operator><name>p</name> <operator>+</operator> <name>offset</name><operator>)</operator><operator>)</operator></expr></argument> &gt;</argument_list></name>
<name>INT64_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>,
<argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>,
<argument><expr><literal type="string">"Malformed 64-bit "</literal>
<literal type="string">"uncompressed size"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ARCHIVE_FAILED</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>uncompressed_size</name></name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>datasize</name> <operator>-=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip_entry</name><operator>-&gt;</operator><name>compressed_size</name></name> <operator>==</operator> <literal type="number">0xffffffff</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>t</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>datasize</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">8</literal>
<operator>||</operator> <operator>(</operator><name>t</name> <operator>=</operator> <name>archive_le64dec</name><operator>(</operator><name>p</name> <operator>+</operator> <name>offset</name><operator>)</operator><operator>)</operator></expr></argument> &gt;</argument_list></name>
<name>INT64_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>,
<argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>,
<argument><expr><literal type="string">"Malformed 64-bit "</literal>
<literal type="string">"compressed size"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ARCHIVE_FAILED</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>compressed_size</name></name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>datasize</name> <operator>-=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip_entry</name><operator>-&gt;</operator><name>local_header_offset</name></name> <operator>==</operator> <literal type="number">0xffffffff</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>t</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>datasize</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">8</literal>
<operator>||</operator> <operator>(</operator><name>t</name> <operator>=</operator> <name>archive_le64dec</name><operator>(</operator><name>p</name> <operator>+</operator> <name>offset</name><operator>)</operator><operator>)</operator></expr></argument> &gt;</argument_list></name>
<name>INT64_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>,
<argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>,
<argument><expr><literal type="string">"Malformed 64-bit "</literal>
<literal type="string">"local header offset"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ARCHIVE_FAILED</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>local_header_offset</name></name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>datasize</name> <operator>-=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>



<break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><literal type="number">0x0017</literal></expr>:</case>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>archive_le16dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>offset</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>algId</name> <init>=
<expr><call><name>archive_le16dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>offset</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>bitLen</name> <init>=
<expr><call><name>archive_le16dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>offset</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>=
<expr><call><name>archive_le16dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>offset</name> <operator>+</operator> <literal type="number">6</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"algId=0x%04x, bitLen=%u, "</literal>
<literal type="string">"flgas=%d\n"</literal></expr></argument>, <argument><expr><name>algId</name></expr></argument>, <argument><expr><name>bitLen</name></expr></argument>,<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<case>case <expr><literal type="number">0x5455</literal></expr>:</case>
<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>datasize</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>,
<argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>,
<argument><expr><literal type="string">"Incomplete extended time field"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ARCHIVE_FAILED</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>flags</name> <operator>=</operator> <name><name>p</name><index>[<expr><name>offset</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>datasize</name><operator>--</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <literal type="number">0x01</literal></expr>)</condition>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"mtime: %lld -&gt; %d\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>long</name> <name>long</name><operator>)</operator><name><name>zip_entry</name><operator>-&gt;</operator><name>mtime</name></name></expr></argument>,
<argument><expr><call><name>archive_le32dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><name>datasize</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>mtime</name></name> <operator>=</operator> <call><name>archive_le32dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>datasize</name> <operator>-=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <literal type="number">0x02</literal></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>datasize</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>atime</name></name> <operator>=</operator> <call><name>archive_le32dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>datasize</name> <operator>-=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <literal type="number">0x04</literal></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>datasize</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>ctime</name></name> <operator>=</operator> <call><name>archive_le32dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>datasize</name> <operator>-=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><literal type="number">0x5855</literal></expr>:</case>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>datasize</name> <operator>&gt;=</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>atime</name></name> <operator>=</operator> <call><name>archive_le32dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>mtime</name></name> <operator>=</operator>
<call><name>archive_le32dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>offset</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>datasize</name> <operator>&gt;=</operator> <literal type="number">12</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>uid</name></name> <operator>=</operator>
<call><name>archive_le16dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>offset</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>gid</name></name> <operator>=</operator>
<call><name>archive_le16dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>offset</name> <operator>+</operator> <literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><literal type="number">0x6c78</literal></expr>:</case>
<block>{<block_content>




























<decl_stmt><decl><type><name>int</name></type> <name>bitmap</name></decl>, <decl><type ref="prev"/><name>bitmap_last</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>datasize</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>bitmap_last</name> <operator>=</operator> <name>bitmap</name> <operator>=</operator> <literal type="number">0xff</literal> <operator>&amp;</operator> <name><name>p</name><index>[<expr><name>offset</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>datasize</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>


<while>while <condition>(<expr><operator>(</operator><name>bitmap_last</name> <operator>&amp;</operator> <literal type="number">0x80</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal>
<operator>&amp;&amp;</operator> <name>datasize</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>bitmap_last</name> <operator>=</operator> <name><name>p</name><index>[<expr><name>offset</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>datasize</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>bitmap</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>datasize</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>system</name></name>
<operator>=</operator> <call><name>archive_le16dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>offset</name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>datasize</name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>bitmap</name> <operator>&amp;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>internal_attributes</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>datasize</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>internal_attributes</name>
<operator>=</operator> <call><name>archive_le16dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>internal_attributes</name></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>datasize</name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>bitmap</name> <operator>&amp;</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>external_attributes</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>datasize</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>external_attributes</name>
<operator>=</operator> <call><name>archive_le32dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip_entry</name><operator>-&gt;</operator><name>system</name></name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>mode</name></name>
<operator>=</operator> <name>external_attributes</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>zip_entry</name><operator>-&gt;</operator><name>system</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><literal type="number">0x10</literal> <operator>==</operator> <operator>(</operator><name>external_attributes</name> <operator>&amp;</operator>
<literal type="number">0x10</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator>
<name>AE_IFDIR</name> <operator>|</operator> <literal type="number">0775</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator>
<name>AE_IFREG</name> <operator>|</operator> <literal type="number">0664</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><literal type="number">0x01</literal> <operator>==</operator> <operator>(</operator><name>external_attributes</name> <operator>&amp;</operator>
<literal type="number">0x01</literal><operator>)</operator></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;=</operator> <literal type="number">0555</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>offset</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>datasize</name> <operator>-=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>bitmap</name> <operator>&amp;</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>comment_length</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>datasize</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>comment_length</name>
<operator>=</operator> <call><name>archive_le16dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>datasize</name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>datasize</name> <operator>&lt;</operator> <name>comment_length</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>comment_length</name></expr>;</expr_stmt>
<expr_stmt><expr><name>datasize</name> <operator>-=</operator> <name>comment_length</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><literal type="number">0x7075</literal></expr>:</case>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>datasize</name> <operator>&lt;</operator> <literal type="number">5</literal> <operator>||</operator> <name>entry</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>offset</name> <operator>+=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>datasize</name> <operator>-=</operator> <literal type="number">5</literal></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>sconv_utf8</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>sconv_utf8</name></name> <operator>=</operator>
<call><name>archive_string_conversion_from_charset</name><argument_list>(
<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><literal type="string">"UTF-8"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>sconv_utf8</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>zip</name><operator>-&gt;</operator><name>ignore_crc32</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cp</name> <init>= <expr><call><name>archive_entry_pathname</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>cp</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>file_crc</name> <init>=
<expr><call><name><name>zip</name><operator>-&gt;</operator><name>crc32func</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>cp</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>utf_crc</name> <init>=
<expr><call><name>archive_le32dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>offset</name> <operator>-</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>file_crc</name> <operator>!=</operator> <name>utf_crc</name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
<argument><expr><literal type="string">"CRC filename mismatch; "</literal>
<literal type="string">"CDE is %lx, but UTF8 "</literal>
<literal type="string">"is outdated with %lx\n"</literal></expr></argument>,
<argument><expr><name>file_crc</name></expr></argument>, <argument><expr><name>utf_crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>archive_entry_copy_pathname_l</name><argument_list>(<argument><expr><name>entry</name></expr></argument>,
<argument><expr><name>p</name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><name>datasize</name></expr></argument>, <argument><expr><name><name>zip</name><operator>-&gt;</operator><name>sconv_utf8</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Failed to read the ZIP "</literal>
<literal type="string">"0x7075 extra field path.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><literal type="number">0x7855</literal></expr>:</case>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"uid %d gid %d\n"</literal></expr></argument>,
<argument><expr><call><name>archive_le16dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>offset</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>archive_le16dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>offset</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><name>datasize</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>uid</name></name> <operator>=</operator> <call><name>archive_le16dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>datasize</name> <operator>&gt;=</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>gid</name></name> <operator>=</operator>
<call><name>archive_le16dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>offset</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><literal type="number">0x7875</literal></expr>:</case>
<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>uidsize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>gidsize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name>datasize</name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><name>offset</name></expr>]</index></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>datasize</name> <operator>&gt;=</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>uidsize</name> <operator>=</operator> <literal type="number">0xff</literal> <operator>&amp;</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>p</name><index>[<expr><name>offset</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>uidsize</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>uid</name></name> <operator>=</operator>
<call><name>archive_le16dec</name><argument_list>(
<argument><expr><name>p</name> <operator>+</operator> <name>offset</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>uidsize</name> <operator>==</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <name>datasize</name> <operator>&gt;=</operator> <literal type="number">6</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>uid</name></name> <operator>=</operator>
<call><name>archive_le32dec</name><argument_list>(
<argument><expr><name>p</name> <operator>+</operator> <name>offset</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>datasize</name> <operator>&gt;=</operator> <operator>(</operator><literal type="number">2</literal> <operator>+</operator> <name>uidsize</name> <operator>+</operator> <literal type="number">3</literal><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>gidsize</name> <operator>=</operator> <literal type="number">0xff</literal> <operator>&amp;</operator>
<operator>(</operator><name>int</name><operator>)</operator><name><name>p</name><index>[<expr><name>offset</name><operator>+</operator><literal type="number">2</literal><operator>+</operator><name>uidsize</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>gidsize</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>gid</name></name> <operator>=</operator>
<call><name>archive_le16dec</name><argument_list>(
<argument><expr><name>p</name><operator>+</operator><name>offset</name><operator>+</operator><literal type="number">2</literal><operator>+</operator><name>uidsize</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>gidsize</name> <operator>==</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator>
<name>datasize</name> <operator>&gt;=</operator> <operator>(</operator><literal type="number">2</literal> <operator>+</operator> <name>uidsize</name> <operator>+</operator> <literal type="number">5</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>gid</name></name> <operator>=</operator>
<call><name>archive_le32dec</name><argument_list>(
<argument><expr><name>p</name><operator>+</operator><name>offset</name><operator>+</operator><literal type="number">2</literal><operator>+</operator><name>uidsize</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><literal type="number">0x9901</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>datasize</name> <operator>&lt;</operator> <literal type="number">6</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>,
<argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>,
<argument><expr><literal type="string">"Incomplete AES field"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ARCHIVE_FAILED</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><name>offset</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><name>offset</name> <operator>+</operator> <literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'E'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>aes_extra</name><operator>.</operator><name>vendor</name></name> <operator>=</operator>
<call><name>archive_le16dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>aes_extra</name><operator>.</operator><name>strength</name></name> <operator>=</operator> <name><name>p</name><index>[<expr><name>offset</name> <operator>+</operator> <literal type="number">4</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>aes_extra</name><operator>.</operator><name>compression</name></name> <operator>=</operator>
<name><name>p</name><index>[<expr><name>offset</name> <operator>+</operator> <literal type="number">5</literal></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
<expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>datasize</name></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><name>ARCHIVE_OK</name></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>int</name></type>
<name>zip_read_local_file_header</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_read</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>archive_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>zip</name></name> <modifier>*</modifier></type><name>zip</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>h</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>wchar_t</name> <modifier>*</modifier></type><name>wp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>filename_length</name></decl>, <decl><type ref="prev"/><name>extra_length</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>archive_string_conv</name></name> <modifier>*</modifier></type><name>sconv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>zip_entry</name></name> <modifier>*</modifier></type><name>zip_entry</name> <init>= <expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>zip_entry</name></name></type> <name>zip_entry_central_dir</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><name>ARCHIVE_OK</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>version</name></decl>;</decl_stmt>


<expr_stmt><expr><name>zip_entry_central_dir</name> <operator>=</operator> <operator>*</operator><name>zip_entry</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>decompress_init</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>end_of_entry</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_uncompressed_bytes_read</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_compressed_bytes_read</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_crc32</name></name> <operator>=</operator> <call><name><name>zip</name><operator>-&gt;</operator><name>crc32func</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>sconv</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>zip</name><operator>-&gt;</operator><name>init_default_conversion</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>sconv_default</name></name> <operator>=</operator>
<call><name>archive_string_default_conversion_for_read</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>init_default_conversion</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>__archive_read_ahead</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">30</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>,
<argument><expr><literal type="string">"Truncated ZIP file header"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"PK\003\004"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"Damaged Zip archive"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ARCHIVE_FATAL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>version</name> <operator>=</operator> <name><name>p</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>system</name></name> <operator>=</operator> <name><name>p</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>zip_flags</name></name> <operator>=</operator> <call><name>archive_le16dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip_entry</name><operator>-&gt;</operator><name>zip_flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>ZIP_ENCRYPTED</name> <operator>|</operator> <name>ZIP_STRONG_ENCRYPTED</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>has_encrypted_entries</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_entry_set_is_data_encrypted</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip_entry</name><operator>-&gt;</operator><name>zip_flags</name></name> <operator>&amp;</operator> <name>ZIP_CENTRAL_DIRECTORY_ENCRYPTED</name> <operator>&amp;&amp;</operator>
<name><name>zip_entry</name><operator>-&gt;</operator><name>zip_flags</name></name> <operator>&amp;</operator> <name>ZIP_ENCRYPTED</name> <operator>&amp;&amp;</operator>
<name><name>zip_entry</name><operator>-&gt;</operator><name>zip_flags</name></name> <operator>&amp;</operator> <name>ZIP_STRONG_ENCRYPTED</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_entry_set_is_metadata_encrypted</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ARCHIVE_FATAL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>init_decryption</name></name> <operator>=</operator> <operator>(</operator><name><name>zip_entry</name><operator>-&gt;</operator><name>zip_flags</name></name> <operator>&amp;</operator> <name>ZIP_ENCRYPTED</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>compression</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><call><name>archive_le16dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>mtime</name></name> <operator>=</operator> <call><name>zip_time</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>crc32</name></name> <operator>=</operator> <call><name>archive_le32dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">14</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip_entry</name><operator>-&gt;</operator><name>zip_flags</name></name> <operator>&amp;</operator> <name>ZIP_LENGTH_AT_END</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>decdat</name></name> <operator>=</operator> <name><name>p</name><index>[<expr><literal type="number">11</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>decdat</name></name> <operator>=</operator> <name><name>p</name><index>[<expr><literal type="number">17</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>compressed_size</name></name> <operator>=</operator> <call><name>archive_le32dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">18</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>uncompressed_size</name></name> <operator>=</operator> <call><name>archive_le32dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">22</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>filename_length</name> <operator>=</operator> <call><name>archive_le16dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">26</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>extra_length</name> <operator>=</operator> <call><name>archive_le16dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">28</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>__archive_read_consume</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">30</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>(</operator><name>h</name> <operator>=</operator> <call><name>__archive_read_ahead</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>filename_length</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>,
<argument><expr><literal type="string">"Truncated ZIP file header"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip_entry</name><operator>-&gt;</operator><name>zip_flags</name></name> <operator>&amp;</operator> <name>ZIP_UTF8_NAME</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>sconv_utf8</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>sconv_utf8</name></name> <operator>=</operator>
<call><name>archive_string_conversion_from_charset</name><argument_list>(
<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><literal type="string">"UTF-8"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>sconv_utf8</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>sconv</name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>sconv_utf8</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>sconv</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>sconv</name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>sconv</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>sconv</name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>sconv_default</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>archive_entry_copy_pathname_l</name><argument_list>(<argument><expr><name>entry</name></expr></argument>,
<argument><expr><name>h</name></expr></argument>, <argument><expr><name>filename_length</name></expr></argument>, <argument><expr><name>sconv</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOMEM</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ENOMEM</name></expr></argument>,
<argument><expr><literal type="string">"Can't allocate memory for Pathname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>,
<argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>,
<argument><expr><literal type="string">"Pathname cannot be converted "</literal>
<literal type="string">"from %s to current locale."</literal></expr></argument>,
<argument><expr><call><name>archive_string_conversion_charset_name</name><argument_list>(<argument><expr><name>sconv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>ARCHIVE_WARN</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>__archive_read_consume</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>filename_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>(</operator><name>h</name> <operator>=</operator> <call><name>__archive_read_ahead</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>extra_length</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>,
<argument><expr><literal type="string">"Truncated ZIP file header"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ARCHIVE_OK</name> <operator>!=</operator> <call><name>process_extra</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>extra_length</name></expr></argument>,
<argument><expr><name>zip_entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>ARCHIVE_FATAL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>__archive_read_consume</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>extra_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>zip_entry</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;</operator> <name>AE_IFMT</name><operator>)</operator> <operator>==</operator> <name>AE_IFIFO</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;=</operator> <operator>~</operator> <name>AE_IFMT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>mode</name></name> <operator>|=</operator> <name>AE_IFREG</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>zip_entry</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>mode</name></name> <operator>|=</operator> <literal type="number">0664</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><name><name>zip_entry</name><operator>-&gt;</operator><name>system</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<operator>(</operator><name>wp</name> <operator>=</operator> <call><name>archive_entry_pathname_w</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>wcschr</name><argument_list>(<argument><expr><name>wp</name></expr></argument>, <argument><expr><name>L</name><literal type="char">'/'</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>wcschr</name><argument_list>(<argument><expr><name>wp</name></expr></argument>, <argument><expr><name>L</name><literal type="char">'\\'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>archive_wstring</name></name></type> <name>s</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>archive_string_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_wstrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>wp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>archive_strlen</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>.</operator><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>s</name><operator>.</operator><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>archive_entry_copy_pathname_w</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name><name>s</name><operator>.</operator><name>s</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_wstring_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>zip_entry</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;</operator> <name>AE_IFMT</name><operator>)</operator> <operator>!=</operator> <name>AE_IFDIR</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>has_slash</name></decl>;</decl_stmt>

<expr_stmt><expr><name>wp</name> <operator>=</operator> <call><name>archive_entry_pathname_w</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>wp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>wcslen</name><argument_list>(<argument><expr><name>wp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>has_slash</name> <operator>=</operator> <name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>wp</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>L</name><literal type="char">'/'</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>archive_entry_pathname</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>cp</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>?</condition><then><expr><call><name>strlen</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>has_slash</name> <operator>=</operator> <name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>cp</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>has_slash</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;=</operator> <operator>~</operator><name>AE_IFMT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>mode</name></name> <operator>|=</operator> <name>AE_IFDIR</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>mode</name></name> <operator>|=</operator> <literal type="number">0111</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>zip_entry</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;</operator> <name>AE_IFMT</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>mode</name></name> <operator>|=</operator> <name>AE_IFREG</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>zip_entry</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;</operator> <name>AE_IFMT</name><operator>)</operator> <operator>==</operator> <name>AE_IFDIR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>wp</name> <operator>=</operator> <call><name>archive_entry_pathname_w</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>wp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>wcslen</name><argument_list>(<argument><expr><name>wp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>wp</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>L</name><literal type="char">'/'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>archive_wstring</name></name></type> <name>s</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>archive_string_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_wstrcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>wp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_wstrappend_wchar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>L</name><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_entry_copy_pathname_w</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name><name>s</name><operator>.</operator><name>s</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_wstring_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>archive_entry_pathname</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>cp</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>?</condition><then><expr><call><name>strlen</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>cp</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'/'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>archive_string</name></name></type> <name>s</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>archive_string_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_strcat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_strappend_char</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_entry_set_pathname</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name><name>s</name><operator>.</operator><name>s</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_string_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>zip_entry</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>LA_FROM_CENTRAL_DIRECTORY</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>zip_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>ZIP_LENGTH_AT_END</name></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name><name>zip_entry</name><operator>-&gt;</operator><name>crc32</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>crc32</name></name> <operator>=</operator> <name><name>zip_entry_central_dir</name><operator>.</operator><name>crc32</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>zip</name><operator>-&gt;</operator><name>ignore_crc32</name></name>
<operator>&amp;&amp;</operator> <name><name>zip_entry</name><operator>-&gt;</operator><name>crc32</name></name> <operator>!=</operator> <name><name>zip_entry_central_dir</name><operator>.</operator><name>crc32</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>,
<argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>,
<argument><expr><literal type="string">"Inconsistent CRC32 values"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>ARCHIVE_WARN</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip_entry</name><operator>-&gt;</operator><name>compressed_size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>compressed_size</name></name>
<operator>=</operator> <name><name>zip_entry_central_dir</name><operator>.</operator><name>compressed_size</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>zip_entry</name><operator>-&gt;</operator><name>compressed_size</name></name>
<operator>!=</operator> <name><name>zip_entry_central_dir</name><operator>.</operator><name>compressed_size</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>,
<argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>,
<argument><expr><literal type="string">"Inconsistent compressed size: "</literal>
<literal type="string">"%jd in central directory, %jd in local header"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>intmax_t</name><operator>)</operator><name><name>zip_entry_central_dir</name><operator>.</operator><name>compressed_size</name></name></expr></argument>,
<argument><expr><operator>(</operator><name>intmax_t</name><operator>)</operator><name><name>zip_entry</name><operator>-&gt;</operator><name>compressed_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>ARCHIVE_WARN</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip_entry</name><operator>-&gt;</operator><name>uncompressed_size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>uncompressed_size</name></name>
<operator>=</operator> <name><name>zip_entry_central_dir</name><operator>.</operator><name>uncompressed_size</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>zip_entry</name><operator>-&gt;</operator><name>uncompressed_size</name></name>
<operator>!=</operator> <name><name>zip_entry_central_dir</name><operator>.</operator><name>uncompressed_size</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>,
<argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>,
<argument><expr><literal type="string">"Inconsistent uncompressed size: "</literal>
<literal type="string">"%jd in central directory, %jd in local header"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>intmax_t</name><operator>)</operator><name><name>zip_entry_central_dir</name><operator>.</operator><name>uncompressed_size</name></name></expr></argument>,
<argument><expr><operator>(</operator><name>intmax_t</name><operator>)</operator><name><name>zip_entry</name><operator>-&gt;</operator><name>uncompressed_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>ARCHIVE_WARN</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>archive_entry_set_mode</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>mode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_entry_set_uid</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>uid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_entry_set_gid</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_entry_set_mtime</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>mtime</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_entry_set_ctime</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>ctime</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_entry_set_atime</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>atime</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;</operator> <name>AE_IFMT</name><operator>)</operator> <operator>==</operator> <name>AE_IFLNK</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>linkname_length</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>zip_entry</name><operator>-&gt;</operator><name>compressed_size</name></name> <operator>&gt;</operator> <literal type="number">64</literal> <operator>*</operator> <literal type="number">1024</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_MISC</name></expr></argument>,
<argument><expr><literal type="string">"Zip file with oversized link entry"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ARCHIVE_FATAL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>linkname_length</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name><name>zip_entry</name><operator>-&gt;</operator><name>compressed_size</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>archive_entry_set_size</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><name>size_t</name></type> <name>linkname_full_length</name> <init>= <expr><name>linkname_length</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>compression</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>status</name> <init>= <expr><name>ARCHIVE_FATAL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>uncompressed_buffer</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>compression</name></name></expr>)</condition>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_ZLIB_H</name></expr></cpp:if>
<case>case <expr><literal type="number">8</literal></expr>:</case>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_bytes_remaining</name></name> <operator>=</operator> <name><name>zip_entry</name><operator>-&gt;</operator><name>compressed_size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>zip_read_data_deflate</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>uncompressed_buffer</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>linkname_full_length</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_LZMA_H</name> <operator>&amp;&amp;</operator> <name>HAVE_LIBLZMA</name></expr></cpp:if>
<case>case <expr><literal type="number">14</literal></expr>:</case>

<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_bytes_remaining</name></name> <operator>=</operator> <name><name>zip_entry</name><operator>-&gt;</operator><name>compressed_size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>zip_read_data_zipx_lzma_alone</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>uncompressed_buffer</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>linkname_full_length</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>ARCHIVE_OK</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>uncompressed_buffer</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>,
<argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>,
<argument><expr><literal type="string">"Unsupported ZIP compression method "</literal>
<literal type="string">"during decompression of link entry (%d: %s)"</literal></expr></argument>,
<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>compression</name></name></expr></argument>,
<argument><expr><call><name>compression_name</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>compression</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ARCHIVE_FAILED</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>__archive_read_ahead</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>linkname_length</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_MISC</name></expr></argument>,
<argument><expr><literal type="string">"Truncated Zip file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ARCHIVE_FATAL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>sconv</name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>sconv</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>sconv</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>zip_flags</name></name> <operator>&amp;</operator> <name>ZIP_UTF8_NAME</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>sconv</name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>sconv_utf8</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>sconv</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>sconv</name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>sconv_default</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>archive_entry_copy_symlink_l</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>linkname_full_length</name></expr></argument>,
<argument><expr><name>sconv</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENOMEM</name> <operator>&amp;&amp;</operator> <name>sconv</name> <operator>==</operator> <name><name>zip</name><operator>-&gt;</operator><name>sconv_utf8</name></name> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>zip_flags</name></name> <operator>&amp;</operator> <name>ZIP_UTF8_NAME</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>archive_entry_copy_symlink_l</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>p</name></expr></argument>,
<argument><expr><name>linkname_full_length</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOMEM</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ENOMEM</name></expr></argument>,
<argument><expr><literal type="string">"Can't allocate memory for Symlink"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>





<if_stmt><if>if <condition>(<expr><name>sconv</name> <operator>!=</operator> <name><name>zip</name><operator>-&gt;</operator><name>sconv_utf8</name></name> <operator>||</operator>
<operator>(</operator><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>zip_flags</name></name> <operator>&amp;</operator> <name>ZIP_UTF8_NAME</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>,
<argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>,
<argument><expr><literal type="string">"Symlink cannot be converted "</literal>
<literal type="string">"from %s to current locale."</literal></expr></argument>,
<argument><expr><call><name>archive_string_conversion_charset_name</name><argument_list>(
<argument><expr><name>sconv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>ARCHIVE_WARN</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>uncompressed_size</name></name> <operator>=</operator> <name><name>zip_entry</name><operator>-&gt;</operator><name>compressed_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>__archive_read_consume</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>linkname_length</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_MISC</name></expr></argument>,
<argument><expr><literal type="string">"Read error skipping symlink target name"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ARCHIVE_FATAL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <operator>(</operator><name><name>zip_entry</name><operator>-&gt;</operator><name>zip_flags</name></name> <operator>&amp;</operator> <name>ZIP_LENGTH_AT_END</name><operator>)</operator>
<operator>||</operator> <name><name>zip_entry</name><operator>-&gt;</operator><name>uncompressed_size</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>archive_entry_set_size</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>uncompressed_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_bytes_remaining</name></name> <operator>=</operator> <name><name>zip_entry</name><operator>-&gt;</operator><name>compressed_size</name></name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <operator>(</operator><name><name>zip_entry</name><operator>-&gt;</operator><name>zip_flags</name></name> <operator>&amp;</operator> <name>ZIP_LENGTH_AT_END</name><operator>)</operator>
<operator>&amp;&amp;</operator> <name><name>zip</name><operator>-&gt;</operator><name>entry_bytes_remaining</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>end_of_entry</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>archive_string_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>format_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_string_sprintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>format_name</name></name></expr></argument>, <argument><expr><literal type="string">"ZIP %d.%d (%s)"</literal></expr></argument>,
<argument><expr><name>version</name> <operator>/</operator> <literal type="number">10</literal></expr></argument>, <argument><expr><name>version</name> <operator>%</operator> <literal type="number">10</literal></expr></argument>,
<argument><expr><call><name>compression_name</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>compression</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>archive</name><operator>.</operator><name>archive_format_name</name></name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>format_name</name><operator>.</operator><name>s</name></name></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>ret</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>check_authentication_code</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_read</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>zip</name></name> <modifier>*</modifier></type><name>zip</name> <init>= <expr><operator>(</operator>struct <name>zip</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>format</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>hctx_valid</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>hmac</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>hmac_len</name> <init>= <expr><literal type="number">20</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cmp</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>archive_hmac_sha1_final</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>hctx</name></name></expr></argument>, <argument><expr><name>hmac</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hmac_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>_p</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>__archive_read_ahead</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>AUTH_CODE_SIZE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>,
<argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>,
<argument><expr><literal type="string">"Truncated ZIP file data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>_p</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>hmac</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>AUTH_CODE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>__archive_read_consume</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>AUTH_CODE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>,
<argument><expr><name>ARCHIVE_ERRNO_MISC</name></expr></argument>,
<argument><expr><literal type="string">"ZIP bad Authentication code"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_WARN</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_OK</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

























<function><type><specifier>static</specifier> <name>int</name></type>
<name>zip_read_data_none</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_read</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>_buff</name></decl></parameter>,
<parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>size</name></decl></parameter>, <parameter><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>zip</name></name> <modifier>*</modifier></type><name>zip</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buff</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>bytes_avail</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>offset</name></expr>;</expr_stmt>

<expr_stmt><expr><name>zip</name> <operator>=</operator> <operator>(</operator>struct <name>zip</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>format</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>zip_flags</name></name> <operator>&amp;</operator> <name>ZIP_LENGTH_AT_END</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>grabbing_bytes</name> <init>= <expr><literal type="number">24</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>hctx_valid</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>grabbing_bytes</name> <operator>+=</operator> <name>AUTH_CODE_SIZE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>buff</name> <operator>=</operator> <call><name>__archive_read_ahead</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>grabbing_bytes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytes_avail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bytes_avail</name> <operator>&lt;</operator> <name>grabbing_bytes</name></expr>)</condition> <block>{<block_content>




<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>,
<argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>,
<argument><expr><literal type="string">"Truncated ZIP file data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>p</name> <operator>=</operator> <name>buff</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>hctx_valid</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>AUTH_CODE_SIZE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'P'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'K'</literal>
<operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\007'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\010'</literal>
<operator>&amp;&amp;</operator> <operator>(</operator><call><name>archive_le32dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>zip</name><operator>-&gt;</operator><name>entry_crc32</name></name>
<operator>||</operator> <name><name>zip</name><operator>-&gt;</operator><name>ignore_crc32</name></name>
<operator>||</operator> <operator>(</operator><name><name>zip</name><operator>-&gt;</operator><name>hctx_valid</name></name>
<operator>&amp;&amp;</operator> <name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>aes_extra</name><operator>.</operator><name>vendor</name></name> <operator>==</operator> <name>AES_VENDOR_AE_2</name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>LA_USED_ZIP64</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>compressed</name></decl>, <decl><type ref="prev"/><name>uncompressed</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>crc32</name></name> <operator>=</operator> <call><name>archive_le32dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>compressed</name> <operator>=</operator> <call><name>archive_le64dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>uncompressed</name> <operator>=</operator> <call><name>archive_le64dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>compressed</name> <operator>&gt;</operator> <name>INT64_MAX</name> <operator>||</operator> <name>uncompressed</name> <operator>&gt;</operator>
<name>INT64_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>,
<argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>,
<argument><expr><literal type="string">"Overflow of 64-bit file sizes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ARCHIVE_FAILED</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>compressed_size</name></name> <operator>=</operator> <name>compressed</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>uncompressed_size</name></name> <operator>=</operator> <name>uncompressed</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>unconsumed</name></name> <operator>=</operator> <literal type="number">24</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>crc32</name></name> <operator>=</operator> <call><name>archive_le32dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>compressed_size</name></name> <operator>=</operator>
<call><name>archive_le32dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>uncompressed_size</name></name> <operator>=</operator>
<call><name>archive_le32dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">12</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>unconsumed</name></name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>hctx_valid</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>check_authentication_code</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>ARCHIVE_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>r</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>end_of_entry</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_OK</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt>





<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>buff</name> <operator>+</operator> <name>bytes_avail</name> <operator>-</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'P'</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt> </block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'K'</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt> </block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\007'</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt> </block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\010'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\007'</literal>
<operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'K'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'P'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>hctx_valid</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name> <operator>-=</operator> <name>AUTH_CODE_SIZE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block></if> <else>else <block>{<block_content> <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt> </block_content>}</block></else></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name>bytes_avail</name> <operator>=</operator> <name>p</name> <operator>-</operator> <name>buff</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>entry_bytes_remaining</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>end_of_entry</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>hctx_valid</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>check_authentication_code</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>ARCHIVE_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>r</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_OK</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>buff</name> <operator>=</operator> <call><name>__archive_read_ahead</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytes_avail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bytes_avail</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>,
<argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>,
<argument><expr><literal type="string">"Truncated ZIP file data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>bytes_avail</name> <operator>&gt;</operator> <name><name>zip</name><operator>-&gt;</operator><name>entry_bytes_remaining</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>bytes_avail</name> <operator>=</operator> <operator>(</operator><name>ssize_t</name><operator>)</operator><name><name>zip</name><operator>-&gt;</operator><name>entry_bytes_remaining</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>tctx_valid</name></name> <operator>||</operator> <name><name>zip</name><operator>-&gt;</operator><name>cctx_valid</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>dec_size</name> <init>= <expr><name>bytes_avail</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>dec_size</name> <operator>&gt;</operator> <name><name>zip</name><operator>-&gt;</operator><name>decrypted_buffer_size</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>dec_size</name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>decrypted_buffer_size</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>tctx_valid</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>trad_enc_decrypt_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>tctx</name></name></expr></argument>,
<argument><expr><operator>(</operator><specifier>const</specifier> <name>uint8_t</name> <operator>*</operator><operator>)</operator><name>buff</name></expr></argument>, <argument><expr><name>dec_size</name></expr></argument>,
<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>decrypted_buffer</name></name></expr></argument>, <argument><expr><name>dec_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>dsize</name> <init>= <expr><name>dec_size</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>archive_hmac_sha1_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>hctx</name></name></expr></argument>,
<argument><expr><operator>(</operator><specifier>const</specifier> <name>uint8_t</name> <operator>*</operator><operator>)</operator><name>buff</name></expr></argument>, <argument><expr><name>dec_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_decrypto_aes_ctr_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>cctx</name></name></expr></argument>,
<argument><expr><operator>(</operator><specifier>const</specifier> <name>uint8_t</name> <operator>*</operator><operator>)</operator><name>buff</name></expr></argument>, <argument><expr><name>dec_size</name></expr></argument>,
<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>decrypted_buffer</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>bytes_avail</name> <operator>=</operator> <name>dec_size</name></expr>;</expr_stmt>
<expr_stmt><expr><name>buff</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name><name>zip</name><operator>-&gt;</operator><name>decrypted_buffer</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>size</name> <operator>=</operator> <name>bytes_avail</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_bytes_remaining</name></name> <operator>-=</operator> <name>bytes_avail</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_uncompressed_bytes_read</name></name> <operator>+=</operator> <name>bytes_avail</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_compressed_bytes_read</name></name> <operator>+=</operator> <name>bytes_avail</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>unconsumed</name></name> <operator>+=</operator> <name>bytes_avail</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>_buff</name> <operator>=</operator> <name>buff</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_OK</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>consume_optional_marker</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_read</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>zip</name></name> <modifier>*</modifier></type><name>zip</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>end_of_entry</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>zip_flags</name></name> <operator>&amp;</operator> <name>ZIP_LENGTH_AT_END</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <operator>(</operator><name>p</name> <operator>=</operator> <call><name>__archive_read_ahead</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">24</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>,
<argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>,
<argument><expr><literal type="string">"Truncated ZIP end-of-file record"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'P'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'K'</literal> <operator>&amp;&amp;</operator>
<name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\007'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\010'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>unconsumed</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>LA_USED_ZIP64</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>compressed</name></decl>, <decl><type ref="prev"/><name>uncompressed</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>crc32</name></name> <operator>=</operator> <call><name>archive_le32dec</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>compressed</name> <operator>=</operator> <call><name>archive_le64dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>uncompressed</name> <operator>=</operator> <call><name>archive_le64dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">12</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>compressed</name> <operator>&gt;</operator> <name>INT64_MAX</name> <operator>||</operator>
<name>uncompressed</name> <operator>&gt;</operator> <name>INT64_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>,
<argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>,
<argument><expr><literal type="string">"Overflow of 64-bit file sizes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ARCHIVE_FAILED</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>compressed_size</name></name> <operator>=</operator> <name>compressed</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>uncompressed_size</name></name> <operator>=</operator> <name>uncompressed</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>unconsumed</name></name> <operator>+=</operator> <literal type="number">20</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>crc32</name></name> <operator>=</operator> <call><name>archive_le32dec</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>compressed_size</name></name> <operator>=</operator> <call><name>archive_le32dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>uncompressed_size</name></name> <operator>=</operator> <call><name>archive_le32dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>unconsumed</name></name> <operator>+=</operator> <literal type="number">12</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><operator>(</operator><name>ARCHIVE_OK</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_LZMA_H</name> <operator>&amp;&amp;</operator> <name>HAVE_LIBLZMA</name></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>zipx_xz_init</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_read</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>zip</name></name> <modifier>*</modifier></type><name>zip</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>lzma_ret</name></type> <name>r</name></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>zipx_lzma_valid</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>lzma_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>zipx_lzma_stream</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>zipx_lzma_valid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>zipx_lzma_stream</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>zipx_lzma_stream</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>lzma_stream_decoder</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>zipx_lzma_stream</name></name></expr></argument>, <argument><expr><name>UINT64_MAX</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>LZMA_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name><operator>)</operator></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_MISC</name></expr></argument>,
<argument><expr><literal type="string">"xz initialization failed(%d)"</literal></expr></argument>,
<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>ARCHIVE_FAILED</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>zipx_lzma_valid</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>uncompressed_buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>uncompressed_buffer_size</name></name> <operator>=</operator> <literal type="number">256</literal> <operator>*</operator> <literal type="number">1024</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>uncompressed_buffer</name></name> <operator>=</operator>
<operator>(</operator><name>uint8_t</name><operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>uncompressed_buffer_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>uncompressed_buffer</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ENOMEM</name></expr></argument>,
<argument><expr><literal type="string">"No memory for xz decompression"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>decompress_init</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_OK</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>zipx_lzma_alone_init</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_read</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>zip</name></name> <modifier>*</modifier></type><name>zip</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>lzma_ret</name></type> <name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name><modifier>*</modifier></type> <name>p</name></decl>;</decl_stmt>

<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>pack</name><name>(</name><name>push</name><name>)</name></cpp:pragma>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>pack</name><name>(</name><name>1</name><name>)</name></cpp:pragma>
<struct>struct <name>_alone_header</name> <block>{
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>bytes</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>uncompressed_size</name></decl>;</decl_stmt>
}</block> <decl><name>alone_header</name></decl>;</struct>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>pack</name><name>(</name><name>pop</name><name>)</name></cpp:pragma>

<if_stmt><if>if<condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>zipx_lzma_valid</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>lzma_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>zipx_lzma_stream</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>zipx_lzma_valid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>








<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>zipx_lzma_stream</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>zipx_lzma_stream</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>lzma_alone_decoder</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>zipx_lzma_stream</name></name></expr></argument>, <argument><expr><name>UINT64_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>LZMA_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name><operator>)</operator></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_MISC</name></expr></argument>,
<argument><expr><literal type="string">"lzma initialization failed(%d)"</literal></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>ARCHIVE_FAILED</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>



<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>zipx_lzma_valid</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>







































<if_stmt><if>if<condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>__archive_read_ahead</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>,
<argument><expr><literal type="string">"Truncated lzma data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0x05</literal> <operator>||</operator> <name><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0x00</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>,
<argument><expr><literal type="string">"Invalid lzma data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>



<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>alone_header</name><operator>.</operator><name>bytes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name><name>alone_header</name><operator>.</operator><name>uncompressed_size</name></name> <operator>=</operator> <name>UINT64_MAX</name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>zip</name><operator>-&gt;</operator><name>uncompressed_buffer</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>uncompressed_buffer_size</name></name> <operator>=</operator> <literal type="number">256</literal> <operator>*</operator> <literal type="number">1024</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>uncompressed_buffer</name></name> <operator>=</operator>
<operator>(</operator><name>uint8_t</name><operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>uncompressed_buffer_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>uncompressed_buffer</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ENOMEM</name></expr></argument>,
<argument><expr><literal type="string">"No memory for lzma decompression"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>zipx_lzma_stream</name><operator>.</operator><name>next_in</name></name> <operator>=</operator> <operator>(</operator><name>void</name><operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>alone_header</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>zipx_lzma_stream</name><operator>.</operator><name>avail_in</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>alone_header</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>zipx_lzma_stream</name><operator>.</operator><name>total_in</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>zipx_lzma_stream</name><operator>.</operator><name>next_out</name></name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>uncompressed_buffer</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>zipx_lzma_stream</name><operator>.</operator><name>avail_out</name></name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>uncompressed_buffer_size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>zipx_lzma_stream</name><operator>.</operator><name>total_out</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>




<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>lzma_code</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>zipx_lzma_stream</name></name></expr></argument>, <argument><expr><name>LZMA_RUN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>LZMA_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_PROGRAMMER</name></expr></argument>,
<argument><expr><literal type="string">"lzma stream initialization error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ARCHIVE_FATAL</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>__archive_read_consume</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_bytes_remaining</name></name> <operator>-=</operator> <literal type="number">9</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_compressed_bytes_read</name></name> <operator>+=</operator> <literal type="number">9</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>decompress_init</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_OK</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>zip_read_data_zipx_xz</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_read</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>buff</name></decl></parameter>,
<parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>size</name></decl></parameter>, <parameter><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>zip</name></name><modifier>*</modifier></type> <name>zip</name> <init>= <expr><operator>(</operator>struct <name>zip</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>format</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>lzma_ret</name></type> <name>lz_ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>compressed_buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>bytes_avail</name></decl>, <decl><type ref="prev"/><name>in_bytes</name></decl>, <decl><type ref="prev"/><name>to_consume</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>offset</name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>zip</name><operator>-&gt;</operator><name>decompress_init</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>zipx_xz_init</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>zip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>ARCHIVE_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>ret</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>compressed_buf</name> <operator>=</operator> <call><name>__archive_read_ahead</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytes_avail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bytes_avail</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>,
<argument><expr><literal type="string">"Truncated xz file body"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>in_bytes</name> <operator>=</operator> <call><name>zipmin</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_bytes_remaining</name></name></expr></argument>, <argument><expr><name>bytes_avail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>zipx_lzma_stream</name><operator>.</operator><name>next_in</name></name> <operator>=</operator> <name>compressed_buf</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>zipx_lzma_stream</name><operator>.</operator><name>avail_in</name></name> <operator>=</operator> <name>in_bytes</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>zipx_lzma_stream</name><operator>.</operator><name>total_in</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>zipx_lzma_stream</name><operator>.</operator><name>next_out</name></name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>uncompressed_buffer</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>zipx_lzma_stream</name><operator>.</operator><name>avail_out</name></name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>uncompressed_buffer_size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>zipx_lzma_stream</name><operator>.</operator><name>total_out</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>


<expr_stmt><expr><name>lz_ret</name> <operator>=</operator> <call><name>lzma_code</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>zipx_lzma_stream</name></name></expr></argument>, <argument><expr><name>LZMA_RUN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch<condition>(<expr><name>lz_ret</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>LZMA_DATA_ERROR</name></expr>:</case>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_MISC</name></expr></argument>,
<argument><expr><literal type="string">"xz data error (error %d)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>lz_ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>

<case>case <expr><name>LZMA_NO_CHECK</name></expr>:</case>
<case>case <expr><name>LZMA_OK</name></expr>:</case>
<break>break;</break>

<default>default:</default>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_MISC</name></expr></argument>,
<argument><expr><literal type="string">"xz unknown error %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>lz_ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>

<case>case <expr><name>LZMA_STREAM_END</name></expr>:</case>
<expr_stmt><expr><call><name>lzma_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>zipx_lzma_stream</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>zipx_lzma_valid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><operator>(</operator><name>int64_t</name><operator>)</operator> <name><name>zip</name><operator>-&gt;</operator><name>zipx_lzma_stream</name><operator>.</operator><name>total_in</name></name> <operator>!=</operator>
<name><name>zip</name><operator>-&gt;</operator><name>entry_bytes_remaining</name></name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>,
<argument><expr><name>ARCHIVE_ERRNO_MISC</name></expr></argument>,
<argument><expr><literal type="string">"xz premature end of stream"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>end_of_entry</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>

<expr_stmt><expr><name>to_consume</name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>zipx_lzma_stream</name><operator>.</operator><name>total_in</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>__archive_read_consume</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>to_consume</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_bytes_remaining</name></name> <operator>-=</operator> <name>to_consume</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_compressed_bytes_read</name></name> <operator>+=</operator> <name>to_consume</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_uncompressed_bytes_read</name></name> <operator>+=</operator> <name><name>zip</name><operator>-&gt;</operator><name>zipx_lzma_stream</name><operator>.</operator><name>total_out</name></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>size</name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>zipx_lzma_stream</name><operator>.</operator><name>total_out</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>buff</name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>uncompressed_buffer</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>consume_optional_marker</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>zip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>ARCHIVE_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>ret</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><name>ARCHIVE_OK</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>zip_read_data_zipx_lzma_alone</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_read</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>buff</name></decl></parameter>,
<parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>size</name></decl></parameter>, <parameter><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>zip</name></name><modifier>*</modifier></type> <name>zip</name> <init>= <expr><operator>(</operator>struct <name>zip</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>format</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>lzma_ret</name></type> <name>lz_ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>compressed_buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>bytes_avail</name></decl>, <decl><type ref="prev"/><name>in_bytes</name></decl>, <decl><type ref="prev"/><name>to_consume</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>offset</name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>zip</name><operator>-&gt;</operator><name>decompress_init</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>zipx_lzma_alone_init</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>zip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>ARCHIVE_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>ret</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>









<expr_stmt><expr><name>compressed_buf</name> <operator>=</operator> <call><name>__archive_read_ahead</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytes_avail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bytes_avail</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>,
<argument><expr><literal type="string">"Truncated lzma file body"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>in_bytes</name> <operator>=</operator> <call><name>zipmin</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_bytes_remaining</name></name></expr></argument>, <argument><expr><name>bytes_avail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>zipx_lzma_stream</name><operator>.</operator><name>next_in</name></name> <operator>=</operator> <name>compressed_buf</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>zipx_lzma_stream</name><operator>.</operator><name>avail_in</name></name> <operator>=</operator> <name>in_bytes</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>zipx_lzma_stream</name><operator>.</operator><name>total_in</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>zipx_lzma_stream</name><operator>.</operator><name>next_out</name></name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>uncompressed_buffer</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>zipx_lzma_stream</name><operator>.</operator><name>avail_out</name></name> <operator>=</operator>



<call><name>zipmin</name><argument_list>(<argument><expr><operator>(</operator><name>int64_t</name><operator>)</operator> <name><name>zip</name><operator>-&gt;</operator><name>uncompressed_buffer_size</name></name></expr></argument>,
<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>uncompressed_size</name></name> <operator>-</operator>
<name><name>zip</name><operator>-&gt;</operator><name>entry_uncompressed_bytes_read</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>zipx_lzma_stream</name><operator>.</operator><name>total_out</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>


<expr_stmt><expr><name>lz_ret</name> <operator>=</operator> <call><name>lzma_code</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>zipx_lzma_stream</name></name></expr></argument>, <argument><expr><name>LZMA_RUN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch<condition>(<expr><name>lz_ret</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>LZMA_DATA_ERROR</name></expr>:</case>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_MISC</name></expr></argument>,
<argument><expr><literal type="string">"lzma data error (error %d)"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>lz_ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>



<case>case <expr><name>LZMA_STREAM_END</name></expr>:</case>
<expr_stmt><expr><call><name>lzma_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>zipx_lzma_stream</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>zipx_lzma_valid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><operator>(</operator><name>int64_t</name><operator>)</operator> <name><name>zip</name><operator>-&gt;</operator><name>zipx_lzma_stream</name><operator>.</operator><name>total_in</name></name> <operator>!=</operator>
<name><name>zip</name><operator>-&gt;</operator><name>entry_bytes_remaining</name></name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>,
<argument><expr><name>ARCHIVE_ERRNO_MISC</name></expr></argument>,
<argument><expr><literal type="string">"lzma alone premature end of stream"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>end_of_entry</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>LZMA_OK</name></expr>:</case>
<break>break;</break>

<default>default:</default>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_MISC</name></expr></argument>,
<argument><expr><literal type="string">"lzma unknown error %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>lz_ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>

<expr_stmt><expr><name>to_consume</name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>zipx_lzma_stream</name><operator>.</operator><name>total_in</name></name></expr>;</expr_stmt>


<expr_stmt><expr><call><name>__archive_read_consume</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>to_consume</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_bytes_remaining</name></name> <operator>-=</operator> <name>to_consume</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_compressed_bytes_read</name></name> <operator>+=</operator> <name>to_consume</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_uncompressed_bytes_read</name></name> <operator>+=</operator> <name><name>zip</name><operator>-&gt;</operator><name>zipx_lzma_stream</name><operator>.</operator><name>total_out</name></name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>entry_bytes_remaining</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>end_of_entry</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><operator>*</operator><name>size</name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>zipx_lzma_stream</name><operator>.</operator><name>total_out</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>buff</name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>uncompressed_buffer</name></name></expr>;</expr_stmt>


<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>consume_optional_marker</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>zip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>ARCHIVE_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>ret</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if<condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>end_of_entry</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>lzma_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>zipx_lzma_stream</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>zipx_lzma_valid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<return>return <expr><operator>(</operator><name>ARCHIVE_OK</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>zipx_ppmd8_init</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_read</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>zip</name></name> <modifier>*</modifier></type><name>zip</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>void</name><modifier>*</modifier></type> <name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>val</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>order</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>mem</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>restore_method</name></decl>;</decl_stmt>


<if_stmt><if>if<condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>ppmd8_valid</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>__archive_ppmd8_functions</name><operator>.</operator><name>Ppmd8_Free</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>ppmd8</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>ppmd8_valid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name><name>__archive_ppmd8_functions</name><operator>.</operator><name>Ppmd8_Construct</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>ppmd8</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>ppmd8_stream_failed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>




<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>ppmd8</name><operator>.</operator><name>Stream</name><operator>.</operator><name>In</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>zipx_ppmd_stream</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>zipx_ppmd_stream</name><operator>.</operator><name>a</name></name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>zipx_ppmd_stream</name><operator>.</operator><name>Read</name></name> <operator>=</operator> <operator>&amp;</operator><name>ppmd_read</name></expr>;</expr_stmt>


<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>zipx_ppmd_read_compressed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>


<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>__archive_read_ahead</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><name>p</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>,
<argument><expr><literal type="string">"Truncated file data in PPMd8 stream"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>__archive_read_consume</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>archive_le16dec</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>order</name> <operator>=</operator> <operator>(</operator><name>val</name> <operator>&amp;</operator> <literal type="number">15</literal><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>mem</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>val</name> <operator>&gt;&gt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>restore_method</name> <operator>=</operator> <operator>(</operator><name>val</name> <operator>&gt;&gt;</operator> <literal type="number">12</literal><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name><name>order</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">2</literal> <operator>||</operator> <name>restore_method</name></expr></argument> &gt;</argument_list></name> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>,
<argument><expr><literal type="string">"Invalid parameter set in PPMd8 stream (order=%"</literal> <name>PRId32</name> <literal type="string">", "</literal>
<literal type="string">"restore=%"</literal> <name>PRId32</name> <literal type="string">")"</literal></expr></argument>, <argument><expr><name>order</name></expr></argument>, <argument><expr><name>restore_method</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FAILED</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name><name>__archive_ppmd8_functions</name><operator>.</operator><name>Ppmd8_Alloc</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>ppmd8</name></name></expr></argument>, <argument><expr><name>mem</name> <operator>&lt;&lt;</operator> <literal type="number">20</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ENOMEM</name></expr></argument>,
<argument><expr><literal type="string">"Unable to allocate memory for PPMd8 stream: %"</literal> <name>PRId32</name> <literal type="string">" bytes"</literal></expr></argument>,
<argument><expr><name>mem</name> <operator>&lt;&lt;</operator> <literal type="number">20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>



<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>ppmd8_valid</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>


<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name><name>__archive_ppmd8_functions</name><operator>.</operator><name>Ppmd8_RangeDec_Init</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>ppmd8</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_PROGRAMMER</name></expr></argument>,
<argument><expr><literal type="string">"PPMd8 stream range decoder initialization error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name><name>__archive_ppmd8_functions</name><operator>.</operator><name>Ppmd8_Init</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>ppmd8</name></name></expr></argument>, <argument><expr><name>order</name></expr></argument>,
<argument><expr><name>restore_method</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>uncompressed_buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>uncompressed_buffer_size</name></name> <operator>=</operator> <literal type="number">256</literal> <operator>*</operator> <literal type="number">1024</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>uncompressed_buffer</name></name> <operator>=</operator>
<operator>(</operator><name>uint8_t</name><operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>uncompressed_buffer_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>uncompressed_buffer</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ENOMEM</name></expr></argument>,
<argument><expr><literal type="string">"No memory for PPMd8 decompression"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ARCHIVE_FATAL</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>decompress_init</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>





<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_compressed_bytes_read</name></name> <operator>+=</operator> <literal type="number">2</literal> <operator>+</operator> <name><name>zip</name><operator>-&gt;</operator><name>zipx_ppmd_read_compressed</name></name></expr>;</expr_stmt>

<return>return <expr><name>ARCHIVE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>zip_read_data_zipx_ppmd</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_read</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>buff</name></decl></parameter>,
<parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>size</name></decl></parameter>, <parameter><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>zip</name></name><modifier>*</modifier></type> <name>zip</name> <init>= <expr><operator>(</operator>struct <name>zip</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>format</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>consumed_bytes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>bytes_avail</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>offset</name></expr>;</expr_stmt>



<if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>zip</name><operator>-&gt;</operator><name>decompress_init</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>zipx_ppmd8_init</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>zip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>ret</name> <operator>!=</operator> <name>ARCHIVE_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>



<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>__archive_read_ahead</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytes_avail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>bytes_avail</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>,
<argument><expr><literal type="string">"Truncated PPMd8 file body"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>



<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>zipx_ppmd_read_compressed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>


<do>do <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>sym</name> <init>= <expr><call><name><name>__archive_ppmd8_functions</name><operator>.</operator><name>Ppmd8_DecodeSymbol</name></name><argument_list>(
<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>ppmd8</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>sym</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>end_of_entry</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>



<if_stmt><if>if<condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>ppmd8_stream_failed</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>,
<argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>,
<argument><expr><literal type="string">"Truncated PPMd8 file body"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>uncompressed_buffer</name><index>[<expr><name>consumed_bytes</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator> <name>sym</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>consumed_bytes</name></expr>;</expr_stmt>
</block_content>}</block> while<condition>(<expr><name>consumed_bytes</name> <operator>&lt;</operator> <name><name>zip</name><operator>-&gt;</operator><name>uncompressed_buffer_size</name></name></expr>)</condition>;</do>


<expr_stmt><expr><operator>*</operator><name>buff</name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>uncompressed_buffer</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>size</name> <operator>=</operator> <name>consumed_bytes</name></expr>;</expr_stmt>


<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_bytes_remaining</name></name> <operator>-=</operator> <name><name>zip</name><operator>-&gt;</operator><name>zipx_ppmd_read_compressed</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_compressed_bytes_read</name></name> <operator>+=</operator> <name><name>zip</name><operator>-&gt;</operator><name>zipx_ppmd_read_compressed</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_uncompressed_bytes_read</name></name> <operator>+=</operator> <name>consumed_bytes</name></expr>;</expr_stmt>


<if_stmt><if>if<condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>end_of_entry</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>__archive_ppmd8_functions</name><operator>.</operator><name>Ppmd8_Free</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>ppmd8</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>ppmd8_valid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>consume_optional_marker</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>zip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>ARCHIVE_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>ARCHIVE_OK</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_BZLIB_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>zipx_bzip2_init</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_read</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>zip</name></name> <modifier>*</modifier></type><name>zip</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>



<if_stmt><if>if<condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>bzstream_valid</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>BZ2_bzDecompressEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>bzstream</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>bzstream_valid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>bzstream</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bz_stream</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>BZ2_bzDecompressInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>bzstream</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>r</name> <operator>!=</operator> <name>BZ_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name><operator>)</operator></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_MISC</name></expr></argument>,
<argument><expr><literal type="string">"bzip2 initialization failed(%d)"</literal></expr></argument>,
<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ARCHIVE_FAILED</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>bzstream_valid</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>


<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>uncompressed_buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>uncompressed_buffer_size</name></name> <operator>=</operator> <literal type="number">256</literal> <operator>*</operator> <literal type="number">1024</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>uncompressed_buffer</name></name> <operator>=</operator>
<operator>(</operator><name>uint8_t</name><operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>uncompressed_buffer_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>uncompressed_buffer</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ENOMEM</name></expr></argument>,
<argument><expr><literal type="string">"No memory for bzip2 decompression"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ARCHIVE_FATAL</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>decompress_init</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><name>ARCHIVE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>zip_read_data_zipx_bzip2</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_read</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>buff</name></decl></parameter>,
<parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>size</name></decl></parameter>, <parameter><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>zip</name></name> <modifier>*</modifier></type><name>zip</name> <init>= <expr><operator>(</operator>struct <name>zip</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>format</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>bytes_avail</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>in_bytes</name></decl>, <decl><type ref="prev"/><name>to_consume</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>compressed_buff</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>total_out</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>offset</name></expr>;</expr_stmt>


<if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>zip</name><operator>-&gt;</operator><name>decompress_init</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>zipx_bzip2_init</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>zip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>r</name> <operator>!=</operator> <name>ARCHIVE_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>compressed_buff</name> <operator>=</operator> <call><name>__archive_read_ahead</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytes_avail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>bytes_avail</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>,
<argument><expr><literal type="string">"Truncated bzip2 file body"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>in_bytes</name> <operator>=</operator> <call><name>zipmin</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_bytes_remaining</name></name></expr></argument>, <argument><expr><name>bytes_avail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>in_bytes</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>





<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>,
<argument><expr><literal type="string">"Truncated bzip2 file body"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>bzstream</name><operator>.</operator><name>next_in</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator> <name>compressed_buff</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>bzstream</name><operator>.</operator><name>avail_in</name></name> <operator>=</operator> <name>in_bytes</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>bzstream</name><operator>.</operator><name>total_in_hi32</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>bzstream</name><operator>.</operator><name>total_in_lo32</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>bzstream</name><operator>.</operator><name>next_out</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name><name>zip</name><operator>-&gt;</operator><name>uncompressed_buffer</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>bzstream</name><operator>.</operator><name>avail_out</name></name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>uncompressed_buffer_size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>bzstream</name><operator>.</operator><name>total_out_hi32</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>bzstream</name><operator>.</operator><name>total_out_lo32</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>


<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>BZ2_bzDecompress</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>bzstream</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch<condition>(<expr><name>r</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>BZ_STREAM_END</name></expr>:</case>


<switch>switch<condition>(<expr><call><name>BZ2_bzDecompressEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>bzstream</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>BZ_OK</name></expr>:</case>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>,
<argument><expr><name>ARCHIVE_ERRNO_MISC</name></expr></argument>,
<argument><expr><literal type="string">"Failed to clean up bzip2 "</literal>
<literal type="string">"decompressor"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ARCHIVE_FATAL</name></expr>;</return>
</block_content>}</block></switch>

<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>end_of_entry</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>BZ_OK</name></expr>:</case>


<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_MISC</name></expr></argument>,
<argument><expr><literal type="string">"bzip2 decompression failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ARCHIVE_FATAL</name></expr>;</return>
</block_content>}</block></switch>


<expr_stmt><expr><name>to_consume</name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>bzstream</name><operator>.</operator><name>total_in_lo32</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>__archive_read_consume</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>to_consume</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>total_out</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>zip</name><operator>-&gt;</operator><name>bzstream</name><operator>.</operator><name>total_out_hi32</name></name> <operator>&lt;&lt;</operator> <literal type="number">32</literal><operator>)</operator> <operator>+</operator>
<name><name>zip</name><operator>-&gt;</operator><name>bzstream</name><operator>.</operator><name>total_out_lo32</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_bytes_remaining</name></name> <operator>-=</operator> <name>to_consume</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_compressed_bytes_read</name></name> <operator>+=</operator> <name>to_consume</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_uncompressed_bytes_read</name></name> <operator>+=</operator> <name>total_out</name></expr>;</expr_stmt>


<expr_stmt><expr><operator>*</operator><name>size</name> <operator>=</operator> <name>total_out</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>buff</name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>uncompressed_buffer</name></name></expr>;</expr_stmt>


<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>consume_optional_marker</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>zip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>r</name> <operator>!=</operator> <name>ARCHIVE_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>ARCHIVE_OK</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_ZLIB_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>zip_deflate_init</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_read</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>zip</name></name> <modifier>*</modifier></type><name>zip</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>zip</name><operator>-&gt;</operator><name>decompress_init</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>stream_valid</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>inflateReset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>stream</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>inflateInit2</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>stream</name></name></expr></argument>,
<argument><expr><operator>-</operator><literal type="number">15</literal></expr></argument> )</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>Z_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_MISC</name></expr></argument>,
<argument><expr><literal type="string">"Can't initialize ZIP decompression."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>stream_valid</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>decompress_init</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_OK</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>zip_read_data_deflate</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_read</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>buff</name></decl></parameter>,
<parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>size</name></decl></parameter>, <parameter><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>zip</name></name> <modifier>*</modifier></type><name>zip</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>bytes_avail</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>compressed_buff</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>offset</name></expr>;</expr_stmt>

<expr_stmt><expr><name>zip</name> <operator>=</operator> <operator>(</operator>struct <name>zip</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>format</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>uncompressed_buffer</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>uncompressed_buffer_size</name></name> <operator>=</operator> <literal type="number">256</literal> <operator>*</operator> <literal type="number">1024</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>uncompressed_buffer</name></name>
<operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>uncompressed_buffer_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>uncompressed_buffer</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ENOMEM</name></expr></argument>,
<argument><expr><literal type="string">"No memory for ZIP decompression"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>zip_deflate_init</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>zip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>ARCHIVE_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>r</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>







<expr_stmt><expr><name>compressed_buff</name> <operator>=</operator> <name>sp</name> <operator>=</operator> <call><name>__archive_read_ahead</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytes_avail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <operator>(</operator><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>zip_flags</name></name> <operator>&amp;</operator> <name>ZIP_LENGTH_AT_END</name><operator>)</operator>
<operator>&amp;&amp;</operator> <name>bytes_avail</name> <operator>&gt;</operator> <name><name>zip</name><operator>-&gt;</operator><name>entry_bytes_remaining</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>bytes_avail</name> <operator>=</operator> <operator>(</operator><name>ssize_t</name><operator>)</operator><name><name>zip</name><operator>-&gt;</operator><name>entry_bytes_remaining</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>bytes_avail</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>,
<argument><expr><literal type="string">"Truncated ZIP file body"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>tctx_valid</name></name> <operator>||</operator> <name><name>zip</name><operator>-&gt;</operator><name>cctx_valid</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>decrypted_bytes_remaining</name></name> <operator>&lt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>bytes_avail</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>buff_remaining</name> <init>=
<expr><operator>(</operator><name><name>zip</name><operator>-&gt;</operator><name>decrypted_buffer</name></name> <operator>+</operator>
<name><name>zip</name><operator>-&gt;</operator><name>decrypted_buffer_size</name></name><operator>)</operator>
<operator>-</operator> <operator>(</operator><name><name>zip</name><operator>-&gt;</operator><name>decrypted_ptr</name></name> <operator>+</operator>
<name><name>zip</name><operator>-&gt;</operator><name>decrypted_bytes_remaining</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>buff_remaining</name> <operator>&gt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>bytes_avail</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>buff_remaining</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>bytes_avail</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <operator>(</operator><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>zip_flags</name></name> <operator>&amp;</operator> <name>ZIP_LENGTH_AT_END</name><operator>)</operator> <operator>&amp;&amp;</operator>
<name><name>zip</name><operator>-&gt;</operator><name>entry_bytes_remaining</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int64_t</name><operator>)</operator><operator>(</operator><name><name>zip</name><operator>-&gt;</operator><name>decrypted_bytes_remaining</name></name>
<operator>+</operator> <name>buff_remaining</name><operator>)</operator>
<operator>&gt;</operator> <name><name>zip</name><operator>-&gt;</operator><name>entry_bytes_remaining</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>entry_bytes_remaining</name></name> <operator>&lt;</operator>
<operator>(</operator><name>int64_t</name><operator>)</operator><name><name>zip</name><operator>-&gt;</operator><name>decrypted_bytes_remaining</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>buff_remaining</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>buff_remaining</name> <operator>=</operator>
<operator>(</operator><name>size_t</name><operator>)</operator><name><name>zip</name><operator>-&gt;</operator><name>entry_bytes_remaining</name></name>
<operator>-</operator> <name><name>zip</name><operator>-&gt;</operator><name>decrypted_bytes_remaining</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>buff_remaining</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>tctx_valid</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>trad_enc_decrypt_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>tctx</name></name></expr></argument>,
<argument><expr><name>compressed_buff</name></expr></argument>, <argument><expr><name>buff_remaining</name></expr></argument>,
<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>decrypted_ptr</name></name>
<operator>+</operator> <name><name>zip</name><operator>-&gt;</operator><name>decrypted_bytes_remaining</name></name></expr></argument>,
<argument><expr><name>buff_remaining</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>dsize</name> <init>= <expr><name>buff_remaining</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>archive_decrypto_aes_ctr_update</name><argument_list>(
<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>cctx</name></name></expr></argument>,
<argument><expr><name>compressed_buff</name></expr></argument>, <argument><expr><name>buff_remaining</name></expr></argument>,
<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>decrypted_ptr</name></name>
<operator>+</operator> <name><name>zip</name><operator>-&gt;</operator><name>decrypted_bytes_remaining</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>dsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>decrypted_bytes_remaining</name></name> <operator>+=</operator>
<name>buff_remaining</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>bytes_avail</name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>decrypted_bytes_remaining</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>compressed_buff</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name><name>zip</name><operator>-&gt;</operator><name>decrypted_ptr</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>







<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>stream</name><operator>.</operator><name>next_in</name></name> <operator>=</operator> <operator>(</operator><name>Bytef</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name>compressed_buff</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>stream</name><operator>.</operator><name>avail_in</name></name> <operator>=</operator> <operator>(</operator><name>uInt</name><operator>)</operator><name>bytes_avail</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>stream</name><operator>.</operator><name>total_in</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>stream</name><operator>.</operator><name>next_out</name></name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>uncompressed_buffer</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>stream</name><operator>.</operator><name>avail_out</name></name> <operator>=</operator> <operator>(</operator><name>uInt</name><operator>)</operator><name><name>zip</name><operator>-&gt;</operator><name>uncompressed_buffer_size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>stream</name><operator>.</operator><name>total_out</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>inflate</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>stream</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>r</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>Z_OK</name></expr>:</case>
<break>break;</break>
<case>case <expr><name>Z_STREAM_END</name></expr>:</case>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>end_of_entry</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>Z_MEM_ERROR</name></expr>:</case>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ENOMEM</name></expr></argument>,
<argument><expr><literal type="string">"Out of memory for ZIP decompression"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_MISC</name></expr></argument>,
<argument><expr><literal type="string">"ZIP decompression failed (%d)"</literal></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>


<expr_stmt><expr><name>bytes_avail</name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>stream</name><operator>.</operator><name>total_in</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>tctx_valid</name></name> <operator>||</operator> <name><name>zip</name><operator>-&gt;</operator><name>cctx_valid</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>decrypted_bytes_remaining</name></name> <operator>-=</operator> <name>bytes_avail</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>decrypted_bytes_remaining</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>decrypted_ptr</name></name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>decrypted_buffer</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>decrypted_ptr</name></name> <operator>+=</operator> <name>bytes_avail</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>hctx_valid</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>archive_hmac_sha1_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>hctx</name></name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>bytes_avail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>__archive_read_consume</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>bytes_avail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_bytes_remaining</name></name> <operator>-=</operator> <name>bytes_avail</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_compressed_bytes_read</name></name> <operator>+=</operator> <name>bytes_avail</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>size</name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>stream</name><operator>.</operator><name>total_out</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_uncompressed_bytes_read</name></name> <operator>+=</operator> <name><name>zip</name><operator>-&gt;</operator><name>stream</name><operator>.</operator><name>total_out</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>buff</name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>uncompressed_buffer</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>end_of_entry</name></name> <operator>&amp;&amp;</operator> <name><name>zip</name><operator>-&gt;</operator><name>hctx_valid</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>check_authentication_code</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>ARCHIVE_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>r</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>consume_optional_marker</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>zip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>ARCHIVE_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>r</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><name>ARCHIVE_OK</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>read_decryption_header</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_read</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>zip</name></name> <modifier>*</modifier></type><name>zip</name> <init>= <expr><operator>(</operator>struct <name>zip</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>format</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>remaining_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>ts</name></decl>;</decl_stmt>




<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>__archive_read_ahead</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>truncated</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ts</name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>iv_size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>iv_size</name></name> <operator>=</operator> <call><name>archive_le16dec</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>__archive_read_consume</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ts</name> <operator>&lt;</operator> <name><name>zip</name><operator>-&gt;</operator><name>iv_size</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>iv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>iv</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>__archive_read_ahead</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>zip</name><operator>-&gt;</operator><name>iv_size</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>truncated</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>iv</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>iv</name></name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>iv_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>iv</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>nomem</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>iv</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>zip</name><operator>-&gt;</operator><name>iv_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>__archive_read_consume</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>zip</name><operator>-&gt;</operator><name>iv_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>__archive_read_ahead</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">14</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>truncated</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>remaining_size</name> <operator>=</operator> <call><name>archive_le32dec</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>remaining_size</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">16</literal> <operator>||</operator> <name>remaining_size</name></expr></argument> &gt;</argument_list></name> <argument_list>(<argument><expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">18</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>corrupted</name>;</goto></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>archive_le16dec</name><argument_list>(<argument><expr><name>p</name><operator>+</operator><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>,
<argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>,
<argument><expr><literal type="string">"Unsupported encryption format version: %u"</literal></expr></argument>,
<argument><expr><call><name>archive_le16dec</name><argument_list>(<argument><expr><name>p</name><operator>+</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FAILED</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>




<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>alg_id</name></name> <operator>=</operator> <call><name>archive_le16dec</name><argument_list>(<argument><expr><name>p</name><operator>+</operator><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>alg_id</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0x6601</literal></expr>:</case>
<case>case <expr><literal type="number">0x6602</literal></expr>:</case>
<case>case <expr><literal type="number">0x6603</literal></expr>:</case>
<case>case <expr><literal type="number">0x6609</literal></expr>:</case>
<case>case <expr><literal type="number">0x660E</literal></expr>:</case>
<case>case <expr><literal type="number">0x660F</literal></expr>:</case>
<case>case <expr><literal type="number">0x6610</literal></expr>:</case>
<case>case <expr><literal type="number">0x6702</literal></expr>:</case>
<case>case <expr><literal type="number">0x6720</literal></expr>:</case>
<case>case <expr><literal type="number">0x6721</literal></expr>:</case>
<case>case <expr><literal type="number">0x6801</literal></expr>:</case>

<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>,
<argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>,
<argument><expr><literal type="string">"Unknown encryption algorithm: %u"</literal></expr></argument>, <argument><expr><name><name>zip</name><operator>-&gt;</operator><name>alg_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FAILED</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>




<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>bit_len</name></name> <operator>=</operator> <call><name>archive_le16dec</name><argument_list>(<argument><expr><name>p</name><operator>+</operator><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <call><name>archive_le16dec</name><argument_list>(<argument><expr><name>p</name><operator>+</operator><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <literal type="number">0xf000</literal></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0x0001</literal></expr>:</case>
<case>case <expr><literal type="number">0x0002</literal></expr>:</case>
<case>case <expr><literal type="number">0x0003</literal></expr>:</case>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>,
<argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>,
<argument><expr><literal type="string">"Unknown encryption flag: %u"</literal></expr></argument>, <argument><expr><name><name>zip</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FAILED</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>zip</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <literal type="number">0xf000</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
<operator>(</operator><name><name>zip</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <literal type="number">0xf000</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x4000</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>,
<argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>,
<argument><expr><literal type="string">"Unknown encryption flag: %u"</literal></expr></argument>, <argument><expr><name><name>zip</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FAILED</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>




<expr_stmt><expr><name>ts</name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>erd_size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>erd_size</name></name> <operator>=</operator> <call><name>archive_le16dec</name><argument_list>(<argument><expr><name>p</name><operator>+</operator><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>__archive_read_consume</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">14</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>zip</name><operator>-&gt;</operator><name>erd_size</name></name> <operator>&amp;</operator> <literal type="number">0xf</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
<operator>(</operator><name><name>zip</name><operator>-&gt;</operator><name>erd_size</name></name> <operator>+</operator> <literal type="number">16</literal><operator>)</operator> <operator>&gt;</operator> <name>remaining_size</name> <operator>||</operator>
<operator>(</operator><name><name>zip</name><operator>-&gt;</operator><name>erd_size</name></name> <operator>+</operator> <literal type="number">16</literal><operator>)</operator> <operator>&lt;</operator> <name><name>zip</name><operator>-&gt;</operator><name>erd_size</name></name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>corrupted</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ts</name> <operator>&lt;</operator> <name><name>zip</name><operator>-&gt;</operator><name>erd_size</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>erd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>erd</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>__archive_read_ahead</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>zip</name><operator>-&gt;</operator><name>erd_size</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>truncated</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>erd</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>erd</name></name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>erd_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>erd</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>nomem</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>erd</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>zip</name><operator>-&gt;</operator><name>erd_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>__archive_read_consume</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>zip</name><operator>-&gt;</operator><name>erd_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>__archive_read_ahead</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>truncated</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>archive_le32dec</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>corrupted</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>__archive_read_consume</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>__archive_read_ahead</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>truncated</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ts</name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>v_size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>v_size</name></name> <operator>=</operator> <call><name>archive_le16dec</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>__archive_read_consume</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>zip</name><operator>-&gt;</operator><name>v_size</name></name> <operator>&amp;</operator> <literal type="number">0x0f</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
<operator>(</operator><name><name>zip</name><operator>-&gt;</operator><name>erd_size</name></name> <operator>+</operator> <name><name>zip</name><operator>-&gt;</operator><name>v_size</name></name> <operator>+</operator> <literal type="number">16</literal><operator>)</operator> <operator>&gt;</operator> <name>remaining_size</name> <operator>||</operator>
<operator>(</operator><name><name>zip</name><operator>-&gt;</operator><name>erd_size</name></name> <operator>+</operator> <name><name>zip</name><operator>-&gt;</operator><name>v_size</name></name> <operator>+</operator> <literal type="number">16</literal><operator>)</operator> <operator>&lt;</operator> <operator>(</operator><name><name>zip</name><operator>-&gt;</operator><name>erd_size</name></name> <operator>+</operator> <name><name>zip</name><operator>-&gt;</operator><name>v_size</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>corrupted</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ts</name> <operator>&lt;</operator> <name><name>zip</name><operator>-&gt;</operator><name>v_size</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>v_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>v_data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>__archive_read_ahead</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>zip</name><operator>-&gt;</operator><name>v_size</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>truncated</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>v_data</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>v_data</name></name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>v_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>v_data</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>nomem</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>v_data</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>zip</name><operator>-&gt;</operator><name>v_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>__archive_read_consume</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>zip</name><operator>-&gt;</operator><name>v_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>__archive_read_ahead</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>truncated</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>v_crc32</name></name> <operator>=</operator> <call><name>archive_le32dec</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>__archive_read_consume</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>,
<argument><expr><literal type="string">"Encrypted file is unsupported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FAILED</name><operator>)</operator></expr>;</return>
<label><name>truncated</name>:</label>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>,
<argument><expr><literal type="string">"Truncated ZIP file data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>
<label><name>corrupted</name>:</label>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>,
<argument><expr><literal type="string">"Corrupted ZIP file data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>
<label><name>nomem</name>:</label>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ENOMEM</name></expr></argument>,
<argument><expr><literal type="string">"No memory for ZIP decryption"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>zip_alloc_decryption_buffer</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_read</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>zip</name></name> <modifier>*</modifier></type><name>zip</name> <init>= <expr><operator>(</operator>struct <name>zip</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>format</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>bs</name> <init>= <expr><literal type="number">256</literal> <operator>*</operator> <literal type="number">1024</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>decrypted_buffer</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>decrypted_buffer_size</name></name> <operator>=</operator> <name>bs</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>decrypted_buffer</name></name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>bs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>decrypted_buffer</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ENOMEM</name></expr></argument>,
<argument><expr><literal type="string">"No memory for ZIP decryption"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>decrypted_ptr</name></name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>decrypted_buffer</name></name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_OK</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>init_traditional_PKWARE_decryption</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_read</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>zip</name></name> <modifier>*</modifier></type><name>zip</name> <init>= <expr><operator>(</operator>struct <name>zip</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>format</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>retry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>tctx_valid</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>ARCHIVE_OK</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENC_HEADER_SIZE</name></cpp:macro> <cpp:value>12</cpp:value></cpp:define>
<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <operator>(</operator><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>zip_flags</name></name> <operator>&amp;</operator> <name>ZIP_LENGTH_AT_END</name><operator>)</operator>
<operator>&amp;&amp;</operator> <name><name>zip</name><operator>-&gt;</operator><name>entry_bytes_remaining</name></name> <operator>&lt;</operator> <name>ENC_HEADER_SIZE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>,
<argument><expr><literal type="string">"Truncated Zip encrypted body: only %jd bytes available"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>intmax_t</name><operator>)</operator><name><name>zip</name><operator>-&gt;</operator><name>entry_bytes_remaining</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>__archive_read_ahead</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>ENC_HEADER_SIZE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>,
<argument><expr><literal type="string">"Truncated ZIP file data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>retry</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init><condition>;</condition> <incr><expr><name>retry</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>passphrase</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>crcchk</name></decl>;</decl_stmt>

<expr_stmt><expr><name>passphrase</name> <operator>=</operator> <call><name>__archive_read_next_passphrase</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>passphrase</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_MISC</name></expr></argument>,
<argument><expr><ternary><condition><expr><operator>(</operator><name>retry</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then>
<expr><literal type="string">"Incorrect passphrase"</literal></expr></then><else>:
<expr><literal type="string">"Passphrase required for this entry"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FAILED</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>




<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>trad_enc_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>tctx</name></name></expr></argument>, <argument><expr><name>passphrase</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>passphrase</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>p</name></expr></argument>, <argument><expr><name>ENC_HEADER_SIZE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>crcchk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>crcchk</name> <operator>==</operator> <name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>decdat</name></name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>retry</name> <operator>&gt;</operator> <literal type="number">10000</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_MISC</name></expr></argument>,
<argument><expr><literal type="string">"Too many incorrect passphrases"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FAILED</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>__archive_read_consume</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>ENC_HEADER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>tctx_valid</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <operator>(</operator><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>zip_flags</name></name> <operator>&amp;</operator> <name>ZIP_LENGTH_AT_END</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_bytes_remaining</name></name> <operator>-=</operator> <name>ENC_HEADER_SIZE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_compressed_bytes_read</name></name> <operator>+=</operator> <name>ENC_HEADER_SIZE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>decrypted_bytes_remaining</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><call><name>zip_alloc_decryption_buffer</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ENC_HEADER_SIZE</name></cpp:undef>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>init_WinZip_AES_decryption</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_read</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>zip</name></name> <modifier>*</modifier></type><name>zip</name> <init>= <expr><operator>(</operator>struct <name>zip</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>format</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>pv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>key_len</name></decl>, <decl><type ref="prev"/><name>salt_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>derived_key</name><index>[<expr><name>MAX_DERIVED_KEY_BUF_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>retry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>cctx_valid</name></name> <operator>||</operator> <name><name>zip</name><operator>-&gt;</operator><name>hctx_valid</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>ARCHIVE_OK</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>aes_extra</name><operator>.</operator><name>strength</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">1</literal></expr>:</case> <expr_stmt><expr><name>salt_len</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt> <expr_stmt><expr><name>key_len</name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">2</literal></expr>:</case> <expr_stmt><expr><name>salt_len</name> <operator>=</operator> <literal type="number">12</literal></expr>;</expr_stmt> <expr_stmt><expr><name>key_len</name> <operator>=</operator> <literal type="number">24</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">3</literal></expr>:</case> <expr_stmt><expr><name>salt_len</name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt> <expr_stmt><expr><name>key_len</name> <operator>=</operator> <literal type="number">32</literal></expr>;</expr_stmt> <break>break;</break>
<default>default:</default> <goto>goto <name>corrupted</name>;</goto>
</block_content>}</block></switch>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>__archive_read_ahead</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>salt_len</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>truncated</name>;</goto></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>retry</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init><condition>;</condition> <incr><expr><name>retry</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>passphrase</name></decl>;</decl_stmt>

<expr_stmt><expr><name>passphrase</name> <operator>=</operator> <call><name>__archive_read_next_passphrase</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>passphrase</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_MISC</name></expr></argument>,
<argument><expr><ternary><condition><expr><operator>(</operator><name>retry</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then>
<expr><literal type="string">"Incorrect passphrase"</literal></expr></then><else>:
<expr><literal type="string">"Passphrase required for this entry"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FAILED</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>derived_key</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>derived_key</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>archive_pbkdf2_sha1</name><argument_list>(<argument><expr><name>passphrase</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>passphrase</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>p</name></expr></argument>, <argument><expr><name>salt_len</name></expr></argument>, <argument><expr><literal type="number">1000</literal></expr></argument>, <argument><expr><name>derived_key</name></expr></argument>, <argument><expr><name>key_len</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_MISC</name></expr></argument>,
<argument><expr><literal type="string">"Decryption is unsupported due to lack of "</literal>
<literal type="string">"crypto library"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FAILED</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>pv</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>uint8_t</name> <operator>*</operator><operator>)</operator><name>p</name><operator>)</operator> <operator>+</operator> <name>salt_len</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>derived_key</name><index>[<expr><name>key_len</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <name><name>pv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator>
<name><name>derived_key</name><index>[<expr><name>key_len</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>pv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>retry</name> <operator>&gt;</operator> <literal type="number">10000</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_MISC</name></expr></argument>,
<argument><expr><literal type="string">"Too many incorrect passphrases"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FAILED</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>archive_decrypto_aes_ctr_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>cctx</name></name></expr></argument>, <argument><expr><name>derived_key</name></expr></argument>, <argument><expr><name>key_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_MISC</name></expr></argument>,
<argument><expr><literal type="string">"Decryption is unsupported due to lack of crypto library"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FAILED</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>archive_hmac_sha1_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>hctx</name></name></expr></argument>, <argument><expr><name>derived_key</name> <operator>+</operator> <name>key_len</name></expr></argument>, <argument><expr><name>key_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_decrypto_aes_ctr_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>cctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_MISC</name></expr></argument>,
<argument><expr><literal type="string">"Failed to initialize HMAC-SHA1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FAILED</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>cctx_valid</name></name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>hctx_valid</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>__archive_read_consume</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>salt_len</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_bytes_remaining</name></name> <operator>-=</operator> <name>salt_len</name> <operator>+</operator> <literal type="number">2</literal> <operator>+</operator> <name>AUTH_CODE_SIZE</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <operator>(</operator><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>zip_flags</name></name> <operator>&amp;</operator> <name>ZIP_LENGTH_AT_END</name><operator>)</operator>
<operator>&amp;&amp;</operator> <name><name>zip</name><operator>-&gt;</operator><name>entry_bytes_remaining</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>corrupted</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_compressed_bytes_read</name></name> <operator>+=</operator> <name>salt_len</name> <operator>+</operator> <literal type="number">2</literal> <operator>+</operator> <name>AUTH_CODE_SIZE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>decrypted_bytes_remaining</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>compression</name></name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>aes_extra</name><operator>.</operator><name>compression</name></name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><call><name>zip_alloc_decryption_buffer</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>

<label><name>truncated</name>:</label>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>,
<argument><expr><literal type="string">"Truncated ZIP file data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>
<label><name>corrupted</name>:</label>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>,
<argument><expr><literal type="string">"Corrupted ZIP file data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>archive_read_format_zip_read_data</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_read</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>buff</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>size</name></decl></parameter>, <parameter><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>zip</name></name> <modifier>*</modifier></type><name>zip</name> <init>= <expr><operator>(</operator>struct <name>zip</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>format</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>has_encrypted_entries</name></name> <operator>==</operator>
<name>ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>has_encrypted_entries</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>offset</name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>entry_uncompressed_bytes_read</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>buff</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>end_of_entry</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>ARCHIVE_EOF</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>AE_IFREG</name> <operator>!=</operator> <operator>(</operator><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;</operator> <name>AE_IFMT</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>ARCHIVE_EOF</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>__archive_read_consume</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>zip</name><operator>-&gt;</operator><name>unconsumed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>unconsumed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>init_decryption</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>has_encrypted_entries</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>zip_flags</name></name> <operator>&amp;</operator> <name>ZIP_STRONG_ENCRYPTED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>read_decryption_header</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>compression</name></name> <operator>==</operator> <name>WINZIP_AES_ENCRYPTION</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>init_WinZip_AES_decryption</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>init_traditional_PKWARE_decryption</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>ARCHIVE_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>r</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>init_decryption</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<switch>switch<condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>compression</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>zip_read_data_none</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_BZLIB_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><literal type="number">12</literal></expr>:</case>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>zip_read_data_zipx_bzip2</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_LZMA_H</name> <operator>&amp;&amp;</operator> <name>HAVE_LIBLZMA</name></expr></cpp:if>
<case>case <expr><literal type="number">14</literal></expr>:</case>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>zip_read_data_zipx_lzma_alone</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">95</literal></expr>:</case>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>zip_read_data_zipx_xz</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<case>case <expr><literal type="number">98</literal></expr>:</case>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>zip_read_data_zipx_ppmd</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_ZLIB_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><literal type="number">8</literal></expr>:</case>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>zip_read_data_deflate</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<default>default:</default>

<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>,
<argument><expr><literal type="string">"Unsupported ZIP compression method (%d: %s)"</literal></expr></argument>,
<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>compression</name></name></expr></argument>, <argument><expr><call><name>compression_name</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>compression</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<return>return <expr><operator>(</operator><name>ARCHIVE_FAILED</name><operator>)</operator></expr>;</return>
<break>break;</break>
</block_content>}</block></switch>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>ARCHIVE_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>r</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>size</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_crc32</name></name> <operator>=</operator> <call><name><name>zip</name><operator>-&gt;</operator><name>crc32func</name></name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_crc32</name></name></expr></argument>, <argument><expr><operator>*</operator><name>buff</name></expr></argument>,
<argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><operator>*</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>end_of_entry</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>compressed_size</name></name> <operator>!=</operator>
<name><name>zip</name><operator>-&gt;</operator><name>entry_compressed_bytes_read</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_MISC</name></expr></argument>,
<argument><expr><literal type="string">"ZIP compressed data is wrong size "</literal>
<literal type="string">"(read %jd, expected %jd)"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>intmax_t</name><operator>)</operator><name><name>zip</name><operator>-&gt;</operator><name>entry_compressed_bytes_read</name></name></expr></argument>,
<argument><expr><operator>(</operator><name>intmax_t</name><operator>)</operator><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>compressed_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_WARN</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>uncompressed_size</name></name> <operator>&amp;</operator> <name>UINT32_MAX</name><operator>)</operator>
<operator>!=</operator> <operator>(</operator><name><name>zip</name><operator>-&gt;</operator><name>entry_uncompressed_bytes_read</name></name> <operator>&amp;</operator> <name>UINT32_MAX</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_MISC</name></expr></argument>,
<argument><expr><literal type="string">"ZIP uncompressed data is wrong size "</literal>
<literal type="string">"(read %jd, expected %jd)\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>intmax_t</name><operator>)</operator><name><name>zip</name><operator>-&gt;</operator><name>entry_uncompressed_bytes_read</name></name></expr></argument>,
<argument><expr><operator>(</operator><name>intmax_t</name><operator>)</operator><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>uncompressed_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_WARN</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><name><name>zip</name><operator>-&gt;</operator><name>hctx_valid</name></name> <operator>||</operator>
<name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>aes_extra</name><operator>.</operator><name>vendor</name></name> <operator>!=</operator> <name>AES_VENDOR_AE_2</name><operator>)</operator> <operator>&amp;&amp;</operator>
<name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>crc32</name></name> <operator>!=</operator> <name><name>zip</name><operator>-&gt;</operator><name>entry_crc32</name></name>
<operator>&amp;&amp;</operator> <operator>!</operator><name><name>zip</name><operator>-&gt;</operator><name>ignore_crc32</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_MISC</name></expr></argument>,
<argument><expr><literal type="string">"ZIP bad CRC: 0x%lx should be 0x%lx"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><name><name>zip</name><operator>-&gt;</operator><name>entry_crc32</name></name></expr></argument>,
<argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>crc32</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_WARN</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><operator>(</operator><name>ARCHIVE_OK</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>archive_read_format_zip_cleanup</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_read</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>zip</name></name> <modifier>*</modifier></type><name>zip</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>zip_entry</name></name> <modifier>*</modifier></type><name>zip_entry</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>next_zip_entry</name></decl>;</decl_stmt>

<expr_stmt><expr><name>zip</name> <operator>=</operator> <operator>(</operator>struct <name>zip</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>format</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_ZLIB_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>stream_valid</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>inflateEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>stream</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_LZMA_H</name> <operator>&amp;&amp;</operator> <name>HAVE_LIBLZMA</name></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>zipx_lzma_valid</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>lzma_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>zipx_lzma_stream</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_BZLIB_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>bzstream_valid</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>BZ2_bzDecompressEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>bzstream</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>uncompressed_buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>ppmd8_valid</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>__archive_ppmd8_functions</name><operator>.</operator><name>Ppmd8_Free</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>ppmd8</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>zip_entries</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>zip_entry</name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>zip_entries</name></name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>zip_entry</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>next_zip_entry</name> <operator>=</operator> <name><name>zip_entry</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_string_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip_entry</name><operator>-&gt;</operator><name>rsrcname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>zip_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zip_entry</name> <operator>=</operator> <name>next_zip_entry</name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>decrypted_buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>cctx_valid</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>archive_decrypto_aes_ctr_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>cctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>hctx_valid</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>archive_hmac_sha1_cleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>hctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>iv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>erd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>v_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_string_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>format_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>zip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>format</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_OK</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>archive_read_format_zip_has_encrypted_entries</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_read</name></name> <modifier>*</modifier></type><name>_a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>_a</name> <operator>&amp;&amp;</operator> <name><name>_a</name><operator>-&gt;</operator><name>format</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>zip</name></name> <modifier>*</modifier></type> <name>zip</name> <init>= <expr><operator>(</operator>struct <name>zip</name> <operator>*</operator><operator>)</operator><name><name>_a</name><operator>-&gt;</operator><name>format</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>zip</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name><name>zip</name><operator>-&gt;</operator><name>has_encrypted_entries</name></name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>archive_read_format_zip_options</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_read</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>zip</name></name> <modifier>*</modifier></type><name>zip</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><name>ARCHIVE_FAILED</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>zip</name> <operator>=</operator> <operator>(</operator>struct <name>zip</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>format</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="string">"compat-2x"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>init_default_conversion</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>val</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_OK</name><operator>)</operator></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="string">"hdrcharset"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>val</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>val</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_MISC</name></expr></argument>,
<argument><expr><literal type="string">"zip: hdrcharset option needs a character-set name"</literal></expr></argument>
)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>sconv</name></name> <operator>=</operator> <call><name>archive_string_conversion_from_charset</name><argument_list>(
<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>sconv</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="string">"UTF-8"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>sconv_utf8</name></name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>sconv</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>ARCHIVE_OK</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>ARCHIVE_FATAL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><operator>(</operator><name>ret</name><operator>)</operator></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="string">"ignorecrc32"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>val</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>val</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>crc32func</name></name> <operator>=</operator> <name>real_crc32</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>ignore_crc32</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>crc32func</name></name> <operator>=</operator> <name>fake_crc32</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>ignore_crc32</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_OK</name><operator>)</operator></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="string">"mac-ext"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>process_mac_extensions</name></name> <operator>=</operator> <operator>(</operator><name>val</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>val</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_OK</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>




<return>return <expr><operator>(</operator><name>ARCHIVE_WARN</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>archive_read_support_format_zip</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>archive_read_support_format_zip_streamable</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>ARCHIVE_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><call><name>archive_read_support_format_zip_seekable</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>int</name></type>
<name>archive_read_support_format_zip_capabilities_streamable</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_read</name></name> <modifier>*</modifier></type> <name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>a</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_READ_FORMAT_CAPS_ENCRYPT_DATA</name> <operator>|</operator>
<name>ARCHIVE_READ_FORMAT_CAPS_ENCRYPT_METADATA</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>archive_read_format_zip_streamable_bid</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_read</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>best_bid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>best_bid</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>__archive_read_ahead</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>









<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'P'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'K'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\001'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\002'</literal><operator>)</operator>
<operator>||</operator> <operator>(</operator><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\003'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\004'</literal><operator>)</operator>
<operator>||</operator> <operator>(</operator><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\005'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\006'</literal><operator>)</operator>
<operator>||</operator> <operator>(</operator><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\006'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\006'</literal><operator>)</operator>
<operator>||</operator> <operator>(</operator><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\007'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\010'</literal><operator>)</operator>
<operator>||</operator> <operator>(</operator><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'0'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">29</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>






<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>archive_read_format_zip_streamable_read_header</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_read</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>archive_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>zip</name></name> <modifier>*</modifier></type><name>zip</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>archive</name><operator>.</operator><name>archive_format</name></name> <operator>=</operator> <name>ARCHIVE_FORMAT_ZIP</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>archive</name><operator>.</operator><name>archive_format_name</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>archive</name><operator>.</operator><name>archive_format_name</name></name> <operator>=</operator> <literal type="string">"ZIP"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>zip</name> <operator>=</operator> <operator>(</operator>struct <name>zip</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>format</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator></expr>;</expr_stmt>








<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>has_encrypted_entries</name></name> <operator>==</operator>
<name>ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>has_encrypted_entries</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>zip_entries</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>zip_entries</name></name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>zip_entry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>zip_entries</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ENOMEM</name></expr></argument>,
<argument><expr><literal type="string">"Out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ARCHIVE_FATAL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name></name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>zip_entries</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>zip_entry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>cctx_valid</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>archive_decrypto_aes_ctr_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>cctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>hctx_valid</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>archive_hmac_sha1_cleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>hctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>tctx_valid</name></name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>cctx_valid</name></name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>hctx_valid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>__archive_read_reset_passphrase</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>__archive_read_consume</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>zip</name><operator>-&gt;</operator><name>unconsumed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>unconsumed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name></type> <name>skipped</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>bytes</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>__archive_read_ahead</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>end</name> <operator>=</operator> <name>p</name> <operator>+</operator> <name>bytes</name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>p</name> <operator>+</operator> <literal type="number">4</literal> <operator>&lt;=</operator> <name>end</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'P'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'K'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\003'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\004'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>__archive_read_consume</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>skipped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>zip_read_local_file_header</name><argument_list>(<argument><expr><name>a</name></expr></argument>,
<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>zip</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>














<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\001'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\002'</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><name>ARCHIVE_EOF</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\005'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\006'</literal><operator>)</operator>
<operator>||</operator> <operator>(</operator><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\006'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\006'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>ARCHIVE_EOF</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>skipped</name></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>__archive_read_consume</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>skipped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>archive_read_format_zip_read_data_skip_streamable</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_read</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>zip</name></name> <modifier>*</modifier></type><name>zip</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>bytes_skipped</name></decl>;</decl_stmt>

<expr_stmt><expr><name>zip</name> <operator>=</operator> <operator>(</operator>struct <name>zip</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>format</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>bytes_skipped</name> <operator>=</operator> <call><name>__archive_read_consume</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>zip</name><operator>-&gt;</operator><name>unconsumed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>unconsumed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bytes_skipped</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>end_of_entry</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>ARCHIVE_OK</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <operator>(</operator><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>zip_flags</name></name> <operator>&amp;</operator> <name>ZIP_LENGTH_AT_END</name><operator>)</operator>
<operator>||</operator> <name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>compressed_size</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>bytes_skipped</name> <operator>=</operator> <call><name>__archive_read_consume</name><argument_list>(<argument><expr><name>a</name></expr></argument>,
<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_bytes_remaining</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bytes_skipped</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_OK</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>init_decryption</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>has_encrypted_entries</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>zip_flags</name></name> <operator>&amp;</operator> <name>ZIP_STRONG_ENCRYPTED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>read_decryption_header</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>compression</name></name> <operator>==</operator> <name>WINZIP_AES_ENCRYPTION</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>init_WinZip_AES_decryption</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>init_traditional_PKWARE_decryption</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>ARCHIVE_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>r</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>init_decryption</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>




<switch>switch <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>compression</name></name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_ZLIB_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><literal type="number">8</literal></expr>:</case>
<while>while <condition>(<expr><operator>!</operator><name><name>zip</name><operator>-&gt;</operator><name>end_of_entry</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>buff</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>zip_read_data_deflate</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buff</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>ARCHIVE_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>r</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></while>
<return>return <expr><name>ARCHIVE_OK</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<default>default:</default>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>buff</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>bytes_avail</name></decl>;</decl_stmt>
<expr_stmt><expr><name>buff</name> <operator>=</operator> <call><name>__archive_read_ahead</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytes_avail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bytes_avail</name> <operator>&lt;</operator> <literal type="number">16</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>,
<argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>,
<argument><expr><literal type="string">"Truncated ZIP file data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>buff</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>p</name> <operator>&lt;=</operator> <name>buff</name> <operator>+</operator> <name>bytes_avail</name> <operator>-</operator> <literal type="number">16</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'P'</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt> </block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'K'</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt> </block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\007'</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt> </block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\010'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\007'</literal>
<operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'K'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'P'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>LA_USED_ZIP64</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>__archive_read_consume</name><argument_list>(<argument><expr><name>a</name></expr></argument>,
<argument><expr><name>p</name> <operator>-</operator> <name>buff</name> <operator>+</operator> <literal type="number">24</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>__archive_read_consume</name><argument_list>(<argument><expr><name>a</name></expr></argument>,
<argument><expr><name>p</name> <operator>-</operator> <name>buff</name> <operator>+</operator> <literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return <expr><name>ARCHIVE_OK</name></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content> <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt> </block_content>}</block></else></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>__archive_read_consume</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>p</name> <operator>-</operator> <name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>archive_read_support_format_zip_streamable</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive</name></name> <modifier>*</modifier></type><name>_a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>archive_read</name></name> <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>(</operator>struct <name>archive_read</name> <operator>*</operator><operator>)</operator><name>_a</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>zip</name></name> <modifier>*</modifier></type><name>zip</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>archive_check_magic</name><argument_list>(<argument><expr><name>_a</name></expr></argument>, <argument><expr><name>ARCHIVE_READ_MAGIC</name></expr></argument>,
<argument><expr><name>ARCHIVE_STATE_NEW</name></expr></argument>, <argument><expr><literal type="string">"archive_read_support_format_zip"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>zip</name> <operator>=</operator> <operator>(</operator>struct <name>zip</name> <operator>*</operator><operator>)</operator><call><name>calloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>zip</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>zip</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ENOMEM</name></expr></argument>,
<argument><expr><literal type="string">"Can't allocate zip data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>process_mac_extensions</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>





<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>has_encrypted_entries</name></name> <operator>=</operator> <name>ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>crc32func</name></name> <operator>=</operator> <name>real_crc32</name></expr>;</expr_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>__archive_read_register_format</name><argument_list>(<argument><expr><name>a</name></expr></argument>,
<argument><expr><name>zip</name></expr></argument>,
<argument><expr><literal type="string">"zip"</literal></expr></argument>,
<argument><expr><name>archive_read_format_zip_streamable_bid</name></expr></argument>,
<argument><expr><name>archive_read_format_zip_options</name></expr></argument>,
<argument><expr><name>archive_read_format_zip_streamable_read_header</name></expr></argument>,
<argument><expr><name>archive_read_format_zip_read_data</name></expr></argument>,
<argument><expr><name>archive_read_format_zip_read_data_skip_streamable</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>archive_read_format_zip_cleanup</name></expr></argument>,
<argument><expr><name>archive_read_support_format_zip_capabilities_streamable</name></expr></argument>,
<argument><expr><name>archive_read_format_zip_has_encrypted_entries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>ARCHIVE_OK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>zip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_OK</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>int</name></type>
<name>archive_read_support_format_zip_capabilities_seekable</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_read</name></name> <modifier>*</modifier></type> <name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>a</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_READ_FORMAT_CAPS_ENCRYPT_DATA</name> <operator>|</operator>
<name>ARCHIVE_READ_FORMAT_CAPS_ENCRYPT_METADATA</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>










<function><type><specifier>static</specifier> <name>int</name></type>
<name>read_eocd</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>zip</name></name> <modifier>*</modifier></type><name>zip</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>current_offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint16_t</name></type> <name>disk_num</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>cd_size</name></decl>, <decl><type ref="prev"/><name>cd_offset</name></decl>;</decl_stmt>

<expr_stmt><expr><name>disk_num</name> <operator>=</operator> <call><name>archive_le16dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cd_size</name> <operator>=</operator> <call><name>archive_le32dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">12</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cd_offset</name> <operator>=</operator> <call><name>archive_le32dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<if_stmt><if>if <condition>(<expr><name>disk_num</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>disk_num</name> <operator>!=</operator> <call><name>archive_le16dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">6</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>archive_le16dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">10</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>archive_le16dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>cd_offset</name> <operator>+</operator> <name>cd_size</name> <operator>&gt;</operator> <name>current_offset</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>central_directory_offset</name></name> <operator>=</operator> <name>cd_offset</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>central_directory_offset_adjusted</name></name> <operator>=</operator> <name>current_offset</name> <operator>-</operator> <name>cd_size</name></expr>;</expr_stmt>





<return>return <expr><literal type="number">32</literal></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type>
<name>read_zip64_eocd</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_read</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>zip</name></name> <modifier>*</modifier></type><name>zip</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name></type> <name>eocd64_offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>eocd64_size</name></decl>;</decl_stmt>




<if_stmt><if>if <condition>(<expr><call><name>archive_le32dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>archive_le32dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">16</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name>eocd64_offset</name> <operator>=</operator> <call><name>archive_le64dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>__archive_read_seek</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>eocd64_offset</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>__archive_read_ahead</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">56</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>eocd64_size</name> <operator>=</operator> <call><name>archive_le64dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">12</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>eocd64_size</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">56</literal> <operator>||</operator> <name>eocd64_size</name></expr></argument> &gt;</argument_list></name> <literal type="number">16384</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>__archive_read_ahead</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>eocd64_size</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>archive_le32dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">16</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>archive_le32dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">20</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>archive_le64dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">24</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>archive_le64dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">32</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>central_directory_offset</name></name> <operator>=</operator> <call><name>archive_le64dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">48</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>central_directory_offset_adjusted</name></name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>central_directory_offset</name></name></expr>;</expr_stmt>

<return>return <expr><literal type="number">32</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>archive_read_format_zip_seekable_bid</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_read</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>best_bid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>zip</name></name> <modifier>*</modifier></type><name>zip</name> <init>= <expr><operator>(</operator>struct <name>zip</name> <operator>*</operator><operator>)</operator><name><name>a</name><operator>-&gt;</operator><name>format</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>file_size</name></decl>, <decl><type ref="prev"/><name>current_offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>tail</name></decl>;</decl_stmt>



<if_stmt><if>if <condition>(<expr><name>best_bid</name> <operator>&gt;</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>file_size</name> <operator>=</operator> <call><name>__archive_read_seek</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>file_size</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>



<expr_stmt><expr><name>tail</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>zipmin</name><argument_list>(<argument><expr><literal type="number">1024</literal> <operator>*</operator> <literal type="number">16</literal></expr></argument>, <argument><expr><name>file_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>current_offset</name> <operator>=</operator> <call><name>__archive_read_seek</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><operator>-</operator><name>tail</name></expr></argument>, <argument><expr><name>SEEK_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>current_offset</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>__archive_read_ahead</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>tail</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>




<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>tail</name> <operator>-</operator> <literal type="number">22</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition><incr/>)</control> <block>{<block_content>
<switch>switch <condition>(<expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'P'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><literal type="string">"PK\005\006"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>read_eocd</name><argument_list>(<argument><expr><name>zip</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name>i</name></expr></argument>,
<argument><expr><name>current_offset</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <literal type="number">20</literal> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>i</name> <operator>-</operator> <literal type="number">20</literal></expr></argument>, <argument><expr><literal type="string">"PK\006\007"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret_zip64</name> <init>= <expr><call><name>read_zip64_eocd</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>zip</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name>i</name> <operator>-</operator> <literal type="number">20</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ret_zip64</name> <operator>&gt;</operator> <name>ret</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>ret_zip64</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name>ret</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>i</name> <operator>-=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'K'</literal></expr>:</case> <expr_stmt><expr><name>i</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">005</literal></expr>:</case> <expr_stmt><expr><name>i</name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">006</literal></expr>:</case> <expr_stmt><expr><name>i</name> <operator>-=</operator> <literal type="number">3</literal></expr>;</expr_stmt> <break>break;</break>
<default>default:</default> <expr_stmt><expr><name>i</name> <operator>-=</operator> <literal type="number">4</literal></expr>;</expr_stmt> <break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></for>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>int</name></type>
<name>cmp_node</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>archive_rb_node</name></name> <modifier>*</modifier></type><name>n1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>archive_rb_node</name></name> <modifier>*</modifier></type><name>n2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>zip_entry</name></name> <modifier>*</modifier></type><name>e1</name> <init>= <expr><operator>(</operator><specifier>const</specifier> struct <name>zip_entry</name> <operator>*</operator><operator>)</operator><name>n1</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>zip_entry</name></name> <modifier>*</modifier></type><name>e2</name> <init>= <expr><operator>(</operator><specifier>const</specifier> struct <name>zip_entry</name> <operator>*</operator><operator>)</operator><name>n2</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>e1</name><operator>-&gt;</operator><name>local_header_offset</name></name> <operator>&gt;</operator> <name><name>e2</name><operator>-&gt;</operator><name>local_header_offset</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>e1</name><operator>-&gt;</operator><name>local_header_offset</name></name> <operator>&lt;</operator> <name><name>e2</name><operator>-&gt;</operator><name>local_header_offset</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>cmp_key</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>archive_rb_node</name></name> <modifier>*</modifier></type><name>n</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>key</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>archive_rb_tree_ops</name></name></type> <name>rb_ops</name> <init>= <expr><block>{
<expr><operator>&amp;</operator><name>cmp_node</name></expr>, <expr><operator>&amp;</operator><name>cmp_key</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>rsrc_cmp_node</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>archive_rb_node</name></name> <modifier>*</modifier></type><name>n1</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>archive_rb_node</name></name> <modifier>*</modifier></type><name>n2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>zip_entry</name></name> <modifier>*</modifier></type><name>e1</name> <init>= <expr><operator>(</operator><specifier>const</specifier> struct <name>zip_entry</name> <operator>*</operator><operator>)</operator><name>n1</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>zip_entry</name></name> <modifier>*</modifier></type><name>e2</name> <init>= <expr><operator>(</operator><specifier>const</specifier> struct <name>zip_entry</name> <operator>*</operator><operator>)</operator><name>n2</name></expr></init></decl>;</decl_stmt>

<return>return <expr><operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>e2</name><operator>-&gt;</operator><name>rsrcname</name><operator>.</operator><name>s</name></name></expr></argument>, <argument><expr><name><name>e1</name><operator>-&gt;</operator><name>rsrcname</name><operator>.</operator><name>s</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>rsrc_cmp_key</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>archive_rb_node</name></name> <modifier>*</modifier></type><name>n</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>zip_entry</name></name> <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><specifier>const</specifier> struct <name>zip_entry</name> <operator>*</operator><operator>)</operator><name>n</name></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>key</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>rsrcname</name><operator>.</operator><name>s</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>archive_rb_tree_ops</name></name></type> <name>rb_rsrc_ops</name> <init>= <expr><block>{
<expr><operator>&amp;</operator><name>rsrc_cmp_node</name></expr>, <expr><operator>&amp;</operator><name>rsrc_cmp_key</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>rsrc_basename</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>name_length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <name>s</name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>memchr</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>, <argument><expr><name>name_length</name> <operator>-</operator> <operator>(</operator><name>s</name> <operator>-</operator> <name>name</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <operator>++</operator><name>s</name></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><operator>(</operator><name>r</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>expose_parent_dirs</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>zip</name></name> <modifier>*</modifier></type><name>zip</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>name_length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>archive_string</name></name></type> <name>str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>zip_entry</name></name> <modifier>*</modifier></type><name>dir</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>archive_string_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_strncpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>name_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name><name>str</name><operator>.</operator><name>s</name></name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>s</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>


<expr_stmt><expr><name>dir</name> <operator>=</operator> <operator>(</operator>struct <name>zip_entry</name> <operator>*</operator><operator>)</operator>
<call><name>__archive_rb_tree_find_node</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>tree_rsrc</name></name></expr></argument>, <argument><expr><name><name>str</name><operator>.</operator><name>s</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>dir</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>__archive_rb_tree_remove_node</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>tree_rsrc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dir</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_string_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dir</name><operator>-&gt;</operator><name>rsrcname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>__archive_rb_tree_insert_node</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>tree</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dir</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>archive_string_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>slurp_central_directory</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_read</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>archive_entry</name></name><modifier>*</modifier></type> <name>entry</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>zip</name></name> <modifier>*</modifier></type><name>zip</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>found</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>correction</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>bytes_avail</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>











<if_stmt><if>if <condition>(<expr><call><name>__archive_read_seek</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>zip</name><operator>-&gt;</operator><name>central_directory_offset_adjusted</name></name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call>
<operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ARCHIVE_FATAL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>found</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>__archive_read_ahead</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytes_avail</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ARCHIVE_FATAL</name></expr>;</return></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>found</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>!</operator><name>found</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name>bytes_avail</name> <operator>-</operator> <literal type="number">4</literal></expr>;</condition><incr/>)</control> <block>{<block_content>
<switch>switch <condition>(<expr><name><name>p</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">3</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'P'</literal></expr>:</case> <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'K'</literal></expr>:</case> <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">001</literal></expr>:</case> <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">002</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><literal type="string">"PK\001\002"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name>found</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
<break>break;</break>
<case>case <expr><literal type="number">005</literal></expr>:</case> <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="number">006</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><literal type="string">"PK\005\006"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name>found</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><literal type="string">"PK\006\006"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name>found</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
<break>break;</break>
<default>default:</default> <expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt> <break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></for>
<expr_stmt><expr><call><name>__archive_read_consume</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name>correction</name> <operator>=</operator> <call><name>archive_filter_bytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call>
<operator>-</operator> <name><name>zip</name><operator>-&gt;</operator><name>central_directory_offset</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>__archive_rb_tree_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>tree</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rb_ops</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>__archive_rb_tree_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>tree_rsrc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rb_rsrc_ops</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>central_directory_entries_total</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>zip_entry</name></name> <modifier>*</modifier></type><name>zip_entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>filename_length</name></decl>, <decl><type ref="prev"/><name>extra_length</name></decl>, <decl><type ref="prev"/><name>comment_length</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>external_attributes</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>__archive_read_ahead</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ARCHIVE_FATAL</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"PK\006\006"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>
<operator>||</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"PK\005\006"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"PK\001\002"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>,
<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"Invalid central directory signature"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ARCHIVE_FATAL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>__archive_read_ahead</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">46</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ARCHIVE_FATAL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>zip_entry</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>zip_entry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>zip_entry</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ENOMEM</name></expr></argument>,
<argument><expr><literal type="string">"Can't allocate zip entry"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ARCHIVE_FATAL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>zip_entries</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>LA_FROM_CENTRAL_DIRECTORY</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>zip_entries</name></name> <operator>=</operator> <name>zip_entry</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>central_directory_entries_total</name></name><operator>++</operator></expr>;</expr_stmt>


<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>system</name></name> <operator>=</operator> <name><name>p</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>zip_flags</name></name> <operator>=</operator> <call><name>archive_le16dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip_entry</name><operator>-&gt;</operator><name>zip_flags</name></name>
<operator>&amp;</operator> <operator>(</operator><name>ZIP_ENCRYPTED</name> <operator>|</operator> <name>ZIP_STRONG_ENCRYPTED</name><operator>)</operator></expr>)</condition><block>{<block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>has_encrypted_entries</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>compression</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><call><name>archive_le16dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>mtime</name></name> <operator>=</operator> <call><name>zip_time</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">12</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>crc32</name></name> <operator>=</operator> <call><name>archive_le32dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip_entry</name><operator>-&gt;</operator><name>zip_flags</name></name> <operator>&amp;</operator> <name>ZIP_LENGTH_AT_END</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>decdat</name></name> <operator>=</operator> <name><name>p</name><index>[<expr><literal type="number">13</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>decdat</name></name> <operator>=</operator> <name><name>p</name><index>[<expr><literal type="number">19</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>compressed_size</name></name> <operator>=</operator> <call><name>archive_le32dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>uncompressed_size</name></name> <operator>=</operator> <call><name>archive_le32dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">24</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>filename_length</name> <operator>=</operator> <call><name>archive_le16dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">28</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>extra_length</name> <operator>=</operator> <call><name>archive_le16dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">30</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>comment_length</name> <operator>=</operator> <call><name>archive_le16dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><name>external_attributes</name> <operator>=</operator> <call><name>archive_le32dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">38</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>local_header_offset</name></name> <operator>=</operator>
<call><name>archive_le32dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">42</literal></expr></argument>)</argument_list></call> <operator>+</operator> <name>correction</name></expr>;</expr_stmt>




<if_stmt><if>if <condition>(<expr><name><name>zip_entry</name><operator>-&gt;</operator><name>system</name></name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>external_attributes</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>zip_entry</name><operator>-&gt;</operator><name>system</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><literal type="number">0x10</literal> <operator>==</operator> <operator>(</operator><name>external_attributes</name> <operator>&amp;</operator> <literal type="number">0x10</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>AE_IFDIR</name> <operator>|</operator> <literal type="number">0775</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>AE_IFREG</name> <operator>|</operator> <literal type="number">0664</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><literal type="number">0x01</literal> <operator>==</operator> <operator>(</operator><name>external_attributes</name> <operator>&amp;</operator> <literal type="number">0x01</literal><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;=</operator> <literal type="number">0555</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>zip_entry</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>



<expr_stmt><expr><call><name>__archive_read_consume</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">46</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>__archive_read_ahead</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>filename_length</name> <operator>+</operator> <name>extra_length</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>,
<argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>,
<argument><expr><literal type="string">"Truncated ZIP file header"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ARCHIVE_FATAL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ARCHIVE_OK</name> <operator>!=</operator> <call><name>process_extra</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name>filename_length</name></expr></argument>,
<argument><expr><name>extra_length</name></expr></argument>, <argument><expr><name>zip_entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>ARCHIVE_FATAL</name></expr>;</return>
</block_content>}</block></if></if_stmt>






<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>zip</name><operator>-&gt;</operator><name>process_mac_extensions</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>__archive_rb_tree_insert_node</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>tree</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>zip_entry</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>name</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>rsrc_basename</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>filename_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>filename_length</name> <operator>&gt;=</operator> <literal type="number">9</literal> <operator>&amp;&amp;</operator>
<call><name>strncmp</name><argument_list>(<argument><expr><literal type="string">"__MACOSX/"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>



<if_stmt><if>if <condition>(<expr><name><name>name</name><index>[<expr><name>filename_length</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'/'</literal> <operator>&amp;&amp;</operator>
<operator>(</operator><name>r</name> <operator>-</operator> <name>name</name> <operator>&lt;</operator> <literal type="number">3</literal> <operator>||</operator> <name><name>r</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'.'</literal> <operator>||</operator>
<name><name>r</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'_'</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>__archive_rb_tree_insert_node</name><argument_list>(
<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>tree</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zip_entry</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>expose_parent_dirs</name><argument_list>(<argument><expr><name>zip</name></expr></argument>, <argument><expr><name>name</name></expr></argument>,
<argument><expr><name>filename_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>


<expr_stmt><expr><call><name>archive_strncpy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>zip_entry</name><operator>-&gt;</operator><name>rsrcname</name></name><operator>)</operator></expr></argument>,
<argument><expr><name>name</name></expr></argument>, <argument><expr><name>filename_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>__archive_rb_tree_insert_node</name><argument_list>(
<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>tree_rsrc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zip_entry</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>


<expr_stmt><expr><call><name>archive_strcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>zip_entry</name><operator>-&gt;</operator><name>rsrcname</name></name><operator>)</operator></expr></argument>,
<argument><expr><literal type="string">"__MACOSX/"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_strncat</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>zip_entry</name><operator>-&gt;</operator><name>rsrcname</name></name><operator>)</operator></expr></argument>,
<argument><expr><name>name</name></expr></argument>, <argument><expr><name>r</name> <operator>-</operator> <name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_strcat</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>zip_entry</name><operator>-&gt;</operator><name>rsrcname</name></name><operator>)</operator></expr></argument>, <argument><expr><literal type="string">"._"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_strncat</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>zip_entry</name><operator>-&gt;</operator><name>rsrcname</name></name><operator>)</operator></expr></argument>,
<argument><expr><name>name</name> <operator>+</operator> <operator>(</operator><name>r</name> <operator>-</operator> <name>name</name><operator>)</operator></expr></argument>,
<argument><expr><name>filename_length</name> <operator>-</operator> <operator>(</operator><name>r</name> <operator>-</operator> <name>name</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>__archive_rb_tree_insert_node</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>tree</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>zip_entry</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>


<expr_stmt><expr><call><name>__archive_read_consume</name><argument_list>(<argument><expr><name>a</name></expr></argument>,
<argument><expr><name>filename_length</name> <operator>+</operator> <name>extra_length</name> <operator>+</operator> <name>comment_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>

<return>return <expr><name>ARCHIVE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ssize_t</name></type>
<name>zip_get_local_file_header_size</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_read</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>filename_length</name></decl>, <decl><type ref="prev"/><name>extra_length</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>__archive_read_ahead</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>extra</name> <operator>+</operator> <literal type="number">30</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>,
<argument><expr><literal type="string">"Truncated ZIP file header"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_WARN</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>extra</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"PK\003\004"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"Damaged Zip archive"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ARCHIVE_WARN</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>filename_length</name> <operator>=</operator> <call><name>archive_le16dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">26</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>extra_length</name> <operator>=</operator> <call><name>archive_le16dec</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">28</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><literal type="number">30</literal> <operator>+</operator> <name>filename_length</name> <operator>+</operator> <name>extra_length</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>zip_read_mac_metadata</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_read</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>archive_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>zip_entry</name></name> <modifier>*</modifier></type><name>rsrc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>zip</name></name> <modifier>*</modifier></type><name>zip</name> <init>= <expr><operator>(</operator>struct <name>zip</name> <operator>*</operator><operator>)</operator><name><name>a</name><operator>-&gt;</operator><name>format</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>metadata</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>mp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>offset</name> <init>= <expr><call><name>archive_filter_bytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>remaining_bytes</name></decl>, <decl><type ref="prev"/><name>metadata_bytes</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>hsize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><name>ARCHIVE_OK</name></expr></init></decl>, <decl><type ref="prev"/><name>eof</name></decl>;</decl_stmt>

<switch>switch<condition>(<expr><name><name>rsrc</name><operator>-&gt;</operator><name>compression</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>rsrc</name><operator>-&gt;</operator><name>uncompressed_size</name></name> <operator>!=</operator> <name><name>rsrc</name><operator>-&gt;</operator><name>compressed_size</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>,
<argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>,
<argument><expr><literal type="string">"Malformed OS X metadata entry: "</literal>
<literal type="string">"inconsistent size"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_ZLIB_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><literal type="number">8</literal></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<break>break;</break>
<default>default:</default>

<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>,
<argument><expr><literal type="string">"Unsupported ZIP compression method (%s)"</literal></expr></argument>,
<argument><expr><call><name>compression_name</name><argument_list>(<argument><expr><name><name>rsrc</name><operator>-&gt;</operator><name>compression</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<return>return <expr><operator>(</operator><name>ARCHIVE_WARN</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name><name>rsrc</name><operator>-&gt;</operator><name>uncompressed_size</name></name> <operator>&gt;</operator> <operator>(</operator><literal type="number">4</literal> <operator>*</operator> <literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>,
<argument><expr><literal type="string">"Mac metadata is too large: %jd &gt; 4M bytes"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>intmax_t</name><operator>)</operator><name><name>rsrc</name><operator>-&gt;</operator><name>uncompressed_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_WARN</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>rsrc</name><operator>-&gt;</operator><name>compressed_size</name></name> <operator>&gt;</operator> <operator>(</operator><literal type="number">4</literal> <operator>*</operator> <literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>,
<argument><expr><literal type="string">"Mac metadata is too large: %jd &gt; 4M bytes"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>intmax_t</name><operator>)</operator><name><name>rsrc</name><operator>-&gt;</operator><name>compressed_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_WARN</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>metadata</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>rsrc</name><operator>-&gt;</operator><name>uncompressed_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>metadata</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ENOMEM</name></expr></argument>,
<argument><expr><literal type="string">"Can't allocate memory for Mac metadata"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&lt;</operator> <name><name>rsrc</name><operator>-&gt;</operator><name>local_header_offset</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>__archive_read_consume</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>rsrc</name><operator>-&gt;</operator><name>local_header_offset</name></name> <operator>-</operator> <name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>offset</name> <operator>!=</operator> <name><name>rsrc</name><operator>-&gt;</operator><name>local_header_offset</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>__archive_read_seek</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>rsrc</name><operator>-&gt;</operator><name>local_header_offset</name></name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>hsize</name> <operator>=</operator> <call><name>zip_get_local_file_header_size</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>__archive_read_consume</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>hsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>remaining_bytes</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name><name>rsrc</name><operator>-&gt;</operator><name>compressed_size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>metadata_bytes</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name><name>rsrc</name><operator>-&gt;</operator><name>uncompressed_size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>mp</name> <operator>=</operator> <name>metadata</name></expr>;</expr_stmt>
<expr_stmt><expr><name>eof</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>!</operator><name>eof</name> <operator>&amp;&amp;</operator> <name>remaining_bytes</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>bytes_avail</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>bytes_used</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>__archive_read_ahead</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytes_avail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>,
<argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>,
<argument><expr><literal type="string">"Truncated ZIP file header"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>ARCHIVE_WARN</name></expr>;</expr_stmt>
<goto>goto <name>exit_mac_metadata</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>size_t</name><operator>)</operator><name>bytes_avail</name> <operator>&gt;</operator> <name>remaining_bytes</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>bytes_avail</name> <operator>=</operator> <name>remaining_bytes</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<switch>switch<condition>(<expr><name><name>rsrc</name><operator>-&gt;</operator><name>compression</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>size_t</name><operator>)</operator><name>bytes_avail</name> <operator>&gt;</operator> <name>metadata_bytes</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>bytes_avail</name> <operator>=</operator> <name>metadata_bytes</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>mp</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>bytes_avail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bytes_used</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>bytes_avail</name></expr>;</expr_stmt>
<expr_stmt><expr><name>metadata_bytes</name> <operator>-=</operator> <name>bytes_used</name></expr>;</expr_stmt>
<expr_stmt><expr><name>mp</name> <operator>+=</operator> <name>bytes_used</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>metadata_bytes</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>eof</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_ZLIB_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><literal type="number">8</literal></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>zip_deflate_init</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>zip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>ARCHIVE_OK</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>exit_mac_metadata</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>stream</name><operator>.</operator><name>next_in</name></name> <operator>=</operator>
<operator>(</operator><name>Bytef</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>stream</name><operator>.</operator><name>avail_in</name></name> <operator>=</operator> <operator>(</operator><name>uInt</name><operator>)</operator><name>bytes_avail</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>stream</name><operator>.</operator><name>total_in</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>stream</name><operator>.</operator><name>next_out</name></name> <operator>=</operator> <name>mp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>stream</name><operator>.</operator><name>avail_out</name></name> <operator>=</operator> <operator>(</operator><name>uInt</name><operator>)</operator><name>metadata_bytes</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>stream</name><operator>.</operator><name>total_out</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>inflate</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>stream</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>r</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>Z_OK</name></expr>:</case>
<break>break;</break>
<case>case <expr><name>Z_STREAM_END</name></expr>:</case>
<expr_stmt><expr><name>eof</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>Z_MEM_ERROR</name></expr>:</case>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ENOMEM</name></expr></argument>,
<argument><expr><literal type="string">"Out of memory for ZIP decompression"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>ARCHIVE_FATAL</name></expr>;</expr_stmt>
<goto>goto <name>exit_mac_metadata</name>;</goto>
<default>default:</default>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>,
<argument><expr><name>ARCHIVE_ERRNO_MISC</name></expr></argument>,
<argument><expr><literal type="string">"ZIP decompression failed (%d)"</literal></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>ARCHIVE_FATAL</name></expr>;</expr_stmt>
<goto>goto <name>exit_mac_metadata</name>;</goto>
</block_content>}</block></switch>
<expr_stmt><expr><name>bytes_used</name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>stream</name><operator>.</operator><name>total_in</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>metadata_bytes</name> <operator>-=</operator> <name><name>zip</name><operator>-&gt;</operator><name>stream</name><operator>.</operator><name>total_out</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>mp</name> <operator>+=</operator> <name><name>zip</name><operator>-&gt;</operator><name>stream</name><operator>.</operator><name>total_out</name></name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<default>default:</default>
<expr_stmt><expr><name>bytes_used</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>__archive_read_consume</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>bytes_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>remaining_bytes</name> <operator>-=</operator> <name>bytes_used</name></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>archive_entry_copy_mac_metadata</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>metadata</name></expr></argument>,
<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>rsrc</name><operator>-&gt;</operator><name>uncompressed_size</name></name> <operator>-</operator> <name>metadata_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>exit_mac_metadata</name>:</label>
<expr_stmt><expr><call><name>__archive_read_seek</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>decompress_init</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>metadata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ret</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>archive_read_format_zip_seekable_read_header</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_read</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>archive_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>zip</name></name> <modifier>*</modifier></type><name>zip</name> <init>= <expr><operator>(</operator>struct <name>zip</name> <operator>*</operator><operator>)</operator><name><name>a</name><operator>-&gt;</operator><name>format</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>zip_entry</name></name> <modifier>*</modifier></type><name>rsrc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>ret</name> <init>= <expr><name>ARCHIVE_OK</name></expr></init></decl>;</decl_stmt>








<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>has_encrypted_entries</name></name> <operator>==</operator>
<name>ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>has_encrypted_entries</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>archive</name><operator>.</operator><name>archive_format</name></name> <operator>=</operator> <name>ARCHIVE_FORMAT_ZIP</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>archive</name><operator>.</operator><name>archive_format_name</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>archive</name><operator>.</operator><name>archive_format_name</name></name> <operator>=</operator> <literal type="string">"ZIP"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>zip_entries</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>slurp_central_directory</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>zip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>ARCHIVE_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name></name> <operator>=</operator>
<operator>(</operator>struct <name>zip_entry</name> <operator>*</operator><operator>)</operator><call><name>ARCHIVE_RB_TREE_MIN</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>tree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name></name> <operator>=</operator> <operator>(</operator>struct <name>zip_entry</name> <operator>*</operator><operator>)</operator><call><name>__archive_rb_tree_iterate</name><argument_list>(
<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>tree</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>node</name></name></expr></argument>, <argument><expr><name>ARCHIVE_RB_DIR_RIGHT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ARCHIVE_EOF</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>rsrcname</name><operator>.</operator><name>s</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>rsrc</name> <operator>=</operator> <operator>(</operator>struct <name>zip_entry</name> <operator>*</operator><operator>)</operator><call><name>__archive_rb_tree_find_node</name><argument_list>(
<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>tree_rsrc</name></name></expr></argument>, <argument><expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>rsrcname</name><operator>.</operator><name>s</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>rsrc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>cctx_valid</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>archive_decrypto_aes_ctr_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>cctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>hctx_valid</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>archive_hmac_sha1_cleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>hctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>tctx_valid</name></name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>cctx_valid</name></name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>hctx_valid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>__archive_read_reset_passphrase</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>archive_filter_bytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&lt;</operator> <name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>local_header_offset</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>__archive_read_consume</name><argument_list>(<argument><expr><name>a</name></expr></argument>,
<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>local_header_offset</name></name> <operator>-</operator> <name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>offset</name> <operator>!=</operator> <name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>local_header_offset</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>__archive_read_seek</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name><operator>-&gt;</operator><name>local_header_offset</name></name></expr></argument>,
<argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>unconsumed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>zip_read_local_file_header</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>zip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>ARCHIVE_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>r</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>rsrc</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret2</name> <init>= <expr><call><name>zip_read_mac_metadata</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>rsrc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ret2</name> <operator>&lt;</operator> <name>ret</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>ret2</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name>ret</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type>
<name>archive_read_format_zip_read_data_skip_seekable</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_read</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>zip</name></name> <modifier>*</modifier></type><name>zip</name></decl>;</decl_stmt>
<expr_stmt><expr><name>zip</name> <operator>=</operator> <operator>(</operator>struct <name>zip</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>format</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>unconsumed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_OK</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>archive_read_support_format_zip_seekable</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive</name></name> <modifier>*</modifier></type><name>_a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>archive_read</name></name> <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>(</operator>struct <name>archive_read</name> <operator>*</operator><operator>)</operator><name>_a</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>zip</name></name> <modifier>*</modifier></type><name>zip</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>archive_check_magic</name><argument_list>(<argument><expr><name>_a</name></expr></argument>, <argument><expr><name>ARCHIVE_READ_MAGIC</name></expr></argument>,
<argument><expr><name>ARCHIVE_STATE_NEW</name></expr></argument>, <argument><expr><literal type="string">"archive_read_support_format_zip_seekable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>zip</name> <operator>=</operator> <operator>(</operator>struct <name>zip</name> <operator>*</operator><operator>)</operator><call><name>calloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>zip</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>zip</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ENOMEM</name></expr></argument>,
<argument><expr><literal type="string">"Can't allocate zip data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_COPYFILE_H</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>process_mac_extensions</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>





<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>has_encrypted_entries</name></name> <operator>=</operator> <name>ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>crc32func</name></name> <operator>=</operator> <name>real_crc32</name></expr>;</expr_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>__archive_read_register_format</name><argument_list>(<argument><expr><name>a</name></expr></argument>,
<argument><expr><name>zip</name></expr></argument>,
<argument><expr><literal type="string">"zip"</literal></expr></argument>,
<argument><expr><name>archive_read_format_zip_seekable_bid</name></expr></argument>,
<argument><expr><name>archive_read_format_zip_options</name></expr></argument>,
<argument><expr><name>archive_read_format_zip_seekable_read_header</name></expr></argument>,
<argument><expr><name>archive_read_format_zip_read_data</name></expr></argument>,
<argument><expr><name>archive_read_format_zip_read_data_skip_seekable</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>archive_read_format_zip_cleanup</name></expr></argument>,
<argument><expr><name>archive_read_support_format_zip_capabilities_seekable</name></expr></argument>,
<argument><expr><name>archive_read_format_zip_has_encrypted_entries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>ARCHIVE_OK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>zip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_OK</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


</unit>
