<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/libarchive/libarchive/archive_write_set_format_zip.c">






























<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"archive_platform.h"</cpp:file></cpp:include>
<expr_stmt><expr><call><name>__FBSDID</name><argument_list>(<argument><expr><literal type="string">"$FreeBSD$"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_ERRNO_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LANGINFO_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;langinfo.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STDLIB_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRING_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_ZLIB_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;zlib.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"archive.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"archive_cryptor_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"archive_endian.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"archive_entry.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"archive_entry_locale.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"archive_hmac_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"archive_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"archive_random_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"archive_write_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"archive_write_set_format_private.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_ZLIB_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"archive_crc32.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIP_ENTRY_FLAG_ENCRYPTED</name></cpp:macro> <cpp:value>(1&lt;&lt;0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIP_ENTRY_FLAG_LENGTH_AT_END</name></cpp:macro> <cpp:value>(1&lt;&lt;3)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIP_ENTRY_FLAG_UTF8_NAME</name></cpp:macro> <cpp:value>(1 &lt;&lt; 11)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIP_4GB_MAX</name></cpp:macro> <cpp:value>ARCHIVE_LITERAL_LL(0xffffffff)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIP_4GB_MAX_UNCOMPRESSED</name></cpp:macro> <cpp:value>ARCHIVE_LITERAL_LL(0xff000000)</cpp:value></cpp:define>

<enum>enum <name>compression</name> <block>{
<decl><name>COMPRESSION_UNSPECIFIED</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>,
<decl><name>COMPRESSION_STORE</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>COMPRESSION_DEFLATE</name> <init>= <expr><literal type="number">8</literal></expr></init></decl>
}</block>;</enum>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_ZLIB_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPRESSION_DEFAULT</name></cpp:macro> <cpp:value>COMPRESSION_DEFLATE</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPRESSION_DEFAULT</name></cpp:macro> <cpp:value>COMPRESSION_STORE</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<enum>enum <name>encryption</name> <block>{
<decl><name>ENCRYPTION_NONE</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>ENCRYPTION_TRADITIONAL</name></decl>,
<decl><name>ENCRYPTION_WINZIP_AES128</name></decl>,
<decl><name>ENCRYPTION_WINZIP_AES256</name></decl>,
}</block>;</enum>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRAD_HEADER_SIZE</name></cpp:macro> <cpp:value>12</cpp:value></cpp:define>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WINZIP_AES_ENCRYPTION</name></cpp:macro> <cpp:value>99</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WINZIP_AES128_HEADER_SIZE</name></cpp:macro> <cpp:value>(8 + 2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WINZIP_AES256_HEADER_SIZE</name></cpp:macro> <cpp:value>(16 + 2)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AES_VENDOR_AE_1</name></cpp:macro> <cpp:value>0x0001</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AES_VENDOR_AE_2</name></cpp:macro> <cpp:value>0x0002</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AUTH_CODE_SIZE</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_DERIVED_KEY_BUF_SIZE</name></cpp:macro> <cpp:value>(AES_MAX_KEY_SIZE * 2 + 2)</cpp:value></cpp:define>

<struct>struct <name>cd_segment</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>cd_segment</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>buff_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buff</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>trad_enc_ctx</name> <block>{
<decl_stmt><decl><type><name>uint32_t</name></type> <name><name>keys</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>zip</name> <block>{

<decl_stmt><decl><type><name>int64_t</name></type> <name>entry_offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>entry_compressed_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>entry_uncompressed_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>entry_compressed_written</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>entry_uncompressed_written</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>entry_uncompressed_limit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>archive_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>entry_crc32</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>compression</name></name></type> <name>entry_compression</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>encryption</name></name></type> <name>entry_encryption</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>entry_flags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>entry_uses_zip64</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>experiments</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>trad_enc_ctx</name></name></type> <name>tctx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>tctx_valid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>trad_chkdat</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>aes_vendor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>archive_crypto_ctx</name></type> <name>cctx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>cctx_valid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>archive_hmac_sha1_ctx</name></type> <name>hctx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>hctx_valid</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>file_header</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>file_header_extra_offset</name></decl>;</decl_stmt>
<function_decl><type><name>unsigned</name> <name>long</name></type> (<modifier>*</modifier><name>crc32func</name>)<parameter_list>(<parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>crc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>buff</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name><name>struct</name> <name>cd_segment</name></name> <modifier>*</modifier></type><name>central_directory</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>cd_segment</name></name> <modifier>*</modifier></type><name>central_directory_last</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>central_directory_bytes</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>central_directory_entries</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int64_t</name></type> <name>written_bytes</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>archive_string_conv</name></name> <modifier>*</modifier></type><name>opt_sconv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>archive_string_conv</name></name> <modifier>*</modifier></type><name>sconv_default</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>compression</name></name></type> <name>requested_compression</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>deflate_compression_level</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>init_default_conversion</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>encryption</name></name></type> <name>encryption_type</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIP_FLAG_AVOID_ZIP64</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIP_FLAG_FORCE_ZIP64</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIP_FLAG_EXPERIMENT_xl</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_ZLIB_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>z_stream</name></type> <name>stream</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>size_t</name></type> <name>len_buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
}</block>;</struct>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>zipmin</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((a) &gt; (b) ? (b) : (a))</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>ssize_t</name></type> <name>archive_write_zip_data</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_write</name></name> <modifier>*</modifier></type></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>buff</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>s</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>archive_write_zip_close</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_write</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>archive_write_zip_free</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_write</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>archive_write_zip_finish_entry</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_write</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>archive_write_zip_header</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_write</name></name> <modifier>*</modifier></type></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>archive_entry</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>archive_write_zip_options</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_write</name></name> <modifier>*</modifier></type></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>dos_time</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>time_t</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>size_t</name></type> <name>path_length</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_entry</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>write_path</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_entry</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>archive_write</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>copy_path</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_entry</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>struct</name> <name>archive_string_conv</name></name> <modifier>*</modifier></type><name>get_sconv</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_write</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>zip</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>trad_enc_init</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>trad_enc_ctx</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>unsigned</name></type> <name>trad_enc_encrypt_update</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>trad_enc_ctx</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type></decl></parameter>,
<parameter><decl><type><name>size_t</name></type></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>init_traditional_pkware_encryption</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_write</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>is_traditional_pkware_encryption_supported</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>init_winzip_aes_encryption</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_write</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>is_winzip_aes_encryption_supported</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>encryption</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type>
<name>cd_alloc</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>zip</name></name> <modifier>*</modifier></type><name>zip</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>central_directory</name></name> <operator>==</operator> <name>NULL</name>
<operator>||</operator> <operator>(</operator><name><name>zip</name><operator>-&gt;</operator><name>central_directory_last</name><operator>-&gt;</operator><name>p</name></name> <operator>+</operator> <name>length</name>
<operator>&gt;</operator> <name><name>zip</name><operator>-&gt;</operator><name>central_directory_last</name><operator>-&gt;</operator><name>buff</name></name> <operator>+</operator> <name><name>zip</name><operator>-&gt;</operator><name>central_directory_last</name><operator>-&gt;</operator><name>buff_size</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>cd_segment</name></name> <modifier>*</modifier></type><name>segment</name> <init>= <expr><call><name>calloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>segment</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>segment</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>segment</name><operator>-&gt;</operator><name>buff_size</name></name> <operator>=</operator> <literal type="number">64</literal> <operator>*</operator> <literal type="number">1024</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>segment</name><operator>-&gt;</operator><name>buff</name></name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name><name>segment</name><operator>-&gt;</operator><name>buff_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>segment</name><operator>-&gt;</operator><name>buff</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>segment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>segment</name><operator>-&gt;</operator><name>p</name></name> <operator>=</operator> <name><name>segment</name><operator>-&gt;</operator><name>buff</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>central_directory</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>central_directory</name></name>
<operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>central_directory_last</name></name>
<operator>=</operator> <name>segment</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>central_directory_last</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>segment</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>central_directory_last</name></name> <operator>=</operator> <name>segment</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>central_directory_last</name><operator>-&gt;</operator><name>p</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>central_directory_last</name><operator>-&gt;</operator><name>p</name></name> <operator>+=</operator> <name>length</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>central_directory_bytes</name></name> <operator>+=</operator> <name>length</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>p</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type>
<name>real_crc32</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>crc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>buff</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>crc32</name><argument_list>(<argument><expr><name>crc</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type>
<name>fake_crc32</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>crc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>buff</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>crc</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>buff</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>len</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>archive_write_zip_options</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_write</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>zip</name></name> <modifier>*</modifier></type><name>zip</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>format_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><name>ARCHIVE_FAILED</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="string">"compression"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>




<if_stmt><if>if <condition>(<expr><name>val</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>val</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_MISC</name></expr></argument>,
<argument><expr><literal type="string">"%s: compression option needs a compression name"</literal></expr></argument>,
<argument><expr><name><name>a</name><operator>-&gt;</operator><name>format_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="string">"deflate"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_ZLIB_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>requested_compression</name></name> <operator>=</operator> <name>COMPRESSION_DEFLATE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>ARCHIVE_OK</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_MISC</name></expr></argument>,
<argument><expr><literal type="string">"deflate compression not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="string">"store"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>requested_compression</name></name> <operator>=</operator> <name>COMPRESSION_STORE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>ARCHIVE_OK</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name>ret</name><operator>)</operator></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="string">"compression-level"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>val</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><operator>(</operator><name><name>val</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name><name>val</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">'9'</literal><operator>)</operator> <operator>||</operator> <name><name>val</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>ARCHIVE_WARN</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>val</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>requested_compression</name></name> <operator>=</operator> <name>COMPRESSION_STORE</name></expr>;</expr_stmt>
<return>return <expr><name>ARCHIVE_OK</name></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_ZLIB_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>requested_compression</name></name> <operator>=</operator> <name>COMPRESSION_DEFLATE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>deflate_compression_level</name></name> <operator>=</operator> <name><name>val</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
<return>return <expr><name>ARCHIVE_OK</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_MISC</name></expr></argument>,
<argument><expr><literal type="string">"deflate compression not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="string">"encryption"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>val</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>encryption_type</name></name> <operator>=</operator> <name>ENCRYPTION_NONE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>ARCHIVE_OK</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>val</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'1'</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="string">"traditional"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>
<operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="string">"zipcrypt"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>
<operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="string">"ZipCrypt"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>is_traditional_pkware_encryption_supported</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>encryption_type</name></name> <operator>=</operator> <name>ENCRYPTION_TRADITIONAL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>ARCHIVE_OK</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>,
<argument><expr><name>ARCHIVE_ERRNO_MISC</name></expr></argument>,
<argument><expr><literal type="string">"encryption not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="string">"aes128"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>is_winzip_aes_encryption_supported</name><argument_list>(
<argument><expr><name>ENCRYPTION_WINZIP_AES128</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>encryption_type</name></name> <operator>=</operator> <name>ENCRYPTION_WINZIP_AES128</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>ARCHIVE_OK</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>,
<argument><expr><name>ARCHIVE_ERRNO_MISC</name></expr></argument>,
<argument><expr><literal type="string">"encryption not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="string">"aes256"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>is_winzip_aes_encryption_supported</name><argument_list>(
<argument><expr><name>ENCRYPTION_WINZIP_AES256</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>encryption_type</name></name> <operator>=</operator> <name>ENCRYPTION_WINZIP_AES256</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>ARCHIVE_OK</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>,
<argument><expr><name>ARCHIVE_ERRNO_MISC</name></expr></argument>,
<argument><expr><literal type="string">"encryption not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_MISC</name></expr></argument>,
<argument><expr><literal type="string">"%s: unknown encryption '%s'"</literal></expr></argument>,
<argument><expr><name><name>a</name><operator>-&gt;</operator><name>format_name</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><operator>(</operator><name>ret</name><operator>)</operator></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="string">"experimental"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>val</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>val</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator> <name>ZIP_FLAG_EXPERIMENT_xl</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>ZIP_FLAG_EXPERIMENT_xl</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_OK</name><operator>)</operator></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="string">"fakecrc32"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>




<if_stmt><if>if <condition>(<expr><name>val</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>val</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>crc32func</name></name> <operator>=</operator> <name>real_crc32</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>crc32func</name></name> <operator>=</operator> <name>fake_crc32</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_OK</name><operator>)</operator></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="string">"hdrcharset"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>



<if_stmt><if>if <condition>(<expr><name>val</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>val</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_MISC</name></expr></argument>,
<argument><expr><literal type="string">"%s: hdrcharset option needs a character-set name"</literal></expr></argument>,
<argument><expr><name><name>a</name><operator>-&gt;</operator><name>format_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>opt_sconv</name></name> <operator>=</operator> <call><name>archive_string_conversion_to_charset</name><argument_list>(
<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>opt_sconv</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>ARCHIVE_OK</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>ARCHIVE_FATAL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><operator>(</operator><name>ret</name><operator>)</operator></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="string">"zip64"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>






<if_stmt><if>if <condition>(<expr><name>val</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>val</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>ZIP_FLAG_FORCE_ZIP64</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>ZIP_FLAG_AVOID_ZIP64</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>ZIP_FLAG_FORCE_ZIP64</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>ZIP_FLAG_AVOID_ZIP64</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_OK</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>




<return>return <expr><operator>(</operator><name>ARCHIVE_WARN</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>archive_write_zip_set_compression_deflate</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive</name></name> <modifier>*</modifier></type><name>_a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>archive_write</name></name> <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>(</operator>struct <name>archive_write</name> <operator>*</operator><operator>)</operator><name>_a</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><name>ARCHIVE_FAILED</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>archive_check_magic</name><argument_list>(<argument><expr><name>_a</name></expr></argument>, <argument><expr><name>ARCHIVE_WRITE_MAGIC</name></expr></argument>,
<argument><expr><name>ARCHIVE_STATE_NEW</name> <operator>|</operator> <name>ARCHIVE_STATE_HEADER</name> <operator>|</operator> <name>ARCHIVE_STATE_DATA</name></expr></argument>,
<argument><expr><literal type="string">"archive_write_zip_set_compression_deflate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>archive</name><operator>.</operator><name>archive_format</name></name> <operator>!=</operator> <name>ARCHIVE_FORMAT_ZIP</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_MISC</name></expr></argument>,
<argument><expr><literal type="string">"Can only use archive_write_zip_set_compression_deflate"</literal>
<literal type="string">" with zip format"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>ARCHIVE_FATAL</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_ZLIB_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name><name>struct</name> <name>zip</name></name> <modifier>*</modifier></type><name>zip</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>format_data</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>requested_compression</name></name> <operator>=</operator> <name>COMPRESSION_DEFLATE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>ARCHIVE_OK</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_MISC</name></expr></argument>,
<argument><expr><literal type="string">"deflate compression not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>ARCHIVE_FAILED</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></else></if_stmt>
<return>return <expr><operator>(</operator><name>ret</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>archive_write_zip_set_compression_store</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive</name></name> <modifier>*</modifier></type><name>_a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>archive_write</name></name> <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>(</operator>struct <name>archive_write</name> <operator>*</operator><operator>)</operator><name>_a</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>zip</name></name> <modifier>*</modifier></type><name>zip</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>format_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><name>ARCHIVE_FAILED</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>archive_check_magic</name><argument_list>(<argument><expr><name>_a</name></expr></argument>, <argument><expr><name>ARCHIVE_WRITE_MAGIC</name></expr></argument>,
<argument><expr><name>ARCHIVE_STATE_NEW</name> <operator>|</operator> <name>ARCHIVE_STATE_HEADER</name> <operator>|</operator> <name>ARCHIVE_STATE_DATA</name></expr></argument>,
<argument><expr><literal type="string">"archive_write_zip_set_compression_deflate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>archive</name><operator>.</operator><name>archive_format</name></name> <operator>!=</operator> <name>ARCHIVE_FORMAT_ZIP</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_MISC</name></expr></argument>,
<argument><expr><literal type="string">"Can only use archive_write_zip_set_compression_store"</literal>
<literal type="string">" with zip format"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>ARCHIVE_FATAL</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>requested_compression</name></name> <operator>=</operator> <name>COMPRESSION_STORE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>ARCHIVE_OK</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><operator>(</operator><name>ret</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>archive_write_set_format_zip</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive</name></name> <modifier>*</modifier></type><name>_a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>archive_write</name></name> <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>(</operator>struct <name>archive_write</name> <operator>*</operator><operator>)</operator><name>_a</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>zip</name></name> <modifier>*</modifier></type><name>zip</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>archive_check_magic</name><argument_list>(<argument><expr><name>_a</name></expr></argument>, <argument><expr><name>ARCHIVE_WRITE_MAGIC</name></expr></argument>,
<argument><expr><name>ARCHIVE_STATE_NEW</name></expr></argument>, <argument><expr><literal type="string">"archive_write_set_format_zip"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>format_free</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>format_free</name></name><operator>)</operator><operator>(</operator><name>a</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>zip</name> <operator>=</operator> <operator>(</operator>struct <name>zip</name> <operator>*</operator><operator>)</operator> <call><name>calloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>zip</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>zip</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ENOMEM</name></expr></argument>,
<argument><expr><literal type="string">"Can't allocate zip data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>requested_compression</name></name> <operator>=</operator> <name>COMPRESSION_UNSPECIFIED</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_ZLIB_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>deflate_compression_level</name></name> <operator>=</operator> <name>Z_DEFAULT_COMPRESSION</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>crc32func</name></name> <operator>=</operator> <name>real_crc32</name></expr>;</expr_stmt>


<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>len_buf</name></name> <operator>=</operator> <literal type="number">65536</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>buf</name></name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>len_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>buf</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>zip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ENOMEM</name></expr></argument>,
<argument><expr><literal type="string">"Can't allocate compression buffer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>format_data</name></name> <operator>=</operator> <name>zip</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>format_name</name></name> <operator>=</operator> <literal type="string">"zip"</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>format_options</name></name> <operator>=</operator> <name>archive_write_zip_options</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>format_write_header</name></name> <operator>=</operator> <name>archive_write_zip_header</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>format_write_data</name></name> <operator>=</operator> <name>archive_write_zip_data</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>format_finish_entry</name></name> <operator>=</operator> <name>archive_write_zip_finish_entry</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>format_close</name></name> <operator>=</operator> <name>archive_write_zip_close</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>format_free</name></name> <operator>=</operator> <name>archive_write_zip_free</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>archive</name><operator>.</operator><name>archive_format</name></name> <operator>=</operator> <name>ARCHIVE_FORMAT_ZIP</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>archive</name><operator>.</operator><name>archive_format_name</name></name> <operator>=</operator> <literal type="string">"ZIP"</literal></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>ARCHIVE_OK</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>is_all_ascii</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>pp</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>p</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>*</operator><name>pp</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>pp</name><operator>++</operator> <operator>&gt;</operator> <literal type="number">127</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></while>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>archive_write_zip_header</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_write</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>archive_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>local_header</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>local_extra</name><index>[<expr><literal type="number">144</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>zip</name></name> <modifier>*</modifier></type><name>zip</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>format_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>cd_extra</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>filename_length</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>slink</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>slink_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>archive_string_conv</name></name> <modifier>*</modifier></type><name>sconv</name> <init>= <expr><call><name>get_sconv</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>zip</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>, <decl><type ref="prev"/><name>ret2</name> <init>= <expr><name>ARCHIVE_OK</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>mode_t</name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>version_needed</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>archive_entry_filetype</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>AE_IFREG</name> <operator>&amp;&amp;</operator> <name>type</name> <operator>!=</operator> <name>AE_IFDIR</name> <operator>&amp;&amp;</operator> <name>type</name> <operator>!=</operator> <name>AE_IFLNK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>__archive_write_entry_filetype_unsupported</name><argument_list>(
<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><literal type="string">"zip"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ARCHIVE_FAILED</name></expr>;</return>
</block_content>}</block></if></if_stmt><empty_stmt>;</empty_stmt>


<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>ZIP_FLAG_AVOID_ZIP64</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>archive_entry_size_is_set</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <operator>(</operator><call><name>archive_entry_size</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>ZIP_4GB_MAX</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_MISC</name></expr></argument>,
<argument><expr><literal type="string">"Files &gt; 4GB require Zip64 extensions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ARCHIVE_FAILED</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>written_bytes</name></name> <operator>&gt;</operator> <name>ZIP_4GB_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_MISC</name></expr></argument>,
<argument><expr><literal type="string">"Archives &gt; 4GB require Zip64 extensions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ARCHIVE_FAILED</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>AE_IFREG</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>archive_entry_set_size</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>



<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_offset</name></name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>written_bytes</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_uncompressed_limit</name></name> <operator>=</operator> <name>INT64_MAX</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_compressed_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_uncompressed_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_compressed_written</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_uncompressed_written</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_uses_zip64</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_crc32</name></name> <operator>=</operator> <call><name><name>zip</name><operator>-&gt;</operator><name>crc32func</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_encryption</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_entry_free</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>cctx_valid</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>archive_encrypto_aes_ctr_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>cctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>hctx_valid</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>archive_hmac_sha1_cleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>hctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>tctx_valid</name></name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>cctx_valid</name></name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>hctx_valid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>AE_IFREG</name>
<operator>&amp;&amp;</operator><operator>(</operator><operator>!</operator><call><name>archive_entry_size_is_set</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call>
<operator>||</operator> <call><name>archive_entry_size</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>encryption_type</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ENCRYPTION_TRADITIONAL</name></expr>:</case>
<case>case <expr><name>ENCRYPTION_WINZIP_AES128</name></expr>:</case>
<case>case <expr><name>ENCRYPTION_WINZIP_AES256</name></expr>:</case>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_flags</name></name> <operator>|=</operator> <name>ZIP_ENTRY_FLAG_ENCRYPTED</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_encryption</name></name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>encryption_type</name></name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ENCRYPTION_NONE</name></expr>:</case>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></if></if_stmt>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>


<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name></name> <operator>=</operator> <call><name>__la_win_entry_in_posix_pathseparator</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name></name> <operator>==</operator> <name>entry</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name></name> <operator>=</operator> <call><name>archive_entry_clone</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name></name> <operator>=</operator> <call><name>archive_entry_clone</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ENOMEM</name></expr></argument>,
<argument><expr><literal type="string">"Can't allocate zip header data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>sconv</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>archive_entry_pathname_l</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><name>sconv</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOMEM</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ENOMEM</name></expr></argument>,
<argument><expr><literal type="string">"Can't allocate memory for Pathname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>,
<argument><expr><name>ARCHIVE_ERRNO_FILE_FORMAT</name></expr></argument>,
<argument><expr><literal type="string">"Can't translate Pathname '%s' to %s"</literal></expr></argument>,
<argument><expr><call><name>archive_entry_pathname</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>archive_string_conversion_charset_name</name><argument_list>(<argument><expr><name>sconv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret2</name> <operator>=</operator> <name>ARCHIVE_WARN</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>archive_entry_set_pathname</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>






<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>AE_IFLNK</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>archive_entry_symlink_l</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><name>sconv</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOMEM</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ENOMEM</name></expr></argument>,
<argument><expr><literal type="string">"Can't allocate memory "</literal>
<literal type="string">" for Symlink"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>archive_entry_set_symlink</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_all_ascii</name><argument_list>(<argument><expr><call><name>archive_entry_pathname</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>opt_sconv</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>archive_string_conversion_charset_name</name><argument_list>(
<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>opt_sconv</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"UTF-8"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_flags</name></name> <operator>|=</operator> <name>ZIP_ENTRY_FLAG_UTF8_NAME</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_NL_LANGINFO</name></expr></cpp:if>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>nl_langinfo</name><argument_list>(<argument><expr><name>CODESET</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"UTF-8"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_flags</name></name> <operator>|=</operator> <name>ZIP_ENTRY_FLAG_UTF8_NAME</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>filename_length</name> <operator>=</operator> <call><name>path_length</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>AE_IFLNK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>slink</name> <operator>=</operator> <call><name>archive_entry_symlink</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>slink</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>slink_size</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>slink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>slink_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_uncompressed_limit</name></name> <operator>=</operator> <name>slink_size</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_compressed_size</name></name> <operator>=</operator> <name>slink_size</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_uncompressed_size</name></name> <operator>=</operator> <name>slink_size</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_crc32</name></name> <operator>=</operator> <call><name><name>zip</name><operator>-&gt;</operator><name>crc32func</name></name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_crc32</name></name></expr></argument>,
<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>slink</name></expr></argument>, <argument><expr><name>slink_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_compression</name></name> <operator>=</operator> <name>COMPRESSION_STORE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>version_needed</name> <operator>=</operator> <literal type="number">20</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>type</name> <operator>!=</operator> <name>AE_IFREG</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_compression</name></name> <operator>=</operator> <name>COMPRESSION_STORE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_uncompressed_limit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>version_needed</name> <operator>=</operator> <literal type="number">20</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>archive_entry_size_is_set</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name></type> <name>size</name> <init>= <expr><call><name>archive_entry_size</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>additional_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_uncompressed_limit</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_compression</name></name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>requested_compression</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>entry_compression</name></name> <operator>==</operator> <name>COMPRESSION_UNSPECIFIED</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_compression</name></name> <operator>=</operator> <name>COMPRESSION_DEFAULT</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>entry_compression</name></name> <operator>==</operator> <name>COMPRESSION_STORE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_compressed_size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_uncompressed_size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
<expr_stmt><expr><name>version_needed</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_uncompressed_size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
<expr_stmt><expr><name>version_needed</name> <operator>=</operator> <literal type="number">20</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>entry_flags</name></name> <operator>&amp;</operator> <name>ZIP_ENTRY_FLAG_ENCRYPTED</name></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>entry_encryption</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ENCRYPTION_TRADITIONAL</name></expr>:</case>
<expr_stmt><expr><name>additional_size</name> <operator>=</operator> <name>TRAD_HEADER_SIZE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>version_needed</name> <operator>=</operator> <literal type="number">20</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ENCRYPTION_WINZIP_AES128</name></expr>:</case>
<expr_stmt><expr><name>additional_size</name> <operator>=</operator> <name>WINZIP_AES128_HEADER_SIZE</name>
<operator>+</operator> <name>AUTH_CODE_SIZE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>version_needed</name> <operator>=</operator> <literal type="number">20</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ENCRYPTION_WINZIP_AES256</name></expr>:</case>
<expr_stmt><expr><name>additional_size</name> <operator>=</operator> <name>WINZIP_AES256_HEADER_SIZE</name>
<operator>+</operator> <name>AUTH_CODE_SIZE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>version_needed</name> <operator>=</operator> <literal type="number">20</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ENCRYPTION_NONE</name></expr>:</case>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>entry_compression</name></name> <operator>==</operator> <name>COMPRESSION_STORE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_compressed_size</name></name> <operator>+=</operator> <name>additional_size</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>











<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>zip</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>ZIP_FLAG_FORCE_ZIP64</name><operator>)</operator>
<operator>||</operator> <operator>(</operator><name><name>zip</name><operator>-&gt;</operator><name>entry_uncompressed_size</name></name> <operator>+</operator> <name>additional_size</name> <operator>&gt;</operator> <name>ZIP_4GB_MAX</name><operator>)</operator>
<operator>||</operator> <operator>(</operator><name><name>zip</name><operator>-&gt;</operator><name>entry_uncompressed_size</name></name> <operator>&gt;</operator> <name>ZIP_4GB_MAX_UNCOMPRESSED</name>
<operator>&amp;&amp;</operator> <name><name>zip</name><operator>-&gt;</operator><name>entry_compression</name></name> <operator>!=</operator> <name>COMPRESSION_STORE</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_uses_zip64</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>version_needed</name> <operator>=</operator> <literal type="number">45</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_flags</name></name> <operator>|=</operator> <name>ZIP_ENTRY_FLAG_LENGTH_AT_END</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>





<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_compression</name></name> <operator>=</operator> <name>COMPRESSION_DEFAULT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_flags</name></name> <operator>|=</operator> <name>ZIP_ENTRY_FLAG_LENGTH_AT_END</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>zip</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>ZIP_FLAG_AVOID_ZIP64</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_uses_zip64</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>version_needed</name> <operator>=</operator> <literal type="number">45</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>entry_compression</name></name> <operator>==</operator> <name>COMPRESSION_STORE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>version_needed</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>version_needed</name> <operator>=</operator> <literal type="number">20</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>entry_flags</name></name> <operator>&amp;</operator> <name>ZIP_ENTRY_FLAG_ENCRYPTED</name></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>entry_encryption</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ENCRYPTION_TRADITIONAL</name></expr>:</case>
<case>case <expr><name>ENCRYPTION_WINZIP_AES128</name></expr>:</case>
<case>case <expr><name>ENCRYPTION_WINZIP_AES256</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>version_needed</name> <operator>&lt;</operator> <literal type="number">20</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>version_needed</name> <operator>=</operator> <literal type="number">20</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>ENCRYPTION_NONE</name></expr>:</case>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>


<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>local_header</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>local_header</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>local_header</name></expr></argument>, <argument><expr><literal type="string">"PK\003\004"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_le16enc</name><argument_list>(<argument><expr><name>local_header</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>version_needed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_le16enc</name><argument_list>(<argument><expr><name>local_header</name> <operator>+</operator> <literal type="number">6</literal></expr></argument>, <argument><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>entry_encryption</name></name> <operator>==</operator> <name>ENCRYPTION_WINZIP_AES128</name>
<operator>||</operator> <name><name>zip</name><operator>-&gt;</operator><name>entry_encryption</name></name> <operator>==</operator> <name>ENCRYPTION_WINZIP_AES256</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>archive_le16enc</name><argument_list>(<argument><expr><name>local_header</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><name>WINZIP_AES_ENCRYPTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>archive_le16enc</name><argument_list>(<argument><expr><name>local_header</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_compression</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>archive_le32enc</name><argument_list>(<argument><expr><name>local_header</name> <operator>+</operator> <literal type="number">10</literal></expr></argument>,
<argument><expr><call><name>dos_time</name><argument_list>(<argument><expr><call><name>archive_entry_mtime</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_le32enc</name><argument_list>(<argument><expr><name>local_header</name> <operator>+</operator> <literal type="number">14</literal></expr></argument>, <argument><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_crc32</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>entry_uses_zip64</name></name></expr>)</condition> <block>{<block_content>





<expr_stmt><expr><call><name>archive_le32enc</name><argument_list>(<argument><expr><name>local_header</name> <operator>+</operator> <literal type="number">18</literal></expr></argument>, <argument><expr><name>ZIP_4GB_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_le32enc</name><argument_list>(<argument><expr><name>local_header</name> <operator>+</operator> <literal type="number">22</literal></expr></argument>, <argument><expr><name>ZIP_4GB_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>archive_le32enc</name><argument_list>(<argument><expr><name>local_header</name> <operator>+</operator> <literal type="number">18</literal></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>zip</name><operator>-&gt;</operator><name>entry_compressed_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_le32enc</name><argument_list>(<argument><expr><name>local_header</name> <operator>+</operator> <literal type="number">22</literal></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>zip</name><operator>-&gt;</operator><name>entry_uncompressed_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>archive_le16enc</name><argument_list>(<argument><expr><name>local_header</name> <operator>+</operator> <literal type="number">26</literal></expr></argument>, <argument><expr><operator>(</operator><name>uint16_t</name><operator>)</operator><name>filename_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>entry_encryption</name></name> <operator>==</operator> <name>ENCRYPTION_TRADITIONAL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>entry_flags</name></name> <operator>&amp;</operator> <name>ZIP_ENTRY_FLAG_LENGTH_AT_END</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>trad_chkdat</name></name> <operator>=</operator> <name><name>local_header</name><index>[<expr><literal type="number">11</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>trad_chkdat</name></name> <operator>=</operator> <name><name>local_header</name><index>[<expr><literal type="number">17</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>file_header</name></name> <operator>=</operator> <call><name>cd_alloc</name><argument_list>(<argument><expr><name>zip</name></expr></argument>, <argument><expr><literal type="number">46</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name><name>zip</name><operator>-&gt;</operator><name>central_directory_entries</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>file_header</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">46</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>file_header</name></name></expr></argument>, <argument><expr><literal type="string">"PK\001\002"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>archive_le16enc</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>file_header</name></name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">3</literal> <operator>*</operator> <literal type="number">256</literal> <operator>+</operator> <name>version_needed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_le16enc</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>file_header</name></name> <operator>+</operator> <literal type="number">6</literal></expr></argument>, <argument><expr><name>version_needed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_le16enc</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>file_header</name></name> <operator>+</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>entry_encryption</name></name> <operator>==</operator> <name>ENCRYPTION_WINZIP_AES128</name>
<operator>||</operator> <name><name>zip</name><operator>-&gt;</operator><name>entry_encryption</name></name> <operator>==</operator> <name>ENCRYPTION_WINZIP_AES256</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>archive_le16enc</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>file_header</name></name> <operator>+</operator> <literal type="number">10</literal></expr></argument>, <argument><expr><name>WINZIP_AES_ENCRYPTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>archive_le16enc</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>file_header</name></name> <operator>+</operator> <literal type="number">10</literal></expr></argument>, <argument><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_compression</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>archive_le32enc</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>file_header</name></name> <operator>+</operator> <literal type="number">12</literal></expr></argument>,
<argument><expr><call><name>dos_time</name><argument_list>(<argument><expr><call><name>archive_entry_mtime</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_le16enc</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>file_header</name></name> <operator>+</operator> <literal type="number">28</literal></expr></argument>, <argument><expr><operator>(</operator><name>uint16_t</name><operator>)</operator><name>filename_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>archive_le32enc</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>file_header</name></name> <operator>+</operator> <literal type="number">38</literal></expr></argument>,
<argument><expr><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><call><name>archive_entry_mode</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>cd_alloc</name><argument_list>(<argument><expr><name>zip</name></expr></argument>, <argument><expr><name>filename_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>copy_path</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>local_extra</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>local_extra</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>e</name> <operator>=</operator> <name>local_extra</name></expr>;</expr_stmt>






<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><literal type="string">"UT"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_le16enc</name><argument_list>(<argument><expr><name>e</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>,
<argument><expr><literal type="number">1</literal>
<operator>+</operator> <operator>(</operator><ternary><condition><expr><call><name>archive_entry_mtime_is_set</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">4</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator>
<operator>+</operator> <operator>(</operator><ternary><condition><expr><call><name>archive_entry_atime_is_set</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">4</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator>
<operator>+</operator> <operator>(</operator><ternary><condition><expr><call><name>archive_entry_ctime_is_set</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">4</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>e</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>e</name><operator>++</operator> <operator>=</operator>
<operator>(</operator><ternary><condition><expr><call><name>archive_entry_mtime_is_set</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator>
<operator>|</operator> <operator>(</operator><ternary><condition><expr><call><name>archive_entry_atime_is_set</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator>
<operator>|</operator> <operator>(</operator><ternary><condition><expr><call><name>archive_entry_ctime_is_set</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">4</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>archive_entry_mtime_is_set</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_le32enc</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><call><name>archive_entry_mtime</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>e</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>archive_entry_atime_is_set</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_le32enc</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><call><name>archive_entry_atime</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>e</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>archive_entry_ctime_is_set</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_le32enc</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><call><name>archive_entry_ctime</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>e</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>



<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><literal type="string">"ux\013\000\001"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>e</name> <operator>+=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>e</name><operator>++</operator> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_le32enc</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><call><name>archive_entry_uid</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>e</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>e</name><operator>++</operator> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_le32enc</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><call><name>archive_entry_gid</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>e</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>zip</name><operator>-&gt;</operator><name>entry_flags</name></name> <operator>&amp;</operator> <name>ZIP_ENTRY_FLAG_ENCRYPTED</name><operator>)</operator>
<operator>&amp;&amp;</operator> <operator>(</operator><name><name>zip</name><operator>-&gt;</operator><name>entry_encryption</name></name> <operator>==</operator> <name>ENCRYPTION_WINZIP_AES128</name>
<operator>||</operator> <name><name>zip</name><operator>-&gt;</operator><name>entry_encryption</name></name> <operator>==</operator> <name>ENCRYPTION_WINZIP_AES256</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><literal type="string">"\001\231\007\000\001\000AE"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>






<if_stmt><if>if <condition>(<expr><call><name>archive_entry_size_is_set</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <call><name>archive_entry_size</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">20</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_le16enc</name><argument_list>(<argument><expr><name>e</name><operator>+</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>AES_VENDOR_AE_2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>aes_vendor</name></name> <operator>=</operator> <name>AES_VENDOR_AE_2</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>aes_vendor</name></name> <operator>=</operator> <name>AES_VENDOR_AE_1</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name>e</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>e</name><operator>++</operator> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>zip</name><operator>-&gt;</operator><name>entry_encryption</name></name> <operator>==</operator> <name>ENCRYPTION_WINZIP_AES128</name><operator>)</operator></expr>?</condition><then><expr><literal type="number">1</literal></expr></then><else>:<expr><literal type="number">3</literal></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><call><name>archive_le16enc</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_compression</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>e</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>file_header_extra_offset</name></name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>central_directory_bytes</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>cd_extra</name> <operator>=</operator> <call><name>cd_alloc</name><argument_list>(<argument><expr><name>zip</name></expr></argument>, <argument><expr><name>e</name> <operator>-</operator> <name>local_extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>cd_extra</name></expr></argument>, <argument><expr><name>local_extra</name></expr></argument>, <argument><expr><name>e</name> <operator>-</operator> <name>local_extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>










<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>entry_uses_zip64</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zip64_start</name> <init>= <expr><name>e</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><literal type="string">"\001\000\020\000"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>e</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_le64enc</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_uncompressed_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>e</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_le64enc</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_compressed_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>e</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_le16enc</name><argument_list>(<argument><expr><name>zip64_start</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>uint16_t</name><operator>)</operator><operator>(</operator><name>e</name> <operator>-</operator> <operator>(</operator><name>zip64_start</name> <operator>+</operator> <literal type="number">4</literal><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>ZIP_FLAG_EXPERIMENT_xl</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>external_info</name> <init>= <expr><name>e</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>included</name> <init>= <expr><literal type="number">7</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><literal type="string">"xl\000\000"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>e</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>included</name></expr>;</expr_stmt>
<expr_stmt><expr><name>e</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>included</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_le16enc</name><argument_list>(<argument><expr><name>e</name></expr></argument>,
<argument><expr><literal type="number">3</literal> <operator>*</operator> <literal type="number">256</literal> <operator>+</operator> <name>version_needed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>e</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>included</name> <operator>&amp;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_le16enc</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>e</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>included</name> <operator>&amp;</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_le32enc</name><argument_list>(<argument><expr><name>e</name></expr></argument>,
<argument><expr><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>)</operator><call><name>archive_entry_mode</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>e</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>included</name> <operator>&amp;</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>

</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>archive_le16enc</name><argument_list>(<argument><expr><name>external_info</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>uint16_t</name><operator>)</operator><operator>(</operator><name>e</name> <operator>-</operator> <operator>(</operator><name>external_info</name> <operator>+</operator> <literal type="number">4</literal><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>archive_le16enc</name><argument_list>(<argument><expr><name>local_header</name> <operator>+</operator> <literal type="number">28</literal></expr></argument>, <argument><expr><operator>(</operator><name>uint16_t</name><operator>)</operator><operator>(</operator><name>e</name> <operator>-</operator> <name>local_extra</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>__archive_write_output</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>local_header</name></expr></argument>, <argument><expr><literal type="number">30</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>ARCHIVE_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>written_bytes</name></name> <operator>+=</operator> <literal type="number">30</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>write_path</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;=</operator> <name>ARCHIVE_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>written_bytes</name></name> <operator>+=</operator> <name>ret</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>__archive_write_output</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>local_extra</name></expr></argument>, <argument><expr><name>e</name> <operator>-</operator> <name>local_extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>ARCHIVE_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>written_bytes</name></name> <operator>+=</operator> <name>e</name> <operator>-</operator> <name>local_extra</name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>slink</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>__archive_write_output</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>slink</name></expr></argument>, <argument><expr><name>slink_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>ARCHIVE_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_compressed_written</name></name> <operator>+=</operator> <name>slink_size</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_uncompressed_written</name></name> <operator>+=</operator> <name>slink_size</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>written_bytes</name></name> <operator>+=</operator> <name>slink_size</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_ZLIB_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>entry_compression</name></name> <operator>==</operator> <name>COMPRESSION_DEFLATE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>stream</name><operator>.</operator><name>zalloc</name></name> <operator>=</operator> <name>Z_NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>stream</name><operator>.</operator><name>zfree</name></name> <operator>=</operator> <name>Z_NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>stream</name><operator>.</operator><name>opaque</name></name> <operator>=</operator> <name>Z_NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>stream</name><operator>.</operator><name>next_out</name></name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>stream</name><operator>.</operator><name>avail_out</name></name> <operator>=</operator> <operator>(</operator><name>uInt</name><operator>)</operator><name><name>zip</name><operator>-&gt;</operator><name>len_buf</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>deflateInit2</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>stream</name></name></expr></argument>, <argument><expr><name><name>zip</name><operator>-&gt;</operator><name>deflate_compression_level</name></name></expr></argument>,
<argument><expr><name>Z_DEFLATED</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">15</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>Z_DEFAULT_STRATEGY</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>Z_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ENOMEM</name></expr></argument>,
<argument><expr><literal type="string">"Can't init deflate compressor"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><operator>(</operator><name>ret2</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ssize_t</name></type>
<name>archive_write_zip_data</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_write</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>buff</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>zip</name></name> <modifier>*</modifier></type><name>zip</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>format_data</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int64_t</name><operator>)</operator><name>s</name> <operator>&gt;</operator> <name><name>zip</name><operator>-&gt;</operator><name>entry_uncompressed_limit</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name><name>zip</name><operator>-&gt;</operator><name>entry_uncompressed_limit</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_uncompressed_written</name></name> <operator>+=</operator> <name>s</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>entry_flags</name></name> <operator>&amp;</operator> <name>ZIP_ENTRY_FLAG_ENCRYPTED</name></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>entry_encryption</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ENCRYPTION_TRADITIONAL</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>zip</name><operator>-&gt;</operator><name>tctx_valid</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>init_traditional_pkware_encryption</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>ARCHIVE_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>ret</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>tctx_valid</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>ENCRYPTION_WINZIP_AES128</name></expr>:</case>
<case>case <expr><name>ENCRYPTION_WINZIP_AES256</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>zip</name><operator>-&gt;</operator><name>cctx_valid</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>init_winzip_aes_encryption</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>ARCHIVE_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>ret</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>cctx_valid</name></name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>hctx_valid</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>ENCRYPTION_NONE</name></expr>:</case>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>entry_compression</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>COMPRESSION_STORE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>tctx_valid</name></name> <operator>||</operator> <name><name>zip</name><operator>-&gt;</operator><name>cctx_valid</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>rb</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>uint8_t</name> <operator>*</operator><operator>)</operator><name>buff</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier> <specifier>const</specifier></type> <name>re</name> <init>= <expr><name>rb</name> <operator>+</operator> <name>s</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>rb</name> <operator>&lt;</operator> <name>re</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>l</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>tctx_valid</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>trad_enc_encrypt_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>tctx</name></name></expr></argument>,
<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>re</name> <operator>-</operator> <name>rb</name></expr></argument>,
<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>zip</name><operator>-&gt;</operator><name>len_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>l</name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>len_buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>archive_encrypto_aes_ctr_update</name><argument_list>(
<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>cctx</name></name></expr></argument>,
<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>re</name> <operator>-</operator> <name>rb</name></expr></argument>, <argument><expr><name><name>zip</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>,
<argument><expr><name>ARCHIVE_ERRNO_MISC</name></expr></argument>,
<argument><expr><literal type="string">"Failed to encrypt file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FAILED</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>archive_hmac_sha1_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>hctx</name></name></expr></argument>,
<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>__archive_write_output</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>zip</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>ARCHIVE_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>ret</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_compressed_written</name></name> <operator>+=</operator> <name>l</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>written_bytes</name></name> <operator>+=</operator> <name>l</name></expr>;</expr_stmt>
<expr_stmt><expr><name>rb</name> <operator>+=</operator> <name>l</name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>__archive_write_output</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>ARCHIVE_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>ret</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>written_bytes</name></name> <operator>+=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_compressed_written</name></name> <operator>+=</operator> <name>s</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_ZLIB_H</name></expr></cpp:if>
<case>case <expr><name>COMPRESSION_DEFLATE</name></expr>:</case>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>stream</name><operator>.</operator><name>next_in</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>buff</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>stream</name><operator>.</operator><name>avail_in</name></name> <operator>=</operator> <operator>(</operator><name>uInt</name><operator>)</operator><name>s</name></expr>;</expr_stmt>
<do>do <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>deflate</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>stream</name></name></expr></argument>, <argument><expr><name>Z_NO_FLUSH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>Z_STREAM_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>stream</name><operator>.</operator><name>avail_out</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>tctx_valid</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>trad_enc_encrypt_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>tctx</name></name></expr></argument>,
<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>zip</name><operator>-&gt;</operator><name>len_buf</name></name></expr></argument>,
<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>zip</name><operator>-&gt;</operator><name>len_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>cctx_valid</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>outl</name> <init>= <expr><name><name>zip</name><operator>-&gt;</operator><name>len_buf</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>archive_encrypto_aes_ctr_update</name><argument_list>(
<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>cctx</name></name></expr></argument>,
<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>zip</name><operator>-&gt;</operator><name>len_buf</name></name></expr></argument>,
<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>outl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>,
<argument><expr><name>ARCHIVE_ERRNO_MISC</name></expr></argument>,
<argument><expr><literal type="string">"Failed to encrypt file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FAILED</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>archive_hmac_sha1_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>hctx</name></name></expr></argument>,
<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>zip</name><operator>-&gt;</operator><name>len_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>__archive_write_output</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>zip</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>,
<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>len_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>ARCHIVE_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>ret</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_compressed_written</name></name> <operator>+=</operator> <name><name>zip</name><operator>-&gt;</operator><name>len_buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>written_bytes</name></name> <operator>+=</operator> <name><name>zip</name><operator>-&gt;</operator><name>len_buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>stream</name><operator>.</operator><name>next_out</name></name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>stream</name><operator>.</operator><name>avail_out</name></name> <operator>=</operator> <operator>(</operator><name>uInt</name><operator>)</operator><name><name>zip</name><operator>-&gt;</operator><name>len_buf</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block> while <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>stream</name><operator>.</operator><name>avail_in</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>;</do>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<case>case <expr><name>COMPRESSION_UNSPECIFIED</name></expr>:</case>
<default>default:</default>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_MISC</name></expr></argument>,
<argument><expr><literal type="string">"Invalid ZIP compression type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ARCHIVE_FATAL</name></expr>;</return>
</block_content>}</block></switch>

<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_uncompressed_limit</name></name> <operator>-=</operator> <name>s</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>zip</name><operator>-&gt;</operator><name>cctx_valid</name></name> <operator>||</operator> <name><name>zip</name><operator>-&gt;</operator><name>aes_vendor</name></name> <operator>!=</operator> <name>AES_VENDOR_AE_2</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_crc32</name></name> <operator>=</operator>
<call><name><name>zip</name><operator>-&gt;</operator><name>crc32func</name></name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_crc32</name></name></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><name>s</name><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>archive_write_zip_finish_entry</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_write</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>zip</name></name> <modifier>*</modifier></type><name>zip</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>format_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_ZLIB_H</name></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>entry_compression</name></name> <operator>==</operator> <name>COMPRESSION_DEFLATE</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>remainder</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>deflate</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>stream</name></name></expr></argument>, <argument><expr><name>Z_FINISH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>Z_STREAM_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>remainder</name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>len_buf</name></name> <operator>-</operator> <name><name>zip</name><operator>-&gt;</operator><name>stream</name><operator>.</operator><name>avail_out</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>tctx_valid</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>trad_enc_encrypt_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>tctx</name></name></expr></argument>,
<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name>remainder</name></expr></argument>, <argument><expr><name><name>zip</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name>remainder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>cctx_valid</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>outl</name> <init>= <expr><name>remainder</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>archive_encrypto_aes_ctr_update</name><argument_list>(
<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>cctx</name></name></expr></argument>, <argument><expr><name><name>zip</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name>remainder</name></expr></argument>,
<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>outl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>,
<argument><expr><name>ARCHIVE_ERRNO_MISC</name></expr></argument>,
<argument><expr><literal type="string">"Failed to encrypt file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FAILED</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>archive_hmac_sha1_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>hctx</name></name></expr></argument>,
<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name>remainder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>__archive_write_output</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>zip</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name>remainder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>ARCHIVE_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>ret</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_compressed_written</name></name> <operator>+=</operator> <name>remainder</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>written_bytes</name></name> <operator>+=</operator> <name>remainder</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>stream</name><operator>.</operator><name>next_out</name></name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>buf</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>stream</name><operator>.</operator><name>avail_out</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>stream</name><operator>.</operator><name>avail_out</name></name> <operator>=</operator> <operator>(</operator><name>uInt</name><operator>)</operator><name><name>zip</name><operator>-&gt;</operator><name>len_buf</name></name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>deflateEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>stream</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>hctx_valid</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>hmac</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>hmac_len</name> <init>= <expr><literal type="number">20</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>archive_hmac_sha1_final</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>hctx</name></name></expr></argument>, <argument><expr><name>hmac</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hmac_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>__archive_write_output</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>hmac</name></expr></argument>, <argument><expr><name>AUTH_CODE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>ARCHIVE_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>ret</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_compressed_written</name></name> <operator>+=</operator> <name>AUTH_CODE_SIZE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>written_bytes</name></name> <operator>+=</operator> <name>AUTH_CODE_SIZE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>zip</name><operator>-&gt;</operator><name>entry_flags</name></name> <operator>&amp;</operator> <name>ZIP_ENTRY_FLAG_LENGTH_AT_END</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>d</name><index>[<expr><literal type="number">24</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="string">"PK\007\010"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>cctx_valid</name></name> <operator>&amp;&amp;</operator> <name><name>zip</name><operator>-&gt;</operator><name>aes_vendor</name></name> <operator>==</operator> <name>AES_VENDOR_AE_2</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>archive_le32enc</name><argument_list>(<argument><expr><name>d</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>archive_le32enc</name><argument_list>(<argument><expr><name>d</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_crc32</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>entry_uses_zip64</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_le64enc</name><argument_list>(<argument><expr><name>d</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>zip</name><operator>-&gt;</operator><name>entry_compressed_written</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_le64enc</name><argument_list>(<argument><expr><name>d</name> <operator>+</operator> <literal type="number">16</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>zip</name><operator>-&gt;</operator><name>entry_uncompressed_written</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>__archive_write_output</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="number">24</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>written_bytes</name></name> <operator>+=</operator> <literal type="number">24</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>archive_le32enc</name><argument_list>(<argument><expr><name>d</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>zip</name><operator>-&gt;</operator><name>entry_compressed_written</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_le32enc</name><argument_list>(<argument><expr><name>d</name> <operator>+</operator> <literal type="number">12</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>zip</name><operator>-&gt;</operator><name>entry_uncompressed_written</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>__archive_write_output</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>written_bytes</name></name> <operator>+=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>ARCHIVE_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>entry_compressed_written</name></name> <operator>&gt;</operator> <name>ZIP_4GB_MAX</name>
<operator>||</operator> <name><name>zip</name><operator>-&gt;</operator><name>entry_uncompressed_written</name></name> <operator>&gt;</operator> <name>ZIP_4GB_MAX</name>
<operator>||</operator> <name><name>zip</name><operator>-&gt;</operator><name>entry_offset</name></name> <operator>&gt;</operator> <name>ZIP_4GB_MAX</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>zip64</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><name>zip64</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zd</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="string">"\001\000\000\000"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>z</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>entry_uncompressed_written</name></name> <operator>&gt;=</operator> <name>ZIP_4GB_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_le64enc</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_uncompressed_written</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>z</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>entry_compressed_written</name></name> <operator>&gt;=</operator> <name>ZIP_4GB_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_le64enc</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_compressed_written</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>z</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>entry_offset</name></name> <operator>&gt;=</operator> <name>ZIP_4GB_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_le64enc</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>z</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>archive_le16enc</name><argument_list>(<argument><expr><name>zip64</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>uint16_t</name><operator>)</operator><operator>(</operator><name>z</name> <operator>-</operator> <operator>(</operator><name>zip64</name> <operator>+</operator> <literal type="number">4</literal><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zd</name> <operator>=</operator> <call><name>cd_alloc</name><argument_list>(<argument><expr><name>zip</name></expr></argument>, <argument><expr><name>z</name> <operator>-</operator> <name>zip64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>zd</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ENOMEM</name></expr></argument>,
<argument><expr><literal type="string">"Can't allocate zip data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zd</name></expr></argument>, <argument><expr><name>zip64</name></expr></argument>, <argument><expr><name>z</name> <operator>-</operator> <name>zip64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>archive_le16dec</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>file_header</name></name> <operator>+</operator> <literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">45</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>archive_le16enc</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>file_header</name></name> <operator>+</operator> <literal type="number">6</literal></expr></argument>, <argument><expr><literal type="number">45</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>cctx_valid</name></name> <operator>&amp;&amp;</operator> <name><name>zip</name><operator>-&gt;</operator><name>aes_vendor</name></name> <operator>==</operator> <name>AES_VENDOR_AE_2</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>archive_le32enc</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>file_header</name></name> <operator>+</operator> <literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>archive_le32enc</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>file_header</name></name> <operator>+</operator> <literal type="number">16</literal></expr></argument>, <argument><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_crc32</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>archive_le32enc</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>file_header</name></name> <operator>+</operator> <literal type="number">20</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><call><name>zipmin</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_compressed_written</name></name></expr></argument>,
<argument><expr><name>ZIP_4GB_MAX</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_le32enc</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>file_header</name></name> <operator>+</operator> <literal type="number">24</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><call><name>zipmin</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_uncompressed_written</name></name></expr></argument>,
<argument><expr><name>ZIP_4GB_MAX</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_le16enc</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>file_header</name></name> <operator>+</operator> <literal type="number">30</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uint16_t</name><operator>)</operator><operator>(</operator><name><name>zip</name><operator>-&gt;</operator><name>central_directory_bytes</name></name> <operator>-</operator> <name><name>zip</name><operator>-&gt;</operator><name>file_header_extra_offset</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_le32enc</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>file_header</name></name> <operator>+</operator> <literal type="number">42</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><call><name>zipmin</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_offset</name></name></expr></argument>,
<argument><expr><name>ZIP_4GB_MAX</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>ARCHIVE_OK</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>archive_write_zip_close</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_write</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>buff</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>offset_start</name></decl>, <decl><type ref="prev"/><name>offset_end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>zip</name></name> <modifier>*</modifier></type><name>zip</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>format_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>cd_segment</name></name> <modifier>*</modifier></type><name>segment</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><name>offset_start</name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>written_bytes</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>segment</name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>central_directory</name></name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>segment</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>__archive_write_output</name><argument_list>(<argument><expr><name>a</name></expr></argument>,
<argument><expr><name><name>segment</name><operator>-&gt;</operator><name>buff</name></name></expr></argument>, <argument><expr><name><name>segment</name><operator>-&gt;</operator><name>p</name></name> <operator>-</operator> <name><name>segment</name><operator>-&gt;</operator><name>buff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>ARCHIVE_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>written_bytes</name></name> <operator>+=</operator> <name><name>segment</name><operator>-&gt;</operator><name>p</name></name> <operator>-</operator> <name><name>segment</name><operator>-&gt;</operator><name>buff</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>segment</name> <operator>=</operator> <name><name>segment</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name>offset_end</name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>written_bytes</name></name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>offset_end</name> <operator>-</operator> <name>offset_start</name> <operator>&gt;</operator> <name>ZIP_4GB_MAX</name>
<operator>||</operator> <name>offset_start</name> <operator>&gt;</operator> <name>ZIP_4GB_MAX</name>
<operator>||</operator> <name><name>zip</name><operator>-&gt;</operator><name>central_directory_entries</name></name> <operator>&gt;</operator> <literal type="number">0xffffUL</literal>
<operator>||</operator> <operator>(</operator><name><name>zip</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>ZIP_FLAG_FORCE_ZIP64</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">56</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><literal type="string">"PK\006\006"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_le64enc</name><argument_list>(<argument><expr><name>buff</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">44</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_le16enc</name><argument_list>(<argument><expr><name>buff</name> <operator>+</operator> <literal type="number">12</literal></expr></argument>, <argument><expr><literal type="number">45</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_le16enc</name><argument_list>(<argument><expr><name>buff</name> <operator>+</operator> <literal type="number">14</literal></expr></argument>, <argument><expr><literal type="number">45</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>archive_le64enc</name><argument_list>(<argument><expr><name>buff</name> <operator>+</operator> <literal type="number">24</literal></expr></argument>, <argument><expr><name><name>zip</name><operator>-&gt;</operator><name>central_directory_entries</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_le64enc</name><argument_list>(<argument><expr><name>buff</name> <operator>+</operator> <literal type="number">32</literal></expr></argument>, <argument><expr><name><name>zip</name><operator>-&gt;</operator><name>central_directory_entries</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_le64enc</name><argument_list>(<argument><expr><name>buff</name> <operator>+</operator> <literal type="number">40</literal></expr></argument>, <argument><expr><name>offset_end</name> <operator>-</operator> <name>offset_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_le64enc</name><argument_list>(<argument><expr><name>buff</name> <operator>+</operator> <literal type="number">48</literal></expr></argument>, <argument><expr><name>offset_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>__archive_write_output</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><literal type="number">56</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>ARCHIVE_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>written_bytes</name></name> <operator>+=</operator> <literal type="number">56</literal></expr>;</expr_stmt>


<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><literal type="string">"PK\006\007"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_le32enc</name><argument_list>(<argument><expr><name>buff</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_le64enc</name><argument_list>(<argument><expr><name>buff</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><name>offset_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_le32enc</name><argument_list>(<argument><expr><name>buff</name> <operator>+</operator> <literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>__archive_write_output</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>ARCHIVE_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>written_bytes</name></name> <operator>+=</operator> <literal type="number">20</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><literal type="string">"PK\005\006"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_le16enc</name><argument_list>(<argument><expr><name>buff</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><operator>(</operator><name>uint16_t</name><operator>)</operator><call><name>zipmin</name><argument_list>(<argument><expr><literal type="number">0xffffU</literal></expr></argument>,
<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>central_directory_entries</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_le16enc</name><argument_list>(<argument><expr><name>buff</name> <operator>+</operator> <literal type="number">10</literal></expr></argument>, <argument><expr><operator>(</operator><name>uint16_t</name><operator>)</operator><call><name>zipmin</name><argument_list>(<argument><expr><literal type="number">0xffffU</literal></expr></argument>,
<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>central_directory_entries</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_le32enc</name><argument_list>(<argument><expr><name>buff</name> <operator>+</operator> <literal type="number">12</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><call><name>zipmin</name><argument_list>(<argument><expr><name>ZIP_4GB_MAX</name></expr></argument>, <argument><expr><operator>(</operator><name>offset_end</name> <operator>-</operator> <name>offset_start</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_le32enc</name><argument_list>(<argument><expr><name>buff</name> <operator>+</operator> <literal type="number">16</literal></expr></argument>,
<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><call><name>zipmin</name><argument_list>(<argument><expr><name>ZIP_4GB_MAX</name></expr></argument>, <argument><expr><name>offset_start</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>__archive_write_output</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><literal type="number">22</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>ARCHIVE_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>written_bytes</name></name> <operator>+=</operator> <literal type="number">22</literal></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_OK</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>archive_write_zip_free</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_write</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>zip</name></name> <modifier>*</modifier></type><name>zip</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>cd_segment</name></name> <modifier>*</modifier></type><name>segment</name></decl>;</decl_stmt>

<expr_stmt><expr><name>zip</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>format_data</name></name></expr>;</expr_stmt>
<while>while <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>central_directory</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>segment</name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>central_directory</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>central_directory</name></name> <operator>=</operator> <name><name>segment</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>segment</name><operator>-&gt;</operator><name>buff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>segment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_entry_free</name><argument_list>(<argument><expr><name><name>zip</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>cctx_valid</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>archive_encrypto_aes_ctr_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>cctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>hctx_valid</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>archive_hmac_sha1_cleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>hctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>zip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>format_data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_OK</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type>
<name>dos_time</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>time_t</name></type> <name>unix_time</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>tm</name></name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>dt</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LOCALTIME_R</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE__LOCALTIME64_S</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name><name>struct</name> <name>tm</name></name></type> <name>tmbuf</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE__LOCALTIME64_S</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>errno_t</name></type> <name>terr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>__time64_t</name></type> <name>tmptime</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LOCALTIME_R</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>localtime_r</name><argument_list>(<argument><expr><operator>&amp;</operator><name>unix_time</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE__LOCALTIME64_S</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<expr_stmt><expr><name>tmptime</name> <operator>=</operator> <name>unix_time</name></expr>;</expr_stmt>
<expr_stmt><expr><name>terr</name> <operator>=</operator> <call><name>_localtime64_s</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmbuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmptime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>terr</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>t</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>t</name> <operator>=</operator> <operator>&amp;</operator><name>tmbuf</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>localtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>unix_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<if_stmt><if>if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>&lt;</operator> <literal type="number">1980</literal> <operator>-</operator> <literal type="number">1900</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>dt</name> <operator>=</operator> <literal type="number">0x00210000U</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>&gt;</operator> <literal type="number">2107</literal> <operator>-</operator> <literal type="number">1900</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>dt</name> <operator>=</operator> <literal type="number">0xff9fbf7dU</literal></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>dt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>dt</name> <operator>+=</operator> <operator>(</operator><operator>(</operator><name><name>t</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>-</operator> <literal type="number">80</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x7f</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">9</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>dt</name> <operator>+=</operator> <operator>(</operator><operator>(</operator><name><name>t</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x0f</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">5</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>dt</name> <operator>+=</operator> <operator>(</operator><name><name>t</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>&amp;</operator> <literal type="number">0x1f</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>dt</name> <operator>&lt;&lt;=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>dt</name> <operator>+=</operator> <operator>(</operator><name><name>t</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>&amp;</operator> <literal type="number">0x1f</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">11</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>dt</name> <operator>+=</operator> <operator>(</operator><name><name>t</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">5</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>dt</name> <operator>+=</operator> <operator>(</operator><name><name>t</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>&amp;</operator> <literal type="number">0x3e</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>dt</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>path_length</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>mode_t</name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>archive_entry_filetype</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>archive_entry_pathname</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>path</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>AE_IFDIR</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>path</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> <name><name>path</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'/'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>write_path</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>archive_write</name></name> <modifier>*</modifier></type><name>archive</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>mode_t</name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>written_bytes</name></decl>;</decl_stmt>

<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>archive_entry_pathname</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>archive_entry_filetype</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>written_bytes</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>path</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>__archive_write_output</name><argument_list>(<argument><expr><name>archive</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>ARCHIVE_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>written_bytes</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>(</operator><name>type</name> <operator>==</operator> <name>AE_IFDIR</name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name><name>path</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'/'</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>__archive_write_output</name><argument_list>(<argument><expr><name>archive</name></expr></argument>, <argument><expr><literal type="string">"/"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>ARCHIVE_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>written_bytes</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><operator>(</operator><operator>(</operator><name>int</name><operator>)</operator><name>written_bytes</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>copy_path</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>pathlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>mode_t</name></type> <name>type</name></decl>;</decl_stmt>

<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>archive_entry_pathname</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pathlen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>archive_entry_filetype</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pathlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>(</operator><name>type</name> <operator>==</operator> <name>AE_IFDIR</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>path</name><index>[<expr><name>pathlen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'/'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>p</name><index>[<expr><name>pathlen</name></expr>]</index></name> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name><name>struct</name> <name>archive_string_conv</name></name> <modifier>*</modifier></type>
<name>get_sconv</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_write</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>zip</name></name> <modifier>*</modifier></type><name>zip</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>opt_sconv</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name><name>zip</name><operator>-&gt;</operator><name>opt_sconv</name></name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>zip</name><operator>-&gt;</operator><name>init_default_conversion</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>sconv_default</name></name> <operator>=</operator>
<call><name>archive_string_default_conversion_for_write</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>init_default_conversion</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name><name>zip</name><operator>-&gt;</operator><name>sconv_default</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type>
<name>trad_enc_update_keys</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>trad_enc_ctx</name></name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>t</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CRC32</name><parameter_list>(<parameter><type><name>c</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(crc32(c ^ 0xffffffffUL, &amp;b, 1) ^ 0xffffffffUL)</cpp:value></cpp:define>

<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>keys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>CRC32</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>keys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>keys</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>keys</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>keys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator><operator>)</operator> <operator>*</operator> <literal type="number">134775813L</literal> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>t</name> <operator>=</operator> <operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>keys</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">24</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>keys</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>CRC32</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>keys</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CRC32</name></cpp:undef>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint8_t</name></type>
<name>trad_enc_decrypt_byte</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>trad_enc_ctx</name></name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>temp</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>keys</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>|</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>(</operator><name>uint8_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name>temp</name> <operator>*</operator> <operator>(</operator><name>temp</name> <operator>^</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>unsigned</name></type>
<name>trad_enc_encrypt_update</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>trad_enc_ctx</name></name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>in</name></decl></parameter>,
<parameter><decl><type><name>size_t</name></type> <name>in_len</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>out_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>max</name></decl>;</decl_stmt>

<expr_stmt><expr><name>max</name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><ternary><condition><expr><operator>(</operator><name>in_len</name> <operator>&lt;</operator> <name>out_len</name><operator>)</operator></expr>?</condition><then> <expr><name>in_len</name></expr></then><else>: <expr><name>out_len</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>t</name> <init>= <expr><name><name>in</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>out</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>t</name> <operator>^</operator> <call><name>trad_enc_decrypt_byte</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>trad_enc_update_keys</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>trad_enc_init</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>trad_enc_ctx</name></name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pw</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>pw_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>keys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">305419896L</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>keys</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">591751049L</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>keys</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">878082192L</literal></expr>;</expr_stmt>

<for>for <control>(<init>;</init><condition><expr><name>pw_len</name></expr>;</condition> <incr><expr><operator>--</operator><name>pw_len</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>trad_enc_update_keys</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>*</operator><name>pw</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>is_traditional_pkware_encryption_supported</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>key</name><index>[<expr><name>TRAD_HEADER_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>archive_random</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ARCHIVE_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>init_traditional_pkware_encryption</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_write</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>zip</name></name> <modifier>*</modifier></type><name>zip</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>format_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>passphrase</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>key</name><index>[<expr><name>TRAD_HEADER_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>key_encrypted</name><index>[<expr><name>TRAD_HEADER_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><name>passphrase</name> <operator>=</operator> <call><name>__archive_write_get_passphrase</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>passphrase</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_MISC</name></expr></argument>,
<argument><expr><literal type="string">"Encryption needs passphrase"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ARCHIVE_FAILED</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>archive_random</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ARCHIVE_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_MISC</name></expr></argument>,
<argument><expr><literal type="string">"Can't generate random number for encryption"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ARCHIVE_FATAL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>trad_enc_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>tctx</name></name></expr></argument>, <argument><expr><name>passphrase</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>passphrase</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name><name>key</name><index>[<expr><name>TRAD_HEADER_SIZE</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>zip</name><operator>-&gt;</operator><name>trad_chkdat</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>trad_enc_encrypt_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>tctx</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>TRAD_HEADER_SIZE</name></expr></argument>,
<argument><expr><name>key_encrypted</name></expr></argument>, <argument><expr><name>TRAD_HEADER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>__archive_write_output</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>key_encrypted</name></expr></argument>, <argument><expr><name>TRAD_HEADER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>ARCHIVE_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>ret</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>written_bytes</name></name> <operator>+=</operator> <name>TRAD_HEADER_SIZE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_compressed_written</name></name> <operator>+=</operator> <name>TRAD_HEADER_SIZE</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ret</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>init_winzip_aes_encryption</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>archive_write</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>zip</name></name> <modifier>*</modifier></type><name>zip</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>format_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>passphrase</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>key_len</name></decl>, <decl><type ref="prev"/><name>salt_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>salt</name><index>[<expr><literal type="number">16</literal> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>derived_key</name><index>[<expr><name>MAX_DERIVED_KEY_BUF_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><name>passphrase</name> <operator>=</operator> <call><name>__archive_write_get_passphrase</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>passphrase</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_MISC</name></expr></argument>,
<argument><expr><literal type="string">"Encryption needs passphrase"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FAILED</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zip</name><operator>-&gt;</operator><name>entry_encryption</name></name> <operator>==</operator> <name>ENCRYPTION_WINZIP_AES128</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>salt_len</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>key_len</name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>salt_len</name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>key_len</name> <operator>=</operator> <literal type="number">32</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>archive_random</name><argument_list>(<argument><expr><name>salt</name></expr></argument>, <argument><expr><name>salt_len</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ARCHIVE_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_MISC</name></expr></argument>,
<argument><expr><literal type="string">"Can't generate random number for encryption"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FATAL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>archive_pbkdf2_sha1</name><argument_list>(<argument><expr><name>passphrase</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>passphrase</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>salt</name></expr></argument>, <argument><expr><name>salt_len</name></expr></argument>, <argument><expr><literal type="number">1000</literal></expr></argument>, <argument><expr><name>derived_key</name></expr></argument>, <argument><expr><name>key_len</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>archive_encrypto_aes_ctr_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>cctx</name></name></expr></argument>, <argument><expr><name>derived_key</name></expr></argument>, <argument><expr><name>key_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_MISC</name></expr></argument>,
<argument><expr><literal type="string">"Decryption is unsupported due to lack of crypto library"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FAILED</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>archive_hmac_sha1_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>hctx</name></name></expr></argument>, <argument><expr><name>derived_key</name> <operator>+</operator> <name>key_len</name></expr></argument>,
<argument><expr><name>key_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>archive_encrypto_aes_ctr_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>zip</name><operator>-&gt;</operator><name>cctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_set_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>archive</name></name></expr></argument>, <argument><expr><name>ARCHIVE_ERRNO_MISC</name></expr></argument>,
<argument><expr><literal type="string">"Failed to initialize HMAC-SHA1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ARCHIVE_FAILED</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name><name>salt</name><index>[<expr><name>salt_len</name></expr>]</index></name> <operator>=</operator> <name><name>derived_key</name><index>[<expr><name>key_len</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>salt</name><index>[<expr><name>salt_len</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>derived_key</name><index>[<expr><name>key_len</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>


<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>__archive_write_output</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>salt</name></expr></argument>, <argument><expr><name>salt_len</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>ARCHIVE_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>ret</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>written_bytes</name></name> <operator>+=</operator> <name>salt_len</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip</name><operator>-&gt;</operator><name>entry_compressed_written</name></name> <operator>+=</operator> <name>salt_len</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>ARCHIVE_OK</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>is_winzip_aes_encryption_supported</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>encryption</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>key_len</name></decl>, <decl><type ref="prev"/><name>salt_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>salt</name><index>[<expr><literal type="number">16</literal> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>derived_key</name><index>[<expr><name>MAX_DERIVED_KEY_BUF_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>archive_crypto_ctx</name></type> <name>cctx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>archive_hmac_sha1_ctx</name></type> <name>hctx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>encryption</name> <operator>==</operator> <name>ENCRYPTION_WINZIP_AES128</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>salt_len</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>key_len</name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>salt_len</name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>key_len</name> <operator>=</operator> <literal type="number">32</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>archive_random</name><argument_list>(<argument><expr><name>salt</name></expr></argument>, <argument><expr><name>salt_len</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ARCHIVE_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>archive_pbkdf2_sha1</name><argument_list>(<argument><expr><literal type="string">"p"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>salt</name></expr></argument>, <argument><expr><name>salt_len</name></expr></argument>, <argument><expr><literal type="number">1000</literal></expr></argument>,
<argument><expr><name>derived_key</name></expr></argument>, <argument><expr><name>key_len</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>archive_encrypto_aes_ctr_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cctx</name></expr></argument>, <argument><expr><name>derived_key</name></expr></argument>, <argument><expr><name>key_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>archive_hmac_sha1_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hctx</name></expr></argument>, <argument><expr><name>derived_key</name> <operator>+</operator> <name>key_len</name></expr></argument>,
<argument><expr><name>key_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>archive_encrypto_aes_ctr_release</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>archive_hmac_sha1_cleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>
</unit>
