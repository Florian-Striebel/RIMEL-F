<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/libcxxrt/stdexcept.h">






























<decl_stmt><decl><type><name>namespace</name></type> <name>std</name>
<block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>exception</name>
<block>{<block_content>
<label><name>public</name>:</label>
<macro><name>exception</name><argument_list>()</argument_list></macro> <expr_stmt><expr><call><name>throw</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<macro><name>exception</name><argument_list>(<argument>const exception&amp;</argument>)</argument_list></macro> <expr_stmt><expr><call><name>throw</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>exception</name><modifier>&amp;</modifier></type> <name>operator</name><init>=<expr><operator>(</operator><specifier>const</specifier> <name>exception</name><operator>&amp;</operator><operator>)</operator> <call><name>throw</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>virtual</name> <operator>~</operator><call><name>exception</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>virtual</name> <specifier>const</specifier> <name>char</name><operator>*</operator> <macro><name>what</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <call><name>throw</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>





<decl_stmt><decl><type><name>class</name></type> <name>bad_alloc</name><range>: <expr><name>public</name> <name>exception</name>
<block>{
<expr><name>public</name><operator>:</operator>
<macro><name>bad_alloc</name><argument_list>()</argument_list></macro> <call><name>throw</name><argument_list>()</argument_list></call></expr>;
<macro><name>bad_alloc</name><argument_list>(<argument>const bad_alloc&amp;</argument>)</argument_list></macro> <expr><call><name>throw</name><argument_list>()</argument_list></call></expr>;
<expr><name>bad_alloc</name><operator>&amp;</operator> <name>operator</name><operator>=</operator><operator>(</operator><specifier>const</specifier> <name>bad_alloc</name><operator>&amp;</operator><operator>)</operator> <call><name>throw</name><argument_list>()</argument_list></call></expr>;
<expr><operator>~</operator><call><name>bad_alloc</name><argument_list>()</argument_list></call></expr>;
<expr><name>virtual</name> <specifier>const</specifier> <name>char</name><operator>*</operator> <macro><name>what</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <call><name>throw</name><argument_list>()</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>




<decl_stmt><decl><type><name>class</name></type> <name>bad_cast</name><range>: <expr><name>public</name> <name>exception</name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>bad_cast</name><argument_list>()</argument_list></macro> <call><name>throw</name><argument_list>()</argument_list></call></expr>;
<macro><name>bad_cast</name><argument_list>(<argument>const bad_cast&amp;</argument>)</argument_list></macro> <expr><call><name>throw</name><argument_list>()</argument_list></call></expr>;
<expr><name>bad_cast</name><operator>&amp;</operator> <name>operator</name><operator>=</operator><operator>(</operator><specifier>const</specifier> <name>bad_cast</name><operator>&amp;</operator><operator>)</operator> <call><name>throw</name><argument_list>()</argument_list></call></expr>;
<expr><name>virtual</name> <operator>~</operator><call><name>bad_cast</name><argument_list>()</argument_list></call></expr>;
<expr><name>virtual</name> <specifier>const</specifier> <name>char</name><operator>*</operator> <macro><name>what</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <call><name>throw</name><argument_list>()</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>




<decl_stmt><decl><type><name>class</name></type> <name>bad_typeid</name><range>: <expr><name>public</name> <name>exception</name>
<block>{
<expr><name>public</name><operator>:</operator>
<macro><name>bad_typeid</name><argument_list>()</argument_list></macro> <call><name>throw</name><argument_list>()</argument_list></call></expr>;
<macro><name>bad_typeid</name><argument_list>(<argument>const bad_typeid &amp;__rhs</argument>)</argument_list></macro> <expr><call><name>throw</name><argument_list>()</argument_list></call></expr>;
<expr><name>virtual</name> <operator>~</operator><call><name>bad_typeid</name><argument_list>()</argument_list></call></expr>;
<expr><name>bad_typeid</name><operator>&amp;</operator> <name>operator</name><operator>=</operator><operator>(</operator><specifier>const</specifier> <name>bad_typeid</name> <operator>&amp;</operator><name>__rhs</name><operator>)</operator> <call><name>throw</name><argument_list>()</argument_list></call></expr>;
<expr><name>virtual</name> <specifier>const</specifier> <name>char</name><operator>*</operator> <macro><name>what</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <call><name>throw</name><argument_list>()</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>bad_array_new_length</name><range>: <expr><name>public</name> <name>bad_alloc</name>
<block>{
<expr><name>public</name><operator>:</operator>
<macro><name>bad_array_new_length</name><argument_list>()</argument_list></macro> <call><name>throw</name><argument_list>()</argument_list></call></expr>;
<macro><name>bad_array_new_length</name><argument_list>(<argument>const bad_array_new_length&amp;</argument>)</argument_list></macro> <expr><call><name>throw</name><argument_list>()</argument_list></call></expr>;
<expr><name>bad_array_new_length</name><operator>&amp;</operator> <name>operator</name><operator>=</operator><operator>(</operator><specifier>const</specifier> <name>bad_array_new_length</name><operator>&amp;</operator><operator>)</operator> <call><name>throw</name><argument_list>()</argument_list></call></expr>;
<expr><name>virtual</name> <operator>~</operator><call><name>bad_array_new_length</name><argument_list>()</argument_list></call></expr>;
<expr><name>virtual</name> <specifier>const</specifier> <name>char</name> <operator>*</operator><macro><name>what</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <call><name>throw</name><argument_list>()</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>


</block_content>}</block></decl></decl_stmt>

</unit>
