<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/byacc/defs.h">

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_CONFIG_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;config.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>class</name></cpp:macro> <cpp:value>myClass</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YYMAJOR</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YYMINOR</name></cpp:macro> <cpp:value>9</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONCAT</name><parameter_list>(<parameter><type><name>first</name></type></parameter>,<parameter><type><name>second</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>first #second</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONCAT1</name><parameter_list>(<parameter><type><name>string</name></type></parameter>,<parameter><type><name>number</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>CONCAT(string, number)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONCAT2</name><parameter_list>(<parameter><type><name>first</name></type></parameter>,<parameter><type><name>second</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>#first "." #second</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYPATCH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VSTRING</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>CONCAT2(a,b) CONCAT1(" ",YYPATCH)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VSTRING</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>CONCAT2(a,b)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VERSION</name></cpp:macro> <cpp:value>VSTRING(YYMAJOR, YYMINOR)</cpp:value></cpp:define>
















<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXCHAR</name></cpp:macro> <cpp:value>UCHAR_MAX</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MAXTABLE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXTABLE</name></cpp:macro> <cpp:value>32500</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MAXTABLE</name> <operator>&lt;=</operator> <name>SHRT_MAX</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YYINT</name></cpp:macro> <cpp:value>short</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXYYINT</name></cpp:macro> <cpp:value>SHRT_MAX</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MINYYINT</name></cpp:macro> <cpp:value>SHRT_MIN</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>MAXTABLE</name> <operator>&lt;=</operator> <name>INT_MAX</name></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YYINT</name></cpp:macro> <cpp:value>int</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXYYINT</name></cpp:macro> <cpp:value>INT_MAX</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MINYYINT</name></cpp:macro> <cpp:value>INT_MIN</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> <cpp:literal>"MAXTABLE is too large for this machine architecture!"</cpp:literal></cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BITS_PER_WORD</name></cpp:macro> <cpp:value>((int) sizeof (unsigned) * CHAR_BIT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WORDSIZE</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((n)+(BITS_PER_WORD-1))/BITS_PER_WORD)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIT</name><parameter_list>(<parameter><type><name>r</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((((r)[(n)/BITS_PER_WORD])&gt;&gt;((n)&amp;(BITS_PER_WORD-1)))&amp;1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SETBIT</name><parameter_list>(<parameter><type><name>r</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((r)[(n)/BITS_PER_WORD]|=((unsigned)1&lt;&lt;((n)&amp;(BITS_PER_WORD-1))))</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUL</name></cpp:macro> <cpp:value>'\0'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEWLINE</name></cpp:macro> <cpp:value>'\n'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SP</name></cpp:macro> <cpp:value>' '</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BS</name></cpp:macro> <cpp:value>'\b'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HT</name></cpp:macro> <cpp:value>'\t'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VT</name></cpp:macro> <cpp:value>'\013'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CR</name></cpp:macro> <cpp:value>'\r'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FF</name></cpp:macro> <cpp:value>'\f'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QUOTE</name></cpp:macro> <cpp:value>'\''</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DOUBLE_QUOTE</name></cpp:macro> <cpp:value>'\"'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BACKSLASH</name></cpp:macro> <cpp:value>'\\'</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UCH</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(unsigned char)(c)</cpp:value></cpp:define>



<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>VMS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CODE_SUFFIX</name></cpp:macro> <cpp:value>"_code.c"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFINES_SUFFIX</name></cpp:macro> <cpp:value>"_tab.h"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXTERNS_SUFFIX</name></cpp:macro> <cpp:value>"_tab.i"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OUTPUT_SUFFIX</name></cpp:macro> <cpp:value>"_tab.c"</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CODE_SUFFIX</name></cpp:macro> <cpp:value>".code.c"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFINES_SUFFIX</name></cpp:macro> <cpp:value>".tab.h"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXTERNS_SUFFIX</name></cpp:macro> <cpp:value>".tab.i"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OUTPUT_SUFFIX</name></cpp:macro> <cpp:value>".tab.c"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VERBOSE_SUFFIX</name></cpp:macro> <cpp:value>".output"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRAPH_SUFFIX</name></cpp:macro> <cpp:value>".dot"</cpp:value></cpp:define>



<typedef>typedef <type><enum>enum
<block>{
<decl><name>TOKEN</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>
,<decl><name>LEFT</name></decl>
,<decl><name>RIGHT</name></decl>
,<decl><name>NONASSOC</name></decl>
,<decl><name>MARK</name></decl>
,<decl><name>TEXT</name></decl>
,<decl><name>TYPE</name></decl>
,<decl><name>START</name></decl>
,<decl><name>UNION</name></decl>
,<decl><name>IDENT</name></decl>
,<decl><name>EXPECT</name></decl>
,<decl><name>EXPECT_RR</name></decl>
,<decl><name>PURE_PARSER</name></decl>
,<decl><name>PARSE_PARAM</name></decl>
,<decl><name>LEX_PARAM</name></decl>
,<decl><name>POSIX_YACC</name></decl>
,<decl><name>TOKEN_TABLE</name></decl>
,<decl><name>ERROR_VERBOSE</name></decl>
,<decl><name>XXXDEBUG</name></decl>
,<decl><name>XCODE</name></decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYBTYACC</name></expr></argument>)</argument_list></call></expr></cpp:if>
,<decl><name>LOCATIONS</name></decl>
,<decl><name>DESTRUCTOR</name></decl>
,<decl><name>INITIAL_ACTION</name></decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></enum></type>
<name>KEY_CASES</name>;</typedef>



<typedef>typedef <type><enum>enum
<block>{
<decl><name>UNKNOWN</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>
,<decl><name>TERM</name></decl>
,<decl><name>NONTERM</name></decl>
,<decl><name>ACTION</name></decl>
,<decl><name>ARGUMENT</name></decl>
}</block></enum></type>
<name>SYM_CASES</name>;</typedef>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNDEFINED</name></cpp:macro> <cpp:value>(-1)</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHIFT</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REDUCE</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_NAME1</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(isalpha(UCH(c)) || (c) == '_' || (c) == '$')</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_NAME2</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(isalnum(UCH(c)) || (c) == '_' || (c) == '$')</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_IDENT</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(isalnum(UCH(c)) || (c) == '_' || (c) == '.' || (c) == '$')</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_OCTAL</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((c) &gt;= '0' &amp;&amp; (c) &lt;= '7')</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISTOKEN</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((s) &lt; start_symbol)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISVAR</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((s) &gt;= start_symbol)</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CALLOC</name><parameter_list>(<parameter><type><name>k</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(calloc((size_t)(k),(size_t)(n)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FREE</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(free((char*)(x)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MALLOC</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(malloc((size_t)(n)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TCMALLOC</name><parameter_list>(<parameter><type><name>t</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((t*) calloc((size_t)(n), sizeof(t)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TMALLOC</name><parameter_list>(<parameter><type><name>t</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((t*) malloc((size_t)(n) * sizeof(t)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEW</name><parameter_list>(<parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((t*)allocate(sizeof(t)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEW2</name><parameter_list>(<parameter><type><name>n</name></type></parameter>,<parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((t*)allocate(((size_t)(n)*sizeof(t))))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REALLOC</name><parameter_list>(<parameter><type><name>p</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(realloc((char*)(p),(size_t)(n)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TREALLOC</name><parameter_list>(<parameter><type><name>t</name></type></parameter>,<parameter><type><name>p</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((t*)realloc((char*)(p), (size_t)(n) * sizeof(t)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DO_FREE</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>if (x) { FREE(x); x = 0; }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NO_SPACE</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>if (p == 0) no_space(); assert(p != 0)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PLURAL</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((n) &gt; 1 ? "s" : "")</cpp:value></cpp:define>





<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYBTYACC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_HEADER_GUARDS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_HEADER_GUARDS</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><name>char</name></type> <name>Assoc_t</name>;</typedef>
<typedef>typedef <type><name>char</name></type> <name>Class_t</name>;</typedef>
<typedef>typedef <type><name>YYINT</name></type> <name>Index_t</name>;</typedef>
<typedef>typedef <type><name>YYINT</name></type> <name>Value_t</name>;</typedef>



<typedef>typedef <type><name><name>struct</name> <name>bucket</name></name></type> <name>bucket</name>;</typedef>
<struct>struct <name>bucket</name>
<block>{
<decl_stmt><decl><type><name><name>struct</name> <name>bucket</name></name> <modifier>*</modifier></type><name>link</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>bucket</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tag</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYBTYACC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argnames</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argtags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>args</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>destructor</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>Value_t</name></type> <name>value</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Index_t</name></type> <name>index</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value_t</name></type> <name>prec</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Class_t</name></type> <name>class</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Assoc_t</name></type> <name>assoc</name></decl>;</decl_stmt>
}</block>;</struct>



<typedef>typedef <type><name><name>struct</name> <name>core</name></name></type> <name>core</name>;</typedef>
<struct>struct <name>core</name>
<block>{
<decl_stmt><decl><type><name><name>struct</name> <name>core</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>core</name></name> <modifier>*</modifier></type><name>link</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value_t</name></type> <name>number</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value_t</name></type> <name>accessing_symbol</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value_t</name></type> <name>nitems</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value_t</name></type> <name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>



<typedef>typedef <type><name><name>struct</name> <name>shifts</name></name></type> <name>shifts</name>;</typedef>
<struct>struct <name>shifts</name>
<block>{
<decl_stmt><decl><type><name><name>struct</name> <name>shifts</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value_t</name></type> <name>number</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value_t</name></type> <name>nshifts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value_t</name></type> <name><name>shift</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>



<typedef>typedef <type><name><name>struct</name> <name>reductions</name></name></type> <name>reductions</name>;</typedef>
<struct>struct <name>reductions</name>
<block>{
<decl_stmt><decl><type><name><name>struct</name> <name>reductions</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value_t</name></type> <name>number</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value_t</name></type> <name>nreds</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value_t</name></type> <name><name>rules</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>



<typedef>typedef <type><name><name>struct</name> <name>action</name></name></type> <name>action</name>;</typedef>
<struct>struct <name>action</name>
<block>{
<decl_stmt><decl><type><name><name>struct</name> <name>action</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value_t</name></type> <name>symbol</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value_t</name></type> <name>number</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value_t</name></type> <name>prec</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>action_code</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Assoc_t</name></type> <name>assoc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>suppressed</name></decl>;</decl_stmt>
}</block>;</struct>


<typedef>typedef <type><name><name>struct</name> <name>param</name></name></type> <name>param</name>;</typedef>
<struct>struct <name>param</name>
<block>{
<decl_stmt><decl><type><name><name>struct</name> <name>param</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>type2</name></decl>;</decl_stmt>
}</block>;</struct>



<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name></type> <name>dflag2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name></type> <name>dflag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name></type> <name>gflag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name></type> <name>iflag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name></type> <name>lflag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name></type> <name>rflag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name></type> <name>sflag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name></type> <name>tflag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name></type> <name>vflag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>symbol_prefix</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>myname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name> <modifier>*</modifier></type><name>cptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name> <modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>lineno</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>outline</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>exit_code</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>pure_parser</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>token_table</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>error_verbose</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYBTYACC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>locations</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>backtrack</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>destructor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name> <modifier>*</modifier></type><name>initial_action</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>banner</name><index>[]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>xdecls</name><index>[]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>tables</name><index>[]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>global_vars</name><index>[]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>impure_vars</name><index>[]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>hdr_defs</name><index>[]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>hdr_vars</name><index>[]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>body_1</name><index>[]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>body_vars</name><index>[]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>init_vars</name><index>[]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>body_2</name><index>[]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>body_3</name><index>[]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>trailer</name><index>[]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name> <modifier>*</modifier></type><name>code_file_name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name> <modifier>*</modifier></type><name>input_file_name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>size_t</name></type> <name>input_file_name_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name> <modifier>*</modifier></type><name>defines_file_name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name> <modifier>*</modifier></type><name>externs_file_name</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>extern</specifier> <name>FILE</name> <modifier>*</modifier></type><name>action_file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>FILE</name> <modifier>*</modifier></type><name>code_file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>FILE</name> <modifier>*</modifier></type><name>defines_file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>FILE</name> <modifier>*</modifier></type><name>externs_file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>FILE</name> <modifier>*</modifier></type><name>input_file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>FILE</name> <modifier>*</modifier></type><name>output_file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>FILE</name> <modifier>*</modifier></type><name>text_file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>FILE</name> <modifier>*</modifier></type><name>union_file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>FILE</name> <modifier>*</modifier></type><name>verbose_file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>FILE</name> <modifier>*</modifier></type><name>graph_file</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>extern</specifier> <name>Value_t</name></type> <name>nitems</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>Value_t</name></type> <name>nrules</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>Value_t</name></type> <name>nsyms</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>Value_t</name></type> <name>ntokens</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>Value_t</name></type> <name>nvars</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>ntags</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name></type> <name>unionized</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name></type> <name><name>line_format</name><index>[]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>extern</specifier> <name>Value_t</name></type> <name>start_symbol</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>symbol_name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>symbol_pname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>Value_t</name> <modifier>*</modifier></type><name>symbol_value</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>Value_t</name> <modifier>*</modifier></type><name>symbol_prec</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name> <modifier>*</modifier></type><name>symbol_assoc</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYBTYACC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>extern</specifier> <name>Value_t</name> <modifier>*</modifier></type><name>symbol_pval</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>symbol_destructor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>symbol_type_tag</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>extern</specifier> <name>Value_t</name> <modifier>*</modifier></type><name>ritem</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>Value_t</name> <modifier>*</modifier></type><name>rlhs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>Value_t</name> <modifier>*</modifier></type><name>rrhs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>Value_t</name> <modifier>*</modifier></type><name>rprec</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>Assoc_t</name> <modifier>*</modifier></type><name>rassoc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>extern</specifier> <name>Value_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>derives</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name> <modifier>*</modifier></type><name>nullable</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>extern</specifier> <name>bucket</name> <modifier>*</modifier></type><name>first_symbol</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>bucket</name> <modifier>*</modifier></type><name>last_symbol</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>nstates</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>core</name> <modifier>*</modifier></type><name>first_state</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>shifts</name> <modifier>*</modifier></type><name>first_shift</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>reductions</name> <modifier>*</modifier></type><name>first_reduction</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>Value_t</name> <modifier>*</modifier></type><name>accessing_symbol</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>core</name> <modifier>*</modifier><modifier>*</modifier></type><name>state_table</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>shifts</name> <modifier>*</modifier><modifier>*</modifier></type><name>shift_table</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>reductions</name> <modifier>*</modifier><modifier>*</modifier></type><name>reduction_table</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>unsigned</name> <modifier>*</modifier></type><name>LA</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>Value_t</name> <modifier>*</modifier></type><name>LAruleno</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>Value_t</name> <modifier>*</modifier></type><name>lookaheads</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>Value_t</name> <modifier>*</modifier></type><name>goto_base</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>Value_t</name> <modifier>*</modifier></type><name>goto_map</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>Value_t</name> <modifier>*</modifier></type><name>from_state</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>Value_t</name> <modifier>*</modifier></type><name>to_state</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>extern</specifier> <name>action</name> <modifier>*</modifier><modifier>*</modifier></type><name>parser</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>SRexpect</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>RRexpect</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>SRtotal</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>RRtotal</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>Value_t</name> <modifier>*</modifier></type><name>SRconflicts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>Value_t</name> <modifier>*</modifier></type><name>RRconflicts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>Value_t</name> <modifier>*</modifier></type><name>defred</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>Value_t</name> <modifier>*</modifier></type><name>rules_used</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>Value_t</name></type> <name>nunused</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>Value_t</name></type> <name>final_state</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>extern</specifier> <name>Value_t</name> <modifier>*</modifier></type><name>itemset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>Value_t</name> <modifier>*</modifier></type><name>itemsetend</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>unsigned</name> <modifier>*</modifier></type><name>ruleset</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>extern</specifier> <name>param</name> <modifier>*</modifier></type><name>lex_param</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>param</name> <modifier>*</modifier></type><name>parse_param</name></decl>;</decl_stmt>



<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>GCC_NORETURN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__dead2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GCC_NORETURN</name></cpp:macro> <cpp:value>__dead2</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__dead</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GCC_NORETURN</name></cpp:macro> <cpp:value>__dead</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GCC_NORETURN</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ATTRIBUTE_NORETURN</name></cpp:macro> <cpp:value>__attribute__((noreturn))</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ATTRIBUTE_NORETURN</name></cpp:macro> <cpp:value>__declspec(noreturn)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ATTRIBUTE_NORETURN</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NODEFAULT</name></cpp:macro> <cpp:value>__assume(0);</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NODEFAULT</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NOTREACHED</name></cpp:macro> <cpp:value>NODEFAULT</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>GCC_UNUSED</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__unused</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GCC_UNUSED</name></cpp:macro> <cpp:value>__unused</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GCC_UNUSED</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>GCC_PRINTFLIKE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GCC_PRINTFLIKE</name><parameter_list>(<parameter><type><name>fmt</name></type></parameter>,<parameter><type><name>var</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>closure</name><parameter_list>(<parameter><decl><type><name>Value_t</name> <modifier>*</modifier></type><name>nucleus</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>finalize_closure</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>set_first_derives</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>


<struct>struct <name>ainfo</name>
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>a_lineno</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>a_line</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>a_cptr</name></decl>;</decl_stmt>
}</block>;</struct>

<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>arg_number_disagree_warning</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>a_lineno</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>a_name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>arg_type_disagree_warning</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>a_lineno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>a_name</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>ATTRIBUTE_NORETURN</name>
<specifier>extern</specifier> <name>void</name></type> <name>at_error</name><argument_list>(<argument><expr><name>int</name> <name>a_lineno</name></expr></argument>, <argument><expr><name>char</name> <operator>*</operator><name>a_line</name></expr></argument>, <argument><expr><name>char</name> <operator>*</operator><name>a_cptr</name></expr></argument>)</argument_list> <name>GCC_NORETURN</name></decl>;</decl_stmt>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>at_warning</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>a_lineno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>ATTRIBUTE_NORETURN</name>
<specifier>extern</specifier> <name>void</name></type> <name>bad_formals</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list> <name>GCC_NORETURN</name></decl>;</decl_stmt>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>default_action_warning</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>destructor_redeclared_warning</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ainfo</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>ATTRIBUTE_NORETURN</name>
<specifier>extern</specifier> <name>void</name></type> <name>dollar_error</name><argument_list>(<argument><expr><name>int</name> <name>a_lineno</name></expr></argument>, <argument><expr><name>char</name> <operator>*</operator><name>a_line</name></expr></argument>, <argument><expr><name>char</name> <operator>*</operator><name>a_cptr</name></expr></argument>)</argument_list> <name>GCC_NORETURN</name></decl>;</decl_stmt>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>dollar_warning</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>a_lineno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>ATTRIBUTE_NORETURN</name>
<specifier>extern</specifier> <name>void</name></type> <name>fatal</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>msg</name></expr></argument>)</argument_list> <name>GCC_NORETURN</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ATTRIBUTE_NORETURN</name>
<specifier>extern</specifier> <name>void</name></type> <name>illegal_character</name><argument_list>(<argument><expr><name>char</name> <operator>*</operator><name>c_cptr</name></expr></argument>)</argument_list> <name>GCC_NORETURN</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ATTRIBUTE_NORETURN</name>
<specifier>extern</specifier> <name>void</name></type> <name>illegal_tag</name><argument_list>(<argument><expr><name>int</name> <name>t_lineno</name></expr></argument>, <argument><expr><name>char</name> <operator>*</operator><name>t_line</name></expr></argument>, <argument><expr><name>char</name> <operator>*</operator><name>t_cptr</name></expr></argument>)</argument_list> <name>GCC_NORETURN</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ATTRIBUTE_NORETURN</name>
<specifier>extern</specifier> <name>void</name></type> <name>missing_brace</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list> <name>GCC_NORETURN</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ATTRIBUTE_NORETURN</name>
<specifier>extern</specifier> <name>void</name></type> <name>no_grammar</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list> <name>GCC_NORETURN</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ATTRIBUTE_NORETURN</name>
<specifier>extern</specifier> <name>void</name></type> <name>no_space</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list> <name>GCC_NORETURN</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ATTRIBUTE_NORETURN</name>
<specifier>extern</specifier> <name>void</name></type> <name>open_error</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>filename</name></expr></argument>)</argument_list> <name>GCC_NORETURN</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ATTRIBUTE_NORETURN</name>
<specifier>extern</specifier> <name>void</name></type> <name>over_unionized</name><argument_list>(<argument><expr><name>char</name> <operator>*</operator><name>u_cptr</name></expr></argument>)</argument_list> <name>GCC_NORETURN</name></decl>;</decl_stmt>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>prec_redeclared</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>reprec_warning</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>restarted_warning</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>retyped_warning</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>revalued_warning</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>start_requires_args</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>a_name</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>ATTRIBUTE_NORETURN</name>
<specifier>extern</specifier> <name>void</name></type> <name>syntax_error</name><argument_list>(<argument><expr><name>int</name> <name>st_lineno</name></expr></argument>, <argument><expr><name>char</name> <operator>*</operator><name>st_line</name></expr></argument>, <argument><expr><name>char</name> <operator>*</operator><name>st_cptr</name></expr></argument>)</argument_list> <name>GCC_NORETURN</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ATTRIBUTE_NORETURN</name>
<specifier>extern</specifier> <name>void</name></type> <name>terminal_lhs</name><argument_list>(<argument><expr><name>int</name> <name>s_lineno</name></expr></argument>)</argument_list> <name>GCC_NORETURN</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ATTRIBUTE_NORETURN</name>
<specifier>extern</specifier> <name>void</name></type> <name>terminal_start</name><argument_list>(<argument><expr><name>char</name> <operator>*</operator><name>s</name></expr></argument>)</argument_list> <name>GCC_NORETURN</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ATTRIBUTE_NORETURN</name>
<specifier>extern</specifier> <name>void</name></type> <name>tokenized_start</name><argument_list>(<argument><expr><name>char</name> <operator>*</operator><name>s</name></expr></argument>)</argument_list> <name>GCC_NORETURN</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ATTRIBUTE_NORETURN</name>
<specifier>extern</specifier> <name>void</name></type> <name>undefined_goal</name><argument_list>(<argument><expr><name>char</name> <operator>*</operator><name>s</name></expr></argument>)</argument_list> <name>GCC_NORETURN</name></decl>;</decl_stmt>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>undefined_symbol_warning</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>ATTRIBUTE_NORETURN</name>
<specifier>extern</specifier> <name>void</name></type> <name>unexpected_EOF</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list> <name>GCC_NORETURN</name></decl>;</decl_stmt>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>unknown_arg_warning</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>d_lineno</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dlr_opt</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>d_arg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>d_line</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>d_cptr</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>ATTRIBUTE_NORETURN</name>
<specifier>extern</specifier> <name>void</name></type> <name>unknown_rhs</name><argument_list>(<argument><expr><name>int</name> <name>i</name></expr></argument>)</argument_list> <name>GCC_NORETURN</name></decl>;</decl_stmt>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>unsupported_flag_warning</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>flag</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>details</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>ATTRIBUTE_NORETURN</name>
<specifier>extern</specifier> <name>void</name></type> <name>unterminated_action</name><argument_list>(<argument><expr><specifier>const</specifier> struct <name>ainfo</name> <operator>*</operator></expr></argument>)</argument_list> <name>GCC_NORETURN</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ATTRIBUTE_NORETURN</name>
<specifier>extern</specifier> <name>void</name></type> <name>unterminated_comment</name><argument_list>(<argument><expr><specifier>const</specifier> struct <name>ainfo</name> <operator>*</operator></expr></argument>)</argument_list> <name>GCC_NORETURN</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ATTRIBUTE_NORETURN</name>
<specifier>extern</specifier> <name>void</name></type> <name>unterminated_string</name><argument_list>(<argument><expr><specifier>const</specifier> struct <name>ainfo</name> <operator>*</operator></expr></argument>)</argument_list> <name>GCC_NORETURN</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ATTRIBUTE_NORETURN</name>
<specifier>extern</specifier> <name>void</name></type> <name>unterminated_text</name><argument_list>(<argument><expr><specifier>const</specifier> struct <name>ainfo</name> <operator>*</operator></expr></argument>)</argument_list> <name>GCC_NORETURN</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ATTRIBUTE_NORETURN</name>
<specifier>extern</specifier> <name>void</name></type> <name>unterminated_union</name><argument_list>(<argument><expr><specifier>const</specifier> struct <name>ainfo</name> <operator>*</operator></expr></argument>)</argument_list> <name>GCC_NORETURN</name></decl>;</decl_stmt>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>untyped_arg_warning</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>a_lineno</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dlr_opt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>a_name</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>ATTRIBUTE_NORETURN</name>
<specifier>extern</specifier> <name>void</name></type> <name>untyped_lhs</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list> <name>GCC_NORETURN</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ATTRIBUTE_NORETURN</name>
<specifier>extern</specifier> <name>void</name></type> <name>untyped_rhs</name><argument_list>(<argument><expr><name>int</name> <name>i</name></expr></argument>, <argument><expr><name>char</name> <operator>*</operator><name>s</name></expr></argument>)</argument_list> <name>GCC_NORETURN</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ATTRIBUTE_NORETURN</name>
<specifier>extern</specifier> <name>void</name></type> <name>used_reserved</name><argument_list>(<argument><expr><name>char</name> <operator>*</operator><name>s</name></expr></argument>)</argument_list> <name>GCC_NORETURN</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ATTRIBUTE_NORETURN</name>
<specifier>extern</specifier> <name>void</name></type> <name>unterminated_arglist</name><argument_list>(<argument><expr><specifier>const</specifier> struct <name>ainfo</name> <operator>*</operator></expr></argument>)</argument_list> <name>GCC_NORETURN</name></decl>;</decl_stmt>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>wrong_number_args_warning</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>which</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>a_name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>wrong_type_for_arg_warning</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>a_name</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>graph</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>lalr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>lr0</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>show_cores</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>show_ritems</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>show_rrhs</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>show_shifts</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><specifier>extern</specifier> <name>void</name> <modifier>*</modifier></type><name>allocate</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>ATTRIBUTE_NORETURN</name>
<specifier>extern</specifier> <name>void</name></type> <name>done</name><argument_list>(<argument><expr><name>int</name> <name>k</name></expr></argument>)</argument_list> <name>GCC_NORETURN</name></decl>;</decl_stmt>


<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>free_parser</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>make_parser</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>


<struct>struct <name>mstring</name>
<block>{
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>base</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>
}</block>;</struct>

<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>msprintf</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>mstring</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> GCC_PRINTFLIKE<parameter_list>(</parameter_list>2<operator>,</operator>3</function_decl>)<empty_stmt>;</empty_stmt>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>mputchar</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>mstring</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name><name>struct</name> <name>mstring</name></name> <modifier>*</modifier></type><name>msnew</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name><name>struct</name> <name>mstring</name></name> <modifier>*</modifier></type><name>msrenew</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>char</name> <modifier>*</modifier></type><name>msdone</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>mstring</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>strnscmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>unsigned</name> <name>int</name></type> <name>strnshash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>mputc</name><parameter_list>(<parameter><type><name>m</name></type></parameter>, <parameter><type><name>ch</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((m)-&gt;ptr == (m)-&gt;end) ? mputchar(m,ch) : (*(m)-&gt;ptr++ = (char) (ch)))</cpp:value></cpp:define>




<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>output</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>reader</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<typedef>typedef <type><enum>enum
<block>{
<decl><name>CODE_HEADER</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>
,<decl><name>CODE_REQUIRES</name></decl>
,<decl><name>CODE_PROVIDES</name></decl>
,<decl><name>CODE_TOP</name></decl>
,<decl><name>CODE_IMPORTS</name></decl>
,<decl><name>CODE_MAX</name></decl>
}</block></enum></type>
<name>CODE_CASES</name>;</typedef>
<struct><specifier>extern</specifier> struct <name>code_lines</name>
<block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>lines</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>num</name></decl>;</decl_stmt>
}</block>
<decl><name><name>code_lines</name><index>[<expr><name>CODE_MAX</name></expr>]</index></name></decl>;</struct>


<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>write_section</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type> <name>fp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>section</name><index>[]</index></name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><specifier>extern</specifier> <name>bucket</name> <modifier>*</modifier></type><name>make_bucket</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>bucket</name> <modifier>*</modifier></type><name>lookup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>create_symbol_table</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>free_symbol_table</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>free_symbols</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>verbose</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>reflexive_transitive_closure</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <modifier>*</modifier></type><name>R</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>print_closure</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>print_EFF</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>print_first_derives</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>print_derives</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NO_LEAKS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>lr0_leaks</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>lalr_leaks</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>mkpar_leaks</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>output_leaks</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>mstring_leaks</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>reader_leaks</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
