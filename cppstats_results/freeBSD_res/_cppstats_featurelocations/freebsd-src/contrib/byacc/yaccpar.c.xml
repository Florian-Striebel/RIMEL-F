<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/byacc/yaccpar.c">





<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"defs.h"</cpp:file></cpp:include>









<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>banner</name><index>[]</index></name> <init>=
<expr><block>{
<expr><literal type="string">"/* original parser id follows */"</literal></expr>,
<expr><literal type="string">"/* yysccsid[] = \"@(#)yaccpar 1.9 (Berkeley) 02/21/93\" */"</literal></expr>,
<expr><literal type="string">"/* (use YYMAJOR/YYMINOR for ifdefs dependent on parser version) */"</literal></expr>,
<expr><literal type="string">""</literal></expr>,
<expr><literal type="string">"#define YYBYACC 1"</literal></expr>,
<expr><call><name>CONCAT1</name><argument_list>(<argument><expr><literal type="string">"#define YYMAJOR "</literal></expr></argument>, <argument><expr><name>YYMAJOR</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>CONCAT1</name><argument_list>(<argument><expr><literal type="string">"#define YYMINOR "</literal></expr></argument>, <argument><expr><name>YYMINOR</name></expr></argument>)</argument_list></call></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYPATCH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><call><name>CONCAT1</name><argument_list>(<argument><expr><literal type="string">"#define YYPATCH "</literal></expr></argument>, <argument><expr><name>YYPATCH</name></expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><literal type="string">""</literal></expr>,
<expr><literal type="string">"#define YYEMPTY (-1)"</literal></expr>,
<expr><literal type="string">"#define yyclearin (yychar = YYEMPTY)"</literal></expr>,
<expr><literal type="string">"#define yyerrok (yyerrflag = 0)"</literal></expr>,
<expr><literal type="string">"#define YYRECOVERING() (yyerrflag != 0)"</literal></expr>,
<expr><literal type="string">"#define YYENOMEM (-2)"</literal></expr>,
<expr><literal type="string">"#define YYEOF 0"</literal></expr>,
<expr><literal type="number">0</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>xdecls</name><index>[]</index></name> <init>=
<expr><block>{
<expr><literal type="string">""</literal></expr>,
<expr><literal type="string">"extern int YYPARSE_DECL();"</literal></expr>,
<expr><literal type="number">0</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>tables</name><index>[]</index></name> <init>=
<expr><block>{
<expr><literal type="string">"extern YYINT yylhs[];"</literal></expr>,
<expr><literal type="string">"extern YYINT yylen[];"</literal></expr>,
<expr><literal type="string">"extern YYINT yydefred[];"</literal></expr>,
<expr><literal type="string">"extern YYINT yydgoto[];"</literal></expr>,
<expr><literal type="string">"extern YYINT yysindex[];"</literal></expr>,
<expr><literal type="string">"extern YYINT yyrindex[];"</literal></expr>,
<expr><literal type="string">"extern YYINT yygindex[];"</literal></expr>,
<expr><literal type="string">"extern YYINT yytable[];"</literal></expr>,
<expr><literal type="string">"extern YYINT yycheck[];"</literal></expr>,
<expr><literal type="string">""</literal></expr>,
<expr><literal type="string">"#if YYDEBUG || defined(yytname)"</literal></expr>,
<expr><literal type="string">"extern char *yyname[];"</literal></expr>,
<expr><literal type="string">"#endif"</literal></expr>,
<expr><literal type="string">"#if YYDEBUG"</literal></expr>,
<expr><literal type="string">"extern char *yyrule[];"</literal></expr>,
<expr><literal type="string">"#endif"</literal></expr>,
<expr><literal type="number">0</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>global_vars</name><index>[]</index></name> <init>=
<expr><block>{
<expr><literal type="string">""</literal></expr>,
<expr><literal type="string">"#if YYDEBUG"</literal></expr>,
<expr><literal type="string">"int yydebug;"</literal></expr>,
<expr><literal type="string">"#endif"</literal></expr>,
<expr><literal type="number">0</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>impure_vars</name><index>[]</index></name> <init>=
<expr><block>{
<expr><literal type="string">""</literal></expr>,
<expr><literal type="string">"int yyerrflag;"</literal></expr>,
<expr><literal type="string">"int yychar;"</literal></expr>,
<expr><literal type="string">"YYSTYPE yyval;"</literal></expr>,
<expr><literal type="string">"YYSTYPE yylval;"</literal></expr>,
<expr><literal type="string">"int yynerrs;"</literal></expr>,
<expr><literal type="number">0</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>hdr_defs</name><index>[]</index></name> <init>=
<expr><block>{
<expr><literal type="string">""</literal></expr>,
<expr><literal type="string">"/* define the initial stack-sizes */"</literal></expr>,
<expr><literal type="string">"#ifdef YYSTACKSIZE"</literal></expr>,
<expr><literal type="string">"#undef YYMAXDEPTH"</literal></expr>,
<expr><literal type="string">"#define YYMAXDEPTH YYSTACKSIZE"</literal></expr>,
<expr><literal type="string">"#else"</literal></expr>,
<expr><literal type="string">"#ifdef YYMAXDEPTH"</literal></expr>,
<expr><literal type="string">"#define YYSTACKSIZE YYMAXDEPTH"</literal></expr>,
<expr><literal type="string">"#else"</literal></expr>,
<expr><literal type="string">"#define YYSTACKSIZE 10000"</literal></expr>,
<expr><literal type="string">"#define YYMAXDEPTH 10000"</literal></expr>,
<expr><literal type="string">"#endif"</literal></expr>,
<expr><literal type="string">"#endif"</literal></expr>,
<expr><literal type="string">""</literal></expr>,
<expr><literal type="string">"#define YYINITSTACKSIZE 200"</literal></expr>,
<expr><literal type="string">""</literal></expr>,
<expr><literal type="string">"typedef struct {"</literal></expr>,
<expr><literal type="string">" unsigned stacksize;"</literal></expr>,
<expr><literal type="string">" YYINT *s_base;"</literal></expr>,
<expr><literal type="string">" YYINT *s_mark;"</literal></expr>,
<expr><literal type="string">" YYINT *s_last;"</literal></expr>,
<expr><literal type="string">" YYSTYPE *l_base;"</literal></expr>,
<expr><literal type="string">" YYSTYPE *l_mark;"</literal></expr>,
<expr><literal type="string">"} YYSTACKDATA;"</literal></expr>,
<expr><literal type="number">0</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>hdr_vars</name><index>[]</index></name> <init>=
<expr><block>{
<expr><literal type="string">"/* variables for the parser stack */"</literal></expr>,
<expr><literal type="string">"static YYSTACKDATA yystack;"</literal></expr>,
<expr><literal type="number">0</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>body_vars</name><index>[]</index></name> <init>=
<expr><block>{
<expr><literal type="string">" int yyerrflag;"</literal></expr>,
<expr><literal type="string">" int yychar;"</literal></expr>,
<expr><literal type="string">" YYSTYPE yyval;"</literal></expr>,
<expr><literal type="string">" YYSTYPE yylval;"</literal></expr>,
<expr><literal type="string">" int yynerrs;"</literal></expr>,
<expr><literal type="string">""</literal></expr>,
<expr><literal type="string">" /* variables for the parser stack */"</literal></expr>,
<expr><literal type="string">" YYSTACKDATA yystack;"</literal></expr>,
<expr><literal type="number">0</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>body_1</name><index>[]</index></name> <init>=
<expr><block>{
<expr><literal type="string">""</literal></expr>,
<expr><literal type="string">"#if YYDEBUG"</literal></expr>,
<expr><literal type="string">"#include &lt;stdio.h&gt; /* needed for printf */"</literal></expr>,
<expr><literal type="string">"#endif"</literal></expr>,
<expr><literal type="string">""</literal></expr>,
<expr><literal type="string">"#include &lt;stdlib.h&gt; /* needed for malloc, etc */"</literal></expr>,
<expr><literal type="string">"#include &lt;string.h&gt; /* needed for memset */"</literal></expr>,
<expr><literal type="string">""</literal></expr>,
<expr><literal type="string">"/* allocate initial stack or double stack size, up to YYMAXDEPTH */"</literal></expr>,
<expr><literal type="string">"static int yygrowstack(YYSTACKDATA *data)"</literal></expr>,
<expr><literal type="string">"{"</literal></expr>,
<expr><literal type="string">" int i;"</literal></expr>,
<expr><literal type="string">" unsigned newsize;"</literal></expr>,
<expr><literal type="string">" YYINT *newss;"</literal></expr>,
<expr><literal type="string">" YYSTYPE *newvs;"</literal></expr>,
<expr><literal type="string">""</literal></expr>,
<expr><literal type="string">" if ((newsize = data-&gt;stacksize) == 0)"</literal></expr>,
<expr><literal type="string">" newsize = YYINITSTACKSIZE;"</literal></expr>,
<expr><literal type="string">" else if (newsize &gt;= YYMAXDEPTH)"</literal></expr>,
<expr><literal type="string">" return YYENOMEM;"</literal></expr>,
<expr><literal type="string">" else if ((newsize *= 2) &gt; YYMAXDEPTH)"</literal></expr>,
<expr><literal type="string">" newsize = YYMAXDEPTH;"</literal></expr>,
<expr><literal type="string">""</literal></expr>,
<expr><literal type="string">" i = (int) (data-&gt;s_mark - data-&gt;s_base);"</literal></expr>,
<expr><literal type="string">" newss = (YYINT *)realloc(data-&gt;s_base, newsize * sizeof(*newss));"</literal></expr>,
<expr><literal type="string">" if (newss == NULL)"</literal></expr>,
<expr><literal type="string">" return YYENOMEM;"</literal></expr>,
<expr><literal type="string">""</literal></expr>,
<expr><literal type="string">" data-&gt;s_base = newss;"</literal></expr>,
<expr><literal type="string">" data-&gt;s_mark = newss + i;"</literal></expr>,
<expr><literal type="string">""</literal></expr>,
<expr><literal type="string">" newvs = (YYSTYPE *)realloc(data-&gt;l_base, newsize * sizeof(*newvs));"</literal></expr>,
<expr><literal type="string">" if (newvs == NULL)"</literal></expr>,
<expr><literal type="string">" return YYENOMEM;"</literal></expr>,
<expr><literal type="string">""</literal></expr>,
<expr><literal type="string">" data-&gt;l_base = newvs;"</literal></expr>,
<expr><literal type="string">" data-&gt;l_mark = newvs + i;"</literal></expr>,
<expr><literal type="string">""</literal></expr>,
<expr><literal type="string">" data-&gt;stacksize = newsize;"</literal></expr>,
<expr><literal type="string">" data-&gt;s_last = data-&gt;s_base + newsize - 1;"</literal></expr>,
<expr><literal type="string">" return 0;"</literal></expr>,
<expr><literal type="string">"}"</literal></expr>,
<expr><literal type="string">""</literal></expr>,
<expr><literal type="string">"#if YYPURE || defined(YY_NO_LEAKS)"</literal></expr>,
<expr><literal type="string">"static void yyfreestack(YYSTACKDATA *data)"</literal></expr>,
<expr><literal type="string">"{"</literal></expr>,
<expr><literal type="string">" free(data-&gt;s_base);"</literal></expr>,
<expr><literal type="string">" free(data-&gt;l_base);"</literal></expr>,
<expr><literal type="string">" memset(data, 0, sizeof(*data));"</literal></expr>,
<expr><literal type="string">"}"</literal></expr>,
<expr><literal type="string">"#else"</literal></expr>,
<expr><literal type="string">"#define yyfreestack(data) /* nothing */"</literal></expr>,
<expr><literal type="string">"#endif"</literal></expr>,
<expr><literal type="string">""</literal></expr>,
<expr><literal type="string">"#define YYABORT goto yyabort"</literal></expr>,
<expr><literal type="string">"#define YYREJECT goto yyabort"</literal></expr>,
<expr><literal type="string">"#define YYACCEPT goto yyaccept"</literal></expr>,
<expr><literal type="string">"#define YYERROR goto yyerrlab"</literal></expr>,
<expr><literal type="string">""</literal></expr>,
<expr><literal type="string">"int"</literal></expr>,
<expr><literal type="string">"YYPARSE_DECL()"</literal></expr>,
<expr><literal type="string">"{"</literal></expr>,
<expr><literal type="number">0</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>body_2</name><index>[]</index></name> <init>=
<expr><block>{
<expr><literal type="string">" int yym, yyn, yystate;"</literal></expr>,
<expr><literal type="string">"#if YYDEBUG"</literal></expr>,
<expr><literal type="string">" const char *yys;"</literal></expr>,
<expr><literal type="string">""</literal></expr>,
<expr><literal type="string">" if ((yys = getenv(\"YYDEBUG\")) != NULL)"</literal></expr>,
<expr><literal type="string">" {"</literal></expr>,
<expr><literal type="string">" yyn = *yys;"</literal></expr>,
<expr><literal type="string">" if (yyn &gt;= '0' &amp;&amp; yyn &lt;= '9')"</literal></expr>,
<expr><literal type="string">" yydebug = yyn - '0';"</literal></expr>,
<expr><literal type="string">" }"</literal></expr>,
<expr><literal type="string">"#endif"</literal></expr>,
<expr><literal type="string">""</literal></expr>,
<expr><literal type="number">0</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>init_vars</name><index>[]</index></name> <init>=
<expr><block>{
<expr><literal type="string">" memset(&amp;yyval, 0, sizeof(yyval));"</literal></expr>,
<expr><literal type="string">" memset(&amp;yylval, 0, sizeof(yylval));"</literal></expr>,
<expr><literal type="string">""</literal></expr>,
<expr><literal type="number">0</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>body_3</name><index>[]</index></name> <init>=
<expr><block>{
<expr><literal type="string">" yym = 0;"</literal></expr>,
<expr><literal type="string">" yyn = 0;"</literal></expr>,
<expr><literal type="string">" yynerrs = 0;"</literal></expr>,
<expr><literal type="string">" yyerrflag = 0;"</literal></expr>,
<expr><literal type="string">" yychar = YYEMPTY;"</literal></expr>,
<expr><literal type="string">" yystate = 0;"</literal></expr>,
<expr><literal type="string">""</literal></expr>,
<expr><literal type="string">"#if YYPURE"</literal></expr>,
<expr><literal type="string">" memset(&amp;yystack, 0, sizeof(yystack));"</literal></expr>,
<expr><literal type="string">"#endif"</literal></expr>,
<expr><literal type="string">""</literal></expr>,
<expr><literal type="string">" if (yystack.s_base == NULL &amp;&amp; yygrowstack(&amp;yystack) == YYENOMEM) goto yyoverflow;"</literal></expr>,
<expr><literal type="string">" yystack.s_mark = yystack.s_base;"</literal></expr>,
<expr><literal type="string">" yystack.l_mark = yystack.l_base;"</literal></expr>,
<expr><literal type="string">" yystate = 0;"</literal></expr>,
<expr><literal type="string">" *yystack.s_mark = 0;"</literal></expr>,
<expr><literal type="string">""</literal></expr>,
<expr><literal type="string">"yyloop:"</literal></expr>,
<expr><literal type="string">" if ((yyn = yydefred[yystate]) != 0) goto yyreduce;"</literal></expr>,
<expr><literal type="string">" if (yychar &lt; 0)"</literal></expr>,
<expr><literal type="string">" {"</literal></expr>,
<expr><literal type="string">" yychar = YYLEX;"</literal></expr>,
<expr><literal type="string">" if (yychar &lt; 0) yychar = YYEOF;"</literal></expr>,
<expr><literal type="string">"#if YYDEBUG"</literal></expr>,
<expr><literal type="string">" if (yydebug)"</literal></expr>,
<expr><literal type="string">" {"</literal></expr>,
<expr><literal type="string">" if ((yys = yyname[YYTRANSLATE(yychar)]) == NULL) yys = yyname[YYUNDFTOKEN];"</literal></expr>,
<expr><literal type="string">" printf(\"%sdebug: state %d, reading %d (%s)\\n\","</literal></expr>,
<expr><literal type="string">" YYPREFIX, yystate, yychar, yys);"</literal></expr>,
<expr><literal type="string">" }"</literal></expr>,
<expr><literal type="string">"#endif"</literal></expr>,
<expr><literal type="string">" }"</literal></expr>,
<expr><literal type="string">" if (((yyn = yysindex[yystate]) != 0) &amp;&amp; (yyn += yychar) &gt;= 0 &amp;&amp;"</literal></expr>,
<expr><literal type="string">" yyn &lt;= YYTABLESIZE &amp;&amp; yycheck[yyn] == (YYINT) yychar)"</literal></expr>,
<expr><literal type="string">" {"</literal></expr>,
<expr><literal type="string">"#if YYDEBUG"</literal></expr>,
<expr><literal type="string">" if (yydebug)"</literal></expr>,
<expr><literal type="string">" printf(\"%sdebug: state %d, shifting to state %d\\n\","</literal></expr>,
<expr><literal type="string">" YYPREFIX, yystate, yytable[yyn]);"</literal></expr>,
<expr><literal type="string">"#endif"</literal></expr>,
<expr><literal type="string">" if (yystack.s_mark &gt;= yystack.s_last &amp;&amp; yygrowstack(&amp;yystack) == YYENOMEM) goto yyoverflow;"</literal></expr>,
<expr><literal type="string">" yystate = yytable[yyn];"</literal></expr>,
<expr><literal type="string">" *++yystack.s_mark = yytable[yyn];"</literal></expr>,
<expr><literal type="string">" *++yystack.l_mark = yylval;"</literal></expr>,
<expr><literal type="string">" yychar = YYEMPTY;"</literal></expr>,
<expr><literal type="string">" if (yyerrflag &gt; 0) --yyerrflag;"</literal></expr>,
<expr><literal type="string">" goto yyloop;"</literal></expr>,
<expr><literal type="string">" }"</literal></expr>,
<expr><literal type="string">" if (((yyn = yyrindex[yystate]) != 0) &amp;&amp; (yyn += yychar) &gt;= 0 &amp;&amp;"</literal></expr>,
<expr><literal type="string">" yyn &lt;= YYTABLESIZE &amp;&amp; yycheck[yyn] == (YYINT) yychar)"</literal></expr>,
<expr><literal type="string">" {"</literal></expr>,
<expr><literal type="string">" yyn = yytable[yyn];"</literal></expr>,
<expr><literal type="string">" goto yyreduce;"</literal></expr>,
<expr><literal type="string">" }"</literal></expr>,
<expr><literal type="string">" if (yyerrflag != 0) goto yyinrecovery;"</literal></expr>,
<expr><literal type="string">""</literal></expr>,
<expr><literal type="string">" YYERROR_CALL(\"syntax error\");"</literal></expr>,
<expr><literal type="string">""</literal></expr>,
<expr><literal type="string">" goto yyerrlab; /* redundant goto avoids 'unused label' warning */"</literal></expr>,
<expr><literal type="string">"yyerrlab:"</literal></expr>,
<expr><literal type="string">" ++yynerrs;"</literal></expr>,
<expr><literal type="string">""</literal></expr>,
<expr><literal type="string">"yyinrecovery:"</literal></expr>,
<expr><literal type="string">" if (yyerrflag &lt; 3)"</literal></expr>,
<expr><literal type="string">" {"</literal></expr>,
<expr><literal type="string">" yyerrflag = 3;"</literal></expr>,
<expr><literal type="string">" for (;;)"</literal></expr>,
<expr><literal type="string">" {"</literal></expr>,
<expr><literal type="string">" if (((yyn = yysindex[*yystack.s_mark]) != 0) &amp;&amp; (yyn += YYERRCODE) &gt;= 0 &amp;&amp;"</literal></expr>,
<expr><literal type="string">" yyn &lt;= YYTABLESIZE &amp;&amp; yycheck[yyn] == (YYINT) YYERRCODE)"</literal></expr>,
<expr><literal type="string">" {"</literal></expr>,
<expr><literal type="string">"#if YYDEBUG"</literal></expr>,
<expr><literal type="string">" if (yydebug)"</literal></expr>,
<expr><literal type="string">" printf(\"%sdebug: state %d, error recovery shifting\\"</literal></expr>,
<expr><literal type="string">" to state %d\\n\", YYPREFIX, *yystack.s_mark, yytable[yyn]);"</literal></expr>,
<expr><literal type="string">"#endif"</literal></expr>,
<expr><literal type="string">" if (yystack.s_mark &gt;= yystack.s_last &amp;&amp; yygrowstack(&amp;yystack) == YYENOMEM) goto yyoverflow;"</literal></expr>,
<expr><literal type="string">" yystate = yytable[yyn];"</literal></expr>,
<expr><literal type="string">" *++yystack.s_mark = yytable[yyn];"</literal></expr>,
<expr><literal type="string">" *++yystack.l_mark = yylval;"</literal></expr>,
<expr><literal type="string">" goto yyloop;"</literal></expr>,
<expr><literal type="string">" }"</literal></expr>,
<expr><literal type="string">" else"</literal></expr>,
<expr><literal type="string">" {"</literal></expr>,
<expr><literal type="string">"#if YYDEBUG"</literal></expr>,
<expr><literal type="string">" if (yydebug)"</literal></expr>,
<expr><literal type="string">" printf(\"%sdebug: error recovery discarding state %d\\n\","</literal></expr>,
<expr><literal type="string">" YYPREFIX, *yystack.s_mark);"</literal></expr>,
<expr><literal type="string">"#endif"</literal></expr>,
<expr><literal type="string">" if (yystack.s_mark &lt;= yystack.s_base) goto yyabort;"</literal></expr>,
<expr><literal type="string">" --yystack.s_mark;"</literal></expr>,
<expr><literal type="string">" --yystack.l_mark;"</literal></expr>,
<expr><literal type="string">" }"</literal></expr>,
<expr><literal type="string">" }"</literal></expr>,
<expr><literal type="string">" }"</literal></expr>,
<expr><literal type="string">" else"</literal></expr>,
<expr><literal type="string">" {"</literal></expr>,
<expr><literal type="string">" if (yychar == YYEOF) goto yyabort;"</literal></expr>,
<expr><literal type="string">"#if YYDEBUG"</literal></expr>,
<expr><literal type="string">" if (yydebug)"</literal></expr>,
<expr><literal type="string">" {"</literal></expr>,
<expr><literal type="string">" if ((yys = yyname[YYTRANSLATE(yychar)]) == NULL) yys = yyname[YYUNDFTOKEN];"</literal></expr>,
<expr><literal type="string">" printf(\"%sdebug: state %d, error recovery discards token %d (%s)\\n\","</literal></expr>,
<expr><literal type="string">" YYPREFIX, yystate, yychar, yys);"</literal></expr>,
<expr><literal type="string">" }"</literal></expr>,
<expr><literal type="string">"#endif"</literal></expr>,
<expr><literal type="string">" yychar = YYEMPTY;"</literal></expr>,
<expr><literal type="string">" goto yyloop;"</literal></expr>,
<expr><literal type="string">" }"</literal></expr>,
<expr><literal type="string">""</literal></expr>,
<expr><literal type="string">"yyreduce:"</literal></expr>,
<expr><literal type="string">"#if YYDEBUG"</literal></expr>,
<expr><literal type="string">" if (yydebug)"</literal></expr>,
<expr><literal type="string">" printf(\"%sdebug: state %d, reducing by rule %d (%s)\\n\","</literal></expr>,
<expr><literal type="string">" YYPREFIX, yystate, yyn, yyrule[yyn]);"</literal></expr>,
<expr><literal type="string">"#endif"</literal></expr>,
<expr><literal type="string">" yym = yylen[yyn];"</literal></expr>,
<expr><literal type="string">" if (yym &gt; 0)"</literal></expr>,
<expr><literal type="string">" yyval = yystack.l_mark[1-yym];"</literal></expr>,
<expr><literal type="string">" else"</literal></expr>,
<expr><literal type="string">" memset(&amp;yyval, 0, sizeof yyval);"</literal></expr>,
<expr><literal type="string">""</literal></expr>,
<expr><literal type="string">" switch (yyn)"</literal></expr>,
<expr><literal type="string">" {"</literal></expr>,
<expr><literal type="number">0</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>trailer</name><index>[]</index></name> <init>=
<expr><block>{
<expr><literal type="string">" }"</literal></expr>,
<expr><literal type="string">" yystack.s_mark -= yym;"</literal></expr>,
<expr><literal type="string">" yystate = *yystack.s_mark;"</literal></expr>,
<expr><literal type="string">" yystack.l_mark -= yym;"</literal></expr>,
<expr><literal type="string">" yym = yylhs[yyn];"</literal></expr>,
<expr><literal type="string">" if (yystate == 0 &amp;&amp; yym == 0)"</literal></expr>,
<expr><literal type="string">" {"</literal></expr>,
<expr><literal type="string">"#if YYDEBUG"</literal></expr>,
<expr><literal type="string">" if (yydebug)"</literal></expr>,
<expr><literal type="string">" printf(\"%sdebug: after reduction, shifting from state 0 to\\"</literal></expr>,
<expr><literal type="string">" state %d\\n\", YYPREFIX, YYFINAL);"</literal></expr>,
<expr><literal type="string">"#endif"</literal></expr>,
<expr><literal type="string">" yystate = YYFINAL;"</literal></expr>,
<expr><literal type="string">" *++yystack.s_mark = YYFINAL;"</literal></expr>,
<expr><literal type="string">" *++yystack.l_mark = yyval;"</literal></expr>,
<expr><literal type="string">" if (yychar &lt; 0)"</literal></expr>,
<expr><literal type="string">" {"</literal></expr>,
<expr><literal type="string">" yychar = YYLEX;"</literal></expr>,
<expr><literal type="string">" if (yychar &lt; 0) yychar = YYEOF;"</literal></expr>,
<expr><literal type="string">"#if YYDEBUG"</literal></expr>,
<expr><literal type="string">" if (yydebug)"</literal></expr>,
<expr><literal type="string">" {"</literal></expr>,
<expr><literal type="string">" if ((yys = yyname[YYTRANSLATE(yychar)]) == NULL) yys = yyname[YYUNDFTOKEN];"</literal></expr>,
<expr><literal type="string">" printf(\"%sdebug: state %d, reading %d (%s)\\n\","</literal></expr>,
<expr><literal type="string">" YYPREFIX, YYFINAL, yychar, yys);"</literal></expr>,
<expr><literal type="string">" }"</literal></expr>,
<expr><literal type="string">"#endif"</literal></expr>,
<expr><literal type="string">" }"</literal></expr>,
<expr><literal type="string">" if (yychar == YYEOF) goto yyaccept;"</literal></expr>,
<expr><literal type="string">" goto yyloop;"</literal></expr>,
<expr><literal type="string">" }"</literal></expr>,
<expr><literal type="string">" if (((yyn = yygindex[yym]) != 0) &amp;&amp; (yyn += yystate) &gt;= 0 &amp;&amp;"</literal></expr>,
<expr><literal type="string">" yyn &lt;= YYTABLESIZE &amp;&amp; yycheck[yyn] == (YYINT) yystate)"</literal></expr>,
<expr><literal type="string">" yystate = yytable[yyn];"</literal></expr>,
<expr><literal type="string">" else"</literal></expr>,
<expr><literal type="string">" yystate = yydgoto[yym];"</literal></expr>,
<expr><literal type="string">"#if YYDEBUG"</literal></expr>,
<expr><literal type="string">" if (yydebug)"</literal></expr>,
<expr><literal type="string">" printf(\"%sdebug: after reduction, shifting from state %d \\"</literal></expr>,
<expr><literal type="string">"to state %d\\n\", YYPREFIX, *yystack.s_mark, yystate);"</literal></expr>,
<expr><literal type="string">"#endif"</literal></expr>,
<expr><literal type="string">" if (yystack.s_mark &gt;= yystack.s_last &amp;&amp; yygrowstack(&amp;yystack) == YYENOMEM) goto yyoverflow;"</literal></expr>,
<expr><literal type="string">" *++yystack.s_mark = (YYINT) yystate;"</literal></expr>,
<expr><literal type="string">" *++yystack.l_mark = yyval;"</literal></expr>,
<expr><literal type="string">" goto yyloop;"</literal></expr>,
<expr><literal type="string">""</literal></expr>,
<expr><literal type="string">"yyoverflow:"</literal></expr>,
<expr><literal type="string">" YYERROR_CALL(\"yacc stack overflow\");"</literal></expr>,
<expr><literal type="string">""</literal></expr>,
<expr><literal type="string">"yyabort:"</literal></expr>,
<expr><literal type="string">" yyfreestack(&amp;yystack);"</literal></expr>,
<expr><literal type="string">" return (1);"</literal></expr>,
<expr><literal type="string">""</literal></expr>,
<expr><literal type="string">"yyaccept:"</literal></expr>,
<expr><literal type="string">" yyfreestack(&amp;yystack);"</literal></expr>,
<expr><literal type="string">" return (0);"</literal></expr>,
<expr><literal type="string">"}"</literal></expr>,
<expr><literal type="number">0</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>void</name></type>
<name>write_section</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type> <name>fp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>section</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>s</name> <operator>=</operator> <name><name>section</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>fp</name> <operator>==</operator> <name>code_file</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>outline</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>
</unit>
