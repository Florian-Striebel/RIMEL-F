<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/byacc/lalr.c">

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"defs.h"</cpp:file></cpp:include>

<typedef>typedef <type><struct>struct <name>shorts</name>
<block>{
<decl_stmt><decl><type><name><name>struct</name> <name>shorts</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value_t</name></type> <name>value</name></decl>;</decl_stmt>
}</block></struct></type>
<name>shorts</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>Value_t</name></type> <name>map_goto</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>symbol</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Value_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>transpose</name><parameter_list>(<parameter><decl><type><name>Value_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>R</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>add_lookback_edge</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>stateno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ruleno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>gotono</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>build_relations</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>compute_FOLLOWS</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>compute_lookaheads</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>digraph</name><parameter_list>(<parameter><decl><type><name>Value_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>relation</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>initialize_F</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>initialize_LA</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_accessing_symbol</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_goto_map</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_maxrhs</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_reduction_table</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_shift_table</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_state_table</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>traverse</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>tokensetsize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value_t</name> <modifier>*</modifier></type><name>lookaheads</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value_t</name> <modifier>*</modifier></type><name>LAruleno</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <modifier>*</modifier></type><name>LA</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value_t</name> <modifier>*</modifier></type><name>accessing_symbol</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>core</name> <modifier>*</modifier><modifier>*</modifier></type><name>state_table</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>shifts</name> <modifier>*</modifier><modifier>*</modifier></type><name>shift_table</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>reductions</name> <modifier>*</modifier><modifier>*</modifier></type><name>reduction_table</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value_t</name> <modifier>*</modifier></type><name>goto_base</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value_t</name> <modifier>*</modifier></type><name>goto_map</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value_t</name> <modifier>*</modifier></type><name>from_state</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value_t</name> <modifier>*</modifier></type><name>to_state</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>Value_t</name></type> <name>infinity</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>maxrhs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>ngotos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <modifier>*</modifier></type><name>F</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Value_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>includes</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>shorts</name> <modifier>*</modifier><modifier>*</modifier></type><name>lookback</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Value_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>R</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Value_t</name> <modifier>*</modifier></type><name>INDEX</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Value_t</name> <modifier>*</modifier></type><name>VERTICES</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Value_t</name></type> <name>top</name></decl>;</decl_stmt>

<function><type><name>void</name></type>
<name>lalr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>tokensetsize</name> <operator>=</operator> <call><name>WORDSIZE</name><argument_list>(<argument><expr><name>ntokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_state_table</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>set_accessing_symbol</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>set_shift_table</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>set_reduction_table</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>set_maxrhs</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>initialize_LA</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>set_goto_map</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>initialize_F</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>build_relations</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compute_FOLLOWS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compute_lookaheads</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_state_table</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>core</name> <modifier>*</modifier></type><name>sp</name></decl>;</decl_stmt>

<expr_stmt><expr><name>state_table</name> <operator>=</operator> <call><name>NEW2</name><argument_list>(<argument><expr><name>nstates</name></expr></argument>, <argument><expr><name>core</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>sp</name> <operator>=</operator> <name>first_state</name></expr>;</init> <condition><expr><name>sp</name></expr>;</condition> <incr><expr><name>sp</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>state_table</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>number</name></name></expr>]</index></name> <operator>=</operator> <name>sp</name></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_accessing_symbol</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>core</name> <modifier>*</modifier></type><name>sp</name></decl>;</decl_stmt>

<expr_stmt><expr><name>accessing_symbol</name> <operator>=</operator> <call><name>NEW2</name><argument_list>(<argument><expr><name>nstates</name></expr></argument>, <argument><expr><name>Value_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>sp</name> <operator>=</operator> <name>first_state</name></expr>;</init> <condition><expr><name>sp</name></expr>;</condition> <incr><expr><name>sp</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>accessing_symbol</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>number</name></name></expr>]</index></name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>accessing_symbol</name></name></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_shift_table</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>shifts</name> <modifier>*</modifier></type><name>sp</name></decl>;</decl_stmt>

<expr_stmt><expr><name>shift_table</name> <operator>=</operator> <call><name>NEW2</name><argument_list>(<argument><expr><name>nstates</name></expr></argument>, <argument><expr><name>shifts</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>sp</name> <operator>=</operator> <name>first_shift</name></expr>;</init> <condition><expr><name>sp</name></expr>;</condition> <incr><expr><name>sp</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>shift_table</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>number</name></name></expr>]</index></name> <operator>=</operator> <name>sp</name></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_reduction_table</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>reductions</name> <modifier>*</modifier></type><name>rp</name></decl>;</decl_stmt>

<expr_stmt><expr><name>reduction_table</name> <operator>=</operator> <call><name>NEW2</name><argument_list>(<argument><expr><name>nstates</name></expr></argument>, <argument><expr><name>reductions</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>rp</name> <operator>=</operator> <name>first_reduction</name></expr>;</init> <condition><expr><name>rp</name></expr>;</condition> <incr><expr><name>rp</name> <operator>=</operator> <name><name>rp</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>reduction_table</name><index>[<expr><name><name>rp</name><operator>-&gt;</operator><name>number</name></name></expr>]</index></name> <operator>=</operator> <name>rp</name></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_maxrhs</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Value_t</name> <modifier>*</modifier></type><name>itemp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value_t</name> <modifier>*</modifier></type><name>item_end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>length</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>max</name></decl>;</decl_stmt>

<expr_stmt><expr><name>length</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>max</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>item_end</name> <operator>=</operator> <name>ritem</name> <operator>+</operator> <name>nitems</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>itemp</name> <operator>=</operator> <name>ritem</name></expr>;</init> <condition><expr><name>itemp</name> <operator>&lt;</operator> <name>item_end</name></expr>;</condition> <incr><expr><name>itemp</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>itemp</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>length</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>length</name> <operator>&gt;</operator> <name>max</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>max</name> <operator>=</operator> <name>length</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>length</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>maxrhs</name> <operator>=</operator> <name>max</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>initialize_LA</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>reductions</name> <modifier>*</modifier></type><name>rp</name></decl>;</decl_stmt>

<expr_stmt><expr><name>lookaheads</name> <operator>=</operator> <call><name>NEW2</name><argument_list>(<argument><expr><name>nstates</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>Value_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nstates</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name><name>lookaheads</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Value_t</name><operator>)</operator><name>k</name></expr>;</expr_stmt>
<expr_stmt><expr><name>rp</name> <operator>=</operator> <name><name>reduction_table</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>rp</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>k</name> <operator>+=</operator> <name><name>rp</name><operator>-&gt;</operator><name>nreds</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>lookaheads</name><index>[<expr><name>nstates</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Value_t</name><operator>)</operator><name>k</name></expr>;</expr_stmt>

<expr_stmt><expr><name>LA</name> <operator>=</operator> <call><name>NEW2</name><argument_list>(<argument><expr><name>k</name> <operator>*</operator> <name>tokensetsize</name></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>LAruleno</name> <operator>=</operator> <call><name>NEW2</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>Value_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lookback</name> <operator>=</operator> <call><name>NEW2</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>shorts</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nstates</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>rp</name> <operator>=</operator> <name><name>reduction_table</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>rp</name></expr>)</condition>
<block>{<block_content>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>rp</name><operator>-&gt;</operator><name>nreds</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name><name>LAruleno</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name><name>rp</name><operator>-&gt;</operator><name>rules</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>k</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_goto_map</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>shifts</name> <modifier>*</modifier></type><name>sp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>symbol</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value_t</name> <modifier>*</modifier></type><name>temp_base</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value_t</name> <modifier>*</modifier></type><name>temp_map</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value_t</name></type> <name>state2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value_t</name></type> <name>state1</name></decl>;</decl_stmt>

<expr_stmt><expr><name>goto_base</name> <operator>=</operator> <call><name>NEW2</name><argument_list>(<argument><expr><name>nvars</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>Value_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>temp_base</name> <operator>=</operator> <call><name>NEW2</name><argument_list>(<argument><expr><name>nvars</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>Value_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>goto_map</name> <operator>=</operator> <name>goto_base</name> <operator>-</operator> <name>ntokens</name></expr>;</expr_stmt>
<expr_stmt><expr><name>temp_map</name> <operator>=</operator> <name>temp_base</name> <operator>-</operator> <name>ntokens</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ngotos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>sp</name> <operator>=</operator> <name>first_shift</name></expr>;</init> <condition><expr><name>sp</name></expr>;</condition> <incr><expr><name>sp</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
<block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>nshifts</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>symbol</name> <operator>=</operator> <name><name>accessing_symbol</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>shift</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ISTOKEN</name><argument_list>(<argument><expr><name>symbol</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ngotos</name> <operator>==</operator> <name>MAXYYINT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"too many gotos"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ngotos</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>goto_map</name><index>[<expr><name>symbol</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>

<expr_stmt><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>ntokens</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nsyms</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name><name>temp_map</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Value_t</name><operator>)</operator><name>k</name></expr>;</expr_stmt>
<expr_stmt><expr><name>k</name> <operator>+=</operator> <name><name>goto_map</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>ntokens</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nsyms</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>goto_map</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>temp_map</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><name><name>goto_map</name><index>[<expr><name>nsyms</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Value_t</name><operator>)</operator><name>ngotos</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>temp_map</name><index>[<expr><name>nsyms</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Value_t</name><operator>)</operator><name>ngotos</name></expr>;</expr_stmt>

<expr_stmt><expr><name>from_state</name> <operator>=</operator> <call><name>NEW2</name><argument_list>(<argument><expr><name>ngotos</name></expr></argument>, <argument><expr><name>Value_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>to_state</name> <operator>=</operator> <call><name>NEW2</name><argument_list>(<argument><expr><name>ngotos</name></expr></argument>, <argument><expr><name>Value_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>sp</name> <operator>=</operator> <name>first_shift</name></expr>;</init> <condition><expr><name>sp</name></expr>;</condition> <incr><expr><name>sp</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>state1</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>number</name></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>nshifts</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>state2</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>shift</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>symbol</name> <operator>=</operator> <name><name>accessing_symbol</name><index>[<expr><name>state2</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ISTOKEN</name><argument_list>(<argument><expr><name>symbol</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>k</name> <operator>=</operator> <name><name>temp_map</name><index>[<expr><name>symbol</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>from_state</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>state1</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>to_state</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>state2</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>

<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>temp_base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>Value_t</name></type>
<name>map_goto</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>symbol</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>high</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>low</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>middle</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>s</name></decl>;</decl_stmt>

<expr_stmt><expr><name>low</name> <operator>=</operator> <name><name>goto_map</name><index>[<expr><name>symbol</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>high</name> <operator>=</operator> <name><name>goto_map</name><index>[<expr><name>symbol</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
<block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>low</name> <operator>&lt;=</operator> <name>high</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>middle</name> <operator>=</operator> <operator>(</operator><name>low</name> <operator>+</operator> <name>high</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>from_state</name><index>[<expr><name>middle</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <name>state</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>Value_t</name><operator>)</operator><operator>(</operator><name>middle</name><operator>)</operator></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>s</name> <operator>&lt;</operator> <name>state</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>low</name> <operator>=</operator> <name>middle</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>high</name> <operator>=</operator> <name>middle</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>initialize_F</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>shifts</name> <modifier>*</modifier></type><name>sp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value_t</name> <modifier>*</modifier></type><name>edge</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <modifier>*</modifier></type><name>rowp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value_t</name> <modifier>*</modifier></type><name>rp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>reads</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nedges</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>stateno</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>symbol</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nwords</name></decl>;</decl_stmt>

<expr_stmt><expr><name>nwords</name> <operator>=</operator> <name>ngotos</name> <operator>*</operator> <name>tokensetsize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>F</name> <operator>=</operator> <call><name>NEW2</name><argument_list>(<argument><expr><name>nwords</name></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>reads</name> <operator>=</operator> <call><name>NEW2</name><argument_list>(<argument><expr><name>ngotos</name></expr></argument>, <argument><expr><name>Value_t</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>edge</name> <operator>=</operator> <call><name>NEW2</name><argument_list>(<argument><expr><name>ngotos</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>Value_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nedges</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>rowp</name> <operator>=</operator> <name>F</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ngotos</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>stateno</name> <operator>=</operator> <name><name>to_state</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>sp</name> <operator>=</operator> <name><name>shift_table</name><index>[<expr><name>stateno</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>sp</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>k</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>nshifts</name></name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>k</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>symbol</name> <operator>=</operator> <name><name>accessing_symbol</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>shift</name><index>[<expr><name>j</name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ISVAR</name><argument_list>(<argument><expr><name>symbol</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>SETBIT</name><argument_list>(<argument><expr><name>rowp</name></expr></argument>, <argument><expr><name>symbol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<for>for <control>(<init>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>k</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>symbol</name> <operator>=</operator> <name><name>accessing_symbol</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>shift</name><index>[<expr><name>j</name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>nullable</name><index>[<expr><name>symbol</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>edge</name><index>[<expr><name>nedges</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>map_goto</name><argument_list>(<argument><expr><name>stateno</name></expr></argument>, <argument><expr><name>symbol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>nedges</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>reads</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>rp</name> <operator>=</operator> <call><name>NEW2</name><argument_list>(<argument><expr><name>nedges</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>Value_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nedges</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>rp</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>edge</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><name><name>rp</name><index>[<expr><name>nedges</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>nedges</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>rowp</name> <operator>+=</operator> <name>tokensetsize</name></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>SETBIT</name><argument_list>(<argument><expr><name>F</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>digraph</name><argument_list>(<argument><expr><name>reads</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ngotos</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>reads</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name><name>reads</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>reads</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>edge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>build_relations</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value_t</name> <modifier>*</modifier></type><name>rulep</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value_t</name> <modifier>*</modifier></type><name>rp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>shifts</name> <modifier>*</modifier></type><name>sp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>length</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nedges</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>done_flag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value_t</name></type> <name>state1</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value_t</name></type> <name>stateno</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>symbol1</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>symbol2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value_t</name> <modifier>*</modifier></type><name>shortp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value_t</name> <modifier>*</modifier></type><name>edge</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value_t</name> <modifier>*</modifier></type><name>states</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>new_includes</name></decl>;</decl_stmt>

<expr_stmt><expr><name>includes</name> <operator>=</operator> <call><name>NEW2</name><argument_list>(<argument><expr><name>ngotos</name></expr></argument>, <argument><expr><name>Value_t</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>edge</name> <operator>=</operator> <call><name>NEW2</name><argument_list>(<argument><expr><name>ngotos</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>Value_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>states</name> <operator>=</operator> <call><name>NEW2</name><argument_list>(<argument><expr><name>maxrhs</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>Value_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ngotos</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>nedges</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>state1</name> <operator>=</operator> <name><name>from_state</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>symbol1</name> <operator>=</operator> <name><name>accessing_symbol</name><index>[<expr><name><name>to_state</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>rulep</name> <operator>=</operator> <name><name>derives</name><index>[<expr><name>symbol1</name></expr>]</index></name></expr>;</init> <condition><expr><operator>*</operator><name>rulep</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>rulep</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>length</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>states</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>state1</name></expr>;</expr_stmt>
<expr_stmt><expr><name>stateno</name> <operator>=</operator> <name>state1</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>rp</name> <operator>=</operator> <name>ritem</name> <operator>+</operator> <name><name>rrhs</name><index>[<expr><operator>*</operator><name>rulep</name></expr>]</index></name></expr>;</init> <condition><expr><operator>*</operator><name>rp</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>rp</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>symbol2</name> <operator>=</operator> <operator>*</operator><name>rp</name></expr>;</expr_stmt>
<expr_stmt><expr><name>sp</name> <operator>=</operator> <name><name>shift_table</name><index>[<expr><name>stateno</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>k</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>nshifts</name></name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>k</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>stateno</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>shift</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>accessing_symbol</name><index>[<expr><name>stateno</name></expr>]</index></name> <operator>==</operator> <name>symbol2</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name><name>states</name><index>[<expr><name>length</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>stateno</name></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>add_lookback_edge</name><argument_list>(<argument><expr><name>stateno</name></expr></argument>, <argument><expr><operator>*</operator><name>rulep</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>length</name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>done_flag</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>!</operator><name>done_flag</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>done_flag</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>rp</name><operator>--</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ISVAR</name><argument_list>(<argument><expr><operator>*</operator><name>rp</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>stateno</name> <operator>=</operator> <name><name>states</name><index>[<expr><operator>--</operator><name>length</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>edge</name><index>[<expr><name>nedges</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>map_goto</name><argument_list>(<argument><expr><name>stateno</name></expr></argument>, <argument><expr><operator>*</operator><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>nullable</name><index>[<expr><operator>*</operator><name>rp</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name>length</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>done_flag</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>nedges</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>includes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>shortp</name> <operator>=</operator> <call><name>NEW2</name><argument_list>(<argument><expr><name>nedges</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>Value_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nedges</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>shortp</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>edge</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><name><name>shortp</name><index>[<expr><name>nedges</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>new_includes</name> <operator>=</operator> <call><name>transpose</name><argument_list>(<argument><expr><name>includes</name></expr></argument>, <argument><expr><name>ngotos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ngotos</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>includes</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name><name>includes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>

<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>includes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>includes</name> <operator>=</operator> <name>new_includes</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>edge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>states</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_lookback_edge</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>stateno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ruleno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>gotono</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>found</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>shorts</name> <modifier>*</modifier></type><name>sp</name></decl>;</decl_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>lookaheads</name><index>[<expr><name>stateno</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>k</name> <operator>=</operator> <name><name>lookaheads</name><index>[<expr><name>stateno</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>found</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>!</operator><name>found</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name>k</name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>LAruleno</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>ruleno</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>found</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>i</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>sp</name> <operator>=</operator> <call><name>NEW</name><argument_list>(<argument><expr><name>shorts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>lookback</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <operator>(</operator><name>Value_t</name><operator>)</operator><name>gotono</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lookback</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>sp</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Value_t</name> <modifier>*</modifier><modifier>*</modifier></type>
<name>transpose</name><parameter_list>(<parameter><decl><type><name>Value_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>R2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Value_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>new_R</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>temp_R</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value_t</name> <modifier>*</modifier></type><name>nedges</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value_t</name> <modifier>*</modifier></type><name>sp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>

<expr_stmt><expr><name>nedges</name> <operator>=</operator> <call><name>NEW2</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>Value_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>sp</name> <operator>=</operator> <name><name>R2</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>sp</name></expr>)</condition>
<block>{<block_content>
<while>while <condition>(<expr><operator>*</operator><name>sp</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>nedges</name><index>[<expr><operator>*</operator><name>sp</name><operator>++</operator></expr>]</index></name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>new_R</name> <operator>=</operator> <call><name>NEW2</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>Value_t</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>temp_R</name> <operator>=</operator> <call><name>NEW2</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>Value_t</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>k</name> <operator>=</operator> <name><name>nedges</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>k</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>sp</name> <operator>=</operator> <call><name>NEW2</name><argument_list>(<argument><expr><name>k</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>Value_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_R</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>sp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>temp_R</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>sp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>nedges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>sp</name> <operator>=</operator> <name><name>R2</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>sp</name></expr>)</condition>
<block>{<block_content>
<while>while <condition>(<expr><operator>*</operator><name>sp</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name><name>temp_R</name><index>[<expr><operator>*</operator><name>sp</name><operator>++</operator></expr>]</index></name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>Value_t</name><operator>)</operator><name>i</name></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>temp_R</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>new_R</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>compute_FOLLOWS</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>digraph</name><argument_list>(<argument><expr><name>includes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>compute_lookaheads</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <modifier>*</modifier></type><name>fp1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>fp2</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>fp3</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>shorts</name> <modifier>*</modifier></type><name>sp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <modifier>*</modifier></type><name>rowp</name></decl>;</decl_stmt>

<expr_stmt><expr><name>rowp</name> <operator>=</operator> <name>LA</name></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>lookaheads</name><index>[<expr><name>nstates</name></expr>]</index></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>fp3</name> <operator>=</operator> <name>rowp</name> <operator>+</operator> <name>tokensetsize</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>sp</name> <operator>=</operator> <name><name>lookback</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</init> <condition><expr><name>sp</name></expr>;</condition> <incr><expr><name>sp</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>fp1</name> <operator>=</operator> <name>rowp</name></expr>;</expr_stmt>
<expr_stmt><expr><name>fp2</name> <operator>=</operator> <name>F</name> <operator>+</operator> <name>tokensetsize</name> <operator>*</operator> <name><name>sp</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>fp1</name> <operator>&lt;</operator> <name>fp3</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>fp1</name><operator>++</operator> <operator>|=</operator> <operator>*</operator><name>fp2</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></for>
<expr_stmt><expr><name>rowp</name> <operator>=</operator> <name>fp3</name></expr>;</expr_stmt>
</block_content>}</block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>sp</name> <operator>=</operator> <name><name>lookback</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</init> <condition><expr><name>sp</name></expr>;</condition> <incr><expr><name>sp</name> <operator>=</operator> <name>next</name></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for></block_content></block></for>

<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>lookback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>F</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>digraph</name><parameter_list>(<parameter><decl><type><name>Value_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>infinity</name> <operator>=</operator> <operator>(</operator><name>Value_t</name><operator>)</operator><operator>(</operator><name>ngotos</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>INDEX</name> <operator>=</operator> <call><name>NEW2</name><argument_list>(<argument><expr><name>ngotos</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>Value_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>VERTICES</name> <operator>=</operator> <call><name>NEW2</name><argument_list>(<argument><expr><name>ngotos</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>Value_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>top</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>R</name> <operator>=</operator> <name>relation</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ngotos</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>INDEX</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ngotos</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>INDEX</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>R</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>traverse</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>VERTICES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>traverse</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <modifier>*</modifier></type><name>fp1</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <modifier>*</modifier></type><name>fp2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <modifier>*</modifier></type><name>fp3</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value_t</name> <modifier>*</modifier></type><name>rp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Value_t</name></type> <name>height</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <modifier>*</modifier></type><name>base</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>VERTICES</name><index>[<expr><operator>++</operator><name>top</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Value_t</name><operator>)</operator><name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>INDEX</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>height</name> <operator>=</operator> <name>top</name></expr>;</expr_stmt>

<expr_stmt><expr><name>base</name> <operator>=</operator> <name>F</name> <operator>+</operator> <name>i</name> <operator>*</operator> <name>tokensetsize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>fp3</name> <operator>=</operator> <name>base</name> <operator>+</operator> <name>tokensetsize</name></expr>;</expr_stmt>

<expr_stmt><expr><name>rp</name> <operator>=</operator> <name><name>R</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>rp</name></expr>)</condition>
<block>{<block_content>
<while>while <condition>(<expr><operator>(</operator><name>j</name> <operator>=</operator> <operator>*</operator><name>rp</name><operator>++</operator><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>INDEX</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>traverse</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>INDEX</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name><name>INDEX</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>INDEX</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>INDEX</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>fp1</name> <operator>=</operator> <name>base</name></expr>;</expr_stmt>
<expr_stmt><expr><name>fp2</name> <operator>=</operator> <name>F</name> <operator>+</operator> <name>j</name> <operator>*</operator> <name>tokensetsize</name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>fp1</name> <operator>&lt;</operator> <name>fp3</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>fp1</name><operator>++</operator> <operator>|=</operator> <operator>*</operator><name>fp2</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></while>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>INDEX</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>height</name></expr>)</condition>
<block>{<block_content>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
<block>{<block_content>
<expr_stmt><expr><name>j</name> <operator>=</operator> <name><name>VERTICES</name><index>[<expr><name>top</name><operator>--</operator></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>INDEX</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>infinity</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>j</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>fp1</name> <operator>=</operator> <name>base</name></expr>;</expr_stmt>
<expr_stmt><expr><name>fp2</name> <operator>=</operator> <name>F</name> <operator>+</operator> <name>j</name> <operator>*</operator> <name>tokensetsize</name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>fp1</name> <operator>&lt;</operator> <name>fp3</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>fp2</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>fp1</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NO_LEAKS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>void</name></type>
<name>lalr_leaks</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>includes</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ngotos</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>includes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>DO_FREE</name><argument_list>(<argument><expr><name>includes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
