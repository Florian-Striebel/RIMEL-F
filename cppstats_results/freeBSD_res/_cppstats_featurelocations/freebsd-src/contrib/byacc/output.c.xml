<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/byacc/output.c">

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"defs.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>StaticOrR</name></cpp:macro> <cpp:value>(rflag ? "" : "static ")</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CountLine</name><parameter_list>(<parameter><type><name>fp</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(!rflag || ((fp) == code_file))</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYBTYACC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PER_STATE</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PER_STATE</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>nvectors</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>nentries</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Value_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>froms</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Value_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>tos</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYBTYACC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>Value_t</name> <modifier>*</modifier></type><name>conflicts</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Value_t</name></type> <name>nconflicts</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <name>Value_t</name> <modifier>*</modifier></type><name>tally</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Value_t</name> <modifier>*</modifier></type><name>width</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Value_t</name> <modifier>*</modifier></type><name>state_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Value_t</name> <modifier>*</modifier></type><name>order</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Value_t</name> <modifier>*</modifier></type><name>base</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Value_t</name> <modifier>*</modifier></type><name>pos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>maxtable</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Value_t</name> <modifier>*</modifier></type><name>table</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Value_t</name> <modifier>*</modifier></type><name>check</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>lowzero</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>long</name></type> <name>high</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>putc_code</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type> <name>fp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>c</name> <operator>==</operator> <literal type="char">'\n'</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>fp</name> <operator>==</operator> <name>code_file</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>outline</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>putl_code</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type> <name>fp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>fp</name> <operator>==</operator> <name>code_file</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>outline</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>puts_code</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type> <name>fp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>puts_param_types</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type> <name>fp</name></decl></parameter>, <parameter><decl><type><name>param</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>more</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>param</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>list</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>list</name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>len_type</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%s%s%s%s%s"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>type</name></name></expr></argument>,
<argument><expr><operator>(</operator><ternary><condition><expr><operator>(</operator><operator>(</operator><name>len_type</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>type</name><index>[<expr><name>len_type</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal><operator>)</operator><operator>)</operator></expr>
?</condition><then> <expr><literal type="string">""</literal></expr>
</then><else>: <expr><literal type="string">" "</literal></expr></else></ternary><operator>)</operator></expr></argument>,
<argument><expr><name><name>p</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>type2</name></name></expr></argument>,
<argument><expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>more</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">", "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>more</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"void"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>puts_param_names</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type> <name>fp</name></decl></parameter>, <parameter><decl><type><name>param</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>more</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>param</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>list</name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
<argument><expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>more</name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">", "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>write_code_lineno</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type> <name>fp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lflag</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>fp</name> <operator>==</operator> <name>code_file</name><operator>)</operator></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>outline</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>line_format</name></expr></argument>, <argument><expr><name>outline</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>code_file_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>write_input_lineno</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lflag</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>outline</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>, <argument><expr><name>line_format</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>input_file_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>define_prefixed</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type> <name>fp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>bump_line</name> <init>= <expr><call><name>CountLine</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>bump_line</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>outline</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>bump_line</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>outline</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#ifndef %s\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>bump_line</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>outline</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#define %-10s %s%s\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>symbol_prefix</name></expr></argument>, <argument><expr><name>name</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>bump_line</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>outline</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#endif /* %s */\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>output_prefix</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type> <name>fp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>symbol_prefix</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>symbol_prefix</name> <operator>=</operator> <literal type="string">"yy"</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><call><name>define_prefixed</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"yyparse"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>define_prefixed</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"yylex"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>define_prefixed</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"yyerror"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>define_prefixed</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"yychar"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>define_prefixed</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"yyval"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>define_prefixed</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"yylval"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>define_prefixed</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"yydebug"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>define_prefixed</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"yynerrs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>define_prefixed</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"yyerrflag"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>define_prefixed</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"yylhs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>define_prefixed</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"yylen"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>define_prefixed</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"yydefred"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYBTYACC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>define_prefixed</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"yystos"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>define_prefixed</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"yydgoto"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>define_prefixed</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"yysindex"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>define_prefixed</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"yyrindex"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>define_prefixed</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"yygindex"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>define_prefixed</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"yytable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>define_prefixed</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"yycheck"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>define_prefixed</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"yyname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>define_prefixed</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"yyrule"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYBTYACC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>locations</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>define_prefixed</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"yyloc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>define_prefixed</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"yylloc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>putc_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#if YYBTYACC\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>define_prefixed</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"yycindex"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>define_prefixed</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"yyctable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>putc_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#endif /* YYBTYACC */\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putc_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>CountLine</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>outline</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#define YYPREFIX \"%s\"\n"</literal></expr></argument>, <argument><expr><name>symbol_prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>output_code_lines</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type> <name>fp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>code_lines</name><index>[<expr><name>cl</name></expr>]</index></name><operator>.</operator><name>lines</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>fp</name> <operator>==</operator> <name>code_file</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>outline</name> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>code_lines</name><index>[<expr><name>cl</name></expr>]</index></name><operator>.</operator><name>num</name></expr>;</expr_stmt>
<expr_stmt><expr><name>outline</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"/* %%code \"%s\" block start */\n"</literal></expr></argument>, <argument><expr><name><name>code_lines</name><index>[<expr><name>cl</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name><name>code_lines</name><index>[<expr><name>cl</name></expr>]</index></name><operator>.</operator><name>lines</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"/* %%code \"%s\" block end */\n"</literal></expr></argument>, <argument><expr><name><name>code_lines</name><index>[<expr><name>cl</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fp</name> <operator>==</operator> <name>code_file</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>write_code_lineno</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>output_newline</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rflag</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>outline</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>output_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>output_line</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>output_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>output_newline</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>output_int</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>output_file</name></expr></argument>, <argument><expr><literal type="string">"%5d,"</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>start_int_table</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>need</name> <init>= <expr><literal type="number">34</literal> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><call><name>strlen</name><argument_list>(<argument><expr><name>symbol_prefix</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>need</name> <operator>&lt;</operator> <literal type="number">6</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>need</name> <operator>=</operator> <literal type="number">6</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>output_file</name></expr></argument>,
<argument><expr><literal type="string">"%sconst YYINT %s%s[] = {%*d,"</literal></expr></argument>,
<argument><expr><name>StaticOrR</name></expr></argument>, <argument><expr><name>symbol_prefix</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>need</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>start_str_table</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>output_file</name></expr></argument>,
<argument><expr><literal type="string">"%sconst char *const %s%s[] = {"</literal></expr></argument>,
<argument><expr><name>StaticOrR</name></expr></argument>, <argument><expr><name>symbol_prefix</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>output_newline</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>end_table</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>output_newline</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>output_line</name><argument_list>(<argument><expr><literal type="string">"};"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>output_stype</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type> <name>fp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>unionized</name> <operator>&amp;&amp;</operator> <name>ntags</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>putc_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#if "</literal>
<literal type="string">"! defined(YYSTYPE) &amp;&amp; "</literal>
<literal type="string">"! defined(YYSTYPE_IS_DECLARED)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"/* Default: YYSTYPE is the semantic value type. */\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"typedef int YYSTYPE;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#define YYSTYPE_IS_DECLARED 1\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#endif\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYBTYACC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>output_ltype</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type> <name>fp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>putc_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#if ! defined YYLTYPE &amp;&amp; ! defined YYLTYPE_IS_DECLARED\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"/* Default: YYLTYPE is the text position type. */\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"typedef struct YYLTYPE\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"{\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">" int first_line;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">" int first_column;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">" int last_line;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">" int last_column;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">" unsigned source;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"} YYLTYPE;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#define YYLTYPE_IS_DECLARED 1\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#endif\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#define YYRHSLOC(rhs, k) ((rhs)[k])\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>output_YYINT_typedef</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type> <name>fp</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>CountLine</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>outline</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"typedef %s YYINT;\n"</literal></expr></argument>, <argument><expr><call><name>CONCAT1</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>YYINT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>output_rule_data</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>output_YYINT_typedef</name><argument_list>(<argument><expr><name>output_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>start_int_table</name><argument_list>(<argument><expr><literal type="string">"lhs"</literal></expr></argument>, <argument><expr><name><name>symbol_value</name><index>[<expr><name>start_symbol</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">3</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nrules</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;=</operator> <literal type="number">10</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>output_newline</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>j</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>output_int</name><argument_list>(<argument><expr><name><name>symbol_value</name><index>[<expr><name><name>rlhs</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>end_table</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>start_int_table</name><argument_list>(<argument><expr><literal type="string">"len"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">3</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nrules</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;=</operator> <literal type="number">10</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>output_newline</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>output_int</name><argument_list>(<argument><expr><name><name>rrhs</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>rrhs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>end_table</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>output_yydefred</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>start_int_table</name><argument_list>(<argument><expr><literal type="string">"defred"</literal></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name><name>defred</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> ?</condition><then> <expr><name><name>defred</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nstates</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&lt;</operator> <literal type="number">10</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>j</name></expr>;</expr_stmt></block_content></block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><call><name>output_newline</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>output_int</name><argument_list>(<argument><expr><operator>(</operator><ternary><condition><expr><name><name>defred</name><index>[<expr><name>i</name></expr>]</index></name></expr> ?</condition><then> <expr><name><name>defred</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>end_table</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYBTYACC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>output_accessing_symbols</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>translate</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>nstates</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>translate</name> <operator>=</operator> <call><name>TMALLOC</name><argument_list>(<argument><expr><name>int</name></expr></argument>, <argument><expr><name>nstates</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NO_SPACE</name><argument_list>(<argument><expr><name>translate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nstates</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>gsymb</name> <init>= <expr><name><name>accessing_symbol</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>translate</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>symbol_pval</name><index>[<expr><name>gsymb</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>output_file</name></expr></argument>,
<argument><expr><literal type="string">"#if defined(YYDESTRUCT_CALL) || defined(YYSTYPE_TOSTRING)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>start_int_table</name><argument_list>(<argument><expr><literal type="string">"stos"</literal></expr></argument>, <argument><expr><name><name>translate</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nstates</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&lt;</operator> <literal type="number">10</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>j</name></expr>;</expr_stmt></block_content></block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><call><name>output_newline</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>output_int</name><argument_list>(<argument><expr><name><name>translate</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>end_table</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>translate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>output_file</name></expr></argument>,
<argument><expr><literal type="string">"#endif /* YYDESTRUCT_CALL || YYSTYPE_TOSTRING */\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Value_t</name></type>
<name>find_conflict_base</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>cbase</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>cbase</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>+</operator> <name>cbase</name> <operator>&lt;</operator> <name>nconflicts</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>conflicts</name><index>[<expr><name>i</name> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>!=</operator> <name><name>conflicts</name><index>[<expr><name>cbase</name> <operator>+</operator> <name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>+</operator> <name>cbase</name> <operator>&gt;=</operator> <name>nconflicts</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><operator>(</operator><name>Value_t</name><operator>)</operator><name>i</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>token_actions</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value_t</name></type> <name>shiftcount</name></decl>, <decl><type ref="prev"/><name>reducecount</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYBTYACC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>Value_t</name></type> <name>conflictcount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value_t</name></type> <name>csym</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value_t</name></type> <name>cbase</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>int</name></type> <name>max</name></decl>, <decl><type ref="prev"/><name>min</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value_t</name> <modifier>*</modifier></type><name>actionrow</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>r</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>action</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<expr_stmt><expr><name>actionrow</name> <operator>=</operator> <call><name>NEW2</name><argument_list>(<argument><expr><name>PER_STATE</name> <operator>*</operator> <name>ntokens</name></expr></argument>, <argument><expr><name>Value_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nstates</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>parser</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
<block>{<block_content>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>PER_STATE</name> <operator>*</operator> <name>ntokens</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>actionrow</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><name>shiftcount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>reducecount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYBTYACC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>backtrack</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>conflictcount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>csym</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>cbase</name> <operator>=</operator> <name>nconflicts</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name><name>parser</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYBTYACC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>backtrack</name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>csym</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>csym</name> <operator>!=</operator> <name><name>p</name><operator>-&gt;</operator><name>symbol</name></name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>conflictcount</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>conflicts</name><index>[<expr><name>nconflicts</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> <operator>=</operator> <call><name>find_conflict_base</name><argument_list>(<argument><expr><name>cbase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>actionrow</name><index>[<expr><name>csym</name> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>ntokens</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Value_t</name><operator>)</operator><operator>(</operator><name>j</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <name>cbase</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>cbase</name> <operator>=</operator> <name>nconflicts</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>conflicts</name><index>[<expr><name>cbase</name></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>cbase</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>nconflicts</name> <operator>=</operator> <name>cbase</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>csym</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>suppressed</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>action_code</name></name> <operator>==</operator> <name>SHIFT</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>shiftcount</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>actionrow</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>symbol</name></name></expr>]</index></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>number</name></name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>action_code</name></name> <operator>==</operator> <name>REDUCE</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>number</name></name> <operator>!=</operator> <name><name>defred</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>reducecount</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>actionrow</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>symbol</name></name> <operator>+</operator> <name>ntokens</name></expr>]</index></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>number</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYBTYACC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if type="elseif">else if <condition>(<expr><name>backtrack</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>suppressed</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>csym</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>symbol</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>action_code</name></name> <operator>==</operator> <name>SHIFT</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>conflicts</name><index>[<expr><name>nconflicts</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>number</name></name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>action_code</name></name> <operator>==</operator> <name>REDUCE</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>number</name></name> <operator>!=</operator> <name><name>defred</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>cbase</name> <operator>==</operator> <name>nconflicts</name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>cbase</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>cbase</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>conflicts</name><index>[<expr><name>nconflicts</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>conflicts</name><index>[<expr><name>nconflicts</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Value_t</name><operator>)</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>number</name></name> <operator>-</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></for>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYBTYACC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>backtrack</name> <operator>&amp;&amp;</operator> <name>csym</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>conflictcount</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>conflicts</name><index>[<expr><name>nconflicts</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> <operator>=</operator> <call><name>find_conflict_base</name><argument_list>(<argument><expr><name>cbase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>actionrow</name><index>[<expr><name>csym</name> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>ntokens</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Value_t</name><operator>)</operator><operator>(</operator><name>j</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <name>cbase</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>cbase</name> <operator>=</operator> <name>nconflicts</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>conflicts</name><index>[<expr><name>cbase</name></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>cbase</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>nconflicts</name> <operator>=</operator> <name>cbase</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name><name>tally</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>shiftcount</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tally</name><index>[<expr><name>nstates</name> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>=</operator> <name>reducecount</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYBTYACC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>backtrack</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>tally</name><index>[<expr><literal type="number">2</literal> <operator>*</operator> <name>nstates</name> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>=</operator> <name>conflictcount</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>width</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>width</name><index>[<expr><name>nstates</name> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYBTYACC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>backtrack</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>width</name><index>[<expr><literal type="number">2</literal> <operator>*</operator> <name>nstates</name> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><name>shiftcount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>froms</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>r</name> <operator>=</operator> <call><name>NEW2</name><argument_list>(<argument><expr><name>shiftcount</name></expr></argument>, <argument><expr><name>Value_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tos</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>s</name> <operator>=</operator> <call><name>NEW2</name><argument_list>(<argument><expr><name>shiftcount</name></expr></argument>, <argument><expr><name>Value_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>min</name> <operator>=</operator> <name>MAXYYINT</name></expr>;</expr_stmt>
<expr_stmt><expr><name>max</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>ntokens</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>actionrow</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>min</name> <operator>&gt;</operator> <name><name>symbol_value</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>min</name> <operator>=</operator> <name><name>symbol_value</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>max</name> <operator>&lt;</operator> <name><name>symbol_value</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>max</name> <operator>=</operator> <name><name>symbol_value</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>r</name><operator>++</operator> <operator>=</operator> <name><name>symbol_value</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>s</name><operator>++</operator> <operator>=</operator> <name><name>actionrow</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>width</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Value_t</name><operator>)</operator><operator>(</operator><name>max</name> <operator>-</operator> <name>min</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>reducecount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>froms</name><index>[<expr><name>nstates</name> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>=</operator> <name>r</name> <operator>=</operator> <call><name>NEW2</name><argument_list>(<argument><expr><name>reducecount</name></expr></argument>, <argument><expr><name>Value_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tos</name><index>[<expr><name>nstates</name> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>=</operator> <name>s</name> <operator>=</operator> <call><name>NEW2</name><argument_list>(<argument><expr><name>reducecount</name></expr></argument>, <argument><expr><name>Value_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>min</name> <operator>=</operator> <name>MAXYYINT</name></expr>;</expr_stmt>
<expr_stmt><expr><name>max</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>ntokens</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>actionrow</name><index>[<expr><name>ntokens</name> <operator>+</operator> <name>j</name></expr>]</index></name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>min</name> <operator>&gt;</operator> <name><name>symbol_value</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>min</name> <operator>=</operator> <name><name>symbol_value</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>max</name> <operator>&lt;</operator> <name><name>symbol_value</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>max</name> <operator>=</operator> <name><name>symbol_value</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>r</name><operator>++</operator> <operator>=</operator> <name><name>symbol_value</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>s</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>Value_t</name><operator>)</operator><operator>(</operator><name><name>actionrow</name><index>[<expr><name>ntokens</name> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>-</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>width</name><index>[<expr><name>nstates</name> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Value_t</name><operator>)</operator><operator>(</operator><name>max</name> <operator>-</operator> <name>min</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYBTYACC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>backtrack</name> <operator>&amp;&amp;</operator> <name>conflictcount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>froms</name><index>[<expr><literal type="number">2</literal> <operator>*</operator> <name>nstates</name> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>=</operator> <name>r</name> <operator>=</operator> <call><name>NEW2</name><argument_list>(<argument><expr><name>conflictcount</name></expr></argument>, <argument><expr><name>Value_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tos</name><index>[<expr><literal type="number">2</literal> <operator>*</operator> <name>nstates</name> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>=</operator> <name>s</name> <operator>=</operator> <call><name>NEW2</name><argument_list>(<argument><expr><name>conflictcount</name></expr></argument>, <argument><expr><name>Value_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>min</name> <operator>=</operator> <name>MAXYYINT</name></expr>;</expr_stmt>
<expr_stmt><expr><name>max</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>ntokens</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>actionrow</name><index>[<expr><literal type="number">2</literal> <operator>*</operator> <name>ntokens</name> <operator>+</operator> <name>j</name></expr>]</index></name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>min</name> <operator>&gt;</operator> <name><name>symbol_value</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>min</name> <operator>=</operator> <name><name>symbol_value</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>max</name> <operator>&lt;</operator> <name><name>symbol_value</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>max</name> <operator>=</operator> <name><name>symbol_value</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>r</name><operator>++</operator> <operator>=</operator> <name><name>symbol_value</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>s</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>Value_t</name><operator>)</operator><operator>(</operator><name><name>actionrow</name><index>[<expr><literal type="number">2</literal> <operator>*</operator> <name>ntokens</name> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>width</name><index>[<expr><literal type="number">2</literal> <operator>*</operator> <name>nstates</name> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Value_t</name><operator>)</operator><operator>(</operator><name>max</name> <operator>-</operator> <name>min</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>actionrow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>default_goto</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>symbol</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>m</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>default_state</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>max</name></decl>;</decl_stmt>

<expr_stmt><expr><name>m</name> <operator>=</operator> <name><name>goto_map</name><index>[<expr><name>symbol</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>goto_map</name><index>[<expr><name>symbol</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>m</name> <operator>==</operator> <name>n</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nstates</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>state_count</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>m</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>state_count</name><index>[<expr><name><name>to_state</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><name>max</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>default_state</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nstates</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>state_count</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name>max</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>max</name> <operator>=</operator> <name><name>state_count</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>default_state</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<return>return <expr><operator>(</operator><name>default_state</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>save_column</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>symbol</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>default_state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>m</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value_t</name> <modifier>*</modifier></type><name>sp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value_t</name> <modifier>*</modifier></type><name>sp1</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value_t</name> <modifier>*</modifier></type><name>sp2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value_t</name></type> <name>count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>symno</name></decl>;</decl_stmt>

<expr_stmt><expr><name>m</name> <operator>=</operator> <name><name>goto_map</name><index>[<expr><name>symbol</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>goto_map</name><index>[<expr><name>symbol</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>m</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>to_state</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>default_state</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>count</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>symno</name> <operator>=</operator> <name><name>symbol_value</name><index>[<expr><name>symbol</name></expr>]</index></name> <operator>+</operator> <name>PER_STATE</name> <operator>*</operator> <name>nstates</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>froms</name><index>[<expr><name>symno</name></expr>]</index></name> <operator>=</operator> <name>sp1</name> <operator>=</operator> <name>sp</name> <operator>=</operator> <call><name>NEW2</name><argument_list>(<argument><expr><name>count</name></expr></argument>, <argument><expr><name>Value_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tos</name><index>[<expr><name>symno</name></expr>]</index></name> <operator>=</operator> <name>sp2</name> <operator>=</operator> <call><name>NEW2</name><argument_list>(<argument><expr><name>count</name></expr></argument>, <argument><expr><name>Value_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>m</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>to_state</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>default_state</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>sp1</name><operator>++</operator> <operator>=</operator> <name><name>from_state</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>sp2</name><operator>++</operator> <operator>=</operator> <name><name>to_state</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name><name>tally</name><index>[<expr><name>symno</name></expr>]</index></name> <operator>=</operator> <name>count</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>width</name><index>[<expr><name>symno</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Value_t</name><operator>)</operator><operator>(</operator><name><name>sp1</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>sp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>goto_actions</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>

<expr_stmt><expr><name>state_count</name> <operator>=</operator> <call><name>NEW2</name><argument_list>(<argument><expr><name>nstates</name></expr></argument>, <argument><expr><name>Value_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>default_goto</name><argument_list>(<argument><expr><name>start_symbol</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>start_int_table</name><argument_list>(<argument><expr><literal type="string">"dgoto"</literal></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>save_column</name><argument_list>(<argument><expr><name>start_symbol</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>start_symbol</name> <operator>+</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nsyms</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;=</operator> <literal type="number">10</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>output_newline</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>j</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>default_goto</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>output_int</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>save_column</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>end_table</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>state_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>sort_actions</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Value_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>w</name></decl>;</decl_stmt>

<expr_stmt><expr><name>order</name> <operator>=</operator> <call><name>NEW2</name><argument_list>(<argument><expr><name>nvectors</name></expr></argument>, <argument><expr><name>Value_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nentries</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nvectors</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>tally</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>t</name> <operator>=</operator> <name><name>tally</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>width</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> <operator>=</operator> <name>nentries</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><name>j</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>width</name><index>[<expr><name><name>order</name><index>[<expr><name>j</name></expr>]</index></name></expr>]</index></name> <operator>&lt;</operator> <name>w</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>j</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>

<while>while <condition>(<expr><name>j</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>width</name><index>[<expr><name><name>order</name><index>[<expr><name>j</name></expr>]</index></name></expr>]</index></name> <operator>==</operator> <name>w</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>tally</name><index>[<expr><name><name>order</name><index>[<expr><name>j</name></expr>]</index></name></expr>]</index></name> <operator>&lt;</operator> <name>t</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>j</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>

<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <name>nentries</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>k</name> <operator>&gt;</operator> <name>j</name></expr>;</condition> <incr><expr><name>k</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>order</name><index>[<expr><name>k</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>order</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><name><name>order</name><index>[<expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name>nentries</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>
















<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYBTYACC</name></expr></argument>)</argument_list></call></expr></cpp:if>



<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>matching_vector</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>vector</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>w</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>match</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>prev</name></decl>;</decl_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>order</name><index>[<expr><name>vector</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>*</operator> <name>nstates</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>t</name> <operator>=</operator> <name><name>tally</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>width</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>prev</name> <operator>=</operator> <name>vector</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>prev</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>prev</name><operator>--</operator></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>j</name> <operator>=</operator> <name><name>order</name><index>[<expr><name>prev</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>width</name><index>[<expr><name>j</name></expr>]</index></name> <operator>!=</operator> <name>w</name> <operator>||</operator> <name><name>tally</name><index>[<expr><name>j</name></expr>]</index></name> <operator>!=</operator> <name>t</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>match</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>match</name> <operator>&amp;&amp;</operator> <name>k</name> <operator>&lt;</operator> <name>t</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>tos</name><index>[<expr><name>j</name></expr>]</index><index>[<expr><name>k</name></expr>]</index></name> <operator>!=</operator> <name><name>tos</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>k</name></expr>]</index></name> <operator>||</operator> <name><name>froms</name><index>[<expr><name>j</name></expr>]</index><index>[<expr><name>k</name></expr>]</index></name> <operator>!=</operator> <name><name>froms</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>k</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>match</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>match</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>j</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>

<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pack_vector</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>vector</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>, <decl><type ref="prev"/><name>l</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>loc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ok</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value_t</name> <modifier>*</modifier></type><name>from</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value_t</name> <modifier>*</modifier></type><name>to</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>newmax</name></decl>;</decl_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>order</name><index>[<expr><name>vector</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>t</name> <operator>=</operator> <name><name>tally</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>from</name> <operator>=</operator> <name><name>froms</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>to</name> <operator>=</operator> <name><name>tos</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>j</name> <operator>=</operator> <name>lowzero</name> <operator>-</operator> <name><name>from</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>t</name></expr>;</condition> <incr><expr><operator>++</operator><name>k</name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name>lowzero</name> <operator>-</operator> <name><name>from</name><index>[<expr><name>k</name></expr>]</index></name> <operator>&gt;</operator> <name>j</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>j</name> <operator>=</operator> <name>lowzero</name> <operator>-</operator> <name><name>from</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
<for>for <control>(<init>;</init><condition>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ok</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ok</name> <operator>&amp;&amp;</operator> <name>k</name> <operator>&lt;</operator> <name>t</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>loc</name> <operator>=</operator> <name>j</name> <operator>+</operator> <name><name>from</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>loc</name> <operator>&gt;=</operator> <name>maxtable</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>loc</name> <operator>&gt;=</operator> <name>MAXTABLE</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fatal</name><argument_list>(<argument><expr><literal type="string">"maximum table size exceeded"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>newmax</name> <operator>=</operator> <name>maxtable</name></expr>;</expr_stmt>
<do>do
<block>{<block_content>
<expr_stmt><expr><name>newmax</name> <operator>+=</operator> <literal type="number">200</literal></expr>;</expr_stmt>
</block_content>}</block>
while <condition>(<expr><name>newmax</name> <operator>&lt;=</operator> <name>loc</name></expr>)</condition>;</do>

<expr_stmt><expr><name>table</name> <operator>=</operator> <call><name>TREALLOC</name><argument_list>(<argument><expr><name>Value_t</name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><name>newmax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NO_SPACE</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>check</name> <operator>=</operator> <call><name>TREALLOC</name><argument_list>(<argument><expr><name>Value_t</name></expr></argument>, <argument><expr><name>check</name></expr></argument>, <argument><expr><name>newmax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NO_SPACE</name><argument_list>(<argument><expr><name>check</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>l</name> <operator>=</operator> <name>maxtable</name></expr>;</init> <condition><expr><name>l</name> <operator>&lt;</operator> <name>newmax</name></expr>;</condition> <incr><expr><operator>++</operator><name>l</name></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name><name>table</name><index>[<expr><name>l</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>check</name><index>[<expr><name>l</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>maxtable</name> <operator>=</operator> <name>newmax</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>check</name><index>[<expr><name>loc</name></expr>]</index></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ok</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ok</name> <operator>&amp;&amp;</operator> <name>k</name> <operator>&lt;</operator> <name>vector</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>pos</name><index>[<expr><name>k</name></expr>]</index></name> <operator>==</operator> <name>j</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ok</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>ok</name></expr>)</condition>
<block>{<block_content>
<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>t</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>loc</name> <operator>=</operator> <name>j</name> <operator>+</operator> <name><name>from</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>table</name><index>[<expr><name>loc</name></expr>]</index></name> <operator>=</operator> <name><name>to</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>check</name><index>[<expr><name>loc</name></expr>]</index></name> <operator>=</operator> <name><name>from</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>loc</name> <operator>&gt;</operator> <name>high</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>high</name> <operator>=</operator> <name>loc</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<while>while <condition>(<expr><name><name>check</name><index>[<expr><name>lowzero</name></expr>]</index></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>lowzero</name></expr>;</expr_stmt></block_content></block></while>

<return>return <expr><operator>(</operator><name>j</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>pack_table</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Value_t</name></type> <name>place</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>state</name></decl>;</decl_stmt>

<expr_stmt><expr><name>base</name> <operator>=</operator> <call><name>NEW2</name><argument_list>(<argument><expr><name>nvectors</name></expr></argument>, <argument><expr><name>Value_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>NEW2</name><argument_list>(<argument><expr><name>nentries</name></expr></argument>, <argument><expr><name>Value_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>maxtable</name> <operator>=</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>table</name> <operator>=</operator> <call><name>NEW2</name><argument_list>(<argument><expr><name>maxtable</name></expr></argument>, <argument><expr><name>Value_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>check</name> <operator>=</operator> <call><name>NEW2</name><argument_list>(<argument><expr><name>maxtable</name></expr></argument>, <argument><expr><name>Value_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>lowzero</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>high</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>maxtable</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>check</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nentries</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>matching_vector</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>state</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>place</name> <operator>=</operator> <operator>(</operator><name>Value_t</name><operator>)</operator><call><name>pack_vector</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>place</name> <operator>=</operator> <name><name>base</name><index>[<expr><name>state</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name><name>pos</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>place</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>base</name><index>[<expr><name><name>order</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name> <operator>=</operator> <name>place</name></expr>;</expr_stmt>
</block_content>}</block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nvectors</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>froms</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name><name>froms</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>tos</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name><name>tos</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>DO_FREE</name><argument_list>(<argument><expr><name>froms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DO_FREE</name><argument_list>(<argument><expr><name>tos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DO_FREE</name><argument_list>(<argument><expr><name>tally</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DO_FREE</name><argument_list>(<argument><expr><name>width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DO_FREE</name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>output_base</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>start_int_table</name><argument_list>(<argument><expr><literal type="string">"sindex"</literal></expr></argument>, <argument><expr><name><name>base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nstates</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;=</operator> <literal type="number">10</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>output_newline</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>j</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>output_int</name><argument_list>(<argument><expr><name><name>base</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>end_table</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>start_int_table</name><argument_list>(<argument><expr><literal type="string">"rindex"</literal></expr></argument>, <argument><expr><name><name>base</name><index>[<expr><name>nstates</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>nstates</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">2</literal> <operator>*</operator> <name>nstates</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;=</operator> <literal type="number">10</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>output_newline</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>j</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>output_int</name><argument_list>(<argument><expr><name><name>base</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>end_table</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYBTYACC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>output_line</name><argument_list>(<argument><expr><literal type="string">"#if YYBTYACC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>start_int_table</name><argument_list>(<argument><expr><literal type="string">"cindex"</literal></expr></argument>, <argument><expr><name><name>base</name><index>[<expr><literal type="number">2</literal> <operator>*</operator> <name>nstates</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">2</literal> <operator>*</operator> <name>nstates</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">3</literal> <operator>*</operator> <name>nstates</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;=</operator> <literal type="number">10</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>output_newline</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>j</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>output_int</name><argument_list>(<argument><expr><name><name>base</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>end_table</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>output_line</name><argument_list>(<argument><expr><literal type="string">"#endif"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>start_int_table</name><argument_list>(<argument><expr><literal type="string">"gindex"</literal></expr></argument>, <argument><expr><name><name>base</name><index>[<expr><name>PER_STATE</name> <operator>*</operator> <name>nstates</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>PER_STATE</name> <operator>*</operator> <name>nstates</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nvectors</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;=</operator> <literal type="number">10</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>output_newline</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>j</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>output_int</name><argument_list>(<argument><expr><name><name>base</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>end_table</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>output_table</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>high</name> <operator>&gt;=</operator> <name>MAXYYINT</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"YYTABLESIZE: %ld\n"</literal></expr></argument>, <argument><expr><name>high</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Table is longer than %d elements.\n"</literal></expr></argument>, <argument><expr><name>MAXYYINT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>done</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>++</operator><name>outline</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>, <argument><expr><literal type="string">"#define YYTABLESIZE %ld\n"</literal></expr></argument>, <argument><expr><name>high</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>start_int_table</name><argument_list>(<argument><expr><literal type="string">"table"</literal></expr></argument>, <argument><expr><name><name>table</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>high</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;=</operator> <literal type="number">10</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>output_newline</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>j</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>output_int</name><argument_list>(<argument><expr><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>end_table</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>output_check</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>start_int_table</name><argument_list>(<argument><expr><literal type="string">"check"</literal></expr></argument>, <argument><expr><name><name>check</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>high</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;=</operator> <literal type="number">10</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>output_newline</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>j</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>output_int</name><argument_list>(<argument><expr><name><name>check</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>end_table</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>check</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYBTYACC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>output_ctable</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>limit</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>conflicts</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>nconflicts</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>limit</name> <operator>&lt;</operator> <name>high</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>limit</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>high</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>output_line</name><argument_list>(<argument><expr><literal type="string">"#if YYBTYACC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>start_int_table</name><argument_list>(<argument><expr><literal type="string">"ctable"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>conflicts</name></expr> ?</condition><then> <expr><name><name>conflicts</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>limit</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;=</operator> <literal type="number">10</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>output_newline</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>j</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>output_int</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><name>conflicts</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name>nconflicts</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>conflicts</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>conflicts</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>conflicts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>end_table</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>output_line</name><argument_list>(<argument><expr><literal type="string">"#endif"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>output_actions</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>nvectors</name> <operator>=</operator> <name>PER_STATE</name> <operator>*</operator> <name>nstates</name> <operator>+</operator> <name>nvars</name></expr>;</expr_stmt>

<expr_stmt><expr><name>froms</name> <operator>=</operator> <call><name>NEW2</name><argument_list>(<argument><expr><name>nvectors</name></expr></argument>, <argument><expr><name>Value_t</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tos</name> <operator>=</operator> <call><name>NEW2</name><argument_list>(<argument><expr><name>nvectors</name></expr></argument>, <argument><expr><name>Value_t</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tally</name> <operator>=</operator> <call><name>NEW2</name><argument_list>(<argument><expr><name>nvectors</name></expr></argument>, <argument><expr><name>Value_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>width</name> <operator>=</operator> <call><name>NEW2</name><argument_list>(<argument><expr><name>nvectors</name></expr></argument>, <argument><expr><name>Value_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYBTYACC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>backtrack</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>SRtotal</name> <operator>+</operator> <name>RRtotal</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>conflicts</name> <operator>=</operator> <call><name>NEW2</name><argument_list>(<argument><expr><literal type="number">4</literal> <operator>*</operator> <operator>(</operator><name>SRtotal</name> <operator>+</operator> <name>RRtotal</name><operator>)</operator></expr></argument>, <argument><expr><name>Value_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>token_actions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>lookaheads</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>LA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>LAruleno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>accessing_symbol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>goto_actions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>goto_base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>from_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>to_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sort_actions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pack_table</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>output_base</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>output_table</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>output_check</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYBTYACC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>output_ctable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>is_C_identifier</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>s</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><operator>++</operator><name>s</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_NAME1</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><operator>++</operator><name>s</name><operator>)</operator> <operator>!=</operator> <literal type="char">'"'</literal></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_NAME2</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></while>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_NAME1</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><operator>++</operator><name>s</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_NAME2</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></while>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_HEADER_GUARDS</name></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>start_defines_file</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>defines_file</name></expr></argument>, <argument><expr><literal type="string">"#ifndef _%s_defines_h_\n"</literal></expr></argument>, <argument><expr><name>symbol_prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>defines_file</name></expr></argument>, <argument><expr><literal type="string">"#define _%s_defines_h_\n\n"</literal></expr></argument>, <argument><expr><name>symbol_prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>end_defines_file</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>defines_file</name></expr></argument>, <argument><expr><literal type="string">"\n#endif /* _%s_defines_h_ */\n"</literal></expr></argument>, <argument><expr><name>symbol_prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>start_defines_file</name><parameter_list>()</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>end_defines_file</name><parameter_list>()</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>output_defines</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type> <name>fp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fp</name> <operator>==</operator> <name>defines_file</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>output_code_lines</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>CODE_REQUIRES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntokens</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>symbol_name</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>is_C_identifier</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>sflag</name> <operator>||</operator> <operator>*</operator><name>s</name> <operator>!=</operator> <literal type="char">'"'</literal><operator>)</operator></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#define "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>s</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition>
<block>{<block_content>
<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><operator>++</operator><name>s</name><operator>)</operator> <operator>!=</operator> <literal type="char">'"'</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<do>do
<block>{<block_content>
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><operator>++</operator><name>s</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>;</do>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>fp</name> <operator>==</operator> <name>code_file</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>outline</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">" %d\n"</literal></expr></argument>, <argument><expr><name><name>symbol_value</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>fp</name> <operator>==</operator> <name>code_file</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>outline</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>fp</name> <operator>!=</operator> <name>defines_file</name> <operator>||</operator> <name>iflag</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#define YYERRCODE %d\n"</literal></expr></argument>, <argument><expr><name><name>symbol_value</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>fp</name> <operator>==</operator> <name>defines_file</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>output_code_lines</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>CODE_PROVIDES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>token_table</name> <operator>&amp;&amp;</operator> <name>rflag</name> <operator>&amp;&amp;</operator> <name>fp</name> <operator>!=</operator> <name>externs_file</name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>fp</name> <operator>==</operator> <name>code_file</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>outline</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"#undef yytname\n"</literal></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fp</name> <operator>==</operator> <name>code_file</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>outline</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"#define yytname yyname\n"</literal></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>fp</name> <operator>==</operator> <name>defines_file</name> <operator>||</operator> <operator>(</operator><name>iflag</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>dflag</name><operator>)</operator></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>unionized</name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>union_file</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>rewind</name><argument_list>(<argument><expr><name>union_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>getc</name><argument_list>(<argument><expr><name>union_file</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>putc_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pure_parser</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"extern YYSTYPE %slval;\n"</literal></expr></argument>, <argument><expr><name>symbol_prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYBTYACC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>locations</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>output_ltype</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"extern YYLTYPE %slloc;\n"</literal></expr></argument>, <argument><expr><name>symbol_prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>output_stored_text</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type> <name>fp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>in</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>text_file</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>open_error</name><argument_list>(<argument><expr><literal type="string">"text_file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>rewind</name><argument_list>(<argument><expr><name>text_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>in</name> <operator>=</operator> <name>text_file</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>getc</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>putc_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>getc</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>EOF</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>putc_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>write_code_lineno</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>output_yydebug</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type> <name>fp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#ifndef YYDEBUG\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#define YYDEBUG %d\n"</literal></expr></argument>, <argument><expr><name>tflag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#endif\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">3</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>output_debug</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>, <decl><type ref="prev"/><name>max</name></decl>, <decl><type ref="prev"/><name>maxtok</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>symnam</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>++</operator><name>outline</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>, <argument><expr><literal type="string">"#define YYFINAL %d\n"</literal></expr></argument>, <argument><expr><name>final_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>outline</name> <operator>+=</operator> <call><name>output_yydebug</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>rflag</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>output_yydebug</name><argument_list>(<argument><expr><name>output_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>maxtok</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntokens</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>symbol_value</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name>maxtok</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>maxtok</name> <operator>=</operator> <name><name>symbol_value</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>




<expr_stmt><expr><name>max</name> <operator>=</operator> <name>maxtok</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>ntokens</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nsyms</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>maxtok</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>symbol_value</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>&gt;</operator> <name>max</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>max</name> <operator>=</operator> <operator>(</operator><name>maxtok</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>symbol_value</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>

<expr_stmt><expr><operator>++</operator><name>outline</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>, <argument><expr><literal type="string">"#define YYMAXTOKEN %d\n"</literal></expr></argument>, <argument><expr><name>maxtok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name>outline</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>, <argument><expr><literal type="string">"#define YYUNDFTOKEN %d\n"</literal></expr></argument>, <argument><expr><name>max</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name>outline</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>, <argument><expr><literal type="string">"#define YYTRANSLATE(a) ((a) &gt; YYMAXTOKEN ? "</literal>
<literal type="string">"YYUNDFTOKEN : (a))\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>symnam</name> <operator>=</operator> <call><name>TMALLOC</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator></expr></argument>, <argument><expr><name>max</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NO_SPACE</name><argument_list>(<argument><expr><name>symnam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYBTYACC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>symnam</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>nsyms</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>symnam</name><index>[<expr><name><name>symbol_pval</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name> <operator>=</operator> <name><name>symbol_name</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><name><name>symnam</name><index>[<expr><name>max</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"illegal-symbol"</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>max</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>symnam</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>ntokens</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><operator>--</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>symnam</name><index>[<expr><name><name>symbol_value</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name> <operator>=</operator> <name><name>symbol_name</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><name><name>symnam</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"end-of-file"</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>symnam</name><index>[<expr><name>max</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="string">"illegal-symbol"</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>








<if_stmt><if>if <condition>(<expr><name>token_table</name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rflag</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>output_line</name><argument_list>(<argument><expr><literal type="string">"#undef yytname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>output_line</name><argument_list>(<argument><expr><literal type="string">"#define yytname yyname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><call><name>output_line</name><argument_list>(<argument><expr><literal type="string">"#if YYDEBUG"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>start_str_table</name><argument_list>(<argument><expr><literal type="string">"name"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">80</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>max</name> <operator>+</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>s</name> <operator>=</operator> <name><name>symnam</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>k</name> <operator>=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><operator>++</operator><name>s</name> <operator>!=</operator> <literal type="char">'"'</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>k</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>k</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>++</operator><name>s</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>k</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name>j</name> <operator>+=</operator> <name>k</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;</operator> <literal type="number">80</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>output_newline</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> <operator>=</operator> <name>k</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>output_file</name></expr></argument>, <argument><expr><literal type="string">"\"\\\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>symnam</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><operator>++</operator><name>s</name> <operator>!=</operator> <literal type="char">'"'</literal></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>output_file</name></expr></argument>, <argument><expr><literal type="string">"\\\\"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>++</operator><name>s</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>output_file</name></expr></argument>, <argument><expr><literal type="string">"\\\\"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>, <argument><expr><name>output_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>, <argument><expr><name>output_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>output_file</name></expr></argument>, <argument><expr><literal type="string">"\\\"\","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\''</literal></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>j</name> <operator>+=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;</operator> <literal type="number">80</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>output_newline</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>output_file</name></expr></argument>, <argument><expr><literal type="string">"\"'\\\"'\","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><name>k</name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><operator>++</operator><name>s</name> <operator>!=</operator> <literal type="char">'\''</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>k</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>k</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>++</operator><name>s</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>k</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name>j</name> <operator>+=</operator> <name>k</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;</operator> <literal type="number">80</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>output_newline</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> <operator>=</operator> <name>k</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>output_file</name></expr></argument>, <argument><expr><literal type="string">"\"'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>symnam</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><operator>++</operator><name>s</name> <operator>!=</operator> <literal type="char">'\''</literal></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>output_file</name></expr></argument>, <argument><expr><literal type="string">"\\\\"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>++</operator><name>s</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>output_file</name></expr></argument>, <argument><expr><literal type="string">"\\\\"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>, <argument><expr><name>output_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>, <argument><expr><name>output_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>output_file</name></expr></argument>, <argument><expr><literal type="string">"'\","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><name>k</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> <operator>+=</operator> <name>k</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;</operator> <literal type="number">80</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>output_newline</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> <operator>=</operator> <name>k</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><literal type="char">'"'</literal></expr></argument>, <argument><expr><name>output_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<do>do
<block>{<block_content>
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>, <argument><expr><name>output_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
while <condition>(<expr><operator>*</operator><operator>++</operator><name>s</name></expr>)</condition>;</do>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>output_file</name></expr></argument>, <argument><expr><literal type="string">"\","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><name>j</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;</operator> <literal type="number">80</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>output_newline</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>output_file</name></expr></argument>, <argument><expr><literal type="string">"0,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>end_table</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>symnam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>token_table</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>output_line</name><argument_list>(<argument><expr><literal type="string">"#if YYDEBUG"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>start_str_table</name><argument_list>(<argument><expr><literal type="string">"rule"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nrules</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>output_file</name></expr></argument>, <argument><expr><literal type="string">"\"%s :"</literal></expr></argument>, <argument><expr><name><name>symbol_name</name><index>[<expr><name><name>rlhs</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name><name>rrhs</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</init> <condition><expr><name><name>ritem</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>symbol_name</name><index>[<expr><name><name>ritem</name><index>[<expr><name>j</name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>output_file</name></expr></argument>, <argument><expr><literal type="string">" \\\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><operator>++</operator><name>s</name> <operator>!=</operator> <literal type="char">'"'</literal></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>output_file</name></expr></argument>, <argument><expr><literal type="string">"\\\\\\\\"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>output_file</name></expr></argument>, <argument><expr><literal type="string">"\\\\%c"</literal></expr></argument>, <argument><expr><name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><operator>++</operator><name>s</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>, <argument><expr><name>output_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>output_file</name></expr></argument>, <argument><expr><literal type="string">"\\\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\''</literal></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>output_file</name></expr></argument>, <argument><expr><literal type="string">" '\\\"'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>output_file</name></expr></argument>, <argument><expr><literal type="string">" '\\\\\\\\"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>output_file</name></expr></argument>, <argument><expr><literal type="string">" '\\\\%c"</literal></expr></argument>, <argument><expr><name><name>s</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name>s</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><operator>++</operator><name>s</name> <operator>!=</operator> <literal type="char">'\''</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>, <argument><expr><name>output_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><literal type="char">'\''</literal></expr></argument>, <argument><expr><name>output_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>output_file</name></expr></argument>, <argument><expr><literal type="string">" '%c'"</literal></expr></argument>, <argument><expr><name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>output_file</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>output_file</name></expr></argument>, <argument><expr><literal type="string">"\","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>output_newline</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>end_table</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>output_line</name><argument_list>(<argument><expr><literal type="string">"#endif"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYBTYACC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>output_backtracking_parser</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type> <name>fp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#undef YYBTYACC\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYBTYACC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>backtrack</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#define YYBTYACC 1\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>,
<argument><expr><literal type="string">"#define YYDEBUGSTR (yytrial ? YYPREFIX \"debug(trial)\" : YYPREFIX \"debug\")\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{<block_content>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#define YYBTYACC 0\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#define YYDEBUGSTR YYPREFIX \"debug\"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>output_pure_parser</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type> <name>fp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>putc_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fp</name> <operator>==</operator> <name>code_file</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>outline</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#define YYPURE %d\n"</literal></expr></argument>, <argument><expr><name>pure_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putc_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YY_NO_LEAKS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>output_no_leaks</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type> <name>fp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>putc_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fp</name> <operator>==</operator> <name>code_file</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>outline</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"#define YY_NO_LEAKS 1\n"</literal></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putc_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>output_trailing_text</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>last</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>in</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>line</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>in</name> <operator>=</operator> <name>input_file</name></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>cptr</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>lineno</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>getc</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>write_input_lineno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putc_code</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>last</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><call><name>write_input_lineno</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<do>do
<block>{<block_content>
<expr_stmt><expr><call><name>putc_code</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><operator>++</operator><name>cptr</name><operator>)</operator> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition>;</do>
<expr_stmt><expr><call><name>putc_code</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>last</name> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>getc</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>EOF</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>putc_code</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>last</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>last</name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>putc_code</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>write_code_lineno</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>output_semantic_actions</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>last</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rewind</name><argument_list>(<argument><expr><name>action_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>getc</name><argument_list>(<argument><expr><name>action_file</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>last</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putc_code</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>getc</name><argument_list>(<argument><expr><name>action_file</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>EOF</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>putc_code</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>last</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>last</name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>putc_code</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>write_code_lineno</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>output_parse_decl</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type> <name>fp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>putc_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"/* compatibility with bison */\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#ifdef YYPARSE_PARAM\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"/* compatibility with FreeBSD */\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#ifdef YYPARSE_PARAM_TYPE\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>,
<argument><expr><literal type="string">"#define YYPARSE_DECL() yyparse(YYPARSE_PARAM_TYPE YYPARSE_PARAM)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#else\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#define YYPARSE_DECL() yyparse(void *YYPARSE_PARAM)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#endif\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#else\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>puts_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#define YYPARSE_DECL() yyparse("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>puts_param_types</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>parse_param</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">")\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#endif\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>output_lex_decl</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type> <name>fp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>putc_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"/* Parameters sent to lex. */\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#ifdef YYLEX_PARAM\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pure_parser</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#ifdef YYLEX_PARAM_TYPE\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYBTYACC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>locations</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#define YYLEX_DECL() yylex(YYSTYPE *yylval,"</literal>
<literal type="string">" YYLTYPE *yylloc,"</literal>
<literal type="string">" YYLEX_PARAM_TYPE YYLEX_PARAM)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{<block_content>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#define YYLEX_DECL() yylex(YYSTYPE *yylval,"</literal>
<literal type="string">" YYLEX_PARAM_TYPE YYLEX_PARAM)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#else\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYBTYACC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>locations</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#define YYLEX_DECL() yylex(YYSTYPE *yylval,"</literal>
<literal type="string">" YYLTYPE *yylloc,"</literal>
<literal type="string">" void * YYLEX_PARAM)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{<block_content>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#define YYLEX_DECL() yylex(YYSTYPE *yylval,"</literal>
<literal type="string">" void * YYLEX_PARAM)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#endif\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYBTYACC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>locations</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>,
<argument><expr><literal type="string">"#define YYLEX yylex(&amp;yylval, &amp;yylloc, YYLEX_PARAM)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#define YYLEX yylex(&amp;yylval, YYLEX_PARAM)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#define YYLEX_DECL() yylex(void *YYLEX_PARAM)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#define YYLEX yylex(YYLEX_PARAM)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#else\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pure_parser</name> <operator>&amp;&amp;</operator> <name>lex_param</name></expr>)</condition>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYBTYACC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>locations</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>puts_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>,
<argument><expr><literal type="string">"#define YYLEX_DECL() yylex(YYSTYPE *yylval, YYLTYPE *yylloc, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>puts_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#define YYLEX_DECL() yylex(YYSTYPE *yylval, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>puts_param_types</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>lex_param</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">")\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYBTYACC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>locations</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>puts_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#define YYLEX yylex(&amp;yylval, &amp;yylloc, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>puts_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#define YYLEX yylex(&amp;yylval, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>puts_param_names</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>lex_param</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">")\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>pure_parser</name></expr>)</condition>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYBTYACC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>locations</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>,
<argument><expr><literal type="string">"#define YYLEX_DECL() yylex(YYSTYPE *yylval, YYLTYPE *yylloc)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#define YYLEX yylex(&amp;yylval, &amp;yylloc)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{<block_content>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#define YYLEX_DECL() yylex(YYSTYPE *yylval)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#define YYLEX yylex(&amp;yylval)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>lex_param</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>puts_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#define YYLEX_DECL() yylex("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>puts_param_types</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>lex_param</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">")\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>puts_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#define YYLEX yylex("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>puts_param_names</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>lex_param</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">")\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#define YYLEX_DECL() yylex(void)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#define YYLEX yylex()\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#endif\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>






<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pure_parser</name>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYBTYACC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<operator>&amp;&amp;</operator> <operator>!</operator><name>backtrack</name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>symbol_prefix</name></expr></argument>, <argument><expr><literal type="string">"yy"</literal></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#if !(defined(yylex) || defined(YYSTATE))\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"int YYLEX_DECL();\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#endif\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>output_error_decl</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type> <name>fp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>putc_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"/* Parameters sent to yyerror. */\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#ifndef YYERROR_DECL\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>puts_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#define YYERROR_DECL() yyerror("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYBTYACC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>locations</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>puts_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"YYLTYPE *loc, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>puts_param_types</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>parse_param</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"const char *s)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#endif\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#ifndef YYERROR_CALL\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>puts_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#define YYERROR_CALL(msg) yyerror("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYBTYACC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>locations</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>puts_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"&amp;yylloc, "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>puts_param_names</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>parse_param</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"msg)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#endif\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYBTYACC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>output_yydestruct_decl</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type> <name>fp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>putc_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#ifndef YYDESTRUCT_DECL\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>puts_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>,
<argument><expr><literal type="string">"#define YYDESTRUCT_DECL() "</literal>
<literal type="string">"yydestruct(const char *msg, int psymb, YYSTYPE *val"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYBTYACC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>locations</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>puts_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">", YYLTYPE *loc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><name>parse_param</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>puts_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>puts_param_types</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>parse_param</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">")\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#endif\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#ifndef YYDESTRUCT_CALL\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>puts_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#define YYDESTRUCT_CALL(msg, psymb, val"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYBTYACC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>locations</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>puts_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">", loc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>puts_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">") yydestruct(msg, psymb, val"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYBTYACC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>locations</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>puts_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">", loc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><name>parse_param</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>puts_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>puts_param_names</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>parse_param</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">")\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"#endif\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>output_initial_action</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>initial_action</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>initial_action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>output_yydestruct_impl</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>destructor_code</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>putc_code</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>, <argument><expr><literal type="string">"/* Release memory associated with symbol. */\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>, <argument><expr><literal type="string">"#if ! defined YYDESTRUCT_IS_DECLARED\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>, <argument><expr><literal type="string">"static void\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>, <argument><expr><literal type="string">"YYDESTRUCT_DECL()\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>, <argument><expr><literal type="string">"{\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>, <argument><expr><literal type="string">" switch (psymb)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>, <argument><expr><literal type="string">" {\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nsyms</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>destructor_code</name> <operator>=</operator> <name><name>symbol_destructor</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>outline</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>, <argument><expr><literal type="string">"\tcase %d:\n"</literal></expr></argument>, <argument><expr><name><name>symbol_pval</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name>destructor_code</name></expr>;</init> <condition><expr><operator>(</operator><name>s</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>outline</name></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>puts_code</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>, <argument><expr><name>destructor_code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putc_code</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>, <argument><expr><literal type="string">"\tbreak;\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>write_code_lineno</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>destructor_code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>, <argument><expr><literal type="string">" }\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>, <argument><expr><literal type="string">"}\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>, <argument><expr><literal type="string">"#define YYDESTRUCT_IS_DECLARED 1\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putl_code</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>, <argument><expr><literal type="string">"#endif\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DO_FREE</name><argument_list>(<argument><expr><name>symbol_destructor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>free_itemsets</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>core</name> <modifier>*</modifier></type><name>cp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>state_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>cp</name> <operator>=</operator> <name>first_state</name></expr>;</init> <condition><expr><name>cp</name></expr>;</condition> <incr><expr><name>cp</name> <operator>=</operator> <name>next</name></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>cp</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>free_shifts</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>shifts</name> <modifier>*</modifier></type><name>sp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>shift_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>sp</name> <operator>=</operator> <name>first_shift</name></expr>;</init> <condition><expr><name>sp</name></expr>;</condition> <incr><expr><name>sp</name> <operator>=</operator> <name>next</name></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>free_reductions</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>reductions</name> <modifier>*</modifier></type><name>rp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>reduction_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>rp</name> <operator>=</operator> <name>first_reduction</name></expr>;</init> <condition><expr><name>rp</name></expr>;</condition> <incr><expr><name>rp</name> <operator>=</operator> <name>next</name></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>rp</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>output_externs</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type> <name>fp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>section</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>s</name> <operator>=</operator> <name><name>section</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
<block>{<block_content>


<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>s</name> <operator>!=</operator> <literal type="char">'#'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"extern\t"</literal></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>fp</name> <operator>==</operator> <name>code_file</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>outline</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>output</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>free_itemsets</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free_shifts</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free_reductions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>output_code_lines</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>, <argument><expr><name>CODE_TOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYBTYACC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>output_backtracking_parser</name><argument_list>(<argument><expr><name>output_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>rflag</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>output_backtracking_parser</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>iflag</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>write_code_lineno</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>outline</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>, <argument><expr><literal type="string">"#include \"%s\"\n"</literal></expr></argument>, <argument><expr><name>externs_file_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>fp</name> <operator>=</operator> <name>externs_file</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>fp</name> <operator>=</operator> <name>code_file</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>output_prefix</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>output_pure_parser</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YY_NO_LEAKS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>output_no_leaks</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>output_stored_text</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>output_stype</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYBTYACC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>locations</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>output_ltype</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>output_parse_decl</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>output_lex_decl</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>output_error_decl</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYBTYACC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>destructor</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>output_yydestruct_decl</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><name>iflag</name> <operator>||</operator> <operator>!</operator><name>rflag</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>write_section</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>xdecls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>iflag</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>externs_file</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>output_yydebug</name><argument_list>(<argument><expr><name>externs_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>output_externs</name><argument_list>(<argument><expr><name>externs_file</name></expr></argument>, <argument><expr><name>global_vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pure_parser</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>output_externs</name><argument_list>(<argument><expr><name>externs_file</name></expr></argument>, <argument><expr><name>impure_vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>dflag</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>outline</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>, <argument><expr><literal type="string">"#include \"%s\"\n"</literal></expr></argument>, <argument><expr><name>defines_file_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>output_defines</name><argument_list>(<argument><expr><name>externs_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><call><name>putc_code</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>output_defines</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>dflag</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>start_defines_file</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>output_defines</name><argument_list>(<argument><expr><name>defines_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>end_defines_file</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>output_rule_data</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>output_yydefred</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYBTYACC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>output_accessing_symbols</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>output_actions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free_parser</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>output_debug</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>rflag</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>write_section</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>, <argument><expr><name>xdecls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>output_YYINT_typedef</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>write_section</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>, <argument><expr><name>tables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>write_section</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>, <argument><expr><name>global_vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pure_parser</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>write_section</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>, <argument><expr><name>impure_vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>output_code_lines</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>, <argument><expr><name>CODE_REQUIRES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>write_section</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>, <argument><expr><name>hdr_defs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pure_parser</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>write_section</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>, <argument><expr><name>hdr_vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>output_code_lines</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>, <argument><expr><name>CODE_PROVIDES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>output_code_lines</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>, <argument><expr><name>CODE_HEADER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>output_trailing_text</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYBTYACC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>destructor</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>output_yydestruct_impl</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>write_section</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>, <argument><expr><name>body_1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pure_parser</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>write_section</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>, <argument><expr><name>body_vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>write_section</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>, <argument><expr><name>body_2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pure_parser</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>write_section</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>, <argument><expr><name>init_vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YYBTYACC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>initial_action</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>output_initial_action</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>write_section</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>, <argument><expr><name>body_3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>output_semantic_actions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>write_section</name><argument_list>(<argument><expr><name>code_file</name></expr></argument>, <argument><expr><name>trailer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NO_LEAKS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>void</name></type>
<name>output_leaks</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>DO_FREE</name><argument_list>(<argument><expr><name>tally</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DO_FREE</name><argument_list>(<argument><expr><name>width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DO_FREE</name><argument_list>(<argument><expr><name>order</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
