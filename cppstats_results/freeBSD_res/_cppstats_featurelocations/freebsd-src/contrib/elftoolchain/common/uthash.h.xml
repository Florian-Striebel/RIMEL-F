<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/elftoolchain/common/uthash.h">
























<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>UTHASH_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UTHASH_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stddef.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>





<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>_MSC_VER</name> <operator>&gt;=</operator> <literal type="number">1600</literal> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DECLTYPE</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(decltype(x))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NO_DECLTYPE</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DECLTYPE</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DECLTYPE</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(__typeof(x))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NO_DECLTYPE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DECLTYPE_ASSIGN</name><parameter_list>(<parameter><type><name>dst</name></type></parameter>,<parameter><type><name>src</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { char **_da_dst = (char**)(&amp;(dst)); *_da_dst = (char*)(src); } while(0)</cpp:value></cpp:define>




<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DECLTYPE_ASSIGN</name><parameter_list>(<parameter><type><name>dst</name></type></parameter>,<parameter><type><name>src</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { (dst) = DECLTYPE(dst)(src); } while(0)</cpp:value></cpp:define>



<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<typedef>typedef <type><name>unsigned</name> <name>int</name></type> <name>uint32_t</name>;</typedef>
<typedef>typedef <type><name>unsigned</name> <name>char</name></type> <name>uint8_t</name>;</typedef>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;inttypes.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UTHASH_VERSION</name></cpp:macro> <cpp:value>1.9.7</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>uthash_fatal</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>uthash_fatal</name><parameter_list>(<parameter><type><name>msg</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>exit(-1)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>uthash_malloc</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>uthash_malloc</name><parameter_list>(<parameter><type><name>sz</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>malloc(sz)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>uthash_free</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>uthash_free</name><parameter_list>(<parameter><type><name>ptr</name></type></parameter>,<parameter><type><name>sz</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>free(ptr)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>uthash_noexpand_fyi</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>uthash_noexpand_fyi</name><parameter_list>(<parameter><type><name>tbl</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>uthash_expand_fyi</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>uthash_expand_fyi</name><parameter_list>(<parameter><type><name>tbl</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_INITIAL_NUM_BUCKETS</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_INITIAL_NUM_BUCKETS_LOG2</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_BKT_CAPACITY_THRESH</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ELMT_FROM_HH</name><parameter_list>(<parameter><type><name>tbl</name></type></parameter>,<parameter><type><name>hhp</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((void*)(((char*)(hhp)) - ((tbl)-&gt;hho)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_FIND</name><parameter_list>(<parameter><type><name>hh</name></type></parameter>,<parameter><type><name>head</name></type></parameter>,<parameter><type><name>keyptr</name></type></parameter>,<parameter><type><name>keylen</name></type></parameter>,<parameter><type><name>out</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { unsigned _hf_bkt,_hf_hashv; out=NULL; if (head) { HASH_FCN(keyptr,keylen, (head)-&gt;hh.tbl-&gt;num_buckets, _hf_hashv, _hf_bkt); if (HASH_BLOOM_TEST((head)-&gt;hh.tbl, _hf_hashv)) { HASH_FIND_IN_BKT((head)-&gt;hh.tbl, hh, (head)-&gt;hh.tbl-&gt;buckets[ _hf_bkt ], keyptr,keylen,out); } } } while (0)</cpp:value></cpp:define>












<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HASH_BLOOM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_BLOOM_BITLEN</name></cpp:macro> <cpp:value>(1ULL &lt;&lt; HASH_BLOOM)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_BLOOM_BYTELEN</name></cpp:macro> <cpp:value>(HASH_BLOOM_BITLEN/8) + ((HASH_BLOOM_BITLEN%8) ? 1:0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_BLOOM_MAKE</name><parameter_list>(<parameter><type><name>tbl</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { (tbl)-&gt;bloom_nbits = HASH_BLOOM; (tbl)-&gt;bloom_bv = (uint8_t*)uthash_malloc(HASH_BLOOM_BYTELEN); if (!((tbl)-&gt;bloom_bv)) { uthash_fatal( "out of memory"); } memset((tbl)-&gt;bloom_bv, 0, HASH_BLOOM_BYTELEN); (tbl)-&gt;bloom_sig = HASH_BLOOM_SIGNATURE; } while (0)</cpp:value></cpp:define>








<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_BLOOM_FREE</name><parameter_list>(<parameter><type><name>tbl</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { uthash_free((tbl)-&gt;bloom_bv, HASH_BLOOM_BYTELEN); } while (0)</cpp:value></cpp:define>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_BLOOM_BITSET</name><parameter_list>(<parameter><type><name>bv</name></type></parameter>,<parameter><type><name>idx</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(bv[(idx)/8] |= (1U &lt;&lt; ((idx)%8)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_BLOOM_BITTEST</name><parameter_list>(<parameter><type><name>bv</name></type></parameter>,<parameter><type><name>idx</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(bv[(idx)/8] &amp; (1U &lt;&lt; ((idx)%8)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_BLOOM_ADD</name><parameter_list>(<parameter><type><name>tbl</name></type></parameter>,<parameter><type><name>hashv</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>HASH_BLOOM_BITSET((tbl)-&gt;bloom_bv, (hashv &amp; (uint32_t)((1ULL &lt;&lt; (tbl)-&gt;bloom_nbits) - 1)))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_BLOOM_TEST</name><parameter_list>(<parameter><type><name>tbl</name></type></parameter>,<parameter><type><name>hashv</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>HASH_BLOOM_BITTEST((tbl)-&gt;bloom_bv, (hashv &amp; (uint32_t)((1ULL &lt;&lt; (tbl)-&gt;bloom_nbits) - 1)))</cpp:value></cpp:define>


<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_BLOOM_MAKE</name><parameter_list>(<parameter><type><name>tbl</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_BLOOM_FREE</name><parameter_list>(<parameter><type><name>tbl</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_BLOOM_ADD</name><parameter_list>(<parameter><type><name>tbl</name></type></parameter>,<parameter><type><name>hashv</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_BLOOM_TEST</name><parameter_list>(<parameter><type><name>tbl</name></type></parameter>,<parameter><type><name>hashv</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(1)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_MAKE_TABLE</name><parameter_list>(<parameter><type><name>hh</name></type></parameter>,<parameter><type><name>head</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { (head)-&gt;hh.tbl = (UT_hash_table*)uthash_malloc( sizeof(UT_hash_table)); if (!((head)-&gt;hh.tbl)) { uthash_fatal( "out of memory"); } memset((head)-&gt;hh.tbl, 0, sizeof(UT_hash_table)); (head)-&gt;hh.tbl-&gt;tail = &amp;((head)-&gt;hh); (head)-&gt;hh.tbl-&gt;num_buckets = HASH_INITIAL_NUM_BUCKETS; (head)-&gt;hh.tbl-&gt;log2_num_buckets = HASH_INITIAL_NUM_BUCKETS_LOG2; (head)-&gt;hh.tbl-&gt;hho = (char*)(&amp;(head)-&gt;hh) - (char*)(head); (head)-&gt;hh.tbl-&gt;buckets = (UT_hash_bucket*)uthash_malloc( HASH_INITIAL_NUM_BUCKETS*sizeof(struct UT_hash_bucket)); if (! (head)-&gt;hh.tbl-&gt;buckets) { uthash_fatal( "out of memory"); } memset((head)-&gt;hh.tbl-&gt;buckets, 0, HASH_INITIAL_NUM_BUCKETS*sizeof(struct UT_hash_bucket)); HASH_BLOOM_MAKE((head)-&gt;hh.tbl); (head)-&gt;hh.tbl-&gt;signature = HASH_SIGNATURE; } while(0)</cpp:value></cpp:define>


















<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_ADD</name><parameter_list>(<parameter><type><name>hh</name></type></parameter>,<parameter><type><name>head</name></type></parameter>,<parameter><type><name>fieldname</name></type></parameter>,<parameter><type><name>keylen_in</name></type></parameter>,<parameter><type><name>add</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>HASH_ADD_KEYPTR(hh,head,&amp;((add)-&gt;fieldname),keylen_in,add)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_ADD_KEYPTR</name><parameter_list>(<parameter><type><name>hh</name></type></parameter>,<parameter><type><name>head</name></type></parameter>,<parameter><type><name>keyptr</name></type></parameter>,<parameter><type><name>keylen_in</name></type></parameter>,<parameter><type><name>add</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { unsigned _ha_bkt; (add)-&gt;hh.next = NULL; (add)-&gt;hh.key = (char*)keyptr; (add)-&gt;hh.keylen = (unsigned)keylen_in; if (!(head)) { head = (add); (head)-&gt;hh.prev = NULL; HASH_MAKE_TABLE(hh,head); } else { (head)-&gt;hh.tbl-&gt;tail-&gt;next = (add); (add)-&gt;hh.prev = ELMT_FROM_HH((head)-&gt;hh.tbl, (head)-&gt;hh.tbl-&gt;tail); (head)-&gt;hh.tbl-&gt;tail = &amp;((add)-&gt;hh); } (head)-&gt;hh.tbl-&gt;num_items++; (add)-&gt;hh.tbl = (head)-&gt;hh.tbl; HASH_FCN(keyptr,keylen_in, (head)-&gt;hh.tbl-&gt;num_buckets, (add)-&gt;hh.hashv, _ha_bkt); HASH_ADD_TO_BKT((head)-&gt;hh.tbl-&gt;buckets[_ha_bkt],&amp;(add)-&gt;hh); HASH_BLOOM_ADD((head)-&gt;hh.tbl,(add)-&gt;hh.hashv); HASH_EMIT_KEY(hh,head,keyptr,keylen_in); HASH_FSCK(hh,head); } while(0)</cpp:value></cpp:define>
























<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_TO_BKT</name><parameter_list>( <parameter><type><name>hashv</name></type></parameter>, <parameter><type><name>num_bkts</name></type></parameter>, <parameter><type><name>bkt</name></type></parameter> )</parameter_list></cpp:macro> <cpp:value>do { bkt = ((hashv) &amp; ((num_bkts) - 1)); } while(0)</cpp:value></cpp:define>
















<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_DELETE</name><parameter_list>(<parameter><type><name>hh</name></type></parameter>,<parameter><type><name>head</name></type></parameter>,<parameter><type><name>delptr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { unsigned _hd_bkt; struct UT_hash_handle *_hd_hh_del; if ( ((delptr)-&gt;hh.prev == NULL) &amp;&amp; ((delptr)-&gt;hh.next == NULL) ) { uthash_free((head)-&gt;hh.tbl-&gt;buckets, (head)-&gt;hh.tbl-&gt;num_buckets*sizeof(struct UT_hash_bucket) ); HASH_BLOOM_FREE((head)-&gt;hh.tbl); uthash_free((head)-&gt;hh.tbl, sizeof(UT_hash_table)); head = NULL; } else { _hd_hh_del = &amp;((delptr)-&gt;hh); if ((delptr) == ELMT_FROM_HH((head)-&gt;hh.tbl,(head)-&gt;hh.tbl-&gt;tail)) { (head)-&gt;hh.tbl-&gt;tail = (UT_hash_handle*)((ptrdiff_t)((delptr)-&gt;hh.prev) + (head)-&gt;hh.tbl-&gt;hho); } if ((delptr)-&gt;hh.prev) { ((UT_hash_handle*)((ptrdiff_t)((delptr)-&gt;hh.prev) + (head)-&gt;hh.tbl-&gt;hho))-&gt;next = (delptr)-&gt;hh.next; } else { DECLTYPE_ASSIGN(head,(delptr)-&gt;hh.next); } if (_hd_hh_del-&gt;next) { ((UT_hash_handle*)((ptrdiff_t)_hd_hh_del-&gt;next + (head)-&gt;hh.tbl-&gt;hho))-&gt;prev = _hd_hh_del-&gt;prev; } HASH_TO_BKT( _hd_hh_del-&gt;hashv, (head)-&gt;hh.tbl-&gt;num_buckets, _hd_bkt); HASH_DEL_IN_BKT(hh,(head)-&gt;hh.tbl-&gt;buckets[_hd_bkt], _hd_hh_del); (head)-&gt;hh.tbl-&gt;num_items--; } HASH_FSCK(hh,head); } while (0)</cpp:value></cpp:define>




































<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_FIND_STR</name><parameter_list>(<parameter><type><name>head</name></type></parameter>,<parameter><type><name>findstr</name></type></parameter>,<parameter><type><name>out</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>HASH_FIND(hh,head,findstr,strlen(findstr),out)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_ADD_STR</name><parameter_list>(<parameter><type><name>head</name></type></parameter>,<parameter><type><name>strfield</name></type></parameter>,<parameter><type><name>add</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>HASH_ADD(hh,head,strfield,strlen(add-&gt;strfield),add)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_FIND_INT</name><parameter_list>(<parameter><type><name>head</name></type></parameter>,<parameter><type><name>findint</name></type></parameter>,<parameter><type><name>out</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>HASH_FIND(hh,head,findint,sizeof(int),out)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_ADD_INT</name><parameter_list>(<parameter><type><name>head</name></type></parameter>,<parameter><type><name>intfield</name></type></parameter>,<parameter><type><name>add</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>HASH_ADD(hh,head,intfield,sizeof(int),add)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_FIND_PTR</name><parameter_list>(<parameter><type><name>head</name></type></parameter>,<parameter><type><name>findptr</name></type></parameter>,<parameter><type><name>out</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>HASH_FIND(hh,head,findptr,sizeof(void *),out)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_ADD_PTR</name><parameter_list>(<parameter><type><name>head</name></type></parameter>,<parameter><type><name>ptrfield</name></type></parameter>,<parameter><type><name>add</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>HASH_ADD(hh,head,ptrfield,sizeof(void *),add)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_DEL</name><parameter_list>(<parameter><type><name>head</name></type></parameter>,<parameter><type><name>delptr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>HASH_DELETE(hh,head,delptr)</cpp:value></cpp:define>





<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HASH_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_OOPS</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { fprintf(stderr,__VA_ARGS__); exit(-1); } while (0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_FSCK</name><parameter_list>(<parameter><type><name>hh</name></type></parameter>,<parameter><type><name>head</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { unsigned _bkt_i; unsigned _count, _bkt_count; char *_prev; struct UT_hash_handle *_thh; if (head) { _count = 0; for( _bkt_i = 0; _bkt_i &lt; (head)-&gt;hh.tbl-&gt;num_buckets; _bkt_i++) { _bkt_count = 0; _thh = (head)-&gt;hh.tbl-&gt;buckets[_bkt_i].hh_head; _prev = NULL; while (_thh) { if (_prev != (char*)(_thh-&gt;hh_prev)) { HASH_OOPS("invalid hh_prev %p, actual %p\n", _thh-&gt;hh_prev, _prev ); } _bkt_count++; _prev = (char*)(_thh); _thh = _thh-&gt;hh_next; } _count += _bkt_count; if ((head)-&gt;hh.tbl-&gt;buckets[_bkt_i].count != _bkt_count) { HASH_OOPS("invalid bucket count %d, actual %d\n", (head)-&gt;hh.tbl-&gt;buckets[_bkt_i].count, _bkt_count); } } if (_count != (head)-&gt;hh.tbl-&gt;num_items) { HASH_OOPS("invalid hh item count %d, actual %d\n", (head)-&gt;hh.tbl-&gt;num_items, _count ); } _count = 0; _prev = NULL; _thh = &amp;(head)-&gt;hh; while (_thh) { _count++; if (_prev !=(char*)(_thh-&gt;prev)) { HASH_OOPS("invalid prev %p, actual %p\n", _thh-&gt;prev, _prev ); } _prev = (char*)ELMT_FROM_HH((head)-&gt;hh.tbl, _thh); _thh = ( _thh-&gt;next ? (UT_hash_handle*)((char*)(_thh-&gt;next) + (head)-&gt;hh.tbl-&gt;hho) : NULL ); } if (_count != (head)-&gt;hh.tbl-&gt;num_items) { HASH_OOPS("invalid app item count %d, actual %d\n", (head)-&gt;hh.tbl-&gt;num_items, _count ); } } } while (0)</cpp:value></cpp:define>


















































<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_FSCK</name><parameter_list>(<parameter><type><name>hh</name></type></parameter>,<parameter><type><name>head</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>




<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HASH_EMIT_KEYS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_EMIT_KEY</name><parameter_list>(<parameter><type><name>hh</name></type></parameter>,<parameter><type><name>head</name></type></parameter>,<parameter><type><name>keyptr</name></type></parameter>,<parameter><type><name>fieldlen</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { unsigned _klen = fieldlen; write(HASH_EMIT_KEYS, &amp;_klen, sizeof(_klen)); write(HASH_EMIT_KEYS, keyptr, fieldlen); } while (0)</cpp:value></cpp:define>





<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_EMIT_KEY</name><parameter_list>(<parameter><type><name>hh</name></type></parameter>,<parameter><type><name>head</name></type></parameter>,<parameter><type><name>keyptr</name></type></parameter>,<parameter><type><name>fieldlen</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HASH_FUNCTION</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_FCN</name></cpp:macro> <cpp:value>HASH_FUNCTION</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_FCN</name></cpp:macro> <cpp:value>HASH_JEN</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_BER</name><parameter_list>(<parameter><type><name>key</name></type></parameter>,<parameter><type><name>keylen</name></type></parameter>,<parameter><type><name>num_bkts</name></type></parameter>,<parameter><type><name>hashv</name></type></parameter>,<parameter><type><name>bkt</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { unsigned _hb_keylen=keylen; char *_hb_key=(char*)(key); (hashv) = 0; while (_hb_keylen--) { (hashv) = ((hashv) * 33) + *_hb_key++; } bkt = (hashv) &amp; (num_bkts-1); } while (0)</cpp:value></cpp:define>











<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_SAX</name><parameter_list>(<parameter><type><name>key</name></type></parameter>,<parameter><type><name>keylen</name></type></parameter>,<parameter><type><name>num_bkts</name></type></parameter>,<parameter><type><name>hashv</name></type></parameter>,<parameter><type><name>bkt</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { unsigned _sx_i; char *_hs_key=(char*)(key); hashv = 0; for(_sx_i=0; _sx_i &lt; keylen; _sx_i++) hashv ^= (hashv &lt;&lt; 5) + (hashv &gt;&gt; 2) + _hs_key[_sx_i]; bkt = hashv &amp; (num_bkts-1); } while (0)</cpp:value></cpp:define>









<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_FNV</name><parameter_list>(<parameter><type><name>key</name></type></parameter>,<parameter><type><name>keylen</name></type></parameter>,<parameter><type><name>num_bkts</name></type></parameter>,<parameter><type><name>hashv</name></type></parameter>,<parameter><type><name>bkt</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { unsigned _fn_i; char *_hf_key=(char*)(key); hashv = 2166136261UL; for(_fn_i=0; _fn_i &lt; keylen; _fn_i++) hashv = (hashv * 16777619) ^ _hf_key[_fn_i]; bkt = hashv &amp; (num_bkts-1); } while(0)</cpp:value></cpp:define>









<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_OAT</name><parameter_list>(<parameter><type><name>key</name></type></parameter>,<parameter><type><name>keylen</name></type></parameter>,<parameter><type><name>num_bkts</name></type></parameter>,<parameter><type><name>hashv</name></type></parameter>,<parameter><type><name>bkt</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { unsigned _ho_i; char *_ho_key=(char*)(key); hashv = 0; for(_ho_i=0; _ho_i &lt; keylen; _ho_i++) { hashv += _ho_key[_ho_i]; hashv += (hashv &lt;&lt; 10); hashv ^= (hashv &gt;&gt; 6); } hashv += (hashv &lt;&lt; 3); hashv ^= (hashv &gt;&gt; 11); hashv += (hashv &lt;&lt; 15); bkt = hashv &amp; (num_bkts-1); } while(0)</cpp:value></cpp:define>















<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_JEN_MIX</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { a -= b; a -= c; a ^= ( c &gt;&gt; 13 ); b -= c; b -= a; b ^= ( a &lt;&lt; 8 ); c -= a; c -= b; c ^= ( b &gt;&gt; 13 ); a -= b; a -= c; a ^= ( c &gt;&gt; 12 ); b -= c; b -= a; b ^= ( a &lt;&lt; 16 ); c -= a; c -= b; c ^= ( b &gt;&gt; 5 ); a -= b; a -= c; a ^= ( c &gt;&gt; 3 ); b -= c; b -= a; b ^= ( a &lt;&lt; 10 ); c -= a; c -= b; c ^= ( b &gt;&gt; 15 ); } while (0)</cpp:value></cpp:define>












<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_JEN</name><parameter_list>(<parameter><type><name>key</name></type></parameter>,<parameter><type><name>keylen</name></type></parameter>,<parameter><type><name>num_bkts</name></type></parameter>,<parameter><type><name>hashv</name></type></parameter>,<parameter><type><name>bkt</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { unsigned _hj_i,_hj_j,_hj_k; char *_hj_key=(char*)(key); hashv = 0xfeedbeef; _hj_i = _hj_j = 0x9e3779b9; _hj_k = (unsigned)keylen; while (_hj_k &gt;= 12) { _hj_i += (_hj_key[0] + ( (unsigned)_hj_key[1] &lt;&lt; 8 ) + ( (unsigned)_hj_key[2] &lt;&lt; 16 ) + ( (unsigned)_hj_key[3] &lt;&lt; 24 ) ); _hj_j += (_hj_key[4] + ( (unsigned)_hj_key[5] &lt;&lt; 8 ) + ( (unsigned)_hj_key[6] &lt;&lt; 16 ) + ( (unsigned)_hj_key[7] &lt;&lt; 24 ) ); hashv += (_hj_key[8] + ( (unsigned)_hj_key[9] &lt;&lt; 8 ) + ( (unsigned)_hj_key[10] &lt;&lt; 16 ) + ( (unsigned)_hj_key[11] &lt;&lt; 24 ) ); HASH_JEN_MIX(_hj_i, _hj_j, hashv); _hj_key += 12; _hj_k -= 12; } hashv += keylen; switch ( _hj_k ) { case 11: hashv += ( (unsigned)_hj_key[10] &lt;&lt; 24 ); case 10: hashv += ( (unsigned)_hj_key[9] &lt;&lt; 16 ); case 9: hashv += ( (unsigned)_hj_key[8] &lt;&lt; 8 ); case 8: _hj_j += ( (unsigned)_hj_key[7] &lt;&lt; 24 ); case 7: _hj_j += ( (unsigned)_hj_key[6] &lt;&lt; 16 ); case 6: _hj_j += ( (unsigned)_hj_key[5] &lt;&lt; 8 ); case 5: _hj_j += _hj_key[4]; case 4: _hj_i += ( (unsigned)_hj_key[3] &lt;&lt; 24 ); case 3: _hj_i += ( (unsigned)_hj_key[2] &lt;&lt; 16 ); case 2: _hj_i += ( (unsigned)_hj_key[1] &lt;&lt; 8 ); case 1: _hj_i += _hj_key[0]; } HASH_JEN_MIX(_hj_i, _hj_j, hashv); bkt = hashv &amp; (num_bkts-1); } while(0)</cpp:value></cpp:define>









































<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>get16bits</name></cpp:undef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__i386__</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__WATCOMC__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name> <argument_list>(<argument><expr><name>__BORLANDC__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name> <argument_list>(<argument><expr><name>__TURBOC__</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>get16bits</name><parameter_list>(<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(*((const uint16_t *) (d)))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name> <argument_list>(<argument><expr><name>get16bits</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>get16bits</name><parameter_list>(<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((((uint32_t)(((const uint8_t *)(d))[1])) &lt;&lt; 8) +(uint32_t)(((const uint8_t *)(d))[0]) )</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_SFH</name><parameter_list>(<parameter><type><name>key</name></type></parameter>,<parameter><type><name>keylen</name></type></parameter>,<parameter><type><name>num_bkts</name></type></parameter>,<parameter><type><name>hashv</name></type></parameter>,<parameter><type><name>bkt</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { char *_sfh_key=(char*)(key); uint32_t _sfh_tmp, _sfh_len = keylen; int _sfh_rem = _sfh_len &amp; 3; _sfh_len &gt;&gt;= 2; hashv = 0xcafebabe; for (;_sfh_len &gt; 0; _sfh_len--) { hashv += get16bits (_sfh_key); _sfh_tmp = (get16bits (_sfh_key+2) &lt;&lt; 11) ^ hashv; hashv = (hashv &lt;&lt; 16) ^ _sfh_tmp; _sfh_key += 2*sizeof (uint16_t); hashv += hashv &gt;&gt; 11; } switch (_sfh_rem) { case 3: hashv += get16bits (_sfh_key); hashv ^= hashv &lt;&lt; 16; hashv ^= _sfh_key[sizeof (uint16_t)] &lt;&lt; 18; hashv += hashv &gt;&gt; 11; break; case 2: hashv += get16bits (_sfh_key); hashv ^= hashv &lt;&lt; 11; hashv += hashv &gt;&gt; 17; break; case 1: hashv += *_sfh_key; hashv ^= hashv &lt;&lt; 10; hashv += hashv &gt;&gt; 1; } hashv ^= hashv &lt;&lt; 3; hashv += hashv &gt;&gt; 5; hashv ^= hashv &lt;&lt; 4; hashv += hashv &gt;&gt; 17; hashv ^= hashv &lt;&lt; 25; hashv += hashv &gt;&gt; 6; bkt = hashv &amp; (num_bkts-1); } while(0)</cpp:value></cpp:define>











































<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HASH_USING_NO_STRICT_ALIASING</name></expr></argument>)</argument_list></call></expr></cpp:if>









<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>__i386__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__x86_64__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_M_IX86</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUR_GETBLOCK</name><parameter_list>(<parameter><type><name>p</name></type></parameter>,<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>p[i]</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUR_PLUS0_ALIGNED</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((unsigned long)p &amp; 0x3) == 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUR_PLUS1_ALIGNED</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((unsigned long)p &amp; 0x3) == 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUR_PLUS2_ALIGNED</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((unsigned long)p &amp; 0x3) == 2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUR_PLUS3_ALIGNED</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((unsigned long)p &amp; 0x3) == 3)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WP</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((uint32_t*)((unsigned long)(p) &amp; ~3UL))</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>__BIG_ENDIAN__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SPARC</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__ppc__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__ppc64__</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUR_THREE_ONE</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((((*WP(p))&amp;0x00ffffff) &lt;&lt; 8) | (((*(WP(p)+1))&amp;0xff000000) &gt;&gt; 24))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUR_TWO_TWO</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((((*WP(p))&amp;0x0000ffff) &lt;&lt;16) | (((*(WP(p)+1))&amp;0xffff0000) &gt;&gt; 16))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUR_ONE_THREE</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((((*WP(p))&amp;0x000000ff) &lt;&lt;24) | (((*(WP(p)+1))&amp;0xffffff00) &gt;&gt; 8))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUR_THREE_ONE</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((((*WP(p))&amp;0xffffff00) &gt;&gt; 8) | (((*(WP(p)+1))&amp;0x000000ff) &lt;&lt; 24))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUR_TWO_TWO</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((((*WP(p))&amp;0xffff0000) &gt;&gt;16) | (((*(WP(p)+1))&amp;0x0000ffff) &lt;&lt; 16))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUR_ONE_THREE</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((((*WP(p))&amp;0xff000000) &gt;&gt;24) | (((*(WP(p)+1))&amp;0x00ffffff) &lt;&lt; 8))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUR_GETBLOCK</name><parameter_list>(<parameter><type><name>p</name></type></parameter>,<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(MUR_PLUS0_ALIGNED(p) ? ((p)[i]) : (MUR_PLUS1_ALIGNED(p) ? MUR_THREE_ONE(p) : (MUR_PLUS2_ALIGNED(p) ? MUR_TWO_TWO(p) : MUR_ONE_THREE(p))))</cpp:value></cpp:define>



<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUR_ROTL32</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>r</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((x) &lt;&lt; (r)) | ((x) &gt;&gt; (32 - (r))))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUR_FMIX</name><parameter_list>(<parameter><type><name>_h</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { _h ^= _h &gt;&gt; 16; _h *= 0x85ebca6b; _h ^= _h &gt;&gt; 13; _h *= 0xc2b2ae35l; _h ^= _h &gt;&gt; 16; } while(0)</cpp:value></cpp:define>








<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_MUR</name><parameter_list>(<parameter><type><name>key</name></type></parameter>,<parameter><type><name>keylen</name></type></parameter>,<parameter><type><name>num_bkts</name></type></parameter>,<parameter><type><name>hashv</name></type></parameter>,<parameter><type><name>bkt</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { const uint8_t *_mur_data = (const uint8_t*)(key); const int _mur_nblocks = (keylen) / 4; uint32_t _mur_h1 = 0xf88D5353; uint32_t _mur_c1 = 0xcc9e2d51; uint32_t _mur_c2 = 0x1b873593; uint32_t _mur_k1 = 0; const uint8_t *_mur_tail; const uint32_t *_mur_blocks = (const uint32_t*)(_mur_data+_mur_nblocks*4); int _mur_i; for(_mur_i = -_mur_nblocks; _mur_i; _mur_i++) { _mur_k1 = MUR_GETBLOCK(_mur_blocks,_mur_i); _mur_k1 *= _mur_c1; _mur_k1 = MUR_ROTL32(_mur_k1,15); _mur_k1 *= _mur_c2; _mur_h1 ^= _mur_k1; _mur_h1 = MUR_ROTL32(_mur_h1,13); _mur_h1 = _mur_h1*5+0xe6546b64; } _mur_tail = (const uint8_t*)(_mur_data + _mur_nblocks*4); _mur_k1=0; switch((keylen) &amp; 3) { case 3: _mur_k1 ^= _mur_tail[2] &lt;&lt; 16; case 2: _mur_k1 ^= _mur_tail[1] &lt;&lt; 8; case 1: _mur_k1 ^= _mur_tail[0]; _mur_k1 *= _mur_c1; _mur_k1 = MUR_ROTL32(_mur_k1,15); _mur_k1 *= _mur_c2; _mur_h1 ^= _mur_k1; } _mur_h1 ^= (keylen); MUR_FMIX(_mur_h1); hashv = _mur_h1; bkt = hashv &amp; (num_bkts-1); } while(0)</cpp:value></cpp:define>




































<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_KEYCMP</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>memcmp(a,b,len)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_FIND_IN_BKT</name><parameter_list>(<parameter><type><name>tbl</name></type></parameter>,<parameter><type><name>hh</name></type></parameter>,<parameter><type><name>head</name></type></parameter>,<parameter><type><name>keyptr</name></type></parameter>,<parameter><type><name>keylen_in</name></type></parameter>,<parameter><type><name>out</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (head.hh_head) DECLTYPE_ASSIGN(out,ELMT_FROM_HH(tbl,head.hh_head)); else out=NULL; while (out) { if ((out)-&gt;hh.keylen == keylen_in) { if ((HASH_KEYCMP((out)-&gt;hh.key,keyptr,keylen_in)) == 0) break; } if ((out)-&gt;hh.hh_next) DECLTYPE_ASSIGN(out,ELMT_FROM_HH(tbl,(out)-&gt;hh.hh_next)); else out = NULL; } } while(0)</cpp:value></cpp:define>













<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_ADD_TO_BKT</name><parameter_list>(<parameter><type><name>head</name></type></parameter>,<parameter><type><name>addhh</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { head.count++; (addhh)-&gt;hh_next = head.hh_head; (addhh)-&gt;hh_prev = NULL; if (head.hh_head) { (head).hh_head-&gt;hh_prev = (addhh); } (head).hh_head=addhh; if (head.count &gt;= ((head.expand_mult+1) * HASH_BKT_CAPACITY_THRESH) &amp;&amp; (addhh)-&gt;tbl-&gt;noexpand != 1) { HASH_EXPAND_BUCKETS((addhh)-&gt;tbl); } } while(0)</cpp:value></cpp:define>













<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_DEL_IN_BKT</name><parameter_list>(<parameter><type><name>hh</name></type></parameter>,<parameter><type><name>head</name></type></parameter>,<parameter><type><name>hh_del</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(head).count--; if ((head).hh_head == hh_del) { (head).hh_head = hh_del-&gt;hh_next; } if (hh_del-&gt;hh_prev) { hh_del-&gt;hh_prev-&gt;hh_next = hh_del-&gt;hh_next; } if (hh_del-&gt;hh_next) { hh_del-&gt;hh_next-&gt;hh_prev = hh_del-&gt;hh_prev; }</cpp:value></cpp:define>








































<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_EXPAND_BUCKETS</name><parameter_list>(<parameter><type><name>tbl</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { unsigned _he_bkt; unsigned _he_bkt_i; struct UT_hash_handle *_he_thh, *_he_hh_nxt; UT_hash_bucket *_he_new_buckets, *_he_newbkt; _he_new_buckets = (UT_hash_bucket*)uthash_malloc( 2 * tbl-&gt;num_buckets * sizeof(struct UT_hash_bucket)); if (!_he_new_buckets) { uthash_fatal( "out of memory"); } memset(_he_new_buckets, 0, 2 * tbl-&gt;num_buckets * sizeof(struct UT_hash_bucket)); tbl-&gt;ideal_chain_maxlen = (tbl-&gt;num_items &gt;&gt; (tbl-&gt;log2_num_buckets+1)) + ((tbl-&gt;num_items &amp; ((tbl-&gt;num_buckets*2)-1)) ? 1 : 0); tbl-&gt;nonideal_items = 0; for(_he_bkt_i = 0; _he_bkt_i &lt; tbl-&gt;num_buckets; _he_bkt_i++) { _he_thh = tbl-&gt;buckets[ _he_bkt_i ].hh_head; while (_he_thh) { _he_hh_nxt = _he_thh-&gt;hh_next; HASH_TO_BKT( _he_thh-&gt;hashv, tbl-&gt;num_buckets*2, _he_bkt); _he_newbkt = &amp;(_he_new_buckets[ _he_bkt ]); if (++(_he_newbkt-&gt;count) &gt; tbl-&gt;ideal_chain_maxlen) { tbl-&gt;nonideal_items++; _he_newbkt-&gt;expand_mult = _he_newbkt-&gt;count / tbl-&gt;ideal_chain_maxlen; } _he_thh-&gt;hh_prev = NULL; _he_thh-&gt;hh_next = _he_newbkt-&gt;hh_head; if (_he_newbkt-&gt;hh_head) _he_newbkt-&gt;hh_head-&gt;hh_prev = _he_thh; _he_newbkt-&gt;hh_head = _he_thh; _he_thh = _he_hh_nxt; } } uthash_free( tbl-&gt;buckets, tbl-&gt;num_buckets*sizeof(struct UT_hash_bucket) ); tbl-&gt;num_buckets *= 2; tbl-&gt;log2_num_buckets++; tbl-&gt;buckets = _he_new_buckets; tbl-&gt;ineff_expands = (tbl-&gt;nonideal_items &gt; (tbl-&gt;num_items &gt;&gt; 1)) ? (tbl-&gt;ineff_expands+1) : 0; if (tbl-&gt;ineff_expands &gt; 1) { tbl-&gt;noexpand=1; uthash_noexpand_fyi(tbl); } uthash_expand_fyi(tbl); } while(0)</cpp:value></cpp:define>



















































<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_SORT</name><parameter_list>(<parameter><type><name>head</name></type></parameter>,<parameter><type><name>cmpfcn</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>HASH_SRT(hh,head,cmpfcn)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_SRT</name><parameter_list>(<parameter><type><name>hh</name></type></parameter>,<parameter><type><name>head</name></type></parameter>,<parameter><type><name>cmpfcn</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { unsigned _hs_i; unsigned _hs_looping,_hs_nmerges,_hs_insize,_hs_psize,_hs_qsize; struct UT_hash_handle *_hs_p, *_hs_q, *_hs_e, *_hs_list, *_hs_tail; if (head) { _hs_insize = 1; _hs_looping = 1; _hs_list = &amp;((head)-&gt;hh); while (_hs_looping) { _hs_p = _hs_list; _hs_list = NULL; _hs_tail = NULL; _hs_nmerges = 0; while (_hs_p) { _hs_nmerges++; _hs_q = _hs_p; _hs_psize = 0; for ( _hs_i = 0; _hs_i &lt; _hs_insize; _hs_i++ ) { _hs_psize++; _hs_q = (UT_hash_handle*)((_hs_q-&gt;next) ? ((void*)((char*)(_hs_q-&gt;next) + (head)-&gt;hh.tbl-&gt;hho)) : NULL); if (! (_hs_q) ) break; } _hs_qsize = _hs_insize; while ((_hs_psize &gt; 0) || ((_hs_qsize &gt; 0) &amp;&amp; _hs_q )) { if (_hs_psize == 0) { _hs_e = _hs_q; _hs_q = (UT_hash_handle*)((_hs_q-&gt;next) ? ((void*)((char*)(_hs_q-&gt;next) + (head)-&gt;hh.tbl-&gt;hho)) : NULL); _hs_qsize--; } else if ( (_hs_qsize == 0) || !(_hs_q) ) { _hs_e = _hs_p; _hs_p = (UT_hash_handle*)((_hs_p-&gt;next) ? ((void*)((char*)(_hs_p-&gt;next) + (head)-&gt;hh.tbl-&gt;hho)) : NULL); _hs_psize--; } else if (( cmpfcn(DECLTYPE(head)(ELMT_FROM_HH((head)-&gt;hh.tbl,_hs_p)), DECLTYPE(head)(ELMT_FROM_HH((head)-&gt;hh.tbl,_hs_q))) ) &lt;= 0) { _hs_e = _hs_p; _hs_p = (UT_hash_handle*)((_hs_p-&gt;next) ? ((void*)((char*)(_hs_p-&gt;next) + (head)-&gt;hh.tbl-&gt;hho)) : NULL); _hs_psize--; } else { _hs_e = _hs_q; _hs_q = (UT_hash_handle*)((_hs_q-&gt;next) ? ((void*)((char*)(_hs_q-&gt;next) + (head)-&gt;hh.tbl-&gt;hho)) : NULL); _hs_qsize--; } if ( _hs_tail ) { _hs_tail-&gt;next = ((_hs_e) ? ELMT_FROM_HH((head)-&gt;hh.tbl,_hs_e) : NULL); } else { _hs_list = _hs_e; } _hs_e-&gt;prev = ((_hs_tail) ? ELMT_FROM_HH((head)-&gt;hh.tbl,_hs_tail) : NULL); _hs_tail = _hs_e; } _hs_p = _hs_q; } _hs_tail-&gt;next = NULL; if ( _hs_nmerges &lt;= 1 ) { _hs_looping=0; (head)-&gt;hh.tbl-&gt;tail = _hs_tail; DECLTYPE_ASSIGN(head,ELMT_FROM_HH((head)-&gt;hh.tbl, _hs_list)); } _hs_insize *= 2; } HASH_FSCK(hh,head); } } while (0)</cpp:value></cpp:define>



















































































<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_SELECT</name><parameter_list>(<parameter><type><name>hh_dst</name></type></parameter>, <parameter><type><name>dst</name></type></parameter>, <parameter><type><name>hh_src</name></type></parameter>, <parameter><type><name>src</name></type></parameter>, <parameter><type><name>cond</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { unsigned _src_bkt, _dst_bkt; void *_last_elt=NULL, *_elt; UT_hash_handle *_src_hh, *_dst_hh, *_last_elt_hh=NULL; ptrdiff_t _dst_hho = ((char*)(&amp;(dst)-&gt;hh_dst) - (char*)(dst)); if (src) { for(_src_bkt=0; _src_bkt &lt; (src)-&gt;hh_src.tbl-&gt;num_buckets; _src_bkt++) { for(_src_hh = (src)-&gt;hh_src.tbl-&gt;buckets[_src_bkt].hh_head; _src_hh; _src_hh = _src_hh-&gt;hh_next) { _elt = ELMT_FROM_HH((src)-&gt;hh_src.tbl, _src_hh); if (cond(_elt)) { _dst_hh = (UT_hash_handle*)(((char*)_elt) + _dst_hho); _dst_hh-&gt;key = _src_hh-&gt;key; _dst_hh-&gt;keylen = _src_hh-&gt;keylen; _dst_hh-&gt;hashv = _src_hh-&gt;hashv; _dst_hh-&gt;prev = _last_elt; _dst_hh-&gt;next = NULL; if (_last_elt_hh) { _last_elt_hh-&gt;next = _elt; } if (!dst) { DECLTYPE_ASSIGN(dst,_elt); HASH_MAKE_TABLE(hh_dst,dst); } else { _dst_hh-&gt;tbl = (dst)-&gt;hh_dst.tbl; } HASH_TO_BKT(_dst_hh-&gt;hashv, _dst_hh-&gt;tbl-&gt;num_buckets, _dst_bkt); HASH_ADD_TO_BKT(_dst_hh-&gt;tbl-&gt;buckets[_dst_bkt],_dst_hh); (dst)-&gt;hh_dst.tbl-&gt;num_items++; _last_elt = _elt; _last_elt_hh = _dst_hh; } } } } HASH_FSCK(hh_dst,dst); } while (0)</cpp:value></cpp:define>





































<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_CLEAR</name><parameter_list>(<parameter><type><name>hh</name></type></parameter>,<parameter><type><name>head</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (head) { uthash_free((head)-&gt;hh.tbl-&gt;buckets, (head)-&gt;hh.tbl-&gt;num_buckets*sizeof(struct UT_hash_bucket)); HASH_BLOOM_FREE((head)-&gt;hh.tbl); uthash_free((head)-&gt;hh.tbl, sizeof(UT_hash_table)); (head)=NULL; } } while(0)</cpp:value></cpp:define>










<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NO_DECLTYPE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_ITER</name><parameter_list>(<parameter><type><name>hh</name></type></parameter>,<parameter><type><name>head</name></type></parameter>,<parameter><type><name>el</name></type></parameter>,<parameter><type><name>tmp</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>for((el)=(head), (*(char**)(&amp;(tmp)))=(char*)((head)?(head)-&gt;hh.next:NULL); el; (el)=(tmp),(*(char**)(&amp;(tmp)))=(char*)((tmp)?(tmp)-&gt;hh.next:NULL))</cpp:value></cpp:define>


<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_ITER</name><parameter_list>(<parameter><type><name>hh</name></type></parameter>,<parameter><type><name>head</name></type></parameter>,<parameter><type><name>el</name></type></parameter>,<parameter><type><name>tmp</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>for((el)=(head),(tmp)=DECLTYPE(el)((head)?(head)-&gt;hh.next:NULL); el; (el)=(tmp),(tmp)=DECLTYPE(el)((tmp)?(tmp)-&gt;hh.next:NULL))</cpp:value></cpp:define>


<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_COUNT</name><parameter_list>(<parameter><type><name>head</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>HASH_CNT(hh,head)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_CNT</name><parameter_list>(<parameter><type><name>hh</name></type></parameter>,<parameter><type><name>head</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((head)?((head)-&gt;hh.tbl-&gt;num_items):0)</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>UT_hash_bucket</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>UT_hash_handle</name></name> <modifier>*</modifier></type><name>hh_head</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>count</name></decl>;</decl_stmt>













<decl_stmt><decl><type><name>unsigned</name></type> <name>expand_mult</name></decl>;</decl_stmt>

}</block></struct></type> <name>UT_hash_bucket</name>;</typedef>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_SIGNATURE</name></cpp:macro> <cpp:value>0xa0111fe1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASH_BLOOM_SIGNATURE</name></cpp:macro> <cpp:value>0xb12220f2</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>UT_hash_table</name> <block>{
<decl_stmt><decl><type><name>UT_hash_bucket</name> <modifier>*</modifier></type><name>buckets</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>num_buckets</name></decl>, <name>log2_num_buckets</name>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>num_items</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>UT_hash_handle</name></name> <modifier>*</modifier></type><name>tail</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>hho</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>ideal_chain_maxlen</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>unsigned</name></type> <name>nonideal_items</name></decl>;</decl_stmt>







<decl_stmt><decl><type><name>unsigned</name></type> <name>ineff_expands</name></decl>, <name>noexpand</name>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>signature</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HASH_BLOOM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>bloom_sig</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>bloom_bv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>bloom_nbits</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

}</block></struct></type> <name>UT_hash_table</name>;</typedef>

<typedef>typedef <type><struct>struct <name>UT_hash_handle</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>UT_hash_table</name></name> <modifier>*</modifier></type><name>tbl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>UT_hash_handle</name></name> <modifier>*</modifier></type><name>hh_prev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>UT_hash_handle</name></name> <modifier>*</modifier></type><name>hh_next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>key</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>keylen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>hashv</name></decl>;</decl_stmt>
}</block></struct></type> <name>UT_hash_handle</name>;</typedef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
