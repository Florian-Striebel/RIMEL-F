<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/elftoolchain/elfcopy/main.c">

























<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/param.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;err.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;getopt.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;libelftc.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"elfcopy.h"</cpp:file></cpp:include>

<expr_stmt><expr><call><name>ELFTC_VCSID</name><argument_list>(<argument><expr><literal type="string">"$Id: main.c 3757 2019-06-28 01:15:28Z emaste $"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<enum>enum <name>options</name>
<block>{
<decl><name>ECP_ADD_GNU_DEBUGLINK</name></decl>,
<decl><name>ECP_ADD_SECTION</name></decl>,
<decl><name>ECP_CHANGE_ADDR</name></decl>,
<decl><name>ECP_CHANGE_SEC_ADDR</name></decl>,
<decl><name>ECP_CHANGE_SEC_LMA</name></decl>,
<decl><name>ECP_CHANGE_SEC_VMA</name></decl>,
<decl><name>ECP_CHANGE_START</name></decl>,
<decl><name>ECP_CHANGE_WARN</name></decl>,
<decl><name>ECP_GAP_FILL</name></decl>,
<decl><name>ECP_GLOBALIZE_SYMBOL</name></decl>,
<decl><name>ECP_GLOBALIZE_SYMBOLS</name></decl>,
<decl><name>ECP_KEEP_SYMBOLS</name></decl>,
<decl><name>ECP_KEEP_GLOBAL_SYMBOLS</name></decl>,
<decl><name>ECP_LOCALIZE_HIDDEN</name></decl>,
<decl><name>ECP_LOCALIZE_SYMBOLS</name></decl>,
<decl><name>ECP_NO_CHANGE_WARN</name></decl>,
<decl><name>ECP_ONLY_DEBUG</name></decl>,
<decl><name>ECP_ONLY_DWO</name></decl>,
<decl><name>ECP_PAD_TO</name></decl>,
<decl><name>ECP_PREFIX_ALLOC</name></decl>,
<decl><name>ECP_PREFIX_SEC</name></decl>,
<decl><name>ECP_PREFIX_SYM</name></decl>,
<decl><name>ECP_REDEF_SYMBOL</name></decl>,
<decl><name>ECP_REDEF_SYMBOLS</name></decl>,
<decl><name>ECP_RENAME_SECTION</name></decl>,
<decl><name>ECP_SET_OSABI</name></decl>,
<decl><name>ECP_SET_SEC_FLAGS</name></decl>,
<decl><name>ECP_SET_START</name></decl>,
<decl><name>ECP_SREC_FORCE_S3</name></decl>,
<decl><name>ECP_SREC_LEN</name></decl>,
<decl><name>ECP_STRIP_DWO</name></decl>,
<decl><name>ECP_STRIP_SYMBOLS</name></decl>,
<decl><name>ECP_STRIP_UNNEEDED</name></decl>,
<decl><name>ECP_WEAKEN_ALL</name></decl>,
<decl><name>ECP_WEAKEN_SYMBOLS</name></decl>
}</block>;</enum>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>option</name></name></type> <name><name>mcs_longopts</name><index>[]</index></name> <init>=
<expr><block>{
<expr><block>{ <expr><literal type="string">"help"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'h'</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="string">"version"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'V'</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>option</name></name></type> <name><name>strip_longopts</name><index>[]</index></name> <init>=
<expr><block>{
<expr><block>{<expr><literal type="string">"discard-all"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'x'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"discard-locals"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'X'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"help"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'h'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"input-target"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'I'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"keep-symbol"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'K'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"only-keep-debug"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><name>ECP_ONLY_DEBUG</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"output-file"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'o'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"output-target"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'O'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"preserve-dates"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'p'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"remove-section"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'R'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"strip-all"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'s'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"strip-debug"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'S'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"strip-symbol"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'N'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"strip-unneeded"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><name>ECP_STRIP_UNNEEDED</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"version"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'V'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"wildcard"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'w'</literal></expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>option</name></name></type> <name><name>elfcopy_longopts</name><index>[]</index></name> <init>=
<expr><block>{
<expr><block>{<expr><literal type="string">"add-gnu-debuglink"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><name>ECP_ADD_GNU_DEBUGLINK</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"add-section"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><name>ECP_ADD_SECTION</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"adjust-section-vma"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><name>ECP_CHANGE_SEC_ADDR</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"adjust-vma"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><name>ECP_CHANGE_ADDR</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"adjust-start"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><name>ECP_CHANGE_START</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"adjust-warnings"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><name>ECP_CHANGE_WARN</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"binary-architecture"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'B'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"change-addresses"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><name>ECP_CHANGE_ADDR</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"change-section-address"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>,
<expr><name>ECP_CHANGE_SEC_ADDR</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"change-section-lma"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><name>ECP_CHANGE_SEC_LMA</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"change-section-vma"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><name>ECP_CHANGE_SEC_VMA</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"change-start"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><name>ECP_CHANGE_START</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"change-warnings"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><name>ECP_CHANGE_WARN</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"discard-all"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'x'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"discard-locals"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'X'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"extract-dwo"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><name>ECP_ONLY_DWO</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"gap-fill"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><name>ECP_GAP_FILL</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"globalize-symbol"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><name>ECP_GLOBALIZE_SYMBOL</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"globalize-symbols"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><name>ECP_GLOBALIZE_SYMBOLS</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"help"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'h'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"input-target"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'I'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"keep-symbol"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'K'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"keep-symbols"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><name>ECP_KEEP_SYMBOLS</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"keep-global-symbol"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'G'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"keep-global-symbols"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>,
<expr><name>ECP_KEEP_GLOBAL_SYMBOLS</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"localize-hidden"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><name>ECP_LOCALIZE_HIDDEN</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"localize-symbol"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'L'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"localize-symbols"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><name>ECP_LOCALIZE_SYMBOLS</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"no-adjust-warnings"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><name>ECP_NO_CHANGE_WARN</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"no-change-warnings"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><name>ECP_NO_CHANGE_WARN</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"only-keep-debug"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><name>ECP_ONLY_DEBUG</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"only-section"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'j'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"osabi"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><name>ECP_SET_OSABI</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"output-target"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'O'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"pad-to"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><name>ECP_PAD_TO</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"preserve-dates"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'p'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"prefix-alloc-sections"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><name>ECP_PREFIX_ALLOC</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"prefix-sections"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><name>ECP_PREFIX_SEC</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"prefix-symbols"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><name>ECP_PREFIX_SYM</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"redefine-sym"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><name>ECP_REDEF_SYMBOL</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"redefine-syms"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><name>ECP_REDEF_SYMBOLS</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"remove-section"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'R'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"rename-section"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><name>ECP_RENAME_SECTION</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"set-section-flags"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><name>ECP_SET_SEC_FLAGS</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"set-start"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><name>ECP_SET_START</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"srec-forceS3"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><name>ECP_SREC_FORCE_S3</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"srec-len"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><name>ECP_SREC_LEN</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"strip-all"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'S'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"strip-debug"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="char">'g'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"strip-dwo"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><name>ECP_STRIP_DWO</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"strip-symbol"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'N'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"strip-symbols"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><name>ECP_STRIP_SYMBOLS</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"strip-unneeded"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><name>ECP_STRIP_UNNEEDED</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"version"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'V'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"weaken"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><name>ECP_WEAKEN_ALL</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"weaken-symbol"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'W'</literal></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"weaken-symbols"</literal></expr>, <expr><name>required_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><name>ECP_WEAKEN_SYMBOLS</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"wildcard"</literal></expr>, <expr><name>no_argument</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="char">'w'</literal></expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<struct><specifier>static</specifier> struct <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>value</name></decl>;</decl_stmt>
}</block> <decl><name><name>sec_flags</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr><literal type="string">"alloc"</literal></expr>, <expr><name>SF_ALLOC</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"load"</literal></expr>, <expr><name>SF_LOAD</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"noload"</literal></expr>, <expr><name>SF_NOLOAD</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"readonly"</literal></expr>, <expr><name>SF_READONLY</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"debug"</literal></expr>, <expr><name>SF_DEBUG</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"code"</literal></expr>, <expr><name>SF_CODE</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"data"</literal></expr>, <expr><name>SF_DATA</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"rom"</literal></expr>, <expr><name>SF_ROM</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"share"</literal></expr>, <expr><name>SF_SHARED</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"contents"</literal></expr>, <expr><name>SF_CONTENTS</name></expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>
}</block></expr></init></decl>;</struct>

<struct><specifier>static</specifier> struct <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>abi</name></decl>;</decl_stmt>
}</block> <decl><name><name>osabis</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr><literal type="string">"sysv"</literal></expr>, <expr><name>ELFOSABI_SYSV</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"hpus"</literal></expr>, <expr><name>ELFOSABI_HPUX</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"netbsd"</literal></expr>, <expr><name>ELFOSABI_NETBSD</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"linux"</literal></expr>, <expr><name>ELFOSABI_LINUX</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"hurd"</literal></expr>, <expr><name>ELFOSABI_HURD</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"86open"</literal></expr>, <expr><name>ELFOSABI_86OPEN</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"solaris"</literal></expr>, <expr><name>ELFOSABI_SOLARIS</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"aix"</literal></expr>, <expr><name>ELFOSABI_AIX</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"irix"</literal></expr>, <expr><name>ELFOSABI_IRIX</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"freebsd"</literal></expr>, <expr><name>ELFOSABI_FREEBSD</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"tru64"</literal></expr>, <expr><name>ELFOSABI_TRU64</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"modesto"</literal></expr>, <expr><name>ELFOSABI_MODESTO</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"openbsd"</literal></expr>, <expr><name>ELFOSABI_OPENBSD</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"openvms"</literal></expr>, <expr><name>ELFOSABI_OPENVMS</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"nsk"</literal></expr>, <expr><name>ELFOSABI_NSK</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"cloudabi"</literal></expr>, <expr><name>ELFOSABI_CLOUDABI</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"arm"</literal></expr>, <expr><name>ELFOSABI_ARM</name></expr>}</block></expr>,
<expr><block>{<expr><literal type="string">"standalone"</literal></expr>, <expr><name>ELFOSABI_STANDALONE</name></expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>
}</block></expr></init></decl>;</struct>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>copy_from_tempfile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>infd</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>outfd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>in_place</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>create_file</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfcopy</name></name> <modifier>*</modifier></type><name>ecp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>elfcopy_main</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfcopy</name></name> <modifier>*</modifier></type><name>ecp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>elfcopy_usage</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>mcs_main</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfcopy</name></name> <modifier>*</modifier></type><name>ecp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>mcs_usage</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>parse_sec_address_op</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfcopy</name></name> <modifier>*</modifier></type><name>ecp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>optnum</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>optname</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>parse_sec_flags</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sec_action</name></name> <modifier>*</modifier></type><name>sac</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>parse_symlist_file</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfcopy</name></name> <modifier>*</modifier></type><name>ecp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fn</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>op</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>print_version</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_input_target</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfcopy</name></name> <modifier>*</modifier></type><name>ecp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>target_name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_osabi</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfcopy</name></name> <modifier>*</modifier></type><name>ecp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>abi</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_output_target</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfcopy</name></name> <modifier>*</modifier></type><name>ecp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>target_name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>strip_main</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfcopy</name></name> <modifier>*</modifier></type><name>ecp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>strip_usage</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>










































<function><type><name>void</name></type>
<name>create_elf</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfcopy</name></name> <modifier>*</modifier></type><name>ecp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>shtab</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GElf_Ehdr</name></type> <name>ieh</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GElf_Ehdr</name></type> <name>oeh</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>ishnum</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>SYMTAB_INTACT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>SYMTAB_EXIST</name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>gelf_getehdr</name><argument_list>(<argument><expr><name><name>ecp</name><operator>-&gt;</operator><name>ein</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ieh</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"gelf_getehdr() failed: %s"</literal></expr></argument>,
<argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ecp</name><operator>-&gt;</operator><name>iec</name></name> <operator>=</operator> <call><name>gelf_getclass</name><argument_list>(<argument><expr><name><name>ecp</name><operator>-&gt;</operator><name>ein</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>ELFCLASSNONE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"getclass() failed: %s"</literal></expr></argument>,
<argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ecp</name><operator>-&gt;</operator><name>oec</name></name> <operator>==</operator> <name>ELFCLASSNONE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>oec</name></name> <operator>=</operator> <name><name>ecp</name><operator>-&gt;</operator><name>iec</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ecp</name><operator>-&gt;</operator><name>oed</name></name> <operator>==</operator> <name>ELFDATANONE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>oed</name></name> <operator>=</operator> <name><name>ieh</name><operator>.</operator><name>e_ident</name><index>[<expr><name>EI_DATA</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>gelf_newehdr</name><argument_list>(<argument><expr><name><name>ecp</name><operator>-&gt;</operator><name>eout</name></name></expr></argument>, <argument><expr><name><name>ecp</name><operator>-&gt;</operator><name>oec</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"gelf_newehdr failed: %s"</literal></expr></argument>,
<argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>gelf_getehdr</name><argument_list>(<argument><expr><name><name>ecp</name><operator>-&gt;</operator><name>eout</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oeh</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"gelf_getehdr() failed: %s"</literal></expr></argument>,
<argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>oeh</name><operator>.</operator><name>e_ident</name></name></expr></argument>, <argument><expr><name><name>ieh</name><operator>.</operator><name>e_ident</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>ieh</name><operator>.</operator><name>e_ident</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>oeh</name><operator>.</operator><name>e_ident</name><index>[<expr><name>EI_CLASS</name></expr>]</index></name> <operator>=</operator> <name><name>ecp</name><operator>-&gt;</operator><name>oec</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>oeh</name><operator>.</operator><name>e_ident</name><index>[<expr><name>EI_DATA</name></expr>]</index></name> <operator>=</operator> <name><name>ecp</name><operator>-&gt;</operator><name>oed</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ecp</name><operator>-&gt;</operator><name>abi</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>oeh</name><operator>.</operator><name>e_ident</name><index>[<expr><name>EI_OSABI</name></expr>]</index></name> <operator>=</operator> <name><name>ecp</name><operator>-&gt;</operator><name>abi</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>oeh</name><operator>.</operator><name>e_flags</name></name> <operator>=</operator> <name><name>ieh</name><operator>.</operator><name>e_flags</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>oeh</name><operator>.</operator><name>e_machine</name></name> <operator>=</operator> <name><name>ieh</name><operator>.</operator><name>e_machine</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>oeh</name><operator>.</operator><name>e_type</name></name> <operator>=</operator> <name><name>ieh</name><operator>.</operator><name>e_type</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>oeh</name><operator>.</operator><name>e_entry</name></name> <operator>=</operator> <name><name>ieh</name><operator>.</operator><name>e_entry</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>oeh</name><operator>.</operator><name>e_version</name></name> <operator>=</operator> <name><name>ieh</name><operator>.</operator><name>e_version</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>EXECUTABLE</name> <operator>|</operator> <name>DYNAMIC</name> <operator>|</operator> <name>RELOCATABLE</name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ieh</name><operator>.</operator><name>e_type</name></name> <operator>==</operator> <name>ET_EXEC</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>EXECUTABLE</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>ieh</name><operator>.</operator><name>e_type</name></name> <operator>==</operator> <name>ET_DYN</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>DYNAMIC</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>ieh</name><operator>.</operator><name>e_type</name></name> <operator>==</operator> <name>ET_REL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>RELOCATABLE</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"unsupported e_type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>elf_getshnum</name><argument_list>(<argument><expr><name><name>ecp</name><operator>-&gt;</operator><name>ein</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ishnum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"elf_getshnum failed: %s"</literal></expr></argument>,
<argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ishnum</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ecp</name><operator>-&gt;</operator><name>secndx</name></name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><name>ishnum</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>ecp</name><operator>-&gt;</operator><name>secndx</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"calloc failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>setup_phdr</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>







<expr_stmt><expr><call><name>create_scn</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>adjust_addr</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<if_stmt><if>if <condition>(<expr><name><name>ecp</name><operator>-&gt;</operator><name>strip</name></name> <operator>==</operator> <name>STRIP_DEBUG</name> <operator>||</operator>
<name><name>ecp</name><operator>-&gt;</operator><name>strip</name></name> <operator>==</operator> <name>STRIP_UNNEEDED</name> <operator>||</operator>
<name><name>ecp</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>WEAKEN_ALL</name> <operator>||</operator>
<name><name>ecp</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>LOCALIZE_HIDDEN</name> <operator>||</operator>
<name><name>ecp</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>DISCARD_LOCAL</name> <operator>||</operator>
<name><name>ecp</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>DISCARD_LLABEL</name> <operator>||</operator>
<name><name>ecp</name><operator>-&gt;</operator><name>prefix_sym</name></name> <operator>!=</operator> <name>NULL</name> <operator>||</operator>
<operator>!</operator><call><name>STAILQ_EMPTY</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ecp</name><operator>-&gt;</operator><name>v_symop</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>SYMTAB_INTACT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>






<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ecp</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SYMTAB_EXIST</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>create_symtab</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>





<if_stmt><if>if <condition>(<expr><call><name>gelf_update_ehdr</name><argument_list>(<argument><expr><name><name>ecp</name><operator>-&gt;</operator><name>eout</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oeh</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"gelf_update_ehdr() failed: %s"</literal></expr></argument>,
<argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>








<expr_stmt><expr><call><name>copy_content</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>






<expr_stmt><expr><call><name>update_shdr</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>gelf_getehdr</name><argument_list>(<argument><expr><name><name>ecp</name><operator>-&gt;</operator><name>eout</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oeh</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"gelf_getehdr() failed: %s"</literal></expr></argument>,
<argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>














<if_stmt><if>if <condition>(<expr><name><name>oeh</name><operator>.</operator><name>e_ident</name><index>[<expr><name>EI_OSABI</name></expr>]</index></name> <operator>==</operator> <name>ELFOSABI_FREEBSD</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>shtab</name> <operator>=</operator> <call><name>insert_shtab</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>shtab</name> <operator>=</operator> <call><name>insert_shtab</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>






<expr_stmt><expr><call><name>resync_sections</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name><name>oeh</name><operator>.</operator><name>e_shoff</name></name> <operator>=</operator> <name><name>shtab</name><operator>-&gt;</operator><name>off</name></name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>ecp</name><operator>-&gt;</operator><name>ophnum</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>oeh</name><operator>.</operator><name>e_phoff</name></name> <operator>=</operator> <call><name>gelf_fsize</name><argument_list>(<argument><expr><name><name>ecp</name><operator>-&gt;</operator><name>eout</name></name></expr></argument>, <argument><expr><name>ELF_T_EHDR</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>EV_CURRENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>oeh</name><operator>.</operator><name>e_phoff</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"gelf_fsize() failed: %s"</literal></expr></argument>,
<argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><name><name>ecp</name><operator>-&gt;</operator><name>change_addr</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>oeh</name><operator>.</operator><name>e_entry</name></name> <operator>+=</operator> <name><name>ecp</name><operator>-&gt;</operator><name>change_addr</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ecp</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SET_START</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>oeh</name><operator>.</operator><name>e_entry</name></name> <operator>=</operator> <name><name>ecp</name><operator>-&gt;</operator><name>set_start</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ecp</name><operator>-&gt;</operator><name>change_start</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>oeh</name><operator>.</operator><name>e_entry</name></name> <operator>+=</operator> <name><name>ecp</name><operator>-&gt;</operator><name>change_start</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>





<if_stmt><if>if <condition>(<expr><call><name>gelf_update_ehdr</name><argument_list>(<argument><expr><name><name>ecp</name><operator>-&gt;</operator><name>eout</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oeh</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"gelf_update_ehdr() failed: %s"</literal></expr></argument>,
<argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ecp</name><operator>-&gt;</operator><name>ophnum</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>copy_phdr</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>elf_update</name><argument_list>(<argument><expr><name><name>ecp</name><operator>-&gt;</operator><name>eout</name></name></expr></argument>, <argument><expr><name>ELF_C_WRITE</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"elf_update() failed: %s"</literal></expr></argument>,
<argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>free_elf</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>free_elf</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfcopy</name></name> <modifier>*</modifier></type><name>ecp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>segment</name></name> <modifier>*</modifier></type><name>seg</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>seg_temp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>section</name></name> <modifier>*</modifier></type><name>sec</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sec_temp</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>STAILQ_EMPTY</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ecp</name><operator>-&gt;</operator><name>v_seg</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<macro><name>STAILQ_FOREACH_SAFE</name><argument_list>(<argument>seg</argument>, <argument>&amp;ecp-&gt;v_seg</argument>, <argument>seg_list</argument>, <argument>seg_temp</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>STAILQ_REMOVE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ecp</name><operator>-&gt;</operator><name>v_seg</name></name></expr></argument>, <argument><expr><name>seg</name></expr></argument>, <argument><expr><name>segment</name></expr></argument>, <argument><expr><name>seg_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>seg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>free_symtab</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>elftc_string_table_destroy</name><argument_list>(<argument><expr><name><name>ecp</name><operator>-&gt;</operator><name>shstrtab</name><operator>-&gt;</operator><name>strtab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TAILQ_EMPTY</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ecp</name><operator>-&gt;</operator><name>v_sec</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<macro><name>TAILQ_FOREACH_SAFE</name><argument_list>(<argument>sec</argument>, <argument>&amp;ecp-&gt;v_sec</argument>, <argument>sec_list</argument>, <argument>sec_temp</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>TAILQ_REMOVE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ecp</name><operator>-&gt;</operator><name>v_sec</name></name></expr></argument>, <argument><expr><name>sec</name></expr></argument>, <argument><expr><name>sec_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sec</name><operator>-&gt;</operator><name>buf</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>sec</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sec</name><operator>-&gt;</operator><name>newname</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>sec</name><operator>-&gt;</operator><name>newname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sec</name><operator>-&gt;</operator><name>pad</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>sec</name><operator>-&gt;</operator><name>pad</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>sec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>symtab</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>strtab</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>shstrtab</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ecp</name><operator>-&gt;</operator><name>secndx</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>ecp</name><operator>-&gt;</operator><name>secndx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>secndx</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>






<function><type><name>int</name></type>
<name>cleanup_tempfile</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>errno_save</name></decl>, <decl><type ref="prev"/><name>retval</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fn</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>errno_save</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>retval</name> <operator>=</operator> <call><name>unlink</name><argument_list>(<argument><expr><name>fn</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>warn</name><argument_list>(<argument><expr><literal type="string">"unlink tempfile %s failed"</literal></expr></argument>, <argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>errno_save</name></expr>;</expr_stmt>
<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>create_tempfile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>fn</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>_TEMPDIR</name><index>[]</index></name> <init>= <expr><literal type="string">"/tmp/"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>_TEMPFILE</name><index>[]</index></name> <init>= <expr><literal type="string">"ecp.XXXXXXXX"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tmpdir</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmpf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>tlen</name></decl>, <decl><type ref="prev"/><name>slen</name></decl>, <decl><type ref="prev"/><name>plen</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fn</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>fd</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>src</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>tmpdir</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"TMPDIR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tmpdir</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>*</operator><name>tmpdir</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>tmpdir</name> <operator>=</operator> <name>_TEMPDIR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>tlen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>tmpdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>slen</name> <operator>=</operator> <ternary><condition><expr><name><name>tmpdir</name><index>[<expr><name>tlen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>tmpdir</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>tlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>tlen</name> <operator>=</operator> <operator>++</operator><name>tmpdir</name> <operator>-</operator> <name>src</name></expr>;</expr_stmt>
<expr_stmt><expr><name>tmpdir</name> <operator>=</operator> <name>src</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>slen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>plen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>_TEMPFILE</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>tmpf</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>tlen</name> <operator>+</operator> <name>slen</name> <operator>+</operator> <name>plen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tmpf</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"malloc failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>tlen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>tmpf</name></expr></argument>, <argument><expr><name>tmpdir</name></expr></argument>, <argument><expr><name>tlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>slen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>tmpf</name><index>[<expr><name>tlen</name></expr>]</index></name> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>tmpf</name> <operator>+</operator> <name>tlen</name> <operator>+</operator> <name>slen</name></expr></argument>, <argument><expr><name>_TEMPFILE</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>fd</name> <operator>=</operator> <call><name>mkstemp</name><argument_list>(<argument><expr><name>tmpf</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>EACCES</name> <operator>||</operator> <name>src</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"mkstemp %s failed"</literal></expr></argument>, <argument><expr><name>tmpf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tmpf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>src</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><call><name>fchmod</name><argument_list>(<argument><expr><operator>*</operator><name>fd</name></expr></argument>, <argument><expr><literal type="number">0644</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"fchmod %s failed"</literal></expr></argument>, <argument><expr><name>tmpf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>fn</name> <operator>=</operator> <name>tmpf</name></expr>;</expr_stmt>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>int</name></type>
<name>copy_from_tempfile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>infd</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>outfd</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>in_place</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>tmpfd</name></decl>;</decl_stmt>




<if_stmt><if>if <condition>(<expr><name>in_place</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>rename</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>outfd</name> <operator>=</operator> <name>infd</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>EXDEV</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>EACCES</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>







<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>EACCES</name> <operator>&amp;&amp;</operator> <call><name>unlink</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>tmpfd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>O_CREAT</name> <operator>|</operator> <name>O_TRUNC</name> <operator>|</operator> <name>O_WRONLY</name></expr></argument>, <argument><expr><literal type="number">0755</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>elftc_copyfile</name><argument_list>(<argument><expr><name>infd</name></expr></argument>, <argument><expr><name>tmpfd</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>close</name><argument_list>(<argument><expr><name>tmpfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>





<if_stmt><if>if <condition>(<expr><call><name>unlink</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>close</name><argument_list>(<argument><expr><name>tmpfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>close</name><argument_list>(<argument><expr><name>infd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><operator>*</operator><name>outfd</name> <operator>=</operator> <name>tmpfd</name></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>create_file</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfcopy</name></name> <modifier>*</modifier></type><name>ecp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>sb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tempfile</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>elftemp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>efd</name></decl>, <decl><type ref="prev"/><name>ifd</name></decl>, <decl><type ref="prev"/><name>ofd</name></decl>, <decl><type ref="prev"/><name>ofd0</name></decl>, <decl><type ref="prev"/><name>tfd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>in_place</name></decl>;</decl_stmt>

<expr_stmt><expr><name>tempfile</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>src</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"internal: src == NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ifd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"open %s failed"</literal></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>fstat</name><argument_list>(<argument><expr><name>ifd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"fstat %s failed"</literal></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>dst</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>create_tempfile</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tempfile</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ofd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else
if <condition>(<expr><operator>(</operator><name>ofd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>O_RDWR</name><operator>|</operator><name>O_CREAT</name></expr></argument>, <argument><expr><literal type="number">0755</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"open %s failed"</literal></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LIBELF_AR</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><call><name>ac_detect_ar</name><argument_list>(<argument><expr><name>ifd</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ac_create_ar</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>, <argument><expr><name>ifd</name></expr></argument>, <argument><expr><name>ofd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>copy_done</name>;</goto>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><call><name>lseek</name><argument_list>(<argument><expr><name>ifd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>cleanup_tempfile</name><argument_list>(<argument><expr><name>tempfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"lseek failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>





<if_stmt><if>if <condition>(<expr><name><name>ecp</name><operator>-&gt;</operator><name>itf</name></name> <operator>!=</operator> <name>ETF_ELF</name></expr>)</condition> <block>{<block_content>






<if_stmt><if>if <condition>(<expr><name><name>ecp</name><operator>-&gt;</operator><name>otf</name></name> <operator>!=</operator> <name>ETF_ELF</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ecp</name><operator>-&gt;</operator><name>oec</name></name> <operator>==</operator> <name>ELFCLASSNONE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>oec</name></name> <operator>=</operator> <name>ELFCLASS64</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ecp</name><operator>-&gt;</operator><name>oed</name></name> <operator>==</operator> <name>ELFDATANONE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>oed</name></name> <operator>=</operator> <name>ELFDATA2LSB</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>create_tempfile</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elftemp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>efd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ecp</name><operator>-&gt;</operator><name>eout</name></name> <operator>=</operator> <call><name>elf_begin</name><argument_list>(<argument><expr><name>efd</name></expr></argument>, <argument><expr><name>ELF_C_WRITE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>cleanup_tempfile</name><argument_list>(<argument><expr><name>elftemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cleanup_tempfile</name><argument_list>(<argument><expr><name>tempfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"elf_begin() failed: %s"</literal></expr></argument>,
<argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>elf_flagelf</name><argument_list>(<argument><expr><name><name>ecp</name><operator>-&gt;</operator><name>eout</name></name></expr></argument>, <argument><expr><name>ELF_C_SET</name></expr></argument>, <argument><expr><name>ELF_F_LAYOUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ecp</name><operator>-&gt;</operator><name>itf</name></name> <operator>==</operator> <name>ETF_BINARY</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>create_elf_from_binary</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>, <argument><expr><name>ifd</name></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>ecp</name><operator>-&gt;</operator><name>itf</name></name> <operator>==</operator> <name>ETF_IHEX</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>create_elf_from_ihex</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>, <argument><expr><name>ifd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>ecp</name><operator>-&gt;</operator><name>itf</name></name> <operator>==</operator> <name>ETF_SREC</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>create_elf_from_srec</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>, <argument><expr><name>ifd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>cleanup_tempfile</name><argument_list>(<argument><expr><name>elftemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cleanup_tempfile</name><argument_list>(<argument><expr><name>tempfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"Internal: invalid target flavour"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>elf_end</name><argument_list>(<argument><expr><name><name>ecp</name><operator>-&gt;</operator><name>eout</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>ifd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ifd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>elftemp</name></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>cleanup_tempfile</name><argument_list>(<argument><expr><name>elftemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cleanup_tempfile</name><argument_list>(<argument><expr><name>tempfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"open %s failed"</literal></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>efd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>cleanup_tempfile</name><argument_list>(<argument><expr><name>elftemp</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>cleanup_tempfile</name><argument_list>(<argument><expr><name>tempfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"unlink %s failed"</literal></expr></argument>, <argument><expr><name>elftemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>elftemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>elftemp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ecp</name><operator>-&gt;</operator><name>ein</name></name> <operator>=</operator> <call><name>elf_begin</name><argument_list>(<argument><expr><name>ifd</name></expr></argument>, <argument><expr><name>ELF_C_READ</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>cleanup_tempfile</name><argument_list>(<argument><expr><name>tempfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>fstat</name><argument_list>(<argument><expr><name>ifd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>sb</name><operator>.</operator><name>st_size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"file format not recognized"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"elf_begin() failed: %s"</literal></expr></argument>,
<argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><call><name>elf_kind</name><argument_list>(<argument><expr><name><name>ecp</name><operator>-&gt;</operator><name>ein</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ELF_K_NONE</name></expr>:</case>
<expr_stmt><expr><call><name>cleanup_tempfile</name><argument_list>(<argument><expr><name>tempfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"file format not recognized"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<case>case <expr><name>ELF_K_ELF</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ecp</name><operator>-&gt;</operator><name>eout</name></name> <operator>=</operator> <call><name>elf_begin</name><argument_list>(<argument><expr><name>ofd</name></expr></argument>, <argument><expr><name>ELF_C_WRITE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>cleanup_tempfile</name><argument_list>(<argument><expr><name>tempfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"elf_begin() failed: %s"</literal></expr></argument>,
<argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>elf_flagelf</name><argument_list>(<argument><expr><name><name>ecp</name><operator>-&gt;</operator><name>eout</name></name></expr></argument>, <argument><expr><name>ELF_C_SET</name></expr></argument>, <argument><expr><name>ELF_F_LAYOUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><call><name>create_elf</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>elf_end</name><argument_list>(<argument><expr><name><name>ecp</name><operator>-&gt;</operator><name>eout</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<if_stmt><if>if <condition>(<expr><name><name>ecp</name><operator>-&gt;</operator><name>otf</name></name> <operator>!=</operator> <name>ETF_ELF</name></expr>)</condition> <block>{<block_content>




<if_stmt><if>if <condition>(<expr><call><name>cleanup_tempfile</name><argument_list>(<argument><expr><name>tempfile</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"unlink %s failed"</literal></expr></argument>,
<argument><expr><name>tempfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tempfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>create_tempfile</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tempfile</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ofd0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<if_stmt><if>if <condition>(<expr><call><name>lseek</name><argument_list>(<argument><expr><name>ofd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>cleanup_tempfile</name><argument_list>(<argument><expr><name>tempfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>,
<argument><expr><literal type="string">"lseek failed for the output object"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>




<switch>switch <condition>(<expr><name><name>ecp</name><operator>-&gt;</operator><name>otf</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ETF_BINARY</name></expr>:</case>
<expr_stmt><expr><call><name>create_binary</name><argument_list>(<argument><expr><name>ofd</name></expr></argument>, <argument><expr><name>ofd0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ETF_IHEX</name></expr>:</case>
<expr_stmt><expr><call><name>create_ihex</name><argument_list>(<argument><expr><name>ofd</name></expr></argument>, <argument><expr><name>ofd0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ETF_SREC</name></expr>:</case>
<expr_stmt><expr><call><name>create_srec</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>, <argument><expr><name>ofd</name></expr></argument>, <argument><expr><name>ofd0</name></expr></argument>,
<argument><expr><ternary><condition><expr><name>dst</name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>dst</name></expr> </then><else>: <expr><name>src</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ETF_PE</name></expr>:</case>
<case>case <expr><name>ETF_EFI</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>WITH_PE</name></expr></cpp:if>
<expr_stmt><expr><call><name>create_pe</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>, <argument><expr><name>ofd</name></expr></argument>, <argument><expr><name>ofd0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>cleanup_tempfile</name><argument_list>(<argument><expr><name>tempfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"PE/EFI support not enabled"</literal>
<literal type="string">" at compile time"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>cleanup_tempfile</name><argument_list>(<argument><expr><name>tempfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"Internal: unsupported"</literal>
<literal type="string">" output flavour %d"</literal></expr></argument>, <argument><expr><name><name>ecp</name><operator>-&gt;</operator><name>oec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>ofd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ofd</name> <operator>=</operator> <name>ofd0</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>ELF_K_AR</name></expr>:</case>

<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>cleanup_tempfile</name><argument_list>(<argument><expr><name>tempfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"file format not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>

<expr_stmt><expr><call><name>elf_end</name><argument_list>(<argument><expr><name><name>ecp</name><operator>-&gt;</operator><name>ein</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LIBELF_AR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<label><name>copy_done</name>:</label>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>tempfile</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>in_place</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>dst</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>dst</name> <operator>=</operator> <name>src</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>lstat</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>sb</name><operator>.</operator><name>st_nlink</name></name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator> <call><name>S_ISLNK</name><argument_list>(<argument><expr><name><name>sb</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>in_place</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>copy_from_tempfile</name><argument_list>(<argument><expr><name>tempfile</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>ofd</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>tfd</name></expr></argument>, <argument><expr><name>in_place</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>cleanup_tempfile</name><argument_list>(<argument><expr><name>tempfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"creation of %s failed"</literal></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tempfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tempfile</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ofd</name> <operator>=</operator> <name>tfd</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><literal type="string">"/dev/null"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>fchmod</name><argument_list>(<argument><expr><name>ofd</name></expr></argument>, <argument><expr><name><name>sb</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"fchmod %s failed"</literal></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ecp</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PRESERVE_DATE</name><operator>)</operator> <operator>&amp;&amp;</operator>
<call><name>elftc_set_timestamps</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"setting timestamps failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>ifd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>ofd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>elfcopy_main</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfcopy</name></name> <modifier>*</modifier></type><name>ecp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>sec_action</name></name> <modifier>*</modifier></type><name>sac</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>infile</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>outfile</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fn</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>opt</name></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>(</operator><name>opt</name> <operator>=</operator> <call><name>getopt_long</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"dB:gG:I:j:K:L:N:O:pR:s:SwW:xXV"</literal></expr></argument>,
<argument><expr><name>elfcopy_longopts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<switch>switch<condition>(<expr><name>opt</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'B'</literal></expr>:</case>

<break>break;</break>
<case>case <expr><literal type="char">'R'</literal></expr>:</case>
<expr_stmt><expr><name>sac</name> <operator>=</operator> <call><name>lookup_sec_act</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sac</name><operator>-&gt;</operator><name>copy</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>,
<argument><expr><literal type="string">"both copy and remove specified"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>sac</name><operator>-&gt;</operator><name>remove</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>SEC_REMOVE</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'S'</literal></expr>:</case>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>strip</name></name> <operator>=</operator> <name>STRIP_ALL</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'g'</literal></expr>:</case>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>strip</name></name> <operator>=</operator> <name>STRIP_DEBUG</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'G'</literal></expr>:</case>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>KEEP_GLOBAL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>add_to_symop_list</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>SYMOP_KEEPG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'I'</literal></expr>:</case>
<case>case <expr><literal type="char">'s'</literal></expr>:</case>
<expr_stmt><expr><call><name>set_input_target</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'j'</literal></expr>:</case>
<expr_stmt><expr><name>sac</name> <operator>=</operator> <call><name>lookup_sec_act</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sac</name><operator>-&gt;</operator><name>remove</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>,
<argument><expr><literal type="string">"both copy and remove specified"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>sac</name><operator>-&gt;</operator><name>copy</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>SEC_COPY</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'K'</literal></expr>:</case>
<expr_stmt><expr><call><name>add_to_symop_list</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>SYMOP_KEEP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'L'</literal></expr>:</case>
<expr_stmt><expr><call><name>add_to_symop_list</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>SYMOP_LOCALIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'N'</literal></expr>:</case>
<expr_stmt><expr><call><name>add_to_symop_list</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>SYMOP_STRIP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'O'</literal></expr>:</case>
<expr_stmt><expr><call><name>set_output_target</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'p'</literal></expr>:</case>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>PRESERVE_DATE</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'V'</literal></expr>:</case>
<expr_stmt><expr><call><name>print_version</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'w'</literal></expr>:</case>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>WILDCARD</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'W'</literal></expr>:</case>
<expr_stmt><expr><call><name>add_to_symop_list</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>SYMOP_WEAKEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'x'</literal></expr>:</case>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>DISCARD_LOCAL</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'X'</literal></expr>:</case>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>DISCARD_LLABEL</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ECP_ADD_GNU_DEBUGLINK</name></expr>:</case>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>debuglink</name></name> <operator>=</operator> <name>optarg</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ECP_ADD_SECTION</name></expr>:</case>
<expr_stmt><expr><call><name>add_section</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ECP_CHANGE_ADDR</name></expr>:</case>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>change_addr</name></name> <operator>=</operator> <operator>(</operator><name>int64_t</name><operator>)</operator> <call><name>strtoll</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ECP_CHANGE_SEC_ADDR</name></expr>:</case>
<expr_stmt><expr><call><name>parse_sec_address_op</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="string">"--change-section-addr"</literal></expr></argument>,
<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ECP_CHANGE_SEC_LMA</name></expr>:</case>
<expr_stmt><expr><call><name>parse_sec_address_op</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="string">"--change-section-lma"</literal></expr></argument>,
<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ECP_CHANGE_SEC_VMA</name></expr>:</case>
<expr_stmt><expr><call><name>parse_sec_address_op</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="string">"--change-section-vma"</literal></expr></argument>,
<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ECP_CHANGE_START</name></expr>:</case>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>change_start</name></name> <operator>=</operator> <operator>(</operator><name>int64_t</name><operator>)</operator> <call><name>strtoll</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ECP_CHANGE_WARN</name></expr>:</case>

<break>break;</break>
<case>case <expr><name>ECP_GAP_FILL</name></expr>:</case>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>fill</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator> <call><name>strtoul</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>GAP_FILL</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ECP_GLOBALIZE_SYMBOL</name></expr>:</case>
<expr_stmt><expr><call><name>add_to_symop_list</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>SYMOP_GLOBALIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ECP_GLOBALIZE_SYMBOLS</name></expr>:</case>
<expr_stmt><expr><call><name>parse_symlist_file</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>SYMOP_GLOBALIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ECP_KEEP_SYMBOLS</name></expr>:</case>
<expr_stmt><expr><call><name>parse_symlist_file</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>SYMOP_KEEP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ECP_KEEP_GLOBAL_SYMBOLS</name></expr>:</case>
<expr_stmt><expr><call><name>parse_symlist_file</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>SYMOP_KEEPG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ECP_LOCALIZE_HIDDEN</name></expr>:</case>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>LOCALIZE_HIDDEN</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ECP_LOCALIZE_SYMBOLS</name></expr>:</case>
<expr_stmt><expr><call><name>parse_symlist_file</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>SYMOP_LOCALIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ECP_NO_CHANGE_WARN</name></expr>:</case>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>NO_CHANGE_WARN</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ECP_ONLY_DEBUG</name></expr>:</case>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>strip</name></name> <operator>=</operator> <name>STRIP_NONDEBUG</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ECP_ONLY_DWO</name></expr>:</case>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>strip</name></name> <operator>=</operator> <name>STRIP_NONDWO</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ECP_PAD_TO</name></expr>:</case>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>pad_to</name></name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator> <call><name>strtoull</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ECP_PREFIX_ALLOC</name></expr>:</case>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>prefix_alloc</name></name> <operator>=</operator> <name>optarg</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ECP_PREFIX_SEC</name></expr>:</case>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>prefix_sec</name></name> <operator>=</operator> <name>optarg</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ECP_PREFIX_SYM</name></expr>:</case>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>prefix_sym</name></name> <operator>=</operator> <name>optarg</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ECP_REDEF_SYMBOL</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>s</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>,
<argument><expr><literal type="string">"illegal format for --redefine-sym"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>s</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>add_to_symop_list</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>SYMOP_REDEF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ECP_REDEF_SYMBOLS</name></expr>:</case>
<expr_stmt><expr><call><name>parse_symlist_file</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>SYMOP_REDEF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ECP_RENAME_SECTION</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fn</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>,
<argument><expr><literal type="string">"illegal format for --rename-section"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>fn</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>(</operator><name>s</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>fn</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>s</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>sac</name> <operator>=</operator> <call><name>lookup_sec_act</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sac</name><operator>-&gt;</operator><name>rename</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sac</name><operator>-&gt;</operator><name>newname</name></name> <operator>=</operator> <name>fn</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>s</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>parse_sec_flags</name><argument_list>(<argument><expr><name>sac</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>ECP_SET_OSABI</name></expr>:</case>
<expr_stmt><expr><call><name>set_osabi</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ECP_SET_SEC_FLAGS</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>s</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>,
<argument><expr><literal type="string">"illegal format for --set-section-flags"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>s</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>sac</name> <operator>=</operator> <call><name>lookup_sec_act</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>parse_sec_flags</name><argument_list>(<argument><expr><name>sac</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ECP_SET_START</name></expr>:</case>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>SET_START</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>set_start</name></name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator> <call><name>strtoull</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ECP_SREC_FORCE_S3</name></expr>:</case>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>SREC_FORCE_S3</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ECP_SREC_LEN</name></expr>:</case>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>SREC_FORCE_LEN</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>srec_len</name></name> <operator>=</operator> <call><name>strtoul</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ECP_STRIP_DWO</name></expr>:</case>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>strip</name></name> <operator>=</operator> <name>STRIP_DWO</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ECP_STRIP_SYMBOLS</name></expr>:</case>
<expr_stmt><expr><call><name>parse_symlist_file</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>SYMOP_STRIP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ECP_STRIP_UNNEEDED</name></expr>:</case>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>strip</name></name> <operator>=</operator> <name>STRIP_UNNEEDED</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ECP_WEAKEN_ALL</name></expr>:</case>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>WEAKEN_ALL</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ECP_WEAKEN_SYMBOLS</name></expr>:</case>
<expr_stmt><expr><call><name>parse_symlist_file</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>SYMOP_WEAKEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>elfcopy_usage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></while>

<expr_stmt><expr><name>argc</name> <operator>-=</operator> <name>optind</name></expr>;</expr_stmt>
<expr_stmt><expr><name>argv</name> <operator>+=</operator> <name>optind</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>argc</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>elfcopy_usage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>infile</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>outfile</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>outfile</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>create_file</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>, <argument><expr><name>infile</name></expr></argument>, <argument><expr><name>outfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>mcs_main</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfcopy</name></name> <modifier>*</modifier></type><name>ecp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>sec_action</name></name> <modifier>*</modifier></type><name>sac</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>string</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>append</name></decl>, <decl><type ref="prev"/><name>delete</name></decl>, <decl><type ref="prev"/><name>compress</name></decl>, <decl><type ref="prev"/><name>name</name></decl>, <decl><type ref="prev"/><name>print</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>opt</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>append</name> <operator>=</operator> <name>delete</name> <operator>=</operator> <name>compress</name> <operator>=</operator> <name>name</name> <operator>=</operator> <name>print</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>(</operator><name>opt</name> <operator>=</operator> <call><name>getopt_long</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"a:cdhn:pV"</literal></expr></argument>, <argument><expr><name>mcs_longopts</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<switch>switch<condition>(<expr><name>opt</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'a'</literal></expr>:</case>
<expr_stmt><expr><name>append</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>string</name> <operator>=</operator> <name>optarg</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'c'</literal></expr>:</case>
<expr_stmt><expr><name>compress</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'d'</literal></expr>:</case>
<expr_stmt><expr><name>delete</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'n'</literal></expr>:</case>
<expr_stmt><expr><name>name</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>lookup_sec_act</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'p'</literal></expr>:</case>
<expr_stmt><expr><name>print</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'V'</literal></expr>:</case>
<expr_stmt><expr><call><name>print_version</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'h'</literal></expr>:</case>
<default>default:</default>
<expr_stmt><expr><call><name>mcs_usage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></while>

<expr_stmt><expr><name>argc</name> <operator>-=</operator> <name>optind</name></expr>;</expr_stmt>
<expr_stmt><expr><name>argv</name> <operator>+=</operator> <name>optind</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>mcs_usage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name>append</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>compress</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>delete</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>print</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>mcs_usage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>








<if_stmt><if>if <condition>(<expr><name>delete</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>append</name> <operator>=</operator> <name>compress</name> <operator>=</operator> <name>print</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>SEC_REMOVE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>append</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>SEC_APPEND</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>compress</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>SEC_COMPRESS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>print</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>SEC_PRINT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name>name</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>lookup_sec_act</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>, <argument><expr><literal type="string">".comment"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<macro><name>STAILQ_FOREACH</name><argument_list>(<argument>sac</argument>, <argument>&amp;ecp-&gt;v_sac</argument>, <argument>sac_list</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name><name>sac</name><operator>-&gt;</operator><name>append</name></name> <operator>=</operator> <name>append</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sac</name><operator>-&gt;</operator><name>compress</name></name> <operator>=</operator> <name>compress</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sac</name><operator>-&gt;</operator><name>print</name></name> <operator>=</operator> <name>print</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sac</name><operator>-&gt;</operator><name>remove</name></name> <operator>=</operator> <name>delete</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sac</name><operator>-&gt;</operator><name>string</name></name> <operator>=</operator> <name>string</name></expr>;</expr_stmt>
</block_content>}</block>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>print</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>append</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>compress</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>delete</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>create_file</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"/dev/null"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>create_file</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>strip_main</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfcopy</name></name> <modifier>*</modifier></type><name>ecp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>sec_action</name></name> <modifier>*</modifier></type><name>sac</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>outfile</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>opt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>outfile</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>(</operator><name>opt</name> <operator>=</operator> <call><name>getopt_long</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="string">"hI:K:N:o:O:pR:sSdgVxXw"</literal></expr></argument>,
<argument><expr><name>strip_longopts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<switch>switch<condition>(<expr><name>opt</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'R'</literal></expr>:</case>
<expr_stmt><expr><name>sac</name> <operator>=</operator> <call><name>lookup_sec_act</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sac</name><operator>-&gt;</operator><name>remove</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>SEC_REMOVE</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'s'</literal></expr>:</case>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>strip</name></name> <operator>=</operator> <name>STRIP_ALL</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'S'</literal></expr>:</case>
<case>case <expr><literal type="char">'g'</literal></expr>:</case>
<case>case <expr><literal type="char">'d'</literal></expr>:</case>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>strip</name></name> <operator>=</operator> <name>STRIP_DEBUG</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'I'</literal></expr>:</case>

<break>break;</break>
<case>case <expr><literal type="char">'K'</literal></expr>:</case>
<expr_stmt><expr><call><name>add_to_symop_list</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>SYMOP_KEEP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'N'</literal></expr>:</case>
<expr_stmt><expr><call><name>add_to_symop_list</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>SYMOP_STRIP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'o'</literal></expr>:</case>
<expr_stmt><expr><name>outfile</name> <operator>=</operator> <name>optarg</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'O'</literal></expr>:</case>
<expr_stmt><expr><call><name>set_output_target</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'p'</literal></expr>:</case>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>PRESERVE_DATE</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'V'</literal></expr>:</case>
<expr_stmt><expr><call><name>print_version</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'w'</literal></expr>:</case>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>WILDCARD</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'x'</literal></expr>:</case>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>DISCARD_LOCAL</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'X'</literal></expr>:</case>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>DISCARD_LLABEL</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ECP_ONLY_DEBUG</name></expr>:</case>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>strip</name></name> <operator>=</operator> <name>STRIP_NONDEBUG</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ECP_STRIP_UNNEEDED</name></expr>:</case>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>strip</name></name> <operator>=</operator> <name>STRIP_UNNEEDED</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'h'</literal></expr>:</case>
<default>default:</default>
<expr_stmt><expr><call><name>strip_usage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></while>

<expr_stmt><expr><name>argc</name> <operator>-=</operator> <name>optind</name></expr>;</expr_stmt>
<expr_stmt><expr><name>argv</name> <operator>+=</operator> <name>optind</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ecp</name><operator>-&gt;</operator><name>strip</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<operator>(</operator><operator>(</operator><name><name>ecp</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>DISCARD_LOCAL</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><operator>(</operator><name><name>ecp</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>DISCARD_LLABEL</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator>
<call><name>lookup_symop_list</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>SYMOP_STRIP</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>strip</name></name> <operator>=</operator> <name>STRIP_ALL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>strip_usage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><name>outfile</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>argc</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>strip_usage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>create_file</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>outfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>parse_sec_flags</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sec_action</name></name> <modifier>*</modifier></type><name>sac</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>flag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>found</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>flag</name> <operator>=</operator> <call><name>strtok</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>flag</name></expr>;</condition> <incr><expr><name>flag</name> <operator>=</operator> <call><name>strtok</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>found</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>sec_flags</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>sec_flags</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>sac</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name><name>sec_flags</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr>;</expr_stmt>
<expr_stmt><expr><name>found</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt></block_content></block></for>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"unrecognized section flag %s"</literal></expr></argument>,
<argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>parse_sec_address_op</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfcopy</name></name> <modifier>*</modifier></type><name>ecp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>optnum</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>optname</name></decl></parameter>,
<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>sec_action</name></name> <modifier>*</modifier></type><name>sac</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>op</name></decl>;</decl_stmt>

<expr_stmt><expr><name>name</name> <operator>=</operator> <name>v</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<do>do <block>{<block_content>
<expr_stmt><expr><name>v</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><operator>*</operator><name>v</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>v</name> <operator>!=</operator> <literal type="char">'='</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>v</name> <operator>!=</operator> <literal type="char">'+'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>v</name> <operator>!=</operator> <literal type="char">'-'</literal></expr>)</condition>;</do>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>v</name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> <operator>*</operator><operator>(</operator><name>v</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"invalid format for %s"</literal></expr></argument>, <argument><expr><name>optname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>op</name> <operator>=</operator> <operator>*</operator><name>v</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>v</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>sac</name> <operator>=</operator> <call><name>lookup_sec_act</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'='</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>optnum</name> <operator>==</operator> <name>ECP_CHANGE_SEC_LMA</name> <operator>||</operator>
<name>optnum</name> <operator>==</operator> <name>ECP_CHANGE_SEC_ADDR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>sac</name><operator>-&gt;</operator><name>setlma</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sac</name><operator>-&gt;</operator><name>lma</name></name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator> <call><name>strtoull</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>optnum</name> <operator>==</operator> <name>ECP_CHANGE_SEC_VMA</name> <operator>||</operator>
<name>optnum</name> <operator>==</operator> <name>ECP_CHANGE_SEC_ADDR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>sac</name><operator>-&gt;</operator><name>setvma</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sac</name><operator>-&gt;</operator><name>vma</name></name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator> <call><name>strtoull</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'+'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>optnum</name> <operator>==</operator> <name>ECP_CHANGE_SEC_LMA</name> <operator>||</operator>
<name>optnum</name> <operator>==</operator> <name>ECP_CHANGE_SEC_ADDR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sac</name><operator>-&gt;</operator><name>lma_adjust</name></name> <operator>=</operator> <operator>(</operator><name>int64_t</name><operator>)</operator> <call><name>strtoll</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>optnum</name> <operator>==</operator> <name>ECP_CHANGE_SEC_VMA</name> <operator>||</operator>
<name>optnum</name> <operator>==</operator> <name>ECP_CHANGE_SEC_ADDR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sac</name><operator>-&gt;</operator><name>vma_adjust</name></name> <operator>=</operator> <operator>(</operator><name>int64_t</name><operator>)</operator> <call><name>strtoll</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'-'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>optnum</name> <operator>==</operator> <name>ECP_CHANGE_SEC_LMA</name> <operator>||</operator>
<name>optnum</name> <operator>==</operator> <name>ECP_CHANGE_SEC_ADDR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sac</name><operator>-&gt;</operator><name>lma_adjust</name></name> <operator>=</operator> <operator>(</operator><name>int64_t</name><operator>)</operator> <operator>-</operator><call><name>strtoll</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>optnum</name> <operator>==</operator> <name>ECP_CHANGE_SEC_VMA</name> <operator>||</operator>
<name>optnum</name> <operator>==</operator> <name>ECP_CHANGE_SEC_ADDR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sac</name><operator>-&gt;</operator><name>vma_adjust</name></name> <operator>=</operator> <operator>(</operator><name>int64_t</name><operator>)</operator> <operator>-</operator><call><name>strtoll</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>parse_symlist_file</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfcopy</name></name> <modifier>*</modifier></type><name>ecp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fn</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>op</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>symfile</name></name> <modifier>*</modifier></type><name>sf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>sb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>line</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>e</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>fn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"stat %s failed"</literal></expr></argument>, <argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<macro><name>STAILQ_FOREACH</name><argument_list>(<argument>sf</argument>, <argument>&amp;ecp-&gt;v_symfile</argument>, <argument>symfile_list</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>sf</name><operator>-&gt;</operator><name>dev</name></name> <operator>==</operator> <name><name>sb</name><operator>.</operator><name>st_dev</name></name> <operator>&amp;&amp;</operator> <name><name>sf</name><operator>-&gt;</operator><name>ino</name></name> <operator>==</operator> <name><name>sb</name><operator>.</operator><name>st_ino</name></name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>process_symfile</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fp</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>fn</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"can not open %s"</literal></expr></argument>, <argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>data</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name><name>sb</name><operator>.</operator><name>st_size</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"malloc failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sb</name><operator>.</operator><name>st_size</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name><name>sb</name><operator>.</operator><name>st_size</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"fread failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>data</name><index>[<expr><name><name>sb</name><operator>.</operator><name>st_size</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>sf</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>sf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"malloc failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>sf</name><operator>-&gt;</operator><name>dev</name></name> <operator>=</operator> <name><name>sb</name><operator>.</operator><name>st_dev</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sf</name><operator>-&gt;</operator><name>ino</name></name> <operator>=</operator> <name><name>sb</name><operator>.</operator><name>st_ino</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sf</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name><name>sb</name><operator>.</operator><name>st_size</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sf</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>

<label><name>process_symfile</name>:</label>






<expr_stmt><expr><name>end</name> <operator>=</operator> <name><name>sf</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name><name>sf</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>line</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<for>for<control>(<init><expr><name>p</name> <operator>=</operator> <name><name>sf</name><operator>-&gt;</operator><name>data</name></name></expr>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>end</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\t'</literal> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">' '</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>line</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\r'</literal> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>line</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>*</operator><name>line</name> <operator>==</operator> <literal type="char">'#'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>line</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>e</name> <operator>=</operator> <name>p</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<while>while<condition>(<expr><name>e</name> <operator>!=</operator> <name>line</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>e</name> <operator>==</operator> <literal type="char">'\t'</literal> <operator>||</operator> <operator>*</operator><name>e</name> <operator>==</operator> <literal type="char">' '</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>e</name><operator>--</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></while>
<if_stmt><if>if <condition>(<expr><name>op</name> <operator>!=</operator> <name>SYMOP_REDEF</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>add_to_symop_list</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>,
<argument><expr><literal type="string">"illegal format for"</literal>
<literal type="string">" --redefine-sym"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for<control>(<init><expr><name>n</name> <operator>=</operator> <name>line</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>e</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>n</name> <operator>==</operator> <literal type="char">' '</literal> <operator>||</operator> <operator>*</operator><name>n</name> <operator>==</operator> <literal type="char">'\t'</literal></expr>)</condition> <block>{<block_content>
<while>while<condition>(<expr><operator>*</operator><name>n</name> <operator>==</operator> <literal type="char">' '</literal> <operator>||</operator> <operator>*</operator><name>n</name> <operator>==</operator> <literal type="char">'\t'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>n</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></while>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;=</operator> <name>e</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>,
<argument><expr><literal type="string">"illegal format for"</literal>
<literal type="string">" --redefine-sym"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>add_to_symop_list</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>line</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>line</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>line</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_input_target</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfcopy</name></name> <modifier>*</modifier></type><name>ecp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>target_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Elftc_Bfd_Target</name> <modifier>*</modifier></type><name>tgt</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>tgt</name> <operator>=</operator> <call><name>elftc_bfd_find_target</name><argument_list>(<argument><expr><name>target_name</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"%s: invalid target name"</literal></expr></argument>, <argument><expr><name>target_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>itf</name></name> <operator>=</operator> <call><name>elftc_bfd_target_flavor</name><argument_list>(<argument><expr><name>tgt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_output_target</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfcopy</name></name> <modifier>*</modifier></type><name>ecp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>target_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Elftc_Bfd_Target</name> <modifier>*</modifier></type><name>tgt</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>tgt</name> <operator>=</operator> <call><name>elftc_bfd_find_target</name><argument_list>(<argument><expr><name>target_name</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"%s: invalid target name"</literal></expr></argument>, <argument><expr><name>target_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>otf</name></name> <operator>=</operator> <call><name>elftc_bfd_target_flavor</name><argument_list>(<argument><expr><name>tgt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ecp</name><operator>-&gt;</operator><name>otf</name></name> <operator>==</operator> <name>ETF_ELF</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>oec</name></name> <operator>=</operator> <call><name>elftc_bfd_target_class</name><argument_list>(<argument><expr><name>tgt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>oed</name></name> <operator>=</operator> <call><name>elftc_bfd_target_byteorder</name><argument_list>(<argument><expr><name>tgt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>oem</name></name> <operator>=</operator> <call><name>elftc_bfd_target_machine</name><argument_list>(<argument><expr><name>tgt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>abi</name></name> <operator>=</operator> <call><name>elftc_bfd_target_osabi</name><argument_list>(<argument><expr><name>tgt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ecp</name><operator>-&gt;</operator><name>otf</name></name> <operator>==</operator> <name>ETF_EFI</name> <operator>||</operator> <name><name>ecp</name><operator>-&gt;</operator><name>otf</name></name> <operator>==</operator> <name>ETF_PE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>oem</name></name> <operator>=</operator> <call><name>elftc_bfd_target_machine</name><argument_list>(<argument><expr><name>tgt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>otgt</name></name> <operator>=</operator> <name>target_name</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_osabi</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>elfcopy</name></name> <modifier>*</modifier></type><name>ecp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>abi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>found</name></decl>;</decl_stmt>

<expr_stmt><expr><name>found</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>osabis</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>osabis</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name>abi</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>abi</name></name> <operator>=</operator> <name><name>osabis</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>abi</name></expr>;</expr_stmt>
<expr_stmt><expr><name>found</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt></block_content></block></for>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"unrecognized OSABI %s"</literal></expr></argument>, <argument><expr><name>abi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ELFCOPY_USAGE_MESSAGE</name></cpp:macro> <cpp:value>"Usage: %s [options] infile [outfile]\nTransform object files.\n\nOptions:\n-d | -g | --strip-debug Remove debugging information from the output.\n-j SECTION | --only-section=SECTION\nCopy only the named section to the output.\n-p | --preserve-dates Preserve access and modification times.\n-w | --wildcard Use shell-style patterns to name symbols.\n-x | --discard-all Do not copy non-globals to the output.\n-I FORMAT | --input-target=FORMAT\nSpecify object format for the input file.\n-K SYM | --keep-symbol=SYM Copy symbol SYM to the output.\n-L SYM | --localize-symbol=SYM\nMake symbol SYM local to the output file.\n-N SYM | --strip-symbol=SYM Do not copy symbol SYM to the output.\n-O FORMAT | --output-target=FORMAT\nSpecify object format for the output file.\nFORMAT should be a target name understood by\nelftc_bfd_find_target(3).\n-R NAME | --remove-section=NAME\nRemove the named section.\n-S | --strip-all Remove all symbol and relocation information\nfrom the output.\n-V | --version Print a version identifier and exit.\n-W SYM | --weaken-symbol=SYM Mark symbol SYM as weak in the output.\n-X | --discard-locals Do not copy compiler generated symbols to\nthe output.\n--add-section NAME=FILE Add the contents of FILE to the ELF object as\na new section named NAME.\n--adjust-section-vma SECTION{=,+,-}VAL | \\\n--change-section-address SECTION{=,+,-}VAL\nSet or adjust the VMA and the LMA of the\nnamed section by VAL.\n--adjust-start=INCR | --change-start=INCR\nAdd INCR to the start address for the ELF\nobject.\n--adjust-vma=INCR | --change-addresses=INCR\nIncrease the VMA and LMA of all sections by\nINCR.\n--adjust-warning | --change-warnings\nIssue warnings for non-existent sections.\n--change-section-lma SECTION{=,+,-}VAL\nSet or adjust the LMA address of the named\nsection by VAL.\n--change-section-vma SECTION{=,+,-}VAL\nSet or adjust the VMA address of the named\nsection by VAL.\n--gap-fill=VAL Fill the gaps between sections with bytes\nof value VAL.\n--localize-hidden Make all hidden symbols local to the output\nfile.\n--no-adjust-warning| --no-change-warnings\nDo not issue warnings for non-existent\nsections.\n--only-keep-debug Copy only debugging information.\n--output-target=FORMAT Use the specified format for the output.\n--pad-to=ADDRESS Pad the output object up to the given address.\n--prefix-alloc-sections=STRING\nPrefix the section names of all the allocated\nsections with STRING.\n--prefix-sections=STRING Prefix the section names of all the sections\nwith STRING.\n--prefix-symbols=STRING Prefix the symbol names of all the symbols\nwith STRING.\n--rename-section OLDNAME=NEWNAME[,FLAGS]\nRename and optionally change section flags.\n--set-section-flags SECTION=FLAGS\nSet section flags for the named section.\nSupported flags are: 'alloc', 'code',\n'contents', 'data', 'debug', 'load',\n'noload', 'readonly', 'rom', and 'shared'.\n--set-start=ADDRESS Set the start address of the ELF object.\n--srec-forceS3 Only generate S3 S-Records.\n--srec-len=LEN Set the maximum length of a S-Record line.\n--strip-unneeded Do not copy relocation information.\n"</cpp:value></cpp:define>












































































<function><type><specifier>static</specifier> <name>void</name></type>
<name>elfcopy_usage</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>ELFCOPY_USAGE_MESSAGE</name></expr></argument>, <argument><expr><call><name>ELFTC_GETPROGNAME</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MCS_USAGE_MESSAGE</name></cpp:macro> <cpp:value>"Usage: %s [options] file...\nManipulate the comment section in an ELF object.\n\nOptions:\n-a STRING Append 'STRING' to the comment section.\n-c Remove duplicate entries from the comment section.\n-d Delete the comment section.\n-h | --help Print a help message and exit.\n-n NAME Operate on the ELF section with name 'NAME'.\n-p Print the contents of the comment section.\n-V | --version Print a version identifier and exit.\n"</cpp:value></cpp:define>











<function><type><specifier>static</specifier> <name>void</name></type>
<name>mcs_usage</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>MCS_USAGE_MESSAGE</name></expr></argument>, <argument><expr><call><name>ELFTC_GETPROGNAME</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRIP_USAGE_MESSAGE</name></cpp:macro> <cpp:value>"Usage: %s [options] file...\nDiscard information from ELF objects.\n\nOptions:\n-d | -g | -S | --strip-debug Remove debugging symbols.\n-h | --help Print a help message.\n-o FILE | --output-file FILE Write output to FILE.\n--only-keep-debug Keep debugging information only.\n-p | --preserve-dates Preserve access and modification times.\n-s | --strip-all Remove all symbols.\n--strip-unneeded Remove symbols not needed for relocation\nprocessing.\n-w | --wildcard Use shell-style patterns to name symbols.\n-x | --discard-all Discard all non-global symbols.\n-I TGT| --input-target=TGT (Accepted, but ignored).\n-K SYM | --keep-symbol=SYM Keep symbol 'SYM' in the output.\n-N SYM | --strip-symbol=SYM Remove symbol 'SYM' from the output.\n-O TGT | --output-target=TGT Set the output file format to 'TGT'.\n-R SEC | --remove-section=SEC Remove the section named 'SEC'.\n-V | --version Print a version identifier and exit.\n-X | --discard-locals Remove compiler-generated local symbols.\n"</cpp:value></cpp:define>





















<function><type><specifier>static</specifier> <name>void</name></type>
<name>strip_usage</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>STRIP_USAGE_MESSAGE</name></expr></argument>, <argument><expr><call><name>ELFTC_GETPROGNAME</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_version</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s (%s)\n"</literal></expr></argument>, <argument><expr><call><name>ELFTC_GETPROGNAME</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>elftc_version</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>int</name></type>
<name>strrcmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>endlen</name></decl>, <decl><type ref="prev"/><name>slen</name></decl>;</decl_stmt>

<expr_stmt><expr><name>slen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>endlen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>slen</name> <operator>&gt;=</operator> <name>endlen</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>s</name> <operator>+=</operator> <name>slen</name> <operator>-</operator> <name>endlen</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>elfcopy</name></name> <modifier>*</modifier></type><name>ecp</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>elf_version</name><argument_list>(<argument><expr><name>EV_CURRENT</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>EV_NONE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>errx</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"ELF library initialization failed: %s"</literal></expr></argument>,
<argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ecp</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>ecp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ecp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>, <argument><expr><literal type="string">"calloc failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>itf</name></name> <operator>=</operator> <name><name>ecp</name><operator>-&gt;</operator><name>otf</name></name> <operator>=</operator> <name>ETF_ELF</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>iec</name></name> <operator>=</operator> <name><name>ecp</name><operator>-&gt;</operator><name>oec</name></name> <operator>=</operator> <name>ELFCLASSNONE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>oed</name></name> <operator>=</operator> <name>ELFDATANONE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>abi</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>nos</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>fill</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STAILQ_INIT</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ecp</name><operator>-&gt;</operator><name>v_seg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STAILQ_INIT</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ecp</name><operator>-&gt;</operator><name>v_sac</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STAILQ_INIT</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ecp</name><operator>-&gt;</operator><name>v_sadd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STAILQ_INIT</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ecp</name><operator>-&gt;</operator><name>v_symop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STAILQ_INIT</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ecp</name><operator>-&gt;</operator><name>v_symfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STAILQ_INIT</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ecp</name><operator>-&gt;</operator><name>v_arobj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TAILQ_INIT</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ecp</name><operator>-&gt;</operator><name>v_sec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ecp</name><operator>-&gt;</operator><name>progname</name></name> <operator>=</operator> <call><name>ELFTC_GETPROGNAME</name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ecp</name><operator>-&gt;</operator><name>progname</name></name> <operator>=</operator> <literal type="string">"elfcopy"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strrcmp</name><argument_list>(<argument><expr><name><name>ecp</name><operator>-&gt;</operator><name>progname</name></name></expr></argument>, <argument><expr><literal type="string">"strip"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>strip_main</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>strrcmp</name><argument_list>(<argument><expr><name><name>ecp</name><operator>-&gt;</operator><name>progname</name></name></expr></argument>, <argument><expr><literal type="string">"mcs"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>mcs_main</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>strrcmp</name><argument_list>(<argument><expr><name><name>ecp</name><operator>-&gt;</operator><name>progname</name></name></expr></argument>, <argument><expr><literal type="string">"elfcopy"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<call><name>strrcmp</name><argument_list>(<argument><expr><name><name>ecp</name><operator>-&gt;</operator><name>progname</name></name></expr></argument>, <argument><expr><literal type="string">"objcopy"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>warnx</name><argument_list>(<argument><expr><literal type="string">"program mode not known, defaulting to elfcopy"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>elfcopy_main</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free_sec_add</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free_sec_act</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ecp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
